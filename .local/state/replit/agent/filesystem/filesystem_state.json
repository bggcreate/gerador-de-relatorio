{"file_contents":{"monitoramento-lojas-varejo-main/create-relatorio/public/js/pages/gerenciar-usuarios.js":{"content":"import { showToast, showConfirmModal } from '../utils.js';\n\nexport function initGerenciarUsuariosPage(currentUser) {\n    // A função agora inicializa tanto usuários quanto backup\n    initUsuarios(currentUser);\n    initBackup();\n}\n\n// --- LÓGICA DE GERENCIAMENTO DE USUÁRIOS (Sem alterações) ---\nfunction initUsuarios(currentUser) {\n    const tableBody = document.getElementById('tabela-usuarios-corpo');\n    const btnAdicionar = document.getElementById('btn-adicionar-usuario');\n    const modalEl = document.getElementById('modal-usuario');\n    \n    if (!tableBody || !btnAdicionar || !modalEl) return;\n\n    const modal = new bootstrap.Modal(modalEl);\n    const modalForm = document.getElementById('form-usuario');\n    const modalTitle = document.getElementById('modalUsuarioLabel');\n    let usuariosCache = [];\n\n    async function carregarUsuarios() {\n        tableBody.innerHTML = '<tr><td colspan=\"4\" class=\"text-center\">Carregando...</td></tr>';\n        try {\n            const response = await fetch('/api/usuarios');\n            if (!response.ok) throw new Error('Falha ao carregar usuários.');\n            usuariosCache = await response.json();\n            \n            if (usuariosCache.length === 0) {\n                tableBody.innerHTML = '<tr><td colspan=\"4\" class=\"text-center\">Nenhum usuário cadastrado.</td></tr>';\n                return;\n            }\n            tableBody.innerHTML = usuariosCache.map(user => {\n                const isCurrentUser = user.id === currentUser.id;\n                const deleteButton = isCurrentUser ? `<button class=\"btn btn-sm btn-outline-secondary\" disabled title=\"Não é possível excluir o próprio usuário\"><i class=\"bi bi-trash\"></i></button>` : `<button class=\"btn btn-sm btn-outline-danger\" data-action=\"excluir\" data-id=\"${user.id}\" title=\"Excluir\"><i class=\"bi bi-trash\"></i></button>`;\n                return `<tr><td class=\"ps-3\">${user.id}</td><td>${user.username}</td><td><span class=\"badge ${user.role === 'admin' ? 'bg-primary' : 'bg-secondary'}\">${user.role}</span></td><td class=\"text-end pe-3\"><button class=\"btn btn-sm btn-outline-secondary\" data-action=\"editar\" data-id=\"${user.id}\" title=\"Editar\"><i class=\"bi bi-pencil\"></i></button> ${deleteButton}</td></tr>`;\n            }).join('');\n        } catch(e) {\n            tableBody.innerHTML = `<tr><td colspan=\"4\" class=\"text-center text-danger\">Erro ao carregar usuários.</td></tr>`;\n        }\n    }\n\n    function abrirModalParaAdicionar() {\n        modalForm.reset();\n        modalTitle.textContent = 'Adicionar Novo Usuário';\n        document.getElementById('usuario-id').value = '';\n        document.getElementById('usuario-password').required = true;\n        document.getElementById('usuario-password-label').textContent = 'Senha *';\n        modal.show();\n    }\n\n    function abrirModalParaEditar(id) {\n        const user = usuariosCache.find(u => u.id === id);\n        if (!user) return;\n        modalForm.reset();\n        modalTitle.textContent = 'Editar Usuário';\n        document.getElementById('usuario-id').value = user.id;\n        document.getElementById('usuario-username').value = user.username;\n        document.getElementById('usuario-role').value = user.role;\n        document.getElementById('usuario-password').required = false;\n        document.getElementById('usuario-password-label').textContent = 'Nova Senha (deixe em branco para não alterar)';\n        modal.show();\n    }\n\n    async function excluirUsuario(id) {\n        const confirmed = await showConfirmModal(`Tem certeza que deseja excluir o usuário #${id}?`);\n        if (!confirmed) return;\n        try { \n            const response = await fetch(`/api/usuarios/${id}`, { method: 'DELETE' });\n            const result = await response.json();\n            if (!response.ok) throw new Error(result.error);\n            showToast('Sucesso', 'Usuário excluído com sucesso.', 'success');\n            carregarUsuarios();\n        } catch (e) {\n            showToast('Erro', e.message || 'Não foi possível excluir o usuário.', 'danger');\n        }\n    }\n    \n    modalForm.addEventListener('submit', async (e) => {\n        e.preventDefault();\n        const id = document.getElementById('usuario-id').value;\n        const data = { username: document.getElementById('usuario-username').value, password: document.getElementById('usuario-password').value, role: document.getElementById('usuario-role').value };\n        if (!data.password) delete data.password;\n        const method = id ? 'PUT' : 'POST';\n        const url = id ? `/api/usuarios/${id}` : '/api/usuarios';\n        try {\n            const response = await fetch(url, { method, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) });\n            const result = await response.json();\n            if (!response.ok) throw new Error(result.error);\n            showToast('Sucesso', `Usuário ${id ? 'atualizado' : 'adicionado'} com sucesso.`, 'success');\n            modal.hide();\n            carregarUsuarios();\n        } catch(e) {\n            showToast('Erro', e.message || 'Não foi possível salvar o usuário.', 'danger');\n        }\n    });\n\n    btnAdicionar.addEventListener('click', abrirModalParaAdicionar);\n    \n    tableBody.addEventListener('click', (e) => {\n        const button = e.target.closest('button[data-action]');\n        if (!button) return;\n        const id = parseInt(button.dataset.id, 10);\n        const action = button.dataset.action;\n        if (action === 'editar') abrirModalParaEditar(id);\n        if (action === 'excluir') excluirUsuario(id);\n    });\n    \n    carregarUsuarios();\n}\n\n// --- LÓGICA DE BACKUP E RESTAURAÇÃO (NOVO) ---\nfunction initBackup() {\n    const dbSizeSpan = document.getElementById('db-size');\n    const btnLimparDb = document.getElementById('btn-limpar-db');\n    const btnRestaurarBackup = document.getElementById('btn-restaurar-backup');\n    const backupFileInput = document.getElementById('backup-file-input');\n\n    // Carrega o tamanho do DB ao entrar na aba\n    async function carregarInfoBackup() {\n        try {\n            const response = await fetch('/api/backup/info');\n            const data = await response.json();\n            dbSizeSpan.textContent = `${data.sizeMB} MB`;\n        } catch (error) {\n            dbSizeSpan.textContent = 'Erro ao carregar';\n            dbSizeSpan.classList.add('text-danger');\n        }\n    }\n\n    // Limpar DB\n    btnLimparDb.addEventListener('click', async () => {\n        const confirmed = await showConfirmModal('Você tem CERTEZA ABSOLUTA que deseja limpar todos os relatórios e demandas? Esta ação é IRREVERSÍVEL.');\n        if (!confirmed) return;\n\n        btnLimparDb.disabled = true;\n        btnLimparDb.innerHTML = '<span class=\"spinner-border spinner-border-sm\"></span> Limpando...';\n        try {\n            const response = await fetch('/api/backup/clear', { method: 'DELETE' });\n            const result = await response.json();\n            if (!response.ok) throw new Error(result.error);\n            showToast('Sucesso', 'Banco de dados limpo com sucesso.', 'success');\n            carregarInfoBackup(); // Atualiza o tamanho\n        } catch (error) {\n            showToast('Erro', error.message, 'danger');\n        } finally {\n            btnLimparDb.disabled = false;\n            btnLimparDb.innerHTML = '<i class=\"bi bi-trash3-fill me-2\"></i>Limpar Relatórios e Demandas';\n        }\n    });\n\n    // Habilita/Desabilita o botão de restaurar conforme um arquivo é selecionado\n    backupFileInput.addEventListener('change', () => {\n        btnRestaurarBackup.disabled = !backupFileInput.files.length;\n    });\n\n    // Restaurar Backup\n    btnRestaurarBackup.addEventListener('click', async () => {\n        const file = backupFileInput.files[0];\n        if (!file) {\n            showToast('Atenção', 'Selecione um arquivo de backup (.db) primeiro.', 'info');\n            return;\n        }\n\n        const confirmed = await showConfirmModal('Você está prestes a SUBSTITUIR TODO o banco de dados atual. O sistema atual será perdido para sempre. Deseja continuar?');\n        if (!confirmed) return;\n\n        const formData = new FormData();\n        formData.append('backupFile', file);\n\n        btnRestaurarBackup.disabled = true;\n        btnRestaurarBackup.innerHTML = '<span class=\"spinner-border spinner-border-sm\"></span> Restaurando...';\n\n        try {\n            const response = await fetch('/api/backup/restore', {\n                method: 'POST',\n                body: formData\n            });\n            const result = await response.json();\n            if (!response.ok) throw new Error(result.error);\n            showToast('Sucesso!', result.message, 'success');\n            // Recarrega a página inteira para garantir que o sistema use o novo DB\n            setTimeout(() => window.location.reload(), 2000);\n        } catch (error) {\n            showToast('Erro na Restauração', error.message, 'danger');\n            btnRestaurarBackup.disabled = false;\n            btnRestaurarBackup.innerHTML = '<i class=\"bi bi-upload me-2\"></i>Restaurar';\n        }\n    });\n    \n    // Carrega as informações iniciais ao carregar a página\n    carregarInfoBackup();\n}","size_bytes":9189},"public/js/pages/consulta.js":{"content":"import { showToast, showConfirmModal, getAuthHeaders } from '../utils.js';\n\nlet eventController;\n\nexport function initConsultaPage() {\n    const formFiltros = document.getElementById('form-filtros-consulta');\n    const tableBody = document.getElementById('tabela-relatorios-corpo');\n    const filtroLoja = document.getElementById('filtro-loja');\n    const filtroInicio = document.getElementById('filtro-data-inicio');\n    const filtroFim = document.getElementById('filtro-data-fim');\n    // ADICIONADO: Seleção do novo filtro de ordem\n    const filtroOrdem = document.getElementById('filtro-ordem');\n    const btnLimpar = document.getElementById('btn-limpar-filtros');\n    const btnCarregarMais = document.getElementById('btn-carregar-mais');\n    const modalViewEl = document.getElementById('modal-visualizar-relatorio');\n    const pageContent = document.getElementById('page-content');\n\n    if (!formFiltros || !modalViewEl) return;\n    const modalView = new bootstrap.Modal(modalViewEl);\n\n    let currentOffset = 0;\n    const limit = 20;\n    let currentReportId = null;\n    let totalReportsCount = 0;\n\n    if (eventController) {\n        eventController.abort();\n    }\n    eventController = new AbortController();\n\n    async function carregarRelatorios(isNewSearch = true) {\n        if (isNewSearch) {\n            currentOffset = 0;\n            tableBody.innerHTML = '<tr><td colspan=\"5\" class=\"text-center\">Carregando...</td></tr>';\n        }\n        btnCarregarMais.disabled = true;\n        btnCarregarMais.innerHTML = '<span class=\"spinner-border spinner-border-sm\" role=\"status\" aria-hidden=\"true\"></span> Carregando...';\n\n        const params = new URLSearchParams();\n        if (filtroLoja.value) params.append('loja', filtroLoja.value);\n        if (filtroInicio.value) params.append('data_inicio', filtroInicio.value);\n        if (filtroFim.value) params.append('data_fim', filtroFim.value);\n        // ADICIONADO: Envio do parâmetro de ordenação para a API\n        params.append('sortOrder', filtroOrdem.value);\n        params.append('limit', limit);\n        params.append('offset', currentOffset);\n\n        try {\n            const response = await fetch(`/api/relatorios?${params.toString()}`);\n            const { relatorios, total } = await response.json();\n\n            if (isNewSearch) {\n                totalReportsCount = total;\n            }\n\n            const formatCurrency = (value) => {\n                const numberValue = Number(value) || 0;\n                return new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(numberValue);\n            };\n\n            const newRowsHtml = relatorios.map((r, index) => {\n                // ALTERAÇÃO: Lógica para criar um ID sequencial contínuo\n                const isDescending = filtroOrdem.value === 'desc';\n                const sequentialId = isDescending\n                    ? totalReportsCount - currentOffset - index\n                    : currentOffset + index + 1;\n\n                return `\n                    <tr>\n                        <td class=\"ps-3\">${sequentialId}</td>\n                        <td>${r.loja}</td>\n                        <td>${new Date(r.data).toLocaleDateString('pt-BR', {timeZone: 'UTC'})}</td>\n                        <td>${formatCurrency(r.total_vendas_dinheiro)}</td>\n                        <td class=\"text-end pe-3\">\n                            <div class=\"btn-group btn-group-sm\" role=\"group\">\n                                <button type=\"button\" class=\"btn btn-outline-primary\" data-action=\"visualizar\" data-id=\"${r.id}\" title=\"Visualizar\"><i class=\"bi bi-eye\"></i></button>\n                                <a href=\"/novo-relatorio?edit=${r.id}\" class=\"btn btn-outline-secondary\" title=\"Editar\"><i class=\"bi bi-pencil-fill\"></i></a>\n                                <button type=\"button\" class=\"btn btn-outline-danger\" data-action=\"excluir\" data-id=\"${r.id}\" title=\"Excluir\"><i class=\"bi bi-trash\"></i></button>\n                            </div>\n                        </td>\n                    </tr>\n                `;\n            }).join('');\n\n            if (isNewSearch) {\n                tableBody.innerHTML = relatorios.length > 0 ? newRowsHtml : '<tr><td colspan=\"5\" class=\"text-center\">Nenhum relatório encontrado.</td></tr>';\n            } else {\n                tableBody.insertAdjacentHTML('beforeend', newRowsHtml);\n            }\n\n            currentOffset += relatorios.length;\n            btnCarregarMais.classList.toggle('d-none', currentOffset >= totalReportsCount);\n\n        } catch (e) {\n            tableBody.innerHTML = '<tr><td colspan=\"5\" class=\"text-center text-danger\">Erro ao carregar relatórios.</td></tr>';\n        } finally {\n            btnCarregarMais.disabled = false;\n            btnCarregarMais.innerHTML = 'Carregar Mais Relatórios';\n        }\n    }\n\n    async function visualizarRelatorio(id) {\n        currentReportId = id;\n        const modalLabel = document.getElementById('modal-visualizar-label');\n        const listaAnexos = document.getElementById('lista-anexos');\n        const infoLoja = document.getElementById('info-loja');\n        const infoData = document.getElementById('info-data');\n        const infoVendas = document.getElementById('info-vendas');\n        const tabRelatorio = document.getElementById('tab-relatorio');\n        \n        modalLabel.textContent = `Carregando Relatório...`;\n        tabRelatorio.innerHTML = '<div class=\"d-flex justify-content-center align-items-center\" style=\"height: 70vh;\"><div class=\"spinner-border\" role=\"status\"></div></div>';\n        listaAnexos.innerHTML = '<div class=\"text-muted small text-center py-2\"><i class=\"bi bi-file-earmark\"></i> Carregando...</div>';\n        modalView.show();\n\n        try {\n            // Buscar dados do relatório\n            const relatorioResponse = await fetch(`/api/relatorios/${id}`);\n            if (!relatorioResponse.ok) throw new Error(\"Não foi possível carregar dados do relatório.\");\n            const { relatorio } = await relatorioResponse.json();\n            \n            // Preencher informações do relatório\n            infoLoja.textContent = relatorio.loja || '-';\n            infoData.textContent = new Date(relatorio.data).toLocaleDateString('pt-BR', {timeZone: 'UTC'});\n            infoVendas.textContent = new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(relatorio.total_vendas_dinheiro || 0);\n            \n            // Carregar preview do PDF do relatório na aba correta\n            const response = await fetch(`/api/relatorios/${id}/pdf`);\n            if (!response.ok) throw new Error(\"Não foi possível gerar a visualização do PDF.\");\n            const fileBlob = await response.blob();\n            const fileURL = URL.createObjectURL(fileBlob);\n            modalLabel.textContent = `Visualizar Relatório #${id}`;\n            tabRelatorio.innerHTML = `<iframe src=\"${fileURL}\" style=\"width: 100%; height: 70vh; border: none;\"></iframe>`;\n            \n            // Carregar anexos (tickets e rankings)\n            await carregarAnexos(id, relatorio.loja, relatorio.data);\n        } catch (e) {\n            tabRelatorio.innerHTML = `<div class=\"p-3 text-center text-danger\"><h3>Oops!</h3><p>Não foi possível carregar a visualização.</p></div>`;\n            showToast('Erro', e.message, 'danger');\n        }\n    }\n    \n    async function carregarAnexos(relatorioId, loja, data) {\n        const listaAnexos = document.getElementById('lista-anexos');\n        const tabsList = document.getElementById('tabs-visualizacao');\n        const tabsContent = document.getElementById('tabs-visualizacao-content');\n        \n        try {\n            // Buscar PDFs de ticket e ranking associados ao relatório\n            const [ticketsResponse, rankingsResponse] = await Promise.all([\n                fetch(`/api/pdf/tickets?loja=${encodeURIComponent(loja)}&data=${data}`),\n                fetch(`/api/pdf/rankings?loja=${encodeURIComponent(loja)}&data=${data}`)\n            ]);\n            \n            const ticketsData = await ticketsResponse.json();\n            const rankingsData = await rankingsResponse.json();\n            \n            const tickets = ticketsData.tickets || [];\n            const rankings = rankingsData.rankings || [];\n            \n            // Limpar abas antigas (exceto a do relatório)\n            const existingTabs = tabsList.querySelectorAll('li:not(:first-child)');\n            existingTabs.forEach(tab => tab.remove());\n            \n            const existingPanes = tabsContent.querySelectorAll('.tab-pane:not(#tab-relatorio)');\n            existingPanes.forEach(pane => pane.remove());\n            \n            if (tickets.length === 0 && rankings.length === 0) {\n                listaAnexos.innerHTML = '<div class=\"text-muted small text-center py-2\"><i class=\"bi bi-inbox\"></i> Nenhum anexo encontrado</div>';\n                return;\n            }\n            \n            // Renderizar lista de anexos na sidebar\n            let anexosHtml = '';\n            let tabIndex = 1;\n            \n            // Adicionar rankings\n            rankings.forEach(ranking => {\n                const dataUpload = new Date(ranking.uploaded_at).toLocaleDateString('pt-BR');\n                const tabId = `tab-ranking-${ranking.id}`;\n                \n                anexosHtml += `\n                    <div class=\"anexo-item p-2 mb-2 border rounded bg-light\" style=\"cursor: pointer;\" data-tab-target=\"#${tabId}\">\n                        <div class=\"d-flex align-items-center\">\n                            <i class=\"bi bi-file-earmark-pdf text-warning fs-4 me-2\"></i>\n                            <div class=\"flex-grow-1\">\n                                <div class=\"fw-bold small\">PDF Ranking</div>\n                                <div class=\"text-muted\" style=\"font-size: 0.75rem;\">${ranking.filename}</div>\n                                <div class=\"text-muted\" style=\"font-size: 0.7rem;\">Enviado em ${dataUpload}</div>\n                            </div>\n                        </div>\n                    </div>\n                `;\n                \n                // Criar aba para o ranking\n                tabsList.insertAdjacentHTML('beforeend', `\n                    <li class=\"nav-item\" role=\"presentation\">\n                        <button class=\"nav-link\" id=\"${tabId}-btn\" data-bs-toggle=\"tab\" data-bs-target=\"#${tabId}\" type=\"button\" role=\"tab\">\n                            <i class=\"bi bi-file-earmark-pdf text-warning me-1\"></i> Ranking\n                        </button>\n                    </li>\n                `);\n                \n                // Criar conteúdo da aba com iframe\n                tabsContent.insertAdjacentHTML('beforeend', `\n                    <div class=\"tab-pane fade\" id=\"${tabId}\" role=\"tabpanel\" style=\"min-height: 70vh;\">\n                        <div class=\"d-flex justify-content-center align-items-center\" style=\"height: 70vh;\">\n                            <div class=\"spinner-border\" role=\"status\"></div>\n                        </div>\n                    </div>\n                `);\n                \n                // Carregar PDF quando a aba for ativada\n                document.getElementById(`${tabId}-btn`).addEventListener('shown.bs.tab', async () => {\n                    const pane = document.getElementById(tabId);\n                    if (!pane.dataset.loaded) {\n                        try {\n                            const response = await fetch(`/api/pdf/rankings/${ranking.id}/download`);\n                            if (!response.ok) throw new Error(\"Erro ao carregar PDF\");\n                            const blob = await response.blob();\n                            const url = URL.createObjectURL(blob);\n                            pane.innerHTML = `<iframe src=\"${url}\" style=\"width: 100%; height: 70vh; border: none;\"></iframe>`;\n                            pane.dataset.loaded = 'true';\n                        } catch (e) {\n                            pane.innerHTML = `<div class=\"p-3 text-center text-danger\"><h3>Erro</h3><p>Não foi possível carregar o PDF.</p></div>`;\n                        }\n                    }\n                });\n                \n                tabIndex++;\n            });\n            \n            // Adicionar tickets\n            tickets.forEach(ticket => {\n                const dataUpload = new Date(ticket.uploaded_at).toLocaleDateString('pt-BR');\n                const tabId = `tab-ticket-${ticket.id}`;\n                \n                anexosHtml += `\n                    <div class=\"anexo-item p-2 mb-2 border rounded bg-light\" style=\"cursor: pointer;\" data-tab-target=\"#${tabId}\">\n                        <div class=\"d-flex align-items-center\">\n                            <i class=\"bi bi-file-earmark-pdf text-danger fs-4 me-2\"></i>\n                            <div class=\"flex-grow-1\">\n                                <div class=\"fw-bold small\">Ticket Dia</div>\n                                <div class=\"text-muted\" style=\"font-size: 0.75rem;\">${ticket.filename}</div>\n                                <div class=\"text-muted\" style=\"font-size: 0.7rem;\">Enviado em ${dataUpload}</div>\n                            </div>\n                        </div>\n                    </div>\n                `;\n                \n                // Criar aba para o ticket\n                tabsList.insertAdjacentHTML('beforeend', `\n                    <li class=\"nav-item\" role=\"presentation\">\n                        <button class=\"nav-link\" id=\"${tabId}-btn\" data-bs-toggle=\"tab\" data-bs-target=\"#${tabId}\" type=\"button\" role=\"tab\">\n                            <i class=\"bi bi-file-earmark-pdf text-danger me-1\"></i> Ticket\n                        </button>\n                    </li>\n                `);\n                \n                // Criar conteúdo da aba com iframe\n                tabsContent.insertAdjacentHTML('beforeend', `\n                    <div class=\"tab-pane fade\" id=\"${tabId}\" role=\"tabpanel\" style=\"min-height: 70vh;\">\n                        <div class=\"d-flex justify-content-center align-items-center\" style=\"height: 70vh;\">\n                            <div class=\"spinner-border\" role=\"status\"></div>\n                        </div>\n                    </div>\n                `);\n                \n                // Carregar PDF quando a aba for ativada\n                document.getElementById(`${tabId}-btn`).addEventListener('shown.bs.tab', async () => {\n                    const pane = document.getElementById(tabId);\n                    if (!pane.dataset.loaded) {\n                        try {\n                            const response = await fetch(`/api/pdf/tickets/${ticket.id}/download`);\n                            if (!response.ok) throw new Error(\"Erro ao carregar PDF\");\n                            const blob = await response.blob();\n                            const url = URL.createObjectURL(blob);\n                            pane.innerHTML = `<iframe src=\"${url}\" style=\"width: 100%; height: 70vh; border: none;\"></iframe>`;\n                            pane.dataset.loaded = 'true';\n                        } catch (e) {\n                            pane.innerHTML = `<div class=\"p-3 text-center text-danger\"><h3>Erro</h3><p>Não foi possível carregar o PDF.</p></div>`;\n                        }\n                    }\n                });\n                \n                tabIndex++;\n            });\n            \n            listaAnexos.innerHTML = anexosHtml;\n            \n            // Adicionar event listeners para abrir aba ao clicar no anexo\n            document.querySelectorAll('.anexo-item').forEach(item => {\n                item.addEventListener('click', () => {\n                    const tabTarget = item.dataset.tabTarget;\n                    const tabButton = document.querySelector(`[data-bs-target=\"${tabTarget}\"]`);\n                    if (tabButton) {\n                        const tab = new bootstrap.Tab(tabButton);\n                        tab.show();\n                    }\n                });\n            });\n            \n        } catch (e) {\n            listaAnexos.innerHTML = '<div class=\"text-muted small text-center py-2\"><i class=\"bi bi-exclamation-triangle\"></i> Erro ao carregar anexos</div>';\n            console.error('Erro ao carregar anexos:', e);\n        }\n    }\n\n    async function excluirRelatorio(id) {\n        const confirmed = await showConfirmModal(`Tem certeza que deseja excluir o relatório #${id}?`);\n        if (!confirmed) return;\n        try {\n            const response = await fetch(`/api/relatorios/${id}`, { \n                method: 'DELETE',\n                headers: await getAuthHeaders()\n            });\n            if (!response.ok) throw new Error('Falha ao excluir o relatório.');\n            showToast('Sucesso', 'Relatório excluído com sucesso.', 'success');\n            carregarRelatorios(true);\n        } catch (e) {\n            showToast('Erro', 'Não foi possível excluir o relatório.', 'danger');\n        }\n    }\n\n    async function carregarLojasNoFiltro() {\n        try {\n            const response = await fetch('/api/lojas');\n            const lojas = await response.json();\n            filtroLoja.innerHTML = '<option value=\"\">Todas as Lojas</option>';\n            lojas.forEach(loja => filtroLoja.add(new Option(loja.nome, loja.nome)));\n        } catch (e) {\n            console.error(\"Erro ao carregar lojas:\", e);\n        }\n    }\n    \n    // --- Event Listeners ---\n    document.getElementById('btn-copiar-texto-modal')?.addEventListener('click', async () => {\n        if (!currentReportId) return;\n        try {\n            const response = await fetch(`/api/relatorios/${currentReportId}/txt`);\n            if (!response.ok) throw new Error(\"Falha ao buscar texto para cópia.\");\n            const textToCopy = await response.text();\n            await navigator.clipboard.writeText(textToCopy);\n            showToast('Sucesso!', 'Texto copiado.', 'success');\n        } catch (err) {\n            showToast('Erro', 'Não foi possível copiar o texto.', 'danger');\n        }\n    }, { signal: eventController.signal });\n\n    document.getElementById('btn-gerar-pdf-modal')?.addEventListener('click', () => {\n        if (!currentReportId) return;\n        window.open(`/api/relatorios/${currentReportId}/pdf`, '_blank');\n    }, { signal: eventController.signal });\n\n    formFiltros.addEventListener('submit', (e) => { e.preventDefault(); carregarRelatorios(true); }, { signal: eventController.signal });\n    \n    // ADICIONADO: Resetar o filtro de ordem ao limpar\n    btnLimpar.addEventListener('click', () => { \n        formFiltros.reset(); \n        filtroOrdem.value = 'desc'; // Garante que o padrão seja selecionado\n        carregarRelatorios(true); \n    }, { signal: eventController.signal });\n    \n    btnCarregarMais.addEventListener('click', () => carregarRelatorios(false), { signal: eventController.signal });\n\n    pageContent.addEventListener('click', (e) => {\n        const button = e.target.closest('button[data-action]');\n        if (!button || !button.closest('#tabela-relatorios-corpo')) return;\n        const id = button.dataset.id;\n        const action = button.dataset.action;\n        if (action === 'visualizar') visualizarRelatorio(id);\n        if (action === 'excluir') excluirRelatorio(id);\n    }, { signal: eventController.signal });\n    \n    // ADICIONADO: Event listener para o novo filtro de ordem\n    filtroOrdem.addEventListener('change', () => carregarRelatorios(true), { signal: eventController.signal });\n\n    const formExport = document.getElementById('form-export-excel');\n    const exportMonthSelect = document.getElementById('export-month');\n    const exportYearSelect = document.getElementById('export-year');\n    \n    if (exportYearSelect.options.length <= 1) {\n        const currentYear = new Date().getFullYear();\n        for (let i = 0; i < 5; i++) {\n            const year = currentYear - i;\n            exportYearSelect.add(new Option(year, year));\n        }\n    }\n    exportMonthSelect.value = new Date().getMonth() + 1;\n\n    formExport.addEventListener('submit', async (e) => {\n        e.preventDefault();\n        const btn = e.target.querySelector('button[type=\"submit\"]');\n        const originalText = btn.innerHTML;\n        btn.disabled = true;\n        btn.innerHTML = `<span class=\"spinner-border spinner-border-sm\"></span> Gerando...`;\n        \n        try {\n            const response = await fetch(`/api/export/excel?month=${exportMonthSelect.value}&year=${exportYearSelect.value}`);\n            if (response.ok) {\n                const blob = await response.blob();\n                const url = window.URL.createObjectURL(blob);\n                const a = document.createElement('a');\n                const monthName = new Date(exportYearSelect.value, exportMonthSelect.value - 1).toLocaleString('pt-BR', { month: 'long' });\n                a.download = `Relatorios_${monthName}_${exportYearSelect.value}.xlsx`;\n                a.href = url;\n                a.click();\n                window.URL.revokeObjectURL(url);\n            } else {\n                const result = await response.json();\n                showToast(\"Erro ao Exportar\", result.error || \"Não foi possível gerar.\", \"danger\");\n            }\n        } catch (err) {\n            showToast(\"Erro\", \"Falha na exportação.\", \"danger\");\n        } finally {\n            btn.disabled = false;\n            btn.innerHTML = originalText;\n        }\n    }, { signal: eventController.signal });\n\n    // Evento para exportar TODOS os relatórios\n    const btnExportarTodos = document.getElementById('btn-exportar-todos-relatorios');\n    if (btnExportarTodos) {\n        btnExportarTodos.addEventListener('click', async (e) => {\n            e.preventDefault();\n            const originalText = btnExportarTodos.innerHTML;\n            btnExportarTodos.innerHTML = `<span class=\"spinner-border spinner-border-sm\"></span> Gerando...`;\n            btnExportarTodos.style.pointerEvents = 'none';\n            \n            try {\n                const response = await fetch(`/api/export/excel/all`);\n                if (response.ok) {\n                    const blob = await response.blob();\n                    const url = window.URL.createObjectURL(blob);\n                    const a = document.createElement('a');\n                    const currentDate = new Date().toLocaleDateString('pt-BR').replace(/\\//g, '-');\n                    a.download = `Todos_Relatorios_${currentDate}.xlsx`;\n                    a.href = url;\n                    a.click();\n                    window.URL.revokeObjectURL(url);\n                    showToast(\"Sucesso!\", \"Todos os relatórios foram exportados!\", \"success\");\n                } else {\n                    const result = await response.json();\n                    showToast(\"Erro ao Exportar\", result.error || \"Não foi possível gerar.\", \"danger\");\n                }\n            } catch (err) {\n                showToast(\"Erro\", \"Falha na exportação.\", \"danger\");\n            } finally {\n                btnExportarTodos.innerHTML = originalText;\n                btnExportarTodos.style.pointerEvents = 'auto';\n            }\n        }, { signal: eventController.signal });\n    }\n\n    carregarLojasNoFiltro().then(() => carregarRelatorios(true));\n}","size_bytes":23253},"public/js/pages/novo-relatorio.js":{"content":"import { showToast, getCsrfToken, getAuthHeaders } from '../utils.js';\n\nexport function initNovoRelatorioPage() {\n    const form = document.getElementById('form-novo-relatorio');\n    if (!form) return;\n\n    // --- Seleção de Elementos ---\n    const btnImportarPdf = document.getElementById(\"btn-importar-pdf\");\n    const pdfFileInput = document.getElementById(\"pdf-file-input\");\n    const btnTicketDia = document.getElementById(\"btn-ticket-dia\");\n    const ticketPdfInput = document.getElementById(\"ticket-pdf-input\");\n    const btnSalvarTudo = document.getElementById(\"btn-salvar-tudo\");\n    const btnLimparFormulario = document.getElementById(\"btn-limpar-formulario\");\n    const btnAddVendedor = document.getElementById(\"btn-add-vendedor\");\n    const btnAddVendedorManual = document.getElementById(\"btn-add-vendedor-manual\");\n    const containerVendedores = document.getElementById(\"container-vendedores\");\n    const placeholderVendedores = document.getElementById(\"vendedores-placeholder\");\n    const lojaSelect = document.getElementById(\"loja\");\n    const dataInput = document.getElementById(\"data\");\n    const resultadosPdfContainer = document.getElementById('resultados-pdf-container');\n    const totalVendasDinheiroInput = form.querySelector('[name=\"total_vendas_dinheiro\"]');\n    const ticketMedioInput = form.querySelector('[name=\"ticket_medio\"]');\n    const paInput = form.querySelector('[name=\"pa\"]');\n    const clientesMonitoramentoInput = document.getElementById('clientes_monitoramento_input');\n    const vendasMonitoramentoInput = document.getElementById('vendas_monitoramento_input');\n    const clientesLojaInput = document.getElementById('clientes_loja_input');\n    const vendasLojaInput = document.getElementById('vendas_loja_input');\n    const omniInput = document.getElementById('quantidade_omni_input');\n    const monitoramentoDonutCanvas = document.getElementById('monitoramento-donut-chart');\n    const lojaDonutCanvas = document.getElementById('loja-donut-chart');\n    \n    // ADICIONADO: Selecionar os novos inputs de pagamento\n    const vendasCartaoInput = document.getElementById('vendas_cartao_input');\n    const vendasPixInput = document.getElementById('vendas_pix_input');\n    const vendasDinheiroInput = document.getElementById('vendas_dinheiro_input');\n    const vendasTotalPagamentoInput = document.getElementById('vendas_total_pagamento_input');\n\n    // --- Variáveis de Estado ---\n    let lojasCache = [];\n    let vendedoresCache = [];\n    const urlParams = new URLSearchParams(window.location.search);\n    const reportId = urlParams.get('edit');\n    let monitoramentoDonutChart = null;\n    let lojaDonutChart = null;\n    const DRAFT_KEY = 'draftRelatorio';\n    let vendedorCounter = 0;\n    let previousLojaValue = null; // Track previous store to detect changes\n    \n    // Rastreamento de anexos\n    let anexos = {\n        rankingPdf: false,\n        ticketPdf: false\n    };\n\n    // --- Funções de Gerenciamento de Rascunho ---\n    function salvarRascunho() {\n        if (reportId) return;\n        const formData = new FormData(form);\n        const data = Object.fromEntries(formData.entries());\n        const nomes = formData.getAll('vendedor_nome');\n        const atendimentos = formData.getAll('vendedor_atendimentos');\n        const vendas = formData.getAll('vendedor_vendas');\n        data.vendedores = nomes.map((nome, index) => ({ nome: nome.trim(), atendimentos: atendimentos[index] || 0, vendas: vendas[index] || 0 }));\n        data.pdfSectionVisible = resultadosPdfContainer.style.display === 'block';\n        data.anexos = anexos; // Salvar estado dos anexos\n        sessionStorage.setItem(DRAFT_KEY, JSON.stringify(data));\n    }\n\n    function carregarRascunho() {\n        if (reportId) return;\n        const draft = sessionStorage.getItem(DRAFT_KEY);\n        if (!draft) return;\n        const data = JSON.parse(draft);\n        for (const key in data) {\n            const input = form.querySelector(`[name=\"${key}\"]`);\n            if (input && key !== 'vendedores' && key !== 'anexos') input.value = data[key];\n        }\n        if (data.vendedores && Array.isArray(data.vendedores)) {\n            containerVendedores.innerHTML = '';\n            data.vendedores.forEach(vendedor => adicionarVendedor(vendedor));\n        }\n        if (data.pdfSectionVisible && resultadosPdfContainer) {\n            resultadosPdfContainer.style.display = 'block';\n        }\n        // Restaurar estado dos anexos\n        if (data.anexos) {\n            anexos = data.anexos;\n            if (anexos.rankingPdf) marcarBotaoComAnexo(btnImportarPdf);\n            if (anexos.ticketPdf) marcarBotaoComAnexo(btnTicketDia);\n        }\n        updateVendedoresPlaceholder();\n        handleSelecaoDeLoja();\n        calcularEAtualizarGraficos();\n        calcularTotalVendasPagamento(); // Adicionado para atualizar o total ao carregar rascunho\n        showToast(\"Rascunho Carregado\", \"Seu relatório não salvo foi restaurado.\", \"info\");\n    }\n\n    function limparRascunhoEFormulario() {\n        form.reset();\n        sessionStorage.removeItem(DRAFT_KEY);\n        const hoje = new Date();\n        const offset = hoje.getTimezoneOffset();\n        dataInput.value = new Date(hoje.getTime() - (offset * 60 * 1000)).toISOString().split('T')[0];\n        containerVendedores.innerHTML = '';\n        if(resultadosPdfContainer) resultadosPdfContainer.style.display = 'none';\n        // Limpar anexos\n        anexos = { rankingPdf: false, ticketPdf: false };\n        desmarcarBotao(btnImportarPdf);\n        desmarcarBotao(btnTicketDia);\n        updateVendedoresPlaceholder();\n        handleSelecaoDeLoja();\n        calcularEAtualizarGraficos();\n        calcularTotalVendasPagamento(); // Adicionado para resetar o total ao limpar\n        showToast(\"Formulário Limpo\", \"Todos os campos foram resetados.\", \"success\");\n    }\n\n    // --- Funções de UI e Lógica ---\n    const getCssVar = (varName) => getComputedStyle(document.documentElement).getPropertyValue(varName).trim();\n    \n    function renderDonutChart(canvas, percentage, color) {\n        if (!canvas) return null;\n        const textElement = document.getElementById(canvas.id.replace('chart', 'text'));\n        if (textElement) textElement.textContent = `${parseFloat(percentage).toFixed(1)}%`;\n        const data = { datasets: [{ data: [percentage, 100 - percentage > 0 ? 100 - percentage : 0], backgroundColor: [color, '#e5e5e5'], borderColor: getCssVar('--content-bg'), borderWidth: 3, cutout: '75%' }] };\n        const options = { responsive: true, maintainAspectRatio: true, plugins: { legend: { display: false }, tooltip: { enabled: false } } };\n        const ctx = canvas.getContext('2d');\n        if (canvas.chart) canvas.chart.destroy();\n        canvas.chart = new Chart(ctx, { type: 'doughnut', data, options });\n        return canvas.chart;\n    }\n\n    function updateDonutChart(chartInstance, percentage) {\n        if (!chartInstance) return;\n        const textElement = document.getElementById(chartInstance.canvas.id.replace('chart', 'text'));\n        if (textElement) textElement.textContent = `${parseFloat(percentage).toFixed(1)}%`;\n        chartInstance.data.datasets[0].data[0] = percentage;\n        chartInstance.data.datasets[0].data[1] = 100 - percentage > 0 ? 100 - percentage : 0;\n        chartInstance.update();\n    }\n    \n    // ADICIONADO: Nova função para somar os totais de pagamento\n    function calcularTotalVendasPagamento() {\n        const cartao = Number(vendasCartaoInput.value) || 0;\n        const pix = Number(vendasPixInput.value) || 0;\n        const dinheiro = Number(vendasDinheiroInput.value) || 0;\n        vendasTotalPagamentoInput.value = cartao + pix + dinheiro;\n    }\n\n    function calcularEAtualizarGraficos() {\n        const clientesM = Number(clientesMonitoramentoInput.value) || 0;\n        const vendasM = Number(vendasMonitoramentoInput.value) || 0;\n        const omni = omniInput ? (Number(omniInput.value) || 0) : 0;\n        const totalVendasM = vendasM + omni;\n        const txMonitoramento = clientesM > 0 ? (totalVendasM / clientesM) * 100 : 0;\n        updateDonutChart(monitoramentoDonutChart, txMonitoramento);\n        \n        const clientesL = Number(clientesLojaInput.value) || 0;\n        const vendasL = Number(vendasLojaInput.value) || 0;\n        const txLoja = clientesL > 0 ? (vendasL / clientesL) * 100 : 0;\n        updateDonutChart(lojaDonutChart, txLoja);\n    }\n\n    function updateVendedoresPlaceholder() { if(placeholderVendedores) placeholderVendedores.style.display = containerVendedores.children.length === 0 ? \"block\" : \"none\"; };\n    \n    async function carregarLojas() {\n        try {\n            const response = await fetch(\"/api/lojas\");\n            if (!response.ok) throw new Error('Falha ao carregar lojas.');\n            lojasCache = await response.json();\n            lojaSelect.innerHTML = '<option value=\"\" disabled selected>Selecione uma loja</option>';\n            const lojasFiltradas = reportId ? lojasCache : lojasCache.filter(l => l.status === 'ativa');\n            lojasFiltradas.forEach(l => lojaSelect.add(new Option(l.nome, l.nome)));\n        } catch (e) { console.error(\"Erro ao carregar lojas\", e); }\n    }\n    \n    async function carregarVendedoresDaLoja() {\n        const lojaSelecionada = lojasCache.find(loja => loja.nome === lojaSelect.value);\n        if (!lojaSelecionada) {\n            console.log('Nenhuma loja selecionada');\n            vendedoresCache = [];\n            return;\n        }\n        \n        console.log(`Carregando vendedores para loja: ${lojaSelecionada.nome} (ID: ${lojaSelecionada.id})`);\n        \n        try {\n            const response = await fetch(`/api/vendedores?loja_id=${lojaSelecionada.id}`);\n            if (!response.ok) {\n                console.warn('API de vendedores não disponível, usando modo manual');\n                vendedoresCache = [];\n                return;\n            }\n            const todosVendedores = await response.json();\n            vendedoresCache = todosVendedores.filter(v => v.ativo === 1 || v.ativo === true);\n            console.log(`Vendedores carregados: ${vendedoresCache.length} vendedores ativos`);\n            console.log('Vendedores:', vendedoresCache);\n            \n            atualizarDropdownsVendedores();\n        } catch (e) {\n            console.error(\"Erro ao carregar vendedores\", e);\n            vendedoresCache = [];\n        }\n    }\n    \n    function atualizarDropdownsVendedores() {\n        // Atualizar todos os selects de vendedores existentes com o novo cache\n        const selectsExistentes = containerVendedores.querySelectorAll('.vendedor-select');\n        console.log(`Atualizando ${selectsExistentes.length} dropdowns de vendedores com novo cache`);\n        \n        selectsExistentes.forEach(select => {\n            const valorAtual = select.value; // Preservar seleção atual se possível\n            \n            // Reconstruir opções\n            select.innerHTML = '<option value=\"\">Selecione</option>';\n            vendedoresCache.forEach(v => {\n                const option = document.createElement('option');\n                option.value = v.id;\n                option.textContent = v.nome;\n                if (v.id == valorAtual) {\n                    option.selected = true;\n                }\n                select.appendChild(option);\n            });\n            \n            console.log(`Dropdown atualizado. ${vendedoresCache.length} vendedores disponíveis`);\n        });\n    }\n    \n    async function handleSelecaoDeLoja() {\n        const currentLojaValue = lojaSelect.value;\n        console.log(`Loja selecionada: ${currentLojaValue}`);\n        const lojaSelecionada = lojasCache.find(loja => loja.nome === currentLojaValue);\n        const containerEspecial = document.getElementById('container-funcao-especial');\n        const campoOmni = document.getElementById('campo-omni');\n        const campoBuscaAssist = document.getElementById('campo-busca-assist');\n\n        if(containerEspecial) containerEspecial.style.display = \"none\";\n        if(campoOmni) campoOmni.style.display = \"none\";\n        if(campoBuscaAssist) campoBuscaAssist.style.display = \"none\";\n\n        if (!lojaSelecionada || !lojaSelecionada.funcao_especial) {\n            calcularEAtualizarGraficos();\n        } else {\n            containerEspecial.style.display = \"block\";\n            if (lojaSelecionada.funcao_especial === \"Omni\") campoOmni.style.display = \"block\";\n            else if (lojaSelecionada.funcao_especial === \"Busca por Assist. Tec.\") campoBuscaAssist.style.display = \"block\";\n            calcularEAtualizarGraficos();\n        }\n        \n        // Detectar se a loja realmente mudou (usuário trocou manualmente)\n        const lojaChanged = previousLojaValue !== null && previousLojaValue !== currentLojaValue;\n        \n        if (lojaChanged) {\n            // IMPORTANTE: Limpar vendedores existentes APENAS quando o usuário trocar de loja\n            // Isso previne limpar vendedores ao carregar rascunhos/edições\n            containerVendedores.innerHTML = '';\n            console.log('Loja alterada: vendedores limpos. Adicione novos vendedores para esta loja.');\n        }\n        \n        // Atualizar loja anterior\n        previousLojaValue = currentLojaValue;\n        \n        // Carregar vendedores da loja selecionada\n        await carregarVendedoresDaLoja();\n        \n        // Atualizar placeholder de vendedores\n        updateVendedoresPlaceholder();\n    }\n    \n    function adicionarVendedor(vendedor = { nome: '', atendimentos: 0, vendas: 0, id_vendedor: null }, forcarManual = false) {\n        if (!lojaSelect.value) {\n            showToast(\"Atenção\", \"Selecione uma loja antes de adicionar vendedores.\", \"warning\");\n            return;\n        }\n        \n        vendedorCounter++;\n        const uniqueId = `vendedor-${vendedorCounter}`;\n        \n        const card = document.createElement(\"div\");\n        card.className = \"vendedor-card\";\n        card.dataset.uniqueId = uniqueId;\n        \n        // Se forçar manual OU não tiver vendedores cadastrados, mostrar INPUT. Caso contrário, mostrar SELECT\n        const temVendedoresCadastrados = vendedoresCache.length > 0;\n        const mostrarInput = forcarManual || !temVendedoresCadastrados;\n        \n        let selectHtml = '';\n        if (!mostrarInput && temVendedoresCadastrados) {\n            selectHtml = '<select class=\"form-select vendedor-select\" data-id=\"' + uniqueId + '\">';\n            selectHtml += '<option value=\"\">Selecione</option>';\n            vendedoresCache.forEach(v => {\n                const selected = vendedor.id_vendedor === v.id ? 'selected' : '';\n                selectHtml += `<option value=\"${v.id}\" ${selected}>${v.nome}</option>`;\n            });\n            selectHtml += '</select>';\n        }\n        \n        card.innerHTML = `\n            <span class=\"vendedor-numero\">#${vendedorCounter}</span>\n            <div class=\"vendedor-field vendedor-nome\">\n                <label>Vendedor</label>\n                ${mostrarInput ? \n                `<input type=\"text\" class=\"form-control vendedor-nome-input\" \n                    placeholder=\"Nome do vendedor\" value=\"${vendedor.nome || ''}\" required>` : selectHtml}\n                <input type=\"hidden\" class=\"vendedor-nome-hidden\" name=\"vendedor_nome\" value=\"${vendedor.nome || ''}\">\n                <input type=\"hidden\" class=\"vendedor-id-input\" name=\"vendedor_id\" value=\"${vendedor.id_vendedor || ''}\">\n            </div>\n            <div class=\"vendedor-field vendedor-atend\">\n                <label>Atend.</label>\n                <input type=\"number\" class=\"form-control vendedor-atendimentos-input\" \n                    name=\"vendedor_atendimentos\" value=\"${vendedor.atendimentos || 0}\" min=\"0\" required>\n            </div>\n            <div class=\"vendedor-field vendedor-vendas\">\n                <label>Vendas</label>\n                <input type=\"number\" class=\"form-control vendedor-vendas-input\" \n                    name=\"vendedor_vendas\" value=\"${vendedor.vendas || 0}\" min=\"0\" required>\n            </div>\n            <div class=\"vendedor-taxa-conversao\">\n                <span class=\"taxa-valor\">0%</span>\n            </div>\n            <button type=\"button\" class=\"btn-remove-vendedor\">×</button>\n        `;\n        \n        containerVendedores.appendChild(card);\n        updateVendedoresPlaceholder();\n        \n        // Calcular taxa de conversão inicial\n        calcularTaxaConversao(card);\n        \n        // Event listeners para este card\n        const selectVendedor = card.querySelector('.vendedor-select');\n        const nomeInput = card.querySelector('.vendedor-nome-input');\n        const nomeHidden = card.querySelector('.vendedor-nome-hidden');\n        const idInput = card.querySelector('.vendedor-id-input');\n        const atendimentosInput = card.querySelector('.vendedor-atendimentos-input');\n        const vendasInput = card.querySelector('.vendedor-vendas-input');\n        \n        // Se tem SELECT (vendedores cadastrados), adicionar listener\n        if (selectVendedor) {\n            selectVendedor.addEventListener('change', (e) => {\n                const vendedorId = e.target.value;\n                if (vendedorId) {\n                    const vendedorSelecionado = vendedoresCache.find(v => v.id == vendedorId);\n                    if (vendedorSelecionado) {\n                        nomeHidden.value = vendedorSelecionado.nome;\n                        idInput.value = vendedorSelecionado.id;\n                    }\n                } else {\n                    nomeHidden.value = '';\n                    idInput.value = '';\n                }\n                salvarRascunho();\n            });\n        }\n        \n        // Se tem INPUT manual, adicionar listener\n        if (nomeInput) {\n            nomeInput.addEventListener('input', (e) => {\n                nomeHidden.value = e.target.value;\n                salvarRascunho();\n            });\n        }\n        \n        atendimentosInput.addEventListener('input', () => {\n            calcularTaxaConversao(card);\n            salvarRascunho();\n        });\n        \n        vendasInput.addEventListener('input', () => {\n            calcularTaxaConversao(card);\n            salvarRascunho();\n        });\n        \n        // Botão de remover vendedor\n        const btnRemover = card.querySelector('.btn-remove-vendedor');\n        btnRemover.addEventListener('click', () => {\n            card.remove();\n            updateVendedoresPlaceholder();\n            salvarRascunho();\n        });\n    }\n    \n    function calcularTaxaConversao(card) {\n        const atendimentos = Number(card.querySelector('.vendedor-atendimentos-input').value) || 0;\n        const vendas = Number(card.querySelector('.vendedor-vendas-input').value) || 0;\n        const taxa = atendimentos > 0 ? (vendas / atendimentos) * 100 : 0;\n        card.querySelector('.taxa-valor').textContent = `${taxa.toFixed(1)}%`;\n    }\n    \n    async function carregarDadosParaEdicao() {\n        showToast(\"Modo de Edição\", \"Carregando dados do relatório...\", \"info\");\n        await carregarLojas();\n        try {\n            const response = await fetch(`/api/relatorios/${reportId}`);\n            if (!response.ok) throw new Error('Relatório não encontrado.');\n            const { relatorio } = await response.json();\n\n            if(resultadosPdfContainer && relatorio.total_vendas_dinheiro && parseFloat(String(relatorio.total_vendas_dinheiro).replace(/[R$\\s.]/g, '').replace(',', '.')) > 0) {\n                resultadosPdfContainer.style.display = 'block';\n            }\n            \n            const vendedores = JSON.parse(relatorio.vendedores||'[]');\n            for (const key in relatorio) { \n                const input = form.querySelector(`[name=\"${key}\"]`); \n                if (input) input.value = relatorio[key]; \n            }\n            containerVendedores.innerHTML = '';\n            vendedores.forEach(vend => adicionarVendedor(vend));\n            \n            updateVendedoresPlaceholder();\n            handleSelecaoDeLoja();\n            btnSalvarTudo.textContent = 'SALVAR ALTERAÇÕES';\n            calcularEAtualizarGraficos();\n            calcularTotalVendasPagamento(); // Adicionado para calcular o total ao carregar para edição\n        } catch(e) { showToast(\"Erro\", \"Não foi possível carregar os dados para edição.\", \"danger\"); }\n    }\n    \n    async function handleSalvarTudo() {\n        if (!form.checkValidity()) { \n            form.reportValidity(); \n            showToast(\"Campos Inválidos\", \"Por favor, preencha todos os campos obrigatórios.\", \"danger\");\n            return;\n        }\n        \n        const fd = new FormData(form);\n        const data = Object.fromEntries(fd.entries());\n        const n = fd.getAll('vendedor_nome'), a = fd.getAll('vendedor_atendimentos'), v = fd.getAll('vendedor_vendas');\n        data.vendedores = JSON.stringify(n.map((nome, i) => ({ nome: nome.trim(), atendimentos: parseInt(a[i],10)||0, vendas: parseInt(v[i],10)||0 })).filter(vend => vend.nome));\n        \n        const method = reportId ? 'PUT' : 'POST';\n        const url = reportId ? `/api/relatorios/${reportId}` : '/api/relatorios';\n        \n        btnSalvarTudo.disabled = true;\n        btnSalvarTudo.innerHTML = '<span class=\"spinner-border spinner-border-sm me-2\"></span>Salvando...';\n        try {\n            const response = await fetch(url, { method, headers: await getAuthHeaders(), body: JSON.stringify(data) });\n            const result = await response.json();\n            if (!response.ok) throw new Error(result.error || 'Erro desconhecido ao salvar.');\n            showToast('Sucesso!', reportId ? 'Relatório atualizado com sucesso!' : 'Relatório salvo com sucesso!', 'success');\n            \n            if (reportId) {\n                setTimeout(() => window.location.href = '/consulta', 1000);\n            } else {\n                limparRascunhoEFormulario();\n            }\n        } catch (e) {\n            showToast('Falha ao Salvar', e.message, 'danger');\n        } finally {\n            btnSalvarTudo.disabled = false;\n            btnSalvarTudo.textContent = reportId ? 'SALVAR ALTERAÇÕES' : 'SALVAR RELATÓRIO COMPLETO';\n        }\n    }\n    \n    // Função para marcar botão com anexo (laranja permanente)\n    function marcarBotaoComAnexo(botao) {\n        botao.style.backgroundColor = '#ff6600';\n        botao.style.borderColor = '#ff6600';\n        botao.style.color = '#fff';\n        botao.dataset.temAnexo = 'true';\n    }\n    \n    // Função para desmarcar botão (voltar ao padrão)\n    function desmarcarBotao(botao) {\n        botao.style.backgroundColor = '';\n        botao.style.borderColor = '';\n        botao.style.color = '';\n        botao.dataset.temAnexo = 'false';\n    }\n    \n    // Função para feedback temporário de sucesso (mantém laranja)\n    function mostrarFeedbackSucesso(botao) {\n        // Mostrar um toast rápido de sucesso\n        showToast('Anexo Salvo', 'Arquivo anexado com sucesso!', 'success');\n    }\n    \n    // --- Lógica de Importação de PDF ---\n    btnImportarPdf.addEventListener('click', () => pdfFileInput.click());\n    pdfFileInput.addEventListener('change', async (event) => {\n        const file = event.target.files[0];\n        if (!file) return;\n\n        btnImportarPdf.disabled = true;\n        btnImportarPdf.innerHTML = '<span class=\"spinner-border spinner-border-sm me-2\"></span>Processando...';\n\n        try {\n            const formData = new FormData();\n            formData.append('pdfFile', file);\n            const csrfToken = await getCsrfToken();\n            const response = await fetch('/api/process-pdf', { \n                method: 'POST', \n                headers: { 'x-csrf-token': csrfToken },\n                body: formData \n            });\n            const result = await response.json();\n            if (!response.ok) throw new Error(result.error || 'Erro ao processar PDF.');\n            \n            const { data: extractedData } = result;\n            \n            // PREENCHIMENTO EXPLÍCITO CORRIGIDO\n            if (extractedData.total_vendas_dinheiro) totalVendasDinheiroInput.value = extractedData.total_vendas_dinheiro;\n            if (extractedData.ticket_medio) ticketMedioInput.value = extractedData.ticket_medio;\n            if (extractedData.pa) paInput.value = extractedData.pa;\n            if (extractedData.data) dataInput.value = extractedData.data;\n            if (extractedData.loja) {\n                const storeExists = Array.from(lojaSelect.options).some(option => option.text.trim().toUpperCase() === extractedData.loja.trim().toUpperCase());\n                if (storeExists) {\n                    lojaSelect.value = Array.from(lojaSelect.options).find(option => option.text.trim().toUpperCase() === extractedData.loja.trim().toUpperCase()).value;\n                } else {\n                    showToast(\"Atenção\", `A loja \"${extractedData.loja}\" do PDF não foi encontrada no sistema.`, \"danger\");\n                }\n            }\n            \n            // Só limpar vendedores se o PDF trouxer vendedores novos\n            if (extractedData.vendedores && extractedData.vendedores.length > 0) {\n                containerVendedores.innerHTML = '';\n                extractedData.vendedores.forEach(vendedor => adicionarVendedor(vendedor));\n            }\n            \n            if(resultadosPdfContainer) resultadosPdfContainer.style.display = 'block';\n            \n            // ATUALIZAÇÃO DA UI\n            updateVendedoresPlaceholder();\n            handleSelecaoDeLoja();\n            calcularEAtualizarGraficos();\n            salvarRascunho();\n            showToast(\"Sucesso!\", \"Dados do PDF importados com sucesso.\", \"success\");\n            \n            // SALVAR PDF DE RANKING FISICAMENTE NO SERVIDOR\n            const loja = lojaSelect.value;\n            const data = dataInput.value;\n            \n            if (loja && data) {\n                try {\n                    const saveFormData = new FormData();\n                    saveFormData.append('pdf', file);\n                    saveFormData.append('loja', loja);\n                    saveFormData.append('data', data);\n                    \n                    const saveResponse = await fetch('/api/pdf/ranking', {\n                        method: 'POST',\n                        headers: { 'x-csrf-token': csrfToken },\n                        body: saveFormData\n                    });\n                    \n                    if (saveResponse.ok) {\n                        const saveResult = await saveResponse.json();\n                        console.log('PDF de Ranking salvo:', saveResult);\n                    }\n                } catch (saveError) {\n                    console.error('Erro ao salvar PDF de Ranking:', saveError);\n                }\n            }\n            \n            // Marcar botão como anexado\n            btnImportarPdf.disabled = false;\n            btnImportarPdf.innerHTML = '<i class=\"bi bi-file-earmark-arrow-up-fill\"></i>';\n            anexos.rankingPdf = true;\n            marcarBotaoComAnexo(btnImportarPdf);\n            mostrarFeedbackSucesso(btnImportarPdf);\n            salvarRascunho(); // Salvar estado do anexo\n            pdfFileInput.value = '';\n\n        } catch (error) {\n            showToast(\"Erro na Importação\", error.message, \"danger\");\n            btnImportarPdf.disabled = false;\n            btnImportarPdf.innerHTML = '<i class=\"bi bi-file-earmark-arrow-up-fill\"></i>';\n            pdfFileInput.value = '';\n        }\n    });\n\n    // --- Lógica dos Botões de PDF (Ticket) ---\n    // Botão Ticket Dia\n    if (btnTicketDia) {\n        btnTicketDia.addEventListener('click', () => {\n            const loja = lojaSelect.value;\n            const data = dataInput.value;\n            \n            if (!loja || !data) {\n                showToast('Atenção', 'Por favor, selecione a loja e a data antes de salvar o PDF de Ticket.', 'warning');\n                return;\n            }\n            \n            ticketPdfInput.click();\n        });\n    }\n    \n    if (ticketPdfInput) {\n        ticketPdfInput.addEventListener('change', async (event) => {\n            const file = event.target.files[0];\n            if (!file) return;\n            \n            const loja = lojaSelect.value;\n            const data = dataInput.value;\n            \n            if (!loja || !data) {\n                showToast('Atenção', 'Por favor, selecione a loja e a data antes de salvar o PDF.', 'warning');\n                ticketPdfInput.value = '';\n                return;\n            }\n            \n            btnTicketDia.disabled = true;\n            btnTicketDia.innerHTML = '<span class=\"spinner-border spinner-border-sm me-2\"></span>Salvando...';\n            \n            try {\n                const formData = new FormData();\n                formData.append('pdf', file);\n                formData.append('loja', loja);\n                formData.append('data', data);\n                \n                const csrfToken = await getCsrfToken();\n                const response = await fetch('/api/pdf/ticket', {\n                    method: 'POST',\n                    headers: { 'x-csrf-token': csrfToken },\n                    body: formData\n                });\n                \n                const result = await response.json();\n                \n                if (!response.ok) {\n                    throw new Error(result.error || 'Erro ao salvar PDF de Ticket');\n                }\n                \n                showToast('Sucesso!', `PDF de Ticket salvo: ${result.data.filename}`, 'success');\n                \n                // Marcar botão como anexado\n                btnTicketDia.disabled = false;\n                btnTicketDia.innerHTML = '<i class=\"bi bi-receipt\"></i>';\n                anexos.ticketPdf = true;\n                marcarBotaoComAnexo(btnTicketDia);\n                salvarRascunho(); // Salvar estado do anexo\n                ticketPdfInput.value = '';\n                \n            } catch (error) {\n                showToast('Erro', error.message, 'danger');\n                btnTicketDia.disabled = false;\n                btnTicketDia.innerHTML = '<i class=\"bi bi-receipt\"></i>';\n                ticketPdfInput.value = '';\n            }\n        });\n    }\n\n    // --- Inicialização dos Event Listeners ---\n    btnAddVendedor.addEventListener(\"click\", () => adicionarVendedor());\n    btnAddVendedorManual.addEventListener(\"click\", (e) => {\n        e.preventDefault();\n        adicionarVendedor({}, true); // true = forçar modo manual\n    });\n    btnSalvarTudo.addEventListener(\"click\", handleSalvarTudo);\n    btnLimparFormulario.addEventListener(\"click\", limparRascunhoEFormulario);\n    lojaSelect.addEventListener(\"change\", handleSelecaoDeLoja);\n\n    form.addEventListener('input', () => {\n        calcularEAtualizarGraficos();\n        salvarRascunho();\n    });\n\n    // ADICIONADO: Event listeners para os novos campos de pagamento\n    if(vendasCartaoInput) vendasCartaoInput.addEventListener('input', calcularTotalVendasPagamento);\n    if(vendasPixInput) vendasPixInput.addEventListener('input', calcularTotalVendasPagamento);\n    if(vendasDinheiroInput) vendasDinheiroInput.addEventListener('input', calcularTotalVendasPagamento);\n\n    // --- Lógica de Inicialização da Página ---\n    monitoramentoDonutChart = renderDonutChart(monitoramentoDonutCanvas, 0, '#60a5fa');\n    lojaDonutChart = renderDonutChart(lojaDonutCanvas, 0, '#4ade80');\n\n    if (reportId) {\n        document.querySelector('h4.mb-0').textContent = 'Editar Relatório Existente';\n        carregarDadosParaEdicao();\n    } else {\n        carregarLojas();\n        updateVendedoresPlaceholder();\n        carregarRascunho();\n    }\n}","size_bytes":31673},"monitoramento-lojas-varejo-main/create-relatorio/public/js/app.js":{"content":"// =================================================================\n// IMPORTS E CONFIGURAÇÃO DE PÁGINAS\n// =================================================================\nimport { initAdminPage } from './pages/admin.js';\nimport { initConsultaPage } from './pages/consulta.js';\nimport { initGerenciarLojasPage } from './pages/gerenciar-lojas.js';\nimport { initDemandasPage } from './pages/demandas.js';\nimport { initNovoRelatorioPage } from './pages/novo-relatorio.js';\nimport { initGerenciarUsuariosPage } from './pages/gerenciar-usuarios.js';\n\nconst pageInitializers = {\n    'admin': initAdminPage,\n    'consulta': initConsultaPage,\n    'gerenciar-lojas': initGerenciarLojasPage,\n    'demandas': initDemandasPage,\n    'novo-relatorio': initNovoRelatorioPage,\n    // A página gerenciar-usuarios carrega o conteúdo de usuários e backup\n    'gerenciar-usuarios': initGerenciarUsuariosPage \n};\n\nlet currentUser = null;\n\n// =================================================================\n// LÓGICA DE NAVEGAÇÃO E CARREGAMENTO DE PÁGINAS\n// =================================================================\nasync function loadPage(path) {\n    const pageContent = document.getElementById('page-content');\n    if (!pageContent) return;\n\n    const defaultPage = 'admin';\n    const pageName = (path.startsWith('/') ? path.substring(1) : path).split('?')[0] || defaultPage;\n    const activePage = (pageName === '' || pageName === 'index.html') ? defaultPage : pageName;\n\n    // Atualiza a classe 'active' nos menus (desktop e mobile)\n    document.querySelectorAll('.sidebar-nav .nav-item').forEach(item => {\n        const link = item.querySelector('.nav-link');\n        const linkHrefPage = link.getAttribute('href').substring(1);\n        item.classList.toggle('active', linkHrefPage === activePage);\n    });\n\n    pageContent.innerHTML = '<div class=\"d-flex justify-content-center p-5\"><div class=\"spinner-border\" role=\"status\"></div></div>';\n\n    try {\n        const response = await fetch(`/content/${activePage}`);\n        if (!response.ok) throw new Error(`Página /content/${activePage} não encontrada.`);\n\n        pageContent.innerHTML = await response.text();\n        \n        // Garante que a função de inicialização da página seja chamada\n        const initFunc = pageInitializers[activePage];\n        if (typeof initFunc === 'function') {\n           \n            setTimeout(() => {\n                try {\n                    \n                    initFunc(currentUser);\n                } catch (err) {\n                    console.error(`Erro ao inicializar a página '${activePage}':`, err);\n                }\n            }, 0);\n        }\n    } catch (error) {\n        console.error(\"Erro ao carregar página:\", error);\n        pageContent.innerHTML = `<div class=\"p-3 text-center text-danger\"><h3>Oops!</h3><p>Erro ao carregar conteúdo da página.</p></div>`;\n    }\n}\n\nfunction navigateTo(path) {\n    if (location.pathname + location.search === path) return;\n    history.pushState(null, '', path);\n    loadPage(path);\n}\n\n// =================================================================\n// SESSÃO E INICIALIZAÇÃO PRINCIPAL\n// =================================================================\nasync function setupSessionAndUI() {\n    try {\n        const response = await fetch('/api/session-info');\n        if (!response.ok) { window.location.href = '/login'; return; }\n        currentUser = await response.json();\n        const userInfoContainer = document.getElementById('user-info-container');\n        if (userInfoContainer) {\n            let adminButtons = '';\n            // Mostra os links de admin se o usuário for admin\n            if (currentUser.role === 'admin') {\n                document.querySelectorAll('#nav-gerenciar').forEach(el => el?.classList.remove('d-none'));\n                 // A página de gerenciar usuários é acessada pelo link \"Lojas\", mas o botão fica no footer.\n                adminButtons = `<a href=\"/gerenciar-usuarios\" class=\"btn\" title=\"Configurações\"><i class=\"bi bi-gear-fill\"></i></a>`;\n            }\n            // Mostra o link de demandas para todos\n            document.querySelectorAll('#nav-demandas').forEach(el => el?.classList.remove('d-none'));\n\n            userInfoContainer.innerHTML = `<div class=\"user-info\"><span>Olá, <strong>${currentUser.username}</strong></span></div><div class=\"user-actions\"><a href=\"/live\" id=\"live-mode-btn\" class=\"btn\" title=\"Modo Live\"><i class=\"bi bi-broadcast\"></i></a>${adminButtons}<a href=\"/logout\" class=\"btn\" title=\"Sair\"><i class=\"bi bi-box-arrow-right\"></i></a></div>`;\n            \n            document.getElementById('live-mode-btn')?.addEventListener('click', (e) => {\n                e.preventDefault();\n                window.open(e.currentTarget.href, 'live-window', 'width=550,height=850,scrollbars=yes,resizable=yes');\n            });\n        }\n    } catch (e) { console.error(\"Falha na sessão:\", e); window.location.href = '/login'; }\n}\n\nasync function main() {\n    await setupSessionAndUI();\n    const mobileMenuModalEl = document.getElementById('mobileMenuModal');\n    const mobileMenuModal = mobileMenuModalEl ? new bootstrap.Modal(mobileMenuModalEl) : null;\n\n    document.body.addEventListener('click', e => {\n        const navLink = e.target.closest('a.nav-link');\n        if (navLink && navLink.closest('.sidebar-nav')) {\n            e.preventDefault();\n            const destination = navLink.getAttribute('href');\n            \n            if (navLink.closest('#mobileMenuModal')) {\n                mobileMenuModalEl.addEventListener('hidden.bs.modal', () => {\n                    navigateTo(destination);\n                }, { once: true });\n                if (mobileMenuModal) mobileMenuModal.hide();\n            } else {\n                navigateTo(destination);\n            }\n        }\n    });\n\n    window.addEventListener('popstate', () => loadPage(location.pathname + location.search));\n    loadPage(location.pathname + location.search);\n}\n\ndocument.addEventListener('DOMContentLoaded', main);\n\n// =================================================================\n// FUNÇÕES DE UTILIDADE GLOBAIS\n// =================================================================\nexport function showToast(title, message, type = 'success') {\n    const toastEl = document.getElementById('notificationToast');\n    if (!toastEl) return;\n    const toast = bootstrap.Toast.getOrCreateInstance(toastEl);\n    \n    toastEl.querySelector('#toast-title').textContent = title;\n    toastEl.querySelector('#toast-body').textContent = message;\n    const toastHeader = toastEl.querySelector('.toast-header');\n    toastHeader.classList.remove('bg-success', 'bg-danger', 'bg-info');\n    if (type === 'success') toastHeader.classList.add('bg-success');\n    else if (type === 'danger') toastHeader.classList.add('bg-danger');\n    else toastHeader.classList.add('bg-info');\n    \n    toast.show();\n}\n\nexport function showConfirmModal(message) {\n    return new Promise((resolve) => {\n        const confirmModalEl = document.getElementById('confirmModal');\n        if (!confirmModalEl) { resolve(window.confirm(message)); return; }\n\n        const confirmModal = bootstrap.Modal.getOrCreateInstance(confirmModalEl);\n        confirmModalEl.querySelector('#confirmModalBody').textContent = message;\n\n        const btnYes = confirmModalEl.querySelector('#confirm-btn-yes');\n        const btnNo = confirmModalEl.querySelector('#confirm-btn-no');\n\n        const onYesClick = () => resolve(true);\n        const onNoClick = () => resolve(false);\n\n        btnYes.addEventListener('click', onYesClick, { once: true });\n        btnNo.addEventListener('click', onNoClick, { once: true });\n        \n        // Garante que se o modal for fechado de outra forma, ele resolve como 'false'\n        confirmModalEl.addEventListener('hidden.bs.modal', () => resolve(false), { once: true });\n\n        confirmModal.show();\n    });\n}","size_bytes":7920},"public/js/pages/gerenciar-lojas.js":{"content":"import { showToast, showConfirmModal, getAuthHeaders } from '../utils.js';\n\nexport function initGerenciarLojasPage() {\n    const secaoLojas = document.getElementById('secao-gerenciar-lojas');\n    \n    if (!secaoLojas) {\n        console.error('Elementos da página de lojas não encontrados');\n        return;\n    }\n    \n    secaoLojas.style.display = 'block';\n    initGerenciarLojas();\n}\n\nfunction initGerenciarLojas() {\n    const tableBody = document.getElementById('tabela-lojas-corpo');\n    const btnAdicionar = document.getElementById('btn-adicionar-loja');\n    const modalEl = document.getElementById('modal-loja');\n    \n    if (!tableBody || !btnAdicionar || !modalEl) return;\n    \n    const modal = new bootstrap.Modal(modalEl);\n    const modalForm = document.getElementById('form-loja');\n    const modalTitle = document.getElementById('modalLojaLabel');\n    let lojasCache = [];\n    let tecnicosCache = [];\n\n    async function carregarTecnicos() {\n        try {\n            const response = await fetch('/api/usuarios');\n            const usuarios = await response.json();\n            tecnicosCache = usuarios;\n            \n            const tecnicoSelect = document.getElementById('loja-tecnico');\n            tecnicoSelect.innerHTML = '<option value=\"\">Nenhum</option>' + \n                tecnicosCache.map(tec => `<option value=\"${tec.username}\">${tec.username}</option>`).join('');\n        } catch (e) {\n            console.error('Erro ao carregar técnicos:', e);\n        }\n    }\n\n    async function carregarLojas() {\n        tableBody.innerHTML = '<tr><td colspan=\"5\" class=\"text-center\">Carregando...</td></tr>';\n        try {\n            const response = await fetch('/api/lojas');\n            const lojas = await response.json();\n            // Normalizar IDs para números\n            lojasCache = lojas.map(loja => ({\n                ...loja,\n                id: Number(loja.id)\n            }));\n            \n            if (lojasCache.length === 0) {\n                tableBody.innerHTML = '<tr><td colspan=\"5\" class=\"text-center\">Nenhuma loja cadastrada.</td></tr>';\n                return;\n            }\n            \n            let vendedores = [];\n            try {\n                const vendedoresResponse = await fetch('/api/vendedores');\n                if (vendedoresResponse.ok) {\n                    const vendedoresRaw = await vendedoresResponse.json();\n                    // Normalizar IDs para números\n                    vendedores = vendedoresRaw.map(v => ({\n                        ...v,\n                        id: Number(v.id),\n                        loja_id: Number(v.loja_id)\n                    }));\n                }\n            } catch (e) {\n                console.warn('API de vendedores indisponível, continuando sem contagem');\n            }\n            \n            tableBody.innerHTML = lojasCache.map(loja => {\n                const statusBadge = loja.status === 'ativa' \n                    ? `<span class=\"badge\" style=\"background-color: #c3fae8; color: #087f5b;\">Ativo</span>` \n                    : `<span class=\"badge\" style=\"background-color: #f1f3f5; color: #495057;\">Inativo</span>`;\n                    \n                const vendedoresLoja = vendedores.filter(v => v.loja_id === loja.id && v.ativo === 1);\n                const totalVendedores = vendedoresLoja.length;\n                \n                const responsavel = loja.gerente || loja.numero_contato || '-';\n                \n                return `<tr>\n                    <td class=\"align-middle ps-3\"><strong>${loja.nome}</strong></td>\n                    <td class=\"align-middle\">${responsavel}</td>\n                    <td class=\"text-center align-middle\">\n                        <span class=\"badge\" style=\"background-color: #a5d8ff; color: #1971c2;\">${totalVendedores}</span>\n                    </td>\n                    <td class=\"text-center align-middle\">${statusBadge}</td>\n                    <td class=\"text-end align-middle pe-3\">\n                        <button class=\"btn btn-sm\" style=\"background-color: #d0ebff; color: #1971c2; border: 1px solid #a5d8ff;\" data-action=\"detalhes\" data-id=\"${loja.id}\" title=\"Ver Detalhes e Vendedores\">\n                            <i class=\"bi bi-eye me-1\"></i>Detalhes\n                        </button>\n                        <button class=\"btn btn-sm\" style=\"background-color: #e9ecef; color: #495057; border: 1px solid #ced4da;\" data-action=\"editar\" data-id=\"${loja.id}\" title=\"Editar Loja\">\n                            <i class=\"bi bi-pencil me-1\"></i>Editar\n                        </button>\n                        <button class=\"btn btn-sm\" style=\"background-color: #ffe3e3; color: #c92a2a; border: 1px solid #ffc9c9;\" data-action=\"excluir\" data-id=\"${loja.id}\" title=\"Excluir Loja\">\n                            <i class=\"bi bi-trash me-1\"></i>Excluir\n                        </button>\n                    </td>\n                </tr>`;\n            }).join('');\n        } catch (e) {\n            console.error('Erro ao carregar lojas:', e);\n            tableBody.innerHTML = '<tr><td colspan=\"5\" class=\"text-center text-danger\">Erro ao carregar lojas.</td></tr>';\n        }\n    }\n\n    function abrirModalParaAdicionar() {\n        modalForm.reset();\n        modalTitle.textContent = 'Adicionar Nova Loja';\n        document.getElementById('loja-id').value = '';\n        modal.show();\n    }\n\n    function abrirModalParaEditar(id) {\n        const loja = lojasCache.find(l => l.id === id);\n        if (!loja) return;\n        modalForm.reset();\n        modalTitle.textContent = 'Editar Loja';\n        document.getElementById('loja-id').value = loja.id;\n        document.getElementById('loja-nome').value = loja.nome;\n        document.getElementById('loja-cep').value = loja.cep || '';\n        document.getElementById('loja-numero-contato').value = loja.numero_contato || '';\n        document.getElementById('loja-gerente').value = loja.gerente || '';\n        document.getElementById('loja-status').value = loja.status;\n        document.getElementById('loja-funcao-especial').value = loja.funcao_especial || '';\n        document.getElementById('loja-tecnico').value = loja.tecnico_username || '';\n        document.getElementById('loja-observacoes').value = loja.observacoes || '';\n        modal.show();\n    }\n    \n    async function mostrarDetalhes(id) {\n        console.log('=== mostrarDetalhes chamado ===');\n        console.log('ID recebido:', id, 'tipo:', typeof id);\n        console.log('lojasCache:', lojasCache);\n        const loja = lojasCache.find(l => l.id === id);\n        console.log('Loja encontrada:', loja);\n        if (!loja) {\n            console.error('Loja não encontrada com ID:', id);\n            return;\n        }\n        \n        const modalDetalhes = new bootstrap.Modal(document.getElementById('modal-detalhes-loja'));\n        const tabelaVendedoresDetalhes = document.getElementById('tabela-vendedores-detalhes');\n        const semVendedores = document.getElementById('sem-vendedores');\n        \n        // Atualizar título do modal\n        document.getElementById('modalDetalhesLojaLabel').textContent = `Detalhes da Loja - ${loja.nome}`;\n        \n        // Carregar vendedores da loja\n        try {\n            const response = await fetch('/api/vendedores');\n            const vendedoresRaw = await response.json();\n            // Normalizar IDs para números\n            const vendedores = vendedoresRaw.map(v => ({\n                ...v,\n                id: Number(v.id),\n                loja_id: Number(v.loja_id)\n            }));\n            const vendedoresLoja = vendedores.filter(v => v.loja_id === id);\n            \n            if (vendedoresLoja.length === 0) {\n                tabelaVendedoresDetalhes.innerHTML = '';\n                semVendedores.classList.remove('d-none');\n            } else {\n                semVendedores.classList.add('d-none');\n                tabelaVendedoresDetalhes.innerHTML = vendedoresLoja.map(v => {\n                    let statusBadge;\n                    if (v.data_demissao) {\n                        statusBadge = `<span class=\"badge\" style=\"background-color: #ffe3e3; color: #c92a2a;\"><i class=\"bi bi-x-circle-fill me-1\"></i>Demitido</span>`;\n                    } else if (v.ativo === 1) {\n                        statusBadge = `<span class=\"badge\" style=\"background-color: #c3fae8; color: #087f5b;\"><i class=\"bi bi-check-circle-fill me-1\"></i>Ativo</span>`;\n                    } else {\n                        statusBadge = `<span class=\"badge\" style=\"background-color: #f1f3f5; color: #495057;\"><i class=\"bi bi-x-circle-fill me-1\"></i>Inativo</span>`;\n                    }\n                    return `<tr>\n                        <td>${v.nome}</td>\n                        <td>${v.telefone || '-'}</td>\n                        <td>${statusBadge}</td>\n                        <td class=\"text-end pe-3\">\n                            <button class=\"btn btn-sm\" style=\"background-color: #e9ecef; color: #495057; border: 1px solid #ced4da;\" data-action=\"editar-vendedor\" data-id=\"${v.id}\" data-loja-id=\"${id}\">\n                                <i class=\"bi bi-pencil me-1\"></i>Editar\n                            </button>\n                            <button class=\"btn btn-sm\" style=\"background-color: #ffe3e3; color: #c92a2a; border: 1px solid #ffc9c9;\" data-action=\"excluir-vendedor\" data-id=\"${v.id}\" data-loja-id=\"${id}\">\n                                <i class=\"bi bi-trash me-1\"></i>Excluir\n                            </button>\n                        </td>\n                    </tr>`;\n                }).join('');\n            }\n            \n            // Configurar botão de adicionar vendedor\n            const btnAdicionarVendedorDetalhes = document.getElementById('btn-adicionar-vendedor-detalhes');\n            btnAdicionarVendedorDetalhes.onclick = () => {\n                modalDetalhes.hide();\n                abrirModalVendedorParaLoja(id);\n            };\n            \n            modalDetalhes.show();\n        } catch (error) {\n            showToast('Erro', 'Erro ao carregar vendedores da loja', 'danger');\n        }\n    }\n    \n    function abrirModalVendedorParaLoja(lojaId) {\n        const loja = lojasCache.find(l => l.id === lojaId);\n        if (!loja) return;\n        \n        const modalVendedor = bootstrap.Modal.getInstance(document.getElementById('modal-vendedor')) || new bootstrap.Modal(document.getElementById('modal-vendedor'));\n        const formVendedor = document.getElementById('form-vendedor');\n        formVendedor.reset();\n        \n        document.getElementById('modalVendedorLabel').textContent = `Adicionar Vendedor - ${loja.nome}`;\n        document.getElementById('vendedor-id').value = '';\n        document.getElementById('vendedor-loja-id').value = lojaId;\n        \n        modalVendedor.show();\n    }\n\n    async function excluirLoja(id) {\n        const confirmed = await showConfirmModal(`Tem certeza que deseja excluir esta loja?`);\n        if (!confirmed) return;\n        try {\n            const response = await fetch(`/api/lojas/${id}`, { method: 'DELETE', headers: await getAuthHeaders() });\n            if (!response.ok) throw new Error('Falha ao excluir.');\n            showToast('Sucesso', 'Loja excluída.', 'success');\n            carregarLojas();\n        } catch (e) {\n            showToast('Erro', 'Não foi possível excluir a loja.', 'danger');\n        }\n    }\n\n    modalForm.addEventListener('submit', async (e) => {\n        e.preventDefault();\n        const id = document.getElementById('loja-id').value;\n        const data = { \n            nome: document.getElementById('loja-nome').value, \n            cep: document.getElementById('loja-cep').value || null,\n            numero_contato: document.getElementById('loja-numero-contato').value || null,\n            gerente: document.getElementById('loja-gerente').value || null,\n            status: document.getElementById('loja-status').value, \n            funcao_especial: document.getElementById('loja-funcao-especial').value || null,\n            tecnico_username: document.getElementById('loja-tecnico').value || null,\n            observacoes: document.getElementById('loja-observacoes').value || null,\n            cargo: null\n        };\n        const method = id ? 'PUT' : 'POST';\n        const url = id ? `/api/lojas/${id}` : '/api/lojas';\n        try {\n            const response = await fetch(url, { method, headers: await getAuthHeaders(), body: JSON.stringify(data) });\n            if (!response.ok) throw new Error('Falha ao salvar. Nome já existe?');\n            showToast('Sucesso', `Loja salva com sucesso.`, 'success');\n            modal.hide();\n            carregarLojas();\n        } catch(e) { showToast('Erro', e.message, 'danger'); }\n    });\n\n    async function editarVendedor(id, lojaId) {\n        try {\n            const response = await fetch('/api/vendedores');\n            const vendedoresRaw = await response.json();\n            // Normalizar IDs para números\n            const vendedores = vendedoresRaw.map(v => ({\n                ...v,\n                id: Number(v.id),\n                loja_id: Number(v.loja_id)\n            }));\n            const vendedor = vendedores.find(v => v.id === id);\n            if (!vendedor) return;\n            \n            const modalVendedor = new bootstrap.Modal(document.getElementById('modal-vendedor'));\n            const formVendedor = document.getElementById('form-vendedor');\n            \n            document.getElementById('modalVendedorLabel').textContent = 'Editar Vendedor';\n            document.getElementById('vendedor-id').value = vendedor.id;\n            document.getElementById('vendedor-loja-id').value = vendedor.loja_id;\n            document.getElementById('vendedor-nome').value = vendedor.nome;\n            document.getElementById('vendedor-telefone').value = vendedor.telefone;\n            document.getElementById('vendedor-data-entrada').value = vendedor.data_entrada;\n            document.getElementById('vendedor-data-demissao').value = vendedor.data_demissao || '';\n            document.getElementById('vendedor-previsao-entrada').value = vendedor.previsao_entrada || '';\n            document.getElementById('vendedor-previsao-saida').value = vendedor.previsao_saida || '';\n            \n            // Fechar modal de detalhes\n            const modalDetalhes = bootstrap.Modal.getInstance(document.getElementById('modal-detalhes-loja'));\n            if (modalDetalhes) modalDetalhes.hide();\n            \n            modalVendedor.show();\n        } catch (error) {\n            showToast('Erro', 'Erro ao carregar dados do vendedor', 'danger');\n        }\n    }\n    \n    async function excluirVendedor(id, lojaId) {\n        const confirmed = await showConfirmModal('Tem certeza que deseja excluir este vendedor?');\n        if (!confirmed) return;\n        try {\n            const response = await fetch(`/api/vendedores/${id}`, { method: 'DELETE', headers: await getAuthHeaders() });\n            if (!response.ok) throw new Error('Falha ao excluir.');\n            showToast('Sucesso', 'Vendedor excluído.', 'success');\n            // Recarregar detalhes\n            mostrarDetalhes(lojaId);\n        } catch (e) {\n            showToast('Erro', 'Não foi possível excluir o vendedor.', 'danger');\n        }\n    }\n\n    btnAdicionar.addEventListener('click', abrirModalParaAdicionar);\n    tableBody.addEventListener('click', (e) => {\n        const button = e.target.closest('button[data-action]');\n        console.log('Clique detectado:', e.target);\n        console.log('Botão encontrado:', button);\n        if (!button) {\n            console.log('Nenhum botão com data-action encontrado');\n            return;\n        }\n        const id = parseInt(button.dataset.id, 10);\n        const action = button.dataset.action;\n        console.log('ID:', id, 'Action:', action);\n        if (action === 'editar') abrirModalParaEditar(id);\n        if (action === 'detalhes') {\n            console.log('Chamando mostrarDetalhes com ID:', id);\n            mostrarDetalhes(id);\n        }\n        if (action === 'excluir') excluirLoja(id);\n        if (action === 'adicionar-vendedor') abrirModalVendedorParaLoja(id);\n    });\n    \n    // Event listener para botões dentro do modal de detalhes\n    document.getElementById('modal-detalhes-loja').addEventListener('click', (e) => {\n        const button = e.target.closest('button[data-action]');\n        if (!button) return;\n        const id = parseInt(button.getAttribute('data-id'), 10);\n        const lojaId = parseInt(button.getAttribute('data-loja-id'), 10);\n        const action = button.getAttribute('data-action');\n        if (action === 'editar-vendedor') editarVendedor(id, lojaId);\n        if (action === 'excluir-vendedor') excluirVendedor(id, lojaId);\n    });\n    \n    // Event listener para o formulário de vendedor\n    const formVendedor = document.getElementById('form-vendedor');\n    if (formVendedor) {\n        formVendedor.addEventListener('submit', async (e) => {\n            e.preventDefault();\n            \n            const id = document.getElementById('vendedor-id').value;\n            const lojaId = parseInt(document.getElementById('vendedor-loja-id').value, 10);\n            const data = {\n                loja_id: lojaId,\n                nome: document.getElementById('vendedor-nome').value,\n                telefone: document.getElementById('vendedor-telefone').value,\n                data_entrada: document.getElementById('vendedor-data-entrada').value,\n                data_demissao: document.getElementById('vendedor-data-demissao').value || null,\n                previsao_entrada: document.getElementById('vendedor-previsao-entrada').value || null,\n                previsao_saida: document.getElementById('vendedor-previsao-saida').value || null,\n                ativo: document.getElementById('vendedor-data-demissao').value ? 0 : 1\n            };\n            \n            const method = id ? 'PUT' : 'POST';\n            const url = id ? `/api/vendedores/${id}` : '/api/vendedores';\n            \n            try {\n                const response = await fetch(url, { \n                    method, \n                    headers: await getAuthHeaders(), \n                    body: JSON.stringify(data) \n                });\n                \n                if (!response.ok) throw new Error('Falha ao salvar vendedor.');\n                \n                showToast('Sucesso', 'Vendedor salvo com sucesso.', 'success');\n                \n                // Fechar modal de vendedor\n                const modalVendedor = bootstrap.Modal.getInstance(document.getElementById('modal-vendedor'));\n                if (modalVendedor) modalVendedor.hide();\n                \n                // Recarregar tabela de lojas e reabrir modal de detalhes se aplicável\n                await carregarLojas();\n                if (lojaId) {\n                    setTimeout(() => mostrarDetalhes(lojaId), 300);\n                }\n            } catch (e) {\n                showToast('Erro', e.message, 'danger');\n            }\n        });\n    }\n    \n    carregarTecnicos();\n    carregarLojas();\n}\n\nfunction initGerenciarVendedores() {\n    const selectLoja = document.getElementById('select-loja-vendedores');\n    const containerVendedores = document.getElementById('container-vendedores');\n    const tableBody = document.getElementById('tabela-vendedores-corpo');\n    const btnAdicionar = document.getElementById('btn-adicionar-vendedor');\n    const modalEl = document.getElementById('modal-vendedor');\n    \n    if (!selectLoja || !containerVendedores || !tableBody || !btnAdicionar || !modalEl) return;\n    \n    const modal = new bootstrap.Modal(modalEl);\n    const modalForm = document.getElementById('form-vendedor');\n    const modalTitle = document.getElementById('modalVendedorLabel');\n    let vendedoresCache = [];\n    let lojaAtualId = null;\n\n    async function carregarLojas() {\n        console.log('🔍 Iniciando carregamento de lojas para vendedores...');\n        try {\n            const response = await fetch('/api/lojas');\n            console.log('📡 Response status:', response.status);\n            \n            const lojas = await response.json();\n            console.log('📦 Lojas recebidas:', lojas);\n            console.log('📊 Tipo:', typeof lojas, 'É array?', Array.isArray(lojas), 'Quantidade:', lojas.length);\n            \n            if (!Array.isArray(lojas) || lojas.length === 0) {\n                console.warn('⚠️ Nenhuma loja disponível');\n                selectLoja.innerHTML = '<option value=\"\">Nenhuma loja disponível</option>';\n                return;\n            }\n            \n            selectLoja.innerHTML = '<option value=\"\">Selecione uma loja...</option>' + \n                lojas.map(loja => {\n                    console.log('🏪 Adicionando loja:', loja.nome, 'ID:', loja.id);\n                    return `<option value=\"${loja.id}\">${loja.nome}</option>`;\n                }).join('');\n            \n            console.log('✅ Select preenchido com', lojas.length, 'lojas');\n        } catch (e) {\n            console.error('❌ Erro ao carregar lojas:', e);\n            showToast('Erro', 'Não foi possível carregar lojas.', 'danger');\n        }\n    }\n\n    async function carregarVendedores(lojaId) {\n        tableBody.innerHTML = '<tr><td colspan=\"8\" class=\"text-center\">Carregando...</td></tr>';\n        try {\n            const response = await fetch(`/api/vendedores?loja_id=${lojaId}`);\n            const vendedoresRaw = await response.json();\n            // Normalizar IDs para números\n            vendedoresCache = vendedoresRaw.map(v => ({\n                ...v,\n                id: Number(v.id),\n                loja_id: Number(v.loja_id)\n            }));\n            \n            if (vendedoresCache.length === 0) {\n                tableBody.innerHTML = '<tr><td colspan=\"8\" class=\"text-center\">Nenhum vendedor cadastrado nesta loja.</td></tr>';\n                return;\n            }\n            \n            tableBody.innerHTML = vendedoresCache.map(v => {\n                let statusBadge;\n                if (v.data_demissao) {\n                    statusBadge = '<span class=\"badge\" style=\"background-color: #ffe3e3; color: #c92a2a;\">Demitido</span>';\n                } else if (v.ativo === 1) {\n                    statusBadge = '<span class=\"badge\" style=\"background-color: #c3fae8; color: #087f5b;\">Ativo</span>';\n                } else {\n                    statusBadge = '<span class=\"badge\" style=\"background-color: #f1f3f5; color: #495057;\">Inativo</span>';\n                }\n                \n                return `<tr>\n                    <td>${v.nome}</td>\n                    <td>${v.telefone}</td>\n                    <td>${formatarData(v.data_entrada)}</td>\n                    <td>${v.data_demissao ? formatarData(v.data_demissao) : '-'}</td>\n                    <td>${v.previsao_entrada || '-'}</td>\n                    <td>${v.previsao_saida || '-'}</td>\n                    <td>${statusBadge}</td>\n                    <td class=\"text-end pe-3\">\n                        <button class=\"btn btn-sm\" style=\"background-color: #e9ecef; color: #495057; border: 1px solid #ced4da;\" data-action=\"editar\" data-id=\"${v.id}\"><i class=\"bi bi-pencil\"></i></button>\n                        <button class=\"btn btn-sm\" style=\"background-color: #ffe3e3; color: #c92a2a; border: 1px solid #ffc9c9;\" data-action=\"excluir\" data-id=\"${v.id}\"><i class=\"bi bi-trash\"></i></button>\n                    </td>\n                </tr>`;\n            }).join('');\n        } catch (e) {\n            tableBody.innerHTML = '<tr><td colspan=\"8\" class=\"text-center text-danger\">Erro ao carregar vendedores.</td></tr>';\n        }\n    }\n\n    function formatarData(data) {\n        if (!data) return '-';\n        const partes = data.split('-');\n        if (partes.length === 3) {\n            return `${partes[2]}/${partes[1]}/${partes[0]}`;\n        }\n        return data;\n    }\n\n    function abrirModalParaAdicionar() {\n        if (!lojaAtualId) {\n            showToast('Atenção', 'Selecione uma loja primeiro.', 'warning');\n            return;\n        }\n        \n        modalForm.reset();\n        modalTitle.textContent = 'Adicionar Vendedor';\n        document.getElementById('vendedor-id').value = '';\n        document.getElementById('vendedor-loja-id').value = lojaAtualId;\n        modal.show();\n    }\n\n    function abrirModalParaEditar(id) {\n        const vendedor = vendedoresCache.find(v => v.id === id);\n        if (!vendedor) return;\n        \n        modalForm.reset();\n        modalTitle.textContent = 'Editar Vendedor';\n        document.getElementById('vendedor-id').value = vendedor.id;\n        document.getElementById('vendedor-loja-id').value = vendedor.loja_id;\n        document.getElementById('vendedor-nome').value = vendedor.nome;\n        document.getElementById('vendedor-telefone').value = vendedor.telefone;\n        document.getElementById('vendedor-data-entrada').value = vendedor.data_entrada;\n        document.getElementById('vendedor-data-demissao').value = vendedor.data_demissao || '';\n        document.getElementById('vendedor-previsao-entrada').value = vendedor.previsao_entrada || '';\n        document.getElementById('vendedor-previsao-saida').value = vendedor.previsao_saida || '';\n        modal.show();\n    }\n\n    async function excluirVendedor(id) {\n        const confirmed = await showConfirmModal('Tem certeza que deseja excluir este vendedor?');\n        if (!confirmed) return;\n        \n        try {\n            const response = await fetch(`/api/vendedores/${id}`, { method: 'DELETE', headers: await getAuthHeaders() });\n            if (!response.ok) throw new Error('Falha ao excluir.');\n            showToast('Sucesso', 'Vendedor excluído.', 'success');\n            carregarVendedores(lojaAtualId);\n        } catch (e) {\n            showToast('Erro', 'Não foi possível excluir o vendedor.', 'danger');\n        }\n    }\n\n    selectLoja.addEventListener('change', (e) => {\n        lojaAtualId = e.target.value;\n        \n        if (lojaAtualId) {\n            containerVendedores.style.display = 'block';\n            carregarVendedores(lojaAtualId);\n        } else {\n            containerVendedores.style.display = 'none';\n        }\n    });\n\n    btnAdicionar.addEventListener('click', abrirModalParaAdicionar);\n\n    tableBody.addEventListener('click', (e) => {\n        const button = e.target.closest('button[data-action]');\n        if (!button) return;\n        const id = parseInt(button.dataset.id, 10);\n        const action = button.dataset.action;\n        if (action === 'editar') abrirModalParaEditar(id);\n        if (action === 'excluir') excluirVendedor(id);\n    });\n\n    modalForm.addEventListener('submit', async (e) => {\n        e.preventDefault();\n        \n        const id = document.getElementById('vendedor-id').value;\n        const data = {\n            loja_id: parseInt(document.getElementById('vendedor-loja-id').value, 10),\n            nome: document.getElementById('vendedor-nome').value,\n            telefone: document.getElementById('vendedor-telefone').value,\n            data_entrada: document.getElementById('vendedor-data-entrada').value,\n            data_demissao: document.getElementById('vendedor-data-demissao').value || null,\n            previsao_entrada: document.getElementById('vendedor-previsao-entrada').value || null,\n            previsao_saida: document.getElementById('vendedor-previsao-saida').value || null,\n            ativo: document.getElementById('vendedor-data-demissao').value ? 0 : 1\n        };\n        \n        const method = id ? 'PUT' : 'POST';\n        const url = id ? `/api/vendedores/${id}` : '/api/vendedores';\n        \n        try {\n            const response = await fetch(url, { \n                method, \n                headers: await getAuthHeaders(), \n                body: JSON.stringify(data) \n            });\n            \n            if (!response.ok) throw new Error('Falha ao salvar vendedor.');\n            \n            showToast('Sucesso', 'Vendedor salvo com sucesso.', 'success');\n            modal.hide();\n            carregarVendedores(lojaAtualId);\n        } catch (e) {\n            showToast('Erro', e.message, 'danger');\n        }\n    });\n\n    carregarLojas();\n}\n","size_bytes":28204},"monitoramento-lojas-varejo-main/create-relatorio/public/js/pages/admin.js":{"content":"import { showToast } from '../utils.js';\n\n// --- Variáveis de Estado Globais no Módulo ---\nlet dashboardLineChart = null;\nlet lastRankingData = [];\n\n// --- Funções Auxiliares ---\nconst getCssVar = (varName) => getComputedStyle(document.documentElement).getPropertyValue(varName).trim();\nconst toISODateString = (date) => date.toISOString().split('T')[0];\n\nfunction setLoadingState(isLoading) {\n    const kpiElements = document.querySelectorAll('[id^=\"geral-\"], [id^=\"loja-\"]');\n    const chartCanvas = document.getElementById('dashboard-line-chart');\n    const rankingBody = document.getElementById('ranking-corpo-tabela');\n\n    if (isLoading) {\n        kpiElements.forEach(el => {\n            if (el.tagName === 'H2' || el.tagName === 'H3') {\n                el.innerHTML = '<span class=\"spinner-border spinner-border-sm\"></span>';\n            } else { el.innerHTML = ''; }\n        });\n        if (rankingBody) rankingBody.innerHTML = '<tr><td colspan=\"6\" class=\"text-center p-5\"><div class=\"spinner-border\" role=\"status\"></div></td></tr>';\n        if (dashboardLineChart) dashboardLineChart.destroy();\n        if (chartCanvas) chartCanvas.style.opacity = '0.5';\n    } else {\n        if (chartCanvas) chartCanvas.style.opacity = '1';\n    }\n}\n\nfunction getComparisonHtml(current, previous, unit = '') {\n    const currentNum = parseFloat(current);\n    const previousNum = parseFloat(previous);\n    if (isNaN(currentNum) || isNaN(previousNum)) return '';\n\n    if (previousNum === 0) return currentNum > 0 ? '<span class=\"text-success\">▲ Novo</span>' : '';\n    \n    const diff = ((currentNum - previousNum) / previousNum) * 100;\n    if (Math.abs(diff) < 0.1) return '';\n\n    const icon = diff > 0 ? '▲' : '▼';\n    const colorClass = diff > 0 ? 'text-success' : 'text-danger';\n    \n    const previousFormatted = unit === '%' ? previousNum.toFixed(2) : previousNum.toLocaleString('pt-BR');\n    const tooltipTitle = `Valor anterior: ${previousFormatted}${unit}`;\n\n    return `<span class=\"${colorClass}\" data-bs-toggle=\"tooltip\" data-bs-title=\"${tooltipTitle}\">${icon} ${diff.toFixed(1)}%</span>`;\n}\n\n// --- Funções de Renderização ---\nfunction renderRankingTable(rankingData) {\n    const rankingBody = document.getElementById('ranking-corpo-tabela');\n    const sortBy = document.getElementById('ranking-sort-select').value;\n    \n    const sortedData = [...rankingData].sort((a, b) => parseFloat(b[sortBy]) - parseFloat(a[sortBy]));\n\n    if (sortedData.length > 0) {\n        rankingBody.innerHTML = sortedData.map((loja, index) => `\n            <tr>\n                <td class=\"ps-3\"><b>#${index + 1}</b></td>\n                <td>${loja.loja}</td>\n                <td><b>${parseFloat(loja.tx_loja).toFixed(2)}%</b></td>\n                <td>${parseFloat(loja.tx_monitoramento).toFixed(2)}%</td>\n                <td>${loja.total_vendas_loja.toLocaleString('pt-BR')}</td>\n                <td>${loja.total_clientes_loja.toLocaleString('pt-BR')}</td>\n            </tr>\n        `).join('');\n    } else {\n        rankingBody.innerHTML = '<tr><td colspan=\"6\" class=\"text-center p-4\">Nenhuma loja ativa encontrada.</td></tr>';\n    }\n}\n\nfunction renderLineChart(currentChartData, comparisonChartData) {\n    const ctx = document.getElementById('dashboard-line-chart').getContext('2d');\n    \n    const datasets = [\n        {\n            label: 'Tx. Conv. Loja (Atual)',\n            data: currentChartData.txConversaoLoja,\n            borderColor: getCssVar('--color-success'),\n            backgroundColor: getCssVar('--color-success') + '20',\n            fill: true, tension: 0.4, borderWidth: 2.5\n        },\n        {\n            label: 'Tx. Conv. Monit. (Atual)',\n            data: currentChartData.txConversaoMonitoramento,\n            borderColor: getCssVar('--accent-color'),\n            backgroundColor: getCssVar('--accent-color') + '20',\n            fill: true, tension: 0.4, borderWidth: 2.5\n        },\n        {\n            label: 'Tx. Conv. Loja (Comparado)',\n            data: comparisonChartData.txConversaoLoja,\n            borderColor: getCssVar('--color-success'),\n            borderDash: [5, 5], fill: false, tension: 0.4, borderWidth: 1.5\n        },\n        {\n            label: 'Tx. Conv. Monit. (Comparado)',\n            data: comparisonChartData.txConversaoMonitoramento,\n            borderColor: getCssVar('--accent-color'),\n            borderDash: [5, 5], fill: false, tension: 0.4, borderWidth: 1.5\n        }\n    ];\n    \n    if (dashboardLineChart) dashboardLineChart.destroy();\n    dashboardLineChart = new Chart(ctx, {\n        type: 'line',\n        data: { labels: currentChartData.labels, datasets: datasets },\n        options: {\n            responsive: true, maintainAspectRatio: false,\n            interaction: { mode: 'index', intersect: false },\n            plugins: { legend: { position: 'top' }, tooltip: { position: 'nearest' } },\n            scales: { y: { beginAtZero: true, ticks: { callback: (value) => value + '%' } } }\n        }\n    });\n}\n\nfunction updateUI(results) {\n    const [currentData, rankingData, currentChartData, comparisonData, comparisonChartData] = results;\n\n    document.getElementById('geral-clientes').textContent = currentData.total_clientes_monitoramento.toLocaleString('pt-BR');\n    document.getElementById('geral-vendas').textContent = (currentData.total_vendas_monitoramento + currentData.total_omni).toLocaleString('pt-BR');\n    document.getElementById('geral-tx-conversao').textContent = `${parseFloat(currentData.tx_conversao_monitoramento).toFixed(2)}%`;\n    document.getElementById('loja-clientes').textContent = currentData.total_clientes_loja.toLocaleString('pt-BR');\n    document.getElementById('loja-vendas').textContent = currentData.total_vendas_loja.toLocaleString('pt-BR');\n    document.getElementById('loja-tx-conversao').textContent = `${parseFloat(currentData.tx_conversao_loja).toFixed(2)}%`;\n\n    document.getElementById('geral-clientes-comp').innerHTML = getComparisonHtml(currentData.total_clientes_monitoramento, comparisonData.total_clientes_monitoramento);\n    document.getElementById('geral-vendas-comp').innerHTML = getComparisonHtml(currentData.total_vendas_monitoramento + currentData.total_omni, comparisonData.total_vendas_monitoramento + comparisonData.total_omni);\n    document.getElementById('geral-tx-conversao-comp').innerHTML = getComparisonHtml(currentData.tx_conversao_monitoramento, comparisonData.tx_conversao_monitoramento, '%');\n    document.getElementById('loja-clientes-comp').innerHTML = getComparisonHtml(currentData.total_clientes_loja, comparisonData.total_clientes_loja);\n    document.getElementById('loja-vendas-comp').innerHTML = getComparisonHtml(currentData.total_vendas_loja, comparisonData.total_vendas_loja);\n    document.getElementById('loja-tx-conversao-comp').innerHTML = getComparisonHtml(currentData.tx_conversao_loja, comparisonData.tx_conversao_loja, '%');\n\n    renderLineChart(currentChartData, comparisonChartData);\n    \n    lastRankingData = rankingData;\n    renderRankingTable(lastRankingData);\n\n    const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle=\"tooltip\"]');\n    [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl));\n}\n\n// --- Lógica Principal e Eventos ---\nexport function initAdminPage() {\n    const form = document.getElementById('form-filtros-dashboard');\n    if (!form) return;\n\n    const lojaSelect = document.getElementById('filtro-loja-dashboard');\n    const dataInicioInput = document.getElementById('filtro-data-inicio-dashboard');\n    const dataFimInput = document.getElementById('filtro-data-fim-dashboard');\n    const quickPeriodButtons = document.querySelectorAll('[data-period]');\n    const comparisonTypeSelect = document.getElementById('comparison-type-select');\n    const rankingSortSelect = document.getElementById('ranking-sort-select');\n\n    async function carregarLojas() {\n        try {\n            const response = await fetch('/api/lojas?status=ativa');\n            const lojas = await response.json();\n            lojas.forEach(loja => lojaSelect.add(new Option(loja.nome, loja.nome)));\n        } catch (error) { console.error('Falha ao carregar lojas', error); }\n    }\n    \n    function setDateRange(period) {\n        const hoje = new Date();\n        let inicio, fim = new Date(hoje);\n        switch (period) {\n            case 'hoje': inicio = hoje; break;\n            case '7d': inicio = new Date(); inicio.setDate(hoje.getDate() - 6); break;\n            case 'mes-atual': inicio = new Date(hoje.getFullYear(), hoje.getMonth(), 1); break;\n            case 'mes-passado':\n                inicio = new Date(hoje.getFullYear(), hoje.getMonth() - 1, 1);\n                fim = new Date(hoje.getFullYear(), hoje.getMonth(), 0);\n                break;\n        }\n        dataInicioInput.value = toISODateString(inicio);\n        dataFimInput.value = toISODateString(fim);\n    }\n\n    async function analisarDados(e) {\n        if(e) e.preventDefault();\n        setLoadingState(true);\n\n        const loja = lojaSelect.value;\n        const dataInicio = dataInicioInput.value;\n        const dataFim = dataFimInput.value;\n\n        if (!dataInicio || !dataFim) {\n            showToast(\"Atenção\", \"Por favor, selecione um período de datas.\", \"danger\");\n            setLoadingState(false);\n            return;\n        }\n        \n        const baseParams = { data_inicio: dataInicio, data_fim: dataFim };\n        if (loja !== 'todas') {\n            baseParams.loja = loja;\n        }\n\n        const currentParams = new URLSearchParams(baseParams);\n\n        const startDate = new Date(dataInicio + 'T00:00:00');\n        const endDate = new Date(dataFim + 'T00:00:00');\n        let compStartDate, compEndDate;\n        if (comparisonTypeSelect.value === 'ano-anterior') {\n            compStartDate = new Date(startDate); compStartDate.setFullYear(startDate.getFullYear() - 1);\n            compEndDate = new Date(endDate); compEndDate.setFullYear(endDate.getFullYear() - 1);\n        } else {\n            const diff = endDate.getTime() - startDate.getTime();\n            compEndDate = new Date(startDate.getTime() - 86400000);\n            compStartDate = new Date(compEndDate.getTime() - diff);\n        }\n        const compBaseParams = {...baseParams, data_inicio: toISODateString(compStartDate), data_fim: toISODateString(compEndDate) };\n        const comparisonParams = new URLSearchParams(compBaseParams);\n        \n        const apiCalls = [\n            fetch(`/api/dashboard-data?${currentParams.toString()}`),\n            fetch(`/api/ranking?${new URLSearchParams({ data_inicio: dataInicio, data_fim: dataFim })}`),\n            fetch(`/api/dashboard/chart-data?${currentParams.toString()}`),\n            fetch(`/api/dashboard-data?${comparisonParams.toString()}`),\n            fetch(`/api/dashboard/chart-data?${comparisonParams.toString()}`)\n        ];\n        \n        try {\n            const responses = await Promise.all(apiCalls);\n            const results = await Promise.all(responses.map(res => {\n                if(!res.ok) throw new Error(`Falha na API: ${res.status} ${res.statusText}`);\n                return res.json();\n            }));\n\n            updateUI(results);\n        } catch (error) {\n            console.error(\"Erro ao analisar dados:\", error);\n            showToast(\"Erro\", \"Não foi possível carregar os dados do dashboard.\", \"danger\");\n        } finally {\n            setLoadingState(false);\n        }\n    }\n    \n    form.addEventListener('submit', analisarDados);\n    \n    quickPeriodButtons.forEach(button => {\n        button.addEventListener('click', (e) => {\n            quickPeriodButtons.forEach(btn => btn.classList.remove('active'));\n            e.currentTarget.classList.add('active');\n            setDateRange(e.currentTarget.dataset.period);\n        });\n    });\n\n    if (rankingSortSelect) {\n        rankingSortSelect.addEventListener('change', () => {\n            if (lastRankingData.length > 0) {\n                renderRankingTable(lastRankingData);\n            }\n        });\n    }\n\n    carregarLojas();\n    setDateRange('7d');\n    const initialActiveButton = document.querySelector('[data-period=\"7d\"]');\n    if(initialActiveButton) initialActiveButton.classList.add('active');\n    analisarDados();\n}","size_bytes":12240},"monitoramento-lojas-varejo-main/create-relatorio/public/css/style.css":{"content":"@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap');\n\n/* ============================================================\n   VARIÁVEIS\n============================================================ */\n:root {\n    --sidebar-width: 250px;\n    --main-bg: #1A1A1D;\n    --content-bg: rgba(28, 28, 28, 0.65);\n    --hover-bg: #000000;\n    --border-color: #383838;\n    --accent-color: #ff7b00;\n    --glow-color: rgba(255, 123, 0, 0.15);\n    --color-success: #2ea043;\n    --text-light: #ffffff;\n    --text-muted: #b0b0b0;\n    --text-input-color: #e5e7eb;\n    --border-radius-large: 16px;\n    --border-radius-small: 8px;\n    --transition-speed: 0.2s;\n}\n\n/* ============================================================\n   ESTRUTURA PRINCIPAL E ESTILOS GLOBAIS\n============================================================ */\nbody { background-color: var(--main-bg) !important; font-family: 'Inter', sans-serif; }\n.main-content { padding: 2.5rem; height: 100vh; overflow-y: auto; }\n#page-content { max-width: 1400px; margin: 0 auto; }\nbody, body *, .card, .card *, .modal, .modal * { color: var(--text-light) !important; }\nsmall { color: var(--text-muted) !important; }\n\nh4.mb-3 {\n    font-weight: 700; padding-bottom: 1rem; position: relative;\n    border-bottom: 1px solid var(--border-color); margin-bottom: 2.5rem !important;\n}\nh4.mb-3::after {\n    content: ''; position: absolute; bottom: -1px; left: 0; width: 100%; height: 1px;\n    background-color: transparent; box-shadow: 0 0 15px -2px var(--glow-color);\n}\n\n/* ============================================================\n   SIDEBAR DESKTOP\n============================================================ */\n.sidebar-desktop {\n    position: fixed; top: 0; left: 0; width: var(--sidebar-width); height: 100vh;\n    background-color: var(--content-bg); border-right: 1px solid var(--border-color);\n    padding: 1.5rem; z-index: 1000; display: flex; flex-direction: column;\n    -webkit-backdrop-filter: blur(12px); backdrop-filter: blur(12px);\n}\n.sidebar-header { display: flex; align-items: center; gap: 0.75rem; font-size: 1.5rem; font-weight: 700; padding-bottom: 1.5rem; border-bottom: 1px solid var(--border-color); }\n.sidebar-header i { color: var(--accent-color) !important; font-size: 1.8rem; }\n.sidebar-nav { list-style: none !important; padding: 0 !important; margin: 1.5rem 0; flex-grow: 1; }\n.sidebar-nav .nav-item { margin-bottom: 0.25rem !important; }\n.nav-link { display: flex; align-items: center; gap: 1rem; padding: 0.8rem 1rem; border-radius: var(--border-radius-small); color: var(--text-muted) !important; text-decoration: none; transition: all var(--transition-speed); }\n.nav-link:hover { color: var(--text-light) !important; background-color: var(--hover-bg); }\n.nav-item.active .nav-link { color: var(--text-light) !important; background-color: var(--main-bg); font-weight: 600; }\n.nav-item.active .nav-link i { color: var(--accent-color) !important; }\n.sidebar-footer { margin-top: auto; padding-top: 1.5rem; border-top: 1px solid var(--border-color); }\n#user-info-container { display: flex; flex-direction: column; gap: 1rem; }\n#user-info-container .user-info { font-weight: 600; }\n#user-info-container .user-actions { display: flex; gap: 0.5rem; }\n#user-info-container .btn { background-color: transparent !important; border: 1px solid var(--border-color) !important; color: var(--text-muted) !important; padding: 0.4rem 0.6rem; font-size: 1rem; }\n#user-info-container .btn:hover { background-color: var(--hover-bg) !important; color: var(--accent-color) !important; border-color: var(--accent-color) !important; }\n\n/* ============================================================\n   COMPONENTES GERAIS (Cards, Forms, Botões)\n============================================================ */\n.card, .alert, .list-group-item { background-color: var(--content-bg) !important; border-radius: var(--border-radius-large) !important; border: 1px solid var(--border-color) !important; margin-bottom: 1.5rem; }\n#page-content > .container-fluid > .card:first-of-type { box-shadow: 0 8px 32px -8px var(--glow-color); }\n.card-header { font-weight: 600; background-color: transparent !important; border-bottom: 1px solid var(--border-color) !important; padding: 1rem 1.5rem; }\n.card-body { padding: 1.5rem !important; }\n.form-control, .form-select { background-color: var(--main-bg) !important; border: 1px solid var(--border-color) !important; color: var(--text-input-color) !important; }\ninput[type=\"date\"]::-webkit-calendar-picker-indicator { filter: invert(1); opacity: 0.7; cursor: pointer; }\n.btn { transition: all var(--transition-speed) ease; font-weight: 600; border-radius: var(--border-radius-small); }\n.btn-primary { background-color: var(--accent-color) !important; color: var(--main-bg) !important; border: none !important; }\n\n/* ============================================================\n   LAYOUT RESPONSIVO\n============================================================ */\n@media (min-width: 992px) { .main-content { margin-left: var(--sidebar-width); } }\n@media (max-width: 991.98px) { .main-content { padding: 1.5rem; padding-top: 80px; } }\n\n/* ============================================================\n   HEADER E MENU MOBILE (MODAL)\n============================================================ */\n.mobile-header {\n    position: fixed; top: 0; left: 0; width: 100%; height: 60px; background-color: var(--content-bg);\n    border-bottom: 1px solid var(--border-color); display: flex; align-items: center; padding: 0 1rem;\n    z-index: 1030; -webkit-backdrop-filter: blur(12px); backdrop-filter: blur(12px);\n}\n.mobile-header .btn { font-size: 1.5rem; color: var(--text-light) !important; }\n.mobile-header-title { display: flex; align-items: center; gap: 0.5rem; font-size: 1.2rem; font-weight: 700; margin-left: 1rem; }\n.mobile-header-title i { color: var(--accent-color) !important; }\n.modal-content.mobile-menu-content { background-color: #111111; border: none; -webkit-backdrop-filter: none; backdrop-filter: none; }\n.mobile-menu-content .modal-header { border-bottom-color: var(--border-color); }\n.mobile-menu-content .modal-header .modal-title { display: flex; align-items: center; gap: 0.5rem; font-weight: 700; font-size: 1.2rem; }\n.mobile-menu-content .modal-header .modal-title i { color: var(--accent-color) !important; }\n.mobile-menu-content .modal-body { padding-top: 2rem; }\n.mobile-menu-content .nav-link { font-size: 1.2rem; padding: 1rem; }\n\n/* ============================================================\n   CORREÇÕES DE COMPONENTES (Tabelas, Modais, Abas)\n============================================================ */\n.card .table-responsive, .card .table { background-color: transparent; }\n.card .table { --bs-table-bg: transparent; --bs-table-striped-bg: rgba(0, 0, 0, 0.05); }\n.modal-content { background-color: var(--content-bg) !important; border-radius: var(--border-radius-large) !important; border: 1px solid var(--border-color) !important; -webkit-backdrop-filter: blur(12px); backdrop-filter: blur(12px); }\n.modal-header { border-bottom-color: var(--border-color) !important; }\n.modal-footer { border-top-color: var(--border-color) !important; }\n.nav-tabs { border-bottom: 2px solid var(--border-color) !important; }\n.nav-tabs .nav-link { background: transparent !important; border: none !important; border-bottom: 3px solid transparent !important; color: var(--text-muted) !important; margin-bottom: -2px; }\n.nav-tabs .nav-link:hover { border-bottom-color: var(--border-color) !important; }\n.nav-tabs .nav-link.active { color: var(--text-light) !important; font-weight: 600; border-bottom-color: var(--accent-color) !important; }\n\n/* ============================================================\n   REFORMULAÇÃO DO FORMULÁRIO DE FILTROS DO DASHBOARD\n============================================================ */\n#form-filtros-dashboard .form-label {\n    font-size: 0.8rem;\n    font-weight: 500;\n    color: var(--text-muted);\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n    margin-bottom: 0.5rem; /* Espaçamento consistente */\n}\n\n/* Container do controle segmentado */\n#form-filtros-dashboard .btn-group {\n    border: 1px solid var(--border-color);\n    border-radius: var(--border-radius-small);\n    padding: 3px;\n    background-color: var(--main-bg);\n}\n\n/* Botões individuais dentro do controle */\n#form-filtros-dashboard .btn-group .btn {\n    background-color: transparent !important;\n    border: none !important;\n    color: var(--text-muted) !important;\n    font-weight: 500;\n    box-shadow: none !important;\n    transition: all 0.2s ease-in-out;\n    border-radius: 6px !important; /* Bordas arredondadas para todos */\n    padding-top: 0.375rem; /* Ajuste para alinhamento vertical */\n    padding-bottom: 0.375rem;\n    \n}\n\n#form-filtros-dashboard .btn-group .btn:hover {\n    color: var(--text-light) !important;\n    background-color: rgba(255, 255, 255, 0.05) !important;\n}\n\n/* Botão ATIVO no controle */\n#form-filtros-dashboard .btn-group .btn.active {\n    background-color: var(--hover-bg) !important;\n    color: var(--text-light) !important;\n    font-weight: 600;\n    box-shadow: 0 2px 8px rgba(0,0,0,0.3) !important;\n}\n\n.input-group-text {\n    background-color: var(--border-color) !important; /* Um cinza um pouco mais escuro para destaque */\n    border-color: var(--border-color) !important;\n    color: var(--text-muted) !important;\n    font-weight: 600;\n}\n\n.btn:hover {\n    transform: translateY(-2px);\n    opacity: 0.95;\n}\n\n/* Aplica o brilho laranja ao passar o mouse sobre botões primários */\n.btn-primary:hover {\n    box-shadow: 0 0 12px var(--glow-color);\n}\n\n/* Aplica um brilho verde ao passar o mouse sobre botões de sucesso */\n.btn-success:hover {\n    box-shadow: 0 0 12px rgba(46, 160, 67, 0.6);\n}\n\n/* Aplica um brilho vermelho ao passar o mouse sobre botões de perigo */\n.btn-danger:hover, .btn-outline-danger:hover {\n    box-shadow: 0 0 12px rgba(248, 113, 113, 0.6);\n}\n\n/* Aplica um brilho cinza ao passar o mouse sobre botões secundários */\n.btn-secondary:hover, .btn-outline-secondary:hover {\n    box-shadow: 0 0 12px rgba(108, 117, 125, 0.4);\n}","size_bytes":10143},"public/js/pages/admin.js":{"content":"import { showToast } from '../utils.js';\n\n// --- Variáveis de Estado Globais no Módulo ---\nlet dashboardLineChart = null;\nlet dashboardBarChart = null;\nlet dashboardDonutChart = null;\nlet lastRankingData = [];\nlet storeSalesChart = null;\nlet storeTicketChart = null;\nlet storePaChart = null;\nlet paymentDistributionChart = null;\n\n// --- Funções Auxiliares ---\nconst getCssVar = (varName) => getComputedStyle(document.documentElement).getPropertyValue(varName).trim();\nconst toISODateString = (date) => date.toISOString().split('T')[0];\n\nfunction setLoadingState(isLoading) {\n    const kpiElements = document.querySelectorAll('[id^=\"geral-\"], [id^=\"loja-\"], [id^=\"overview-\"]');\n    const chartCanvases = ['dashboard-line-chart', 'dashboard-bar-chart', 'dashboard-donut-chart'];\n\n    if (isLoading) {\n        kpiElements.forEach(el => {\n            if (el.tagName === 'H2' || el.tagName === 'H3' || el.tagName === 'H5') {\n                el.innerHTML = '<span class=\"spinner-border spinner-border-sm\"></span>';\n            } else { el.innerHTML = ''; }\n        });\n        \n        chartCanvases.forEach(canvasId => {\n            const canvas = document.getElementById(canvasId);\n            if (canvas) canvas.style.opacity = '0.5';\n        });\n    } else {\n        chartCanvases.forEach(canvasId => {\n            const canvas = document.getElementById(canvasId);\n            if (canvas) canvas.style.opacity = '1';\n        });\n    }\n}\n\nfunction getComparisonHtml(current, previous, unit = '') {\n    const currentNum = parseFloat(current);\n    const previousNum = parseFloat(previous);\n    if (isNaN(currentNum) || isNaN(previousNum)) return '';\n\n    if (previousNum === 0) return currentNum > 0 ? '<span class=\"text-success\">▲ Novo</span>' : '';\n    \n    const diff = ((currentNum - previousNum) / previousNum) * 100;\n    if (Math.abs(diff) < 0.1) return '';\n\n    const icon = diff > 0 ? '▲' : '▼';\n    const colorClass = diff > 0 ? 'text-success' : 'text-danger';\n    \n    const previousFormatted = unit === '%' ? previousNum.toFixed(2) : previousNum.toLocaleString('pt-BR');\n    const tooltipTitle = `Valor anterior: ${previousFormatted}${unit}`;\n\n    return `<span class=\"${colorClass}\" data-bs-toggle=\"tooltip\" data-bs-title=\"${tooltipTitle}\">${icon} ${diff.toFixed(1)}%</span>`;\n}\n\n// --- Funções de Renderização de Gráficos ---\n\nfunction renderBarChart(rankingData) {\n    const ctx = document.getElementById('dashboard-bar-chart').getContext('2d');\n    const metricSelect = document.getElementById('bar-chart-metric-select');\n    const metric = metricSelect.value;\n\n    let sortedData = [...rankingData];\n    if (metric === 'vendas') {\n        sortedData.sort((a, b) => b.total_vendas_loja - a.total_vendas_loja);\n    } else if (metric === 'clientes') {\n        sortedData.sort((a, b) => b.total_clientes_loja - a.total_clientes_loja);\n    } else if (metric === 'conversao') {\n        sortedData.sort((a, b) => parseFloat(b.tx_loja) - parseFloat(a.tx_loja));\n    }\n    \n    const topLojas = sortedData.slice(0, 10);\n    const labels = topLojas.map(l => l.loja.length > 20 ? l.loja.substring(0, 20) + '...' : l.loja);\n    \n    let data, label, backgroundColor;\n    if (metric === 'vendas') {\n        data = topLojas.map(l => l.total_vendas_loja);\n        label = 'Vendas';\n        backgroundColor = getCssVar('--accent-color');\n    } else if (metric === 'clientes') {\n        data = topLojas.map(l => l.total_clientes_loja);\n        label = 'Clientes';\n        backgroundColor = getCssVar('--color-success');\n    } else {\n        data = topLojas.map(l => parseFloat(l.tx_loja));\n        label = 'Taxa de Conversão (%)';\n        backgroundColor = '#4169E1';\n    }\n\n    if (dashboardBarChart) dashboardBarChart.destroy();\n    dashboardBarChart = new Chart(ctx, {\n        type: 'bar',\n        data: {\n            labels: labels,\n            datasets: [{\n                label: label,\n                data: data,\n                backgroundColor: backgroundColor,\n                borderRadius: 6,\n                borderSkipped: false\n            }]\n        },\n        options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n                legend: { display: true, position: 'top' },\n                tooltip: {\n                    callbacks: {\n                        label: function(context) {\n                            let label = context.dataset.label || '';\n                            if (label) label += ': ';\n                            if (metric === 'conversao') {\n                                label += context.parsed.y.toFixed(2) + '%';\n                            } else {\n                                label += context.parsed.y.toLocaleString('pt-BR');\n                            }\n                            return label;\n                        }\n                    }\n                }\n            },\n            scales: {\n                y: {\n                    beginAtZero: true,\n                    ticks: {\n                        callback: function(value) {\n                            if (metric === 'conversao') {\n                                return value.toFixed(1) + '%';\n                            }\n                            return value.toLocaleString('pt-BR');\n                        }\n                    }\n                }\n            }\n        }\n    });\n}\n\nfunction renderDonutChart(rankingData) {\n    const ctx = document.getElementById('dashboard-donut-chart').getContext('2d');\n    \n    const topLojas = [...rankingData]\n        .sort((a, b) => parseFloat(b.tx_loja) - parseFloat(a.tx_loja))\n        .slice(0, 5);\n    \n    const labels = topLojas.map(l => l.loja.length > 15 ? l.loja.substring(0, 15) + '...' : l.loja);\n    const data = topLojas.map(l => parseFloat(l.tx_loja));\n    \n    // Cores claras e vibrantes (diferentes do gráfico de linha)\n    const colors = ['#f472b6', '#60a5fa', '#fbbf24', '#a78bfa', '#34d399'];\n\n    if (dashboardDonutChart) dashboardDonutChart.destroy();\n    dashboardDonutChart = new Chart(ctx, {\n        type: 'doughnut',\n        data: {\n            labels: labels,\n            datasets: [{\n                data: data,\n                backgroundColor: colors,\n                borderWidth: 2,\n                borderColor: getCssVar('--main-bg')\n            }]\n        },\n        options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n                legend: {\n                    position: 'bottom',\n                    labels: {\n                        padding: 15,\n                        font: { size: 11 }\n                    }\n                },\n                tooltip: {\n                    callbacks: {\n                        label: function(context) {\n                            return context.label + ': ' + context.parsed.toFixed(2) + '%';\n                        }\n                    }\n                }\n            }\n        }\n    });\n}\n\nasync function loadStorePerformance(dataInicio, dataFim) {\n    try {\n        const params = new URLSearchParams();\n        if (dataInicio) params.append('data_inicio', dataInicio);\n        if (dataFim) params.append('data_fim', dataFim);\n        \n        const response = await fetch(`/api/dashboard/store-performance?${params.toString()}`);\n        if (!response.ok) {\n            console.error('Erro ao carregar desempenho das lojas');\n            return;\n        }\n        const data = await response.json();\n        \n        renderStoreSalesChart(data);\n        renderStoreTicketChart(data);\n        renderStorePaChart(data);\n        renderPaymentDistributionChart(data);\n    } catch (error) {\n        console.error('Erro ao carregar desempenho das lojas:', error);\n    }\n}\n\nfunction renderStoreSalesChart(data) {\n    const ctx = document.getElementById('store-sales-chart')?.getContext('2d');\n    if (!ctx) return;\n    \n    const topStores = data.slice(0, 10);\n    const labels = topStores.map(s => s.loja.length > 20 ? s.loja.substring(0, 20) + '...' : s.loja);\n    const values = topStores.map(s => s.vendas_media_dia);\n    \n    if (storeSalesChart) storeSalesChart.destroy();\n    storeSalesChart = new Chart(ctx, {\n        type: 'bar',\n        data: {\n            labels: labels,\n            datasets: [{\n                label: 'Vendas Médias por Dia',\n                data: values,\n                backgroundColor: getCssVar('--accent-color'),\n                borderRadius: 6,\n                borderSkipped: false\n            }]\n        },\n        options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n                legend: { display: true, position: 'top' },\n                tooltip: {\n                    callbacks: {\n                        label: function(context) {\n                            const index = context.dataIndex;\n                            const store = topStores[index];\n                            return [\n                                'Média/dia: ' + store.vendas_media_dia.toLocaleString('pt-BR', { minimumFractionDigits: 2 }),\n                                'Total: ' + store.total_vendas.toLocaleString('pt-BR'),\n                                'Relatórios: ' + store.dias_registrados\n                            ];\n                        }\n                    }\n                }\n            },\n            scales: {\n                y: {\n                    beginAtZero: true,\n                    ticks: {\n                        callback: function(value) {\n                            return value.toLocaleString('pt-BR');\n                        }\n                    }\n                }\n            }\n        }\n    });\n}\n\nfunction renderStoreTicketChart(data) {\n    const ctx = document.getElementById('store-ticket-chart')?.getContext('2d');\n    if (!ctx) return;\n    \n    const topStores = [...data].sort((a, b) => b.ticket_medio - a.ticket_medio).slice(0, 10);\n    const labels = topStores.map(s => s.loja.length > 20 ? s.loja.substring(0, 20) + '...' : s.loja);\n    const values = topStores.map(s => s.ticket_medio);\n    \n    if (storeTicketChart) storeTicketChart.destroy();\n    storeTicketChart = new Chart(ctx, {\n        type: 'bar',\n        data: {\n            labels: labels,\n            datasets: [{\n                label: 'Ticket Médio (R$)',\n                data: values,\n                backgroundColor: '#10b981',\n                borderRadius: 6,\n                borderSkipped: false\n            }]\n        },\n        options: {\n            indexAxis: 'y',\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n                legend: { display: true, position: 'top' },\n                tooltip: {\n                    callbacks: {\n                        label: function(context) {\n                            const index = context.dataIndex;\n                            const store = topStores[index];\n                            return [\n                                'Ticket Médio: R$ ' + store.ticket_medio.toFixed(2),\n                                'Baseado em ' + store.dias_registrados + ' relatório(s)'\n                            ];\n                        }\n                    }\n                }\n            },\n            scales: {\n                x: {\n                    beginAtZero: true,\n                    ticks: {\n                        callback: function(value) {\n                            return 'R$ ' + value.toFixed(2);\n                        }\n                    }\n                }\n            }\n        }\n    });\n}\n\nfunction renderStorePaChart(data) {\n    const ctx = document.getElementById('store-pa-chart')?.getContext('2d');\n    if (!ctx) return;\n    \n    const topStores = [...data].sort((a, b) => b.pa - a.pa).slice(0, 10);\n    const labels = topStores.map(s => s.loja.length > 20 ? s.loja.substring(0, 20) + '...' : s.loja);\n    const values = topStores.map(s => s.pa);\n    \n    if (storePaChart) storePaChart.destroy();\n    storePaChart = new Chart(ctx, {\n        type: 'bar',\n        data: {\n            labels: labels,\n            datasets: [{\n                label: 'Peças por Venda (PA)',\n                data: values,\n                backgroundColor: '#f59e0b',\n                borderRadius: 6,\n                borderSkipped: false\n            }]\n        },\n        options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n                legend: { display: true, position: 'top' },\n                tooltip: {\n                    callbacks: {\n                        label: function(context) {\n                            const index = context.dataIndex;\n                            const store = topStores[index];\n                            return [\n                                'PA: ' + store.pa.toFixed(2),\n                                'Baseado em ' + store.dias_registrados + ' relatório(s)'\n                            ];\n                        }\n                    }\n                }\n            },\n            scales: {\n                y: {\n                    beginAtZero: true,\n                    ticks: {\n                        callback: function(value) {\n                            return value.toFixed(1);\n                        }\n                    }\n                }\n            }\n        }\n    });\n}\n\nfunction renderPaymentDistributionChart(data) {\n    const ctx = document.getElementById('payment-distribution-chart')?.getContext('2d');\n    if (!ctx) return;\n    \n    const totalCartao = data.reduce((sum, s) => sum + s.formas_pagamento.cartao, 0);\n    const totalPix = data.reduce((sum, s) => sum + s.formas_pagamento.pix, 0);\n    const totalDinheiro = data.reduce((sum, s) => sum + s.formas_pagamento.dinheiro, 0);\n    \n    if (paymentDistributionChart) paymentDistributionChart.destroy();\n    paymentDistributionChart = new Chart(ctx, {\n        type: 'doughnut',\n        data: {\n            labels: ['Cartão', 'PIX', 'Dinheiro'],\n            datasets: [{\n                data: [totalCartao, totalPix, totalDinheiro],\n                backgroundColor: ['#3b82f6', '#10b981', '#f59e0b'],\n                borderWidth: 2,\n                borderColor: getCssVar('--main-bg')\n            }]\n        },\n        options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n                legend: {\n                    position: 'bottom',\n                    labels: {\n                        padding: 15,\n                        font: { size: 12 }\n                    }\n                },\n                tooltip: {\n                    callbacks: {\n                        label: function(context) {\n                            const total = totalCartao + totalPix + totalDinheiro;\n                            const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : 0;\n                            return context.label + ': ' + context.parsed.toLocaleString('pt-BR') + ' (' + percentage + '%)';\n                        }\n                    }\n                }\n            }\n        }\n    });\n}\n\nasync function loadDemandas() {\n    const container = document.getElementById('dashboard-demandas-container');\n    if (!container) return;\n    \n    try {\n        const response = await fetch('/api/demandas/pendentes');\n        if (!response.ok) {\n            throw new Error('Erro ao carregar demandas');\n        }\n        const demandas = await response.json();\n        \n        if (demandas.length === 0) {\n            container.innerHTML = `\n                <div class=\"text-center text-muted py-3\">\n                    <i class=\"bi bi-check-circle fs-1\"></i>\n                    <p class=\"mb-0 mt-2\">Nenhuma demanda pendente</p>\n                </div>\n            `;\n            return;\n        }\n        \n        // Mostrar apenas as 5 primeiras demandas\n        const demandasToShow = demandas.slice(0, 5);\n        \n        container.innerHTML = `\n            <div class=\"list-group list-group-flush\">\n                ${demandasToShow.map(demanda => {\n                    const tagColors = {\n                        'urgente': 'danger',\n                        'importante': 'warning',\n                        'normal': 'info'\n                    };\n                    const tagColor = tagColors[demanda.tag] || 'secondary';\n                    const dataFormatada = new Date(demanda.criado_em).toLocaleDateString('pt-BR');\n                    \n                    return `\n                        <div class=\"list-group-item list-group-item-action p-3\">\n                            <div class=\"d-flex w-100 justify-content-between align-items-start\">\n                                <div class=\"flex-grow-1\">\n                                    <h6 class=\"mb-1\">\n                                        <i class=\"bi bi-shop me-1\"></i>${demanda.loja_nome}\n                                    </h6>\n                                    <p class=\"mb-1 small\">${demanda.descricao}</p>\n                                    <small class=\"text-muted\">\n                                        <i class=\"bi bi-person me-1\"></i>${demanda.criado_por_usuario} • ${dataFormatada}\n                                    </small>\n                                </div>\n                                <span class=\"badge bg-${tagColor} ms-2\">${demanda.tag}</span>\n                            </div>\n                        </div>\n                    `;\n                }).join('')}\n            </div>\n            ${demandas.length > 5 ? `\n                <div class=\"text-center mt-2\">\n                    <small class=\"text-muted\">+ ${demandas.length - 5} demandas pendentes</small>\n                </div>\n            ` : ''}\n        `;\n    } catch (error) {\n        console.error('Erro ao carregar demandas:', error);\n        container.innerHTML = `\n            <div class=\"text-center text-danger py-3\">\n                <i class=\"bi bi-exclamation-triangle\"></i>\n                <p class=\"mb-0 mt-2 small\">Erro ao carregar demandas</p>\n            </div>\n        `;\n    }\n}\n\nfunction renderLineChart(currentChartData, comparisonChartData, hideMonitData = false) {\n    const ctx = document.getElementById('dashboard-line-chart').getContext('2d');\n    \n    const datasets = [\n        {\n            label: 'Tx. Conv. Loja (Atual)',\n            data: currentChartData.txConversaoLoja,\n            borderColor: '#4ade80',\n            backgroundColor: 'rgba(74, 222, 128, 0.2)',\n            fill: true, tension: 0.4, borderWidth: 3\n        },\n        {\n            label: 'Tx. Conv. Loja (Comparado)',\n            data: comparisonChartData.txConversaoLoja,\n            borderColor: '#4ade80',\n            borderDash: [5, 5], fill: false, tension: 0.4, borderWidth: 2\n        }\n    ];\n    \n    // Adicionar dados de monitoramento apenas se não for gerente\n    if (!hideMonitData) {\n        datasets.push(\n            {\n                label: 'Tx. Conv. Monit. (Atual)',\n                data: currentChartData.txConversaoMonitoramento,\n                borderColor: '#60a5fa',\n                backgroundColor: 'rgba(96, 165, 250, 0.2)',\n                fill: true, tension: 0.4, borderWidth: 3\n            },\n            {\n                label: 'Tx. Conv. Monit. (Comparado)',\n                data: comparisonChartData.txConversaoMonitoramento,\n                borderColor: '#60a5fa',\n                borderDash: [5, 5], fill: false, tension: 0.4, borderWidth: 2\n            }\n        );\n    }\n    \n    if (dashboardLineChart) dashboardLineChart.destroy();\n    dashboardLineChart = new Chart(ctx, {\n        type: 'line',\n        data: { labels: currentChartData.labels, datasets: datasets },\n        options: {\n            responsive: true, maintainAspectRatio: false,\n            interaction: { mode: 'index', intersect: false },\n            plugins: { \n                legend: { position: 'top' }, \n                tooltip: { position: 'nearest' } \n            },\n            scales: { \n                y: { \n                    beginAtZero: true, \n                    ticks: { callback: (value) => value + '%' } \n                } \n            }\n        }\n    });\n}\n\n\nfunction updateOverviewCards(rankingData, currentData) {\n    // Total de lojas ativas\n    document.getElementById('overview-total-lojas').textContent = rankingData.length;\n    \n    // Melhor loja (por taxa de conversão)\n    if (rankingData.length > 0) {\n        const melhorLoja = [...rankingData].sort((a, b) => parseFloat(b.tx_loja) - parseFloat(a.tx_loja))[0];\n        const nomeLoja = melhorLoja.loja.length > 25 ? melhorLoja.loja.substring(0, 25) + '...' : melhorLoja.loja;\n        document.getElementById('overview-melhor-loja').textContent = `${nomeLoja} (${parseFloat(melhorLoja.tx_loja).toFixed(2)}%)`;\n    } else {\n        document.getElementById('overview-melhor-loja').textContent = '-';\n    }\n    \n    // Média de conversão\n    if (rankingData.length > 0) {\n        const somaConversao = rankingData.reduce((acc, loja) => acc + parseFloat(loja.tx_loja), 0);\n        const media = somaConversao / rankingData.length;\n        document.getElementById('overview-media-conversao').textContent = `${media.toFixed(2)}%`;\n    } else {\n        document.getElementById('overview-media-conversao').textContent = '0.00%';\n    }\n    \n    // Total de vendas\n    const totalVendas = currentData.total_vendas_loja || 0;\n    document.getElementById('overview-total-vendas').textContent = totalVendas.toLocaleString('pt-BR');\n}\n\n// Função para popular os dropdowns de loja nos cards Monitoramento e Bluve\nasync function populateStoreDropdowns() {\n    try {\n        const response = await fetch('/api/lojas');\n        const lojas = await response.json();\n        \n        const filtroMonitoramento = document.getElementById('filtro-loja-monitoramento');\n        const filtroBluve = document.getElementById('filtro-loja-bluve');\n        \n        if (filtroMonitoramento && filtroBluve) {\n            // Limpar opções existentes (exceto \"Geral\")\n            filtroMonitoramento.innerHTML = '<option value=\"\">Geral</option>';\n            filtroBluve.innerHTML = '<option value=\"\">Geral</option>';\n            \n            // Adicionar lojas aos dropdowns\n            lojas.forEach(loja => {\n                const optionMonit = document.createElement('option');\n                optionMonit.value = loja.nome;\n                optionMonit.textContent = loja.nome;\n                filtroMonitoramento.appendChild(optionMonit);\n                \n                const optionBluve = document.createElement('option');\n                optionBluve.value = loja.nome;\n                optionBluve.textContent = loja.nome;\n                filtroBluve.appendChild(optionBluve);\n            });\n        }\n    } catch (error) {\n        console.error('Erro ao carregar lojas para dropdowns:', error);\n    }\n}\n\n// Função para atualizar apenas o card Monitoramento\nasync function updateMonitoramentoCard(loja = '') {\n    try {\n        // Obter a loja selecionada no dropdown Bluve para manter seus dados\n        const filtroBluve = document.getElementById('filtro-loja-bluve');\n        const lojaBluveAtual = filtroBluve ? filtroBluve.value : '';\n        \n        const params = new URLSearchParams();\n        if (loja) params.append('loja_monitoramento', loja);\n        if (lojaBluveAtual) params.append('loja_bluve', lojaBluveAtual);\n        \n        const url = `/api/dashboard/metrics${params.toString() ? '?' + params.toString() : ''}`;\n        const response = await fetch(url);\n        const data = await response.json();\n        \n        // Atualizar card Monitoramento\n        document.getElementById('monitoramento-clientes').textContent = (data.monitoramento.clientes || 0).toLocaleString('pt-BR');\n        document.getElementById('monitoramento-vendas').textContent = (data.monitoramento.vendas || 0).toLocaleString('pt-BR');\n        document.getElementById('monitoramento-tx-conversao').textContent = `${data.monitoramento.tx_conversao}%`;\n    } catch (error) {\n        console.error('Erro ao carregar métricas de Monitoramento:', error);\n    }\n}\n\n// Função para atualizar apenas o card Bluve\nasync function updateBluveCard(loja = '') {\n    try {\n        // Obter a loja selecionada no dropdown Monitoramento para manter seus dados\n        const filtroMonitoramento = document.getElementById('filtro-loja-monitoramento');\n        const lojaMonitoramentoAtual = filtroMonitoramento ? filtroMonitoramento.value : '';\n        \n        const params = new URLSearchParams();\n        if (lojaMonitoramentoAtual) params.append('loja_monitoramento', lojaMonitoramentoAtual);\n        if (loja) params.append('loja_bluve', loja);\n        \n        const url = `/api/dashboard/metrics${params.toString() ? '?' + params.toString() : ''}`;\n        const response = await fetch(url);\n        const data = await response.json();\n        \n        // Atualizar card Bluve\n        document.getElementById('bluve-clientes').textContent = (data.bluve.clientes || 0).toLocaleString('pt-BR');\n        document.getElementById('bluve-vendas').textContent = (data.bluve.vendas || 0).toLocaleString('pt-BR');\n        document.getElementById('bluve-tx-conversao').textContent = `${data.bluve.tx_conversao}%`;\n    } catch (error) {\n        console.error('Erro ao carregar métricas de Bluve:', error);\n    }\n}\n\n// Inicializar dropdowns e métricas\nfunction initMetricsCards() {\n    // Popular dropdowns\n    populateStoreDropdowns();\n    \n    // Carregar métricas gerais inicialmente para ambos os cards\n    updateMonitoramentoCard();\n    updateBluveCard();\n    \n    // Adicionar event listeners aos dropdowns (independentes)\n    const filtroMonitoramento = document.getElementById('filtro-loja-monitoramento');\n    const filtroBluve = document.getElementById('filtro-loja-bluve');\n    \n    if (filtroMonitoramento) {\n        filtroMonitoramento.addEventListener('change', (e) => {\n            updateMonitoramentoCard(e.target.value);\n        });\n    }\n    \n    if (filtroBluve) {\n        filtroBluve.addEventListener('change', (e) => {\n            updateBluveCard(e.target.value);\n        });\n    }\n}\n\nfunction updateUI(results, hideMonitData = false) {\n    const [currentData, rankingData, currentChartData, comparisonData, comparisonChartData] = results;\n\n    // Armazenar rankingData globalmente\n    lastRankingData = rankingData;\n\n    // Atualizar cards de visão geral\n    updateOverviewCards(rankingData, currentData);\n\n    // Atualizar métricas principais (apenas se não for gerente e dados existirem)\n    if (!hideMonitData && currentData.total_clientes_monitoramento !== undefined) {\n        document.getElementById('geral-clientes').textContent = (currentData.total_clientes_monitoramento || 0).toLocaleString('pt-BR');\n        document.getElementById('geral-vendas').textContent = ((currentData.total_vendas_monitoramento || 0) + (currentData.total_omni || 0)).toLocaleString('pt-BR');\n        document.getElementById('geral-tx-conversao').textContent = `${parseFloat(currentData.tx_conversao_monitoramento || 0).toFixed(2)}%`;\n        document.getElementById('geral-clientes-comp').innerHTML = getComparisonHtml(currentData.total_clientes_monitoramento, comparisonData.total_clientes_monitoramento || 0);\n        document.getElementById('geral-vendas-comp').innerHTML = getComparisonHtml((currentData.total_vendas_monitoramento || 0) + (currentData.total_omni || 0), (comparisonData.total_vendas_monitoramento || 0) + (comparisonData.total_omni || 0));\n        document.getElementById('geral-tx-conversao-comp').innerHTML = getComparisonHtml(currentData.tx_conversao_monitoramento, comparisonData.tx_conversao_monitoramento || 0, '%');\n    }\n    \n    // Atualizar métricas da loja\n    const lojaClientes = document.getElementById('loja-clientes');\n    const lojaVendas = document.getElementById('loja-vendas');\n    const lojaTxConversao = document.getElementById('loja-tx-conversao');\n    const lojaClientesComp = document.getElementById('loja-clientes-comp');\n    const lojaVendasComp = document.getElementById('loja-vendas-comp');\n    const lojaTxConversaoComp = document.getElementById('loja-tx-conversao-comp');\n    \n    if (lojaClientes) lojaClientes.textContent = (currentData.total_clientes_loja || 0).toLocaleString('pt-BR');\n    if (lojaVendas) lojaVendas.textContent = (currentData.total_vendas_loja || 0).toLocaleString('pt-BR');\n    if (lojaTxConversao) lojaTxConversao.textContent = `${parseFloat(currentData.tx_conversao_loja || 0).toFixed(2)}%`;\n    if (lojaClientesComp) lojaClientesComp.innerHTML = getComparisonHtml(currentData.total_clientes_loja, comparisonData.total_clientes_loja);\n    if (lojaVendasComp) lojaVendasComp.innerHTML = getComparisonHtml(currentData.total_vendas_loja, comparisonData.total_vendas_loja);\n    if (lojaTxConversaoComp) lojaTxConversaoComp.innerHTML = getComparisonHtml(currentData.tx_conversao_loja, comparisonData.tx_conversao_loja, '%');\n\n    // Renderizar gráficos\n    renderLineChart(currentChartData, comparisonChartData, hideMonitData);\n    renderBarChart(rankingData);\n    renderDonutChart(rankingData);\n\n    // Ativar tooltips\n    const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle=\"tooltip\"]');\n    [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl));\n}\n\n// --- Lógica Principal e Eventos ---\nexport function initAdminPage(currentUser) {\n    const form = document.getElementById('form-filtros-dashboard');\n    if (!form) return;\n\n    const lojaSelect = document.getElementById('filtro-loja-dashboard');\n    const dataInicioInput = document.getElementById('filtro-data-inicio-dashboard');\n    const dataFimInput = document.getElementById('filtro-data-fim-dashboard');\n    const quickPeriodButtons = document.querySelectorAll('[data-period]');\n    const barChartMetricSelect = document.getElementById('bar-chart-metric-select');\n    \n    const allowedMonitoramentoRoles = ['admin', 'monitoramento', 'dev', 'consultor'];\n    const canViewMonitoramento = currentUser && allowedMonitoramentoRoles.includes(currentUser.role);\n    const isGerente = currentUser && currentUser.role === 'gerente';\n    const isTecnico = currentUser && currentUser.role === 'tecnico';\n    const isNotAdmin = isGerente || isTecnico;\n    \n    // Controlar visibilidade do card de Monitoramento\n    const monitoramentoCard = document.getElementById('monitoramento-card');\n    const lojaCardCol = document.getElementById('loja-card-col');\n    \n    if (!canViewMonitoramento) {\n        const comparativeSection = document.getElementById('comparative-charts-section');\n        if (comparativeSection) comparativeSection.style.display = 'none';\n        \n        if (monitoramentoCard) {\n            monitoramentoCard.style.display = 'none';\n            monitoramentoCard.classList.remove('visible');\n        }\n        \n        if (lojaCardCol) {\n            lojaCardCol.classList.add('full-width');\n        }\n        \n        console.log(`Dashboard adaptado para ${currentUser.role} - card Monitoramento oculto (visível apenas para admin, monitoramento, dev, consultor)`);\n    }\n    \n    // Garantir que o card Bluve esteja SEMPRE visível (FORÇADO)\n    if (lojaCardCol) {\n        lojaCardCol.style.display = 'block';\n        lojaCardCol.style.visibility = 'visible';\n        lojaCardCol.style.opacity = '1';\n        lojaCardCol.classList.remove('d-none', 'hidden', 'invisible');\n        console.log('✅ Card Bluve garantido como visível - display:', lojaCardCol.style.display);\n    } else {\n        console.error('❌ ERRO CRÍTICO: Elemento loja-card-col não encontrado no DOM!');\n    }\n    \n    // Verificação adicional após delay para garantir que o card permanece visível\n    setTimeout(() => {\n        const lojaCardCheck = document.getElementById('loja-card-col');\n        if (lojaCardCheck) {\n            lojaCardCheck.style.display = 'block';\n            lojaCardCheck.style.visibility = 'visible';\n            lojaCardCheck.style.opacity = '1';\n            const computedDisplay = window.getComputedStyle(lojaCardCheck).display;\n            console.log('✅ Card Bluve RE-verificado - computedDisplay:', computedDisplay);\n            \n            if (computedDisplay === 'none') {\n                console.error('❌ ALERTA: Card Bluve ainda está com display:none. Forçando novamente...');\n                lojaCardCheck.style.setProperty('display', 'block', 'important');\n            }\n        }\n    }, 100);\n    \n    if (isGerente && lojaSelect) {\n        const todasOption = lojaSelect.querySelector('option[value=\"todas\"]');\n        if (todasOption) todasOption.remove();\n    }\n\n    async function carregarLojas() {\n        try {\n            const response = await fetch('/api/lojas?status=ativa');\n            const lojas = await response.json();\n            lojas.forEach(loja => lojaSelect.add(new Option(loja.nome, loja.nome)));\n        } catch (error) { console.error('Falha ao carregar lojas', error); }\n    }\n    \n    function setDateRange(period) {\n        const hoje = new Date();\n        let inicio, fim = new Date(hoje);\n        switch (period) {\n            case 'hoje': inicio = hoje; break;\n            case '7d': inicio = new Date(); inicio.setDate(hoje.getDate() - 6); break;\n            case 'mes-atual': inicio = new Date(hoje.getFullYear(), hoje.getMonth(), 1); break;\n            case 'mes-passado':\n                inicio = new Date(hoje.getFullYear(), hoje.getMonth() - 1, 1);\n                fim = new Date(hoje.getFullYear(), hoje.getMonth(), 0);\n                break;\n        }\n        dataInicioInput.value = toISODateString(inicio);\n        dataFimInput.value = toISODateString(fim);\n    }\n\n    async function analisarDados(e) {\n        if(e) e.preventDefault();\n        console.log('analisarDados() chamado');\n        setLoadingState(true);\n\n        const loja = lojaSelect.value;\n        const dataInicio = dataInicioInput.value;\n        const dataFim = dataFimInput.value;\n\n        console.log('Dados do filtro:', { loja, dataInicio, dataFim });\n\n        if (!dataInicio || !dataFim) {\n            console.error('Datas não definidas!', { dataInicio, dataFim });\n            showToast(\"Atenção\", \"Por favor, selecione um período de datas.\", \"danger\");\n            setLoadingState(false);\n            return;\n        }\n        \n        const baseParams = { data_inicio: dataInicio, data_fim: dataFim };\n        if (loja !== 'todas') {\n            baseParams.loja = loja;\n        }\n\n        const currentParams = new URLSearchParams(baseParams);\n\n        const startDate = new Date(dataInicio + 'T00:00:00');\n        const endDate = new Date(dataFim + 'T00:00:00');\n        \n        // Sempre comparar com período anterior\n        const diff = endDate.getTime() - startDate.getTime();\n        const compEndDate = new Date(startDate.getTime() - 86400000);\n        const compStartDate = new Date(compEndDate.getTime() - diff);\n        const compBaseParams = {...baseParams, data_inicio: toISODateString(compStartDate), data_fim: toISODateString(compEndDate) };\n        const comparisonParams = new URLSearchParams(compBaseParams);\n        \n        const apiCalls = [\n            fetch(`/api/dashboard-data?${currentParams.toString()}`),\n            fetch(`/api/ranking?${new URLSearchParams({ data_inicio: dataInicio, data_fim: dataFim })}`),\n            fetch(`/api/dashboard/chart-data?${currentParams.toString()}`),\n            fetch(`/api/dashboard-data?${comparisonParams.toString()}`),\n            fetch(`/api/dashboard/chart-data?${comparisonParams.toString()}`)\n        ];\n        \n        try {\n            const responses = await Promise.all(apiCalls);\n            \n            // Verificar cada resposta individualmente\n            for (let i = 0; i < responses.length; i++) {\n                if (!responses[i].ok) {\n                    console.error(`API ${i} falhou:`, responses[i].status, responses[i].statusText);\n                    throw new Error(`Falha na API ${i}: ${responses[i].status} ${responses[i].statusText}`);\n                }\n            }\n            \n            const results = await Promise.all(responses.map(res => res.json()));\n\n            updateUI(results, isNotAdmin);\n            \n            // Atualizar gráficos de desempenho das lojas com o mesmo período\n            loadStorePerformance(dataInicio, dataFim);\n        } catch (error) {\n            console.error(\"Erro ao analisar dados:\", error.message, error.stack);\n            showToast(\"Erro\", \"Não foi possível carregar os dados do dashboard.\", \"danger\");\n        } finally {\n            setLoadingState(false);\n        }\n    }\n    \n    // Event Listeners\n    form.addEventListener('submit', analisarDados);\n    \n    quickPeriodButtons.forEach(button => {\n        button.addEventListener('click', (e) => {\n            quickPeriodButtons.forEach(btn => btn.classList.remove('active'));\n            e.currentTarget.classList.add('active');\n            setDateRange(e.currentTarget.dataset.period);\n        });\n    });\n\n    if (barChartMetricSelect) {\n        barChartMetricSelect.addEventListener('change', () => {\n            if (lastRankingData.length > 0) {\n                renderBarChart(lastRankingData);\n            }\n        });\n    }\n\n    // Inicialização\n    async function inicializar() {\n        console.log('Inicializando dashboard...');\n        await carregarLojas();\n        console.log('Lojas carregadas');\n        \n        // Inicializar cards de Monitoramento e Bluve\n        initMetricsCards();\n        \n        loadDemandas(); // Carregar demandas pendentes\n        \n        // Carregar desempenho das lojas (últimos 30 dias por padrão)\n        const hoje = new Date();\n        const inicioMes = new Date(hoje);\n        inicioMes.setDate(hoje.getDate() - 30);\n        loadStorePerformance(toISODateString(inicioMes), toISODateString(hoje));\n        \n        console.log('Configurando período de 7 dias');\n        setDateRange('7d');\n        const initialActiveButton = document.querySelector('[data-period=\"7d\"]');\n        if(initialActiveButton) initialActiveButton.classList.add('active');\n        console.log('Chamando analisarDados...');\n        analisarDados();\n    }\n    \n    console.log('Iniciando admin page...');\n    inicializar();\n}\n","size_bytes":38236},"public/js/pages/demandas.js":{"content":"import { showToast, showConfirmModal, getAuthHeaders } from '../utils.js';\n\nexport function initDemandasPage() {\n    const containerPendentes = document.getElementById('demandas-pendentes-container');\n    const containerHistorico = document.getElementById('demandas-historico-container');\n    const abas = document.querySelectorAll('#demandasTab .nav-link');\n    const modalDemandaEl = document.getElementById('modal-add-demanda');\n    \n    // ===== A MUDANÇA ESTÁ AQUI =====\n    // Trocamos 'page-content' pelo nosso novo wrapper específico da página.\n    const demandasWrapper = document.getElementById('demandas-page-wrapper');\n    // ===============================\n\n    if (!modalDemandaEl || !demandasWrapper) return; // Adicionada verificação para o wrapper\n\n    const modalDemanda = new bootstrap.Modal(modalDemandaEl);\n    const formDemanda = document.getElementById('form-add-demanda');\n    const selectLojaModal = document.getElementById('demanda-loja');\n\n    async function carregarLojasNoModal() {\n        try {\n            const response = await fetch('/api/lojas?status=ativa');\n            const lojas = await response.json();\n            selectLojaModal.innerHTML = '<option value=\"\" selected disabled>Selecione uma loja</option>';\n            lojas.forEach(loja => {\n                selectLojaModal.add(new Option(loja.nome, loja.nome));\n            });\n        } catch (error) {\n            console.error(\"Falha ao carregar lojas:\", error);\n        }\n    }\n\n    async function carregarDemandas(tipo) {\n        const container = tipo === 'pendentes' ? containerPendentes : containerHistorico;\n        const url = `/api/demandas/${tipo}`;\n        if (!container) return;\n\n        container.innerHTML = '<p class=\"text-center\">Carregando...</p>';\n        try {\n            const response = await fetch(url);\n            const demandas = await response.json();\n            if (demandas.length === 0) {\n                container.innerHTML = '<p class=\"text-center text-muted\">Nenhuma demanda encontrada.</p>';\n                return;\n            }\n\n            const userRole = window.currentUser?.role;\n            const podeExcluir = ['admin', 'dev', 'monitoramento', 'consultor'].includes(userRole);\n            \n            container.innerHTML = demandas.map(d => {\n                const tagCores = { 'Urgente': 'bg-danger', 'Alta': 'bg-warning text-dark', 'Normal': 'bg-info text-dark', 'Baixa': 'bg-secondary' };\n                let acoesHtml = '';\n                \n                if (tipo === 'pendentes') {\n                    const btnExcluir = podeExcluir ? `<button class=\"btn btn-sm btn-danger\" data-action=\"excluir\" data-id=\"${d.id}\" title=\"Excluir\"><i class=\"bi bi-trash\"></i></button>` : '';\n                    acoesHtml = `<div class=\"d-flex justify-content-end mt-2\"><button class=\"btn btn-sm btn-success me-2\" data-action=\"concluir\" data-id=\"${d.id}\" title=\"Concluir\"><i class=\"bi bi-check-lg\"></i></button>${btnExcluir}</div>`;\n                } else if (tipo === 'historico') {\n                    if (podeExcluir) {\n                        acoesHtml = `<div class=\"d-flex justify-content-end mt-2\"><button class=\"btn btn-sm btn-danger\" data-action=\"excluir\" data-id=\"${d.id}\" title=\"Excluir do Histórico\"><i class=\"bi bi-trash\"></i></button></div>`;\n                    }\n                }\n                const footerHtml = tipo === 'pendentes' ? `Criado por <strong>${d.criado_por_usuario}</strong> em ${new Date(d.criado_em).toLocaleDateString('pt-BR')}` : `Concluído por <strong>${d.concluido_por_usuario || 'N/A'}</strong> em ${new Date(d.concluido_em).toLocaleDateString('pt-BR')}`;\n\n                return `<div class=\"card mb-3\"><div class=\"card-body\"><div class=\"d-flex justify-content-between align-items-start\"><div><h5 class=\"card-title mb-1\">${d.loja_nome}</h5><p class=\"card-text mb-0\">${d.descricao}</p></div><span class=\"badge ${tagCores[d.tag] || 'bg-light text-dark'}\">${d.tag}</span></div>${acoesHtml}</div><div class=\"card-footer text-muted small\">${footerHtml}</div></div>`;\n            }).join('');\n        } catch (e) {\n            container.innerHTML = '<p class=\"text-center text-danger\">Erro ao carregar demandas.</p>';\n        }\n    }\n\n    formDemanda.addEventListener('submit', async (e) => {\n        e.preventDefault();\n        const data = Object.fromEntries(new FormData(e.target).entries());\n        if (!data.loja_nome) {\n            showToast('Atenção', 'Selecione uma loja.', 'danger');\n            return;\n        }\n        try {\n            const response = await fetch('/api/demandas', { method: 'POST', headers: await getAuthHeaders(), body: JSON.stringify(data) });\n            if (!response.ok) throw new Error('Falha ao adicionar demanda.');\n            modalDemanda.hide();\n            e.target.reset();\n            showToast('Sucesso', 'Demanda adicionada.', 'success');\n            carregarDemandas('pendentes');\n        } catch (error) {\n            showToast('Erro', error.message, 'danger');\n        }\n    });\n\n    abas.forEach(aba => {\n        aba.addEventListener('shown.bs.tab', (event) => {\n            const targetId = event.target.getAttribute('data-bs-target');\n            // A lógica para carregar o histórico estava errada, corrigido para 'historico'\n            if (targetId === '#pendentes') carregarDemandas('pendentes');\n            else if (targetId === '#historico') carregarDemandas('historico'); // CORREÇÃO LÓGICA\n        });\n    });\n\n    // ===== A MUDANÇA ESTÁ AQUI =====\n    // O ouvinte agora está no nosso wrapper, isolado do resto do app.\n    demandasWrapper.addEventListener('click', async (e) => {\n        const button = e.target.closest('button[data-action]');\n        // A verificação de containeres ainda é uma boa prática\n        if (!button || !button.closest('#demandas-pendentes-container, #demandas-historico-container')) return;\n\n        const id = button.dataset.id;\n        const action = button.dataset.action;\n        const isPendente = !!button.closest('#demandas-pendentes-container');\n\n        if (action === 'concluir') {\n            const confirmed = await showConfirmModal('Marcar esta demanda como concluída?');\n            if (!confirmed) return;\n            try {\n                const response = await fetch(`/api/demandas/${id}/concluir`, { method: 'PUT', headers: await getAuthHeaders() });\n                if (!response.ok) throw new Error('Falha ao concluir demanda.');\n                showToast('Sucesso', 'Demanda movida para o histórico.', 'info');\n                carregarDemandas('pendentes');\n            } catch (e) { showToast('Erro', 'Não foi possível concluir.', 'danger'); }\n        }\n\n        if (action === 'excluir') {\n            const confirmed = await showConfirmModal('EXCLUIR PERMANENTEMENTE esta demanda?');\n            if (!confirmed) return;\n            try {\n                const response = await fetch(`/api/demandas/${id}`, { method: 'DELETE', headers: await getAuthHeaders() });\n                if (!response.ok) throw new Error('Falha ao excluir demanda.');\n                showToast('Sucesso', 'Demanda excluída.', 'success');\n                // A lógica para recarregar o histórico estava errada, corrigido.\n                if (isPendente) carregarDemandas('pendentes');\n                else carregarDemandas('historico'); // CORREÇÃO LÓGICA\n            } catch (e) { showToast('Erro', 'Não foi possível excluir.', 'danger'); }\n        }\n    });\n\n    carregarLojasNoModal();\n    carregarDemandas('pendentes');\n}","size_bytes":7514},"public/js/pages/alertas-tecnico.js":{"content":"import { showToast } from '../utils.js';\n\nexport function initAlertasTecnicoPage() {\n    if (!window.currentUser) {\n        setTimeout(initAlertasTecnicoPage, 100);\n        return;\n    }\n\n    const userRole = window.currentUser.role;\n    \n    if (userRole !== 'tecnico') {\n        window.location.href = '/admin';\n        return;\n    }\n\n    // Aguardar DOM estar pronto\n    setTimeout(() => {\n        carregarEstatisticas();\n        carregarAssistenciasEmAndamento();\n        carregarAssistenciasConcluidas();\n        \n        // Atualizar a cada 30 segundos\n        setInterval(() => {\n            carregarEstatisticas();\n            carregarAssistenciasEmAndamento();\n            carregarAssistenciasConcluidas();\n        }, 30000);\n    }, 100);\n}\n\nasync function carregarEstatisticas() {\n    try {\n        const response = await fetch('/api/assistencias/stats-tecnico');\n        const stats = await response.json();\n        \n        document.getElementById('stat-em-andamento').textContent = stats.emAndamento || 0;\n        document.getElementById('stat-concluidas-hoje').textContent = stats.concluidasHoje || 0;\n        document.getElementById('stat-total-mes').textContent = stats.totalMes || 0;\n        document.getElementById('stat-aguardando-pecas').textContent = stats.aguardandoPecas || 0;\n    } catch (e) {\n        console.error('Erro ao carregar estatísticas:', e);\n    }\n}\n\nasync function carregarAssistenciasEmAndamento() {\n    const tbody = document.getElementById('tabela-em-andamento');\n    \n    try {\n        const response = await fetch('/api/assistencias?status=Em andamento,Aguardando peças');\n        const assistencias = await response.json();\n        \n        if (assistencias.length === 0) {\n            tbody.innerHTML = '<tr><td colspan=\"6\" class=\"text-center py-4 text-muted\">Nenhuma assistência em andamento</td></tr>';\n            return;\n        }\n        \n        tbody.innerHTML = assistencias.map(a => {\n            const statusClass = a.status === 'Em andamento' ? 'warning' : 'danger';\n            const statusTexto = a.status === 'Em andamento' ? 'Em Andamento' : 'Aguardando Peças';\n            const dataEntrada = new Date(a.data_entrada).toLocaleDateString('pt-BR');\n            \n            return `\n                <tr>\n                    <td><strong>#${a.os}</strong></td>\n                    <td>${a.cliente_nome}</td>\n                    <td>${a.aparelho}</td>\n                    <td><span class=\"badge bg-${statusClass}\">${statusTexto}</span></td>\n                    <td>${dataEntrada}</td>\n                    <td class=\"text-end\">\n                        <button class=\"btn btn-sm btn-outline-primary\" onclick=\"window.location.href='/assistencia?os=${a.os}'\">\n                            Ver Detalhes\n                        </button>\n                    </td>\n                </tr>\n            `;\n        }).join('');\n    } catch (e) {\n        console.error('Erro ao carregar assistências em andamento:', e);\n        tbody.innerHTML = '<tr><td colspan=\"6\" class=\"text-center py-4 text-danger\">Erro ao carregar dados</td></tr>';\n    }\n}\n\nasync function carregarAssistenciasConcluidas() {\n    const tbody = document.getElementById('tabela-concluidas');\n    \n    try {\n        const response = await fetch('/api/assistencias?status=Concluído&limit=10');\n        const assistencias = await response.json();\n        \n        if (assistencias.length === 0) {\n            tbody.innerHTML = '<tr><td colspan=\"5\" class=\"text-center py-4 text-muted\">Nenhuma assistência concluída recentemente</td></tr>';\n            return;\n        }\n        \n        tbody.innerHTML = assistencias.map(a => {\n            const dataConclusao = a.data_saida ? new Date(a.data_saida).toLocaleDateString('pt-BR') : '-';\n            \n            return `\n                <tr>\n                    <td><strong>#${a.os}</strong></td>\n                    <td>${a.cliente_nome}</td>\n                    <td>${a.aparelho}</td>\n                    <td>${dataConclusao}</td>\n                    <td class=\"text-end\">\n                        <button class=\"btn btn-sm btn-outline-secondary\" onclick=\"window.location.href='/assistencia?os=${a.os}'\">\n                            Ver Detalhes\n                        </button>\n                    </td>\n                </tr>\n            `;\n        }).join('');\n    } catch (e) {\n        console.error('Erro ao carregar assistências concluídas:', e);\n        tbody.innerHTML = '<tr><td colspan=\"5\" class=\"text-center py-4 text-danger\">Erro ao carregar dados</td></tr>';\n    }\n}\n","size_bytes":4547},"README.md":{"content":"# Gerador de Relatórios para Lojas\n\nSistema simples para **geração e consulta de relatórios** de lojas, desenvolvido utilizando **HTML**, **CSS**, **JavaScript** e diversas APIs. O sistema permite gerar relatórios em formatos como **PDF** e **Excel**.\n\n## 🎯 Tecnologias Utilizadas\n\n- **HTML**\n- **CSS**\n- **JavaScript**\n- **APIs**:\n  - `express`: Framework para criação do servidor.\n  - `express-session`: Gerenciamento de sessões do usuário.\n  - `multer`: Upload de arquivos.\n  - `pdf-parse`: Leitura de arquivos PDF.\n  - `pdfkit`: Geração de arquivos PDF.\n  - `exceljs`: Criação de arquivos Excel.\n  - `pg`: Conexão com banco de dados PostgreSQL.\n\n## 🚀 Como Baixar e Rodar o Sistema\n\nSiga os passos abaixo para **baixar** e **rodar** o sistema localmente:\n\n### 1. Clonar o Repositório\n\nPrimeiro, clone o repositório para sua máquina local. Abra o terminal e execute o comando:\n\n```bash\ngit clone https://github.com/bggcreate/gerador-relatorios-lojas.git\n```\n### 2. Acessar o Diretório do Projeto\n\nDepois de clonado, entre no diretório do projeto:\n\n```bash\ncd gerador-relatorios-lojas\n```\n### 3. Instalar as Dependências\n\nEm seguida, instale as dependências necessárias com o comando:\n\n```bash\nnpm install\n```\n\n4. Iniciar o Servidor\n\nAgora, inicie o servidor local:\n\n```bash\nnpm start\n```\n5. Acessar o Sistema\n\nAbra o navegador e acesse o sistema localmente no seguinte endereço (ou vincule em alguma host/servidor):\n\n```bash\nhttp://localhost:3000\n```\n\n\n---\n\nAgora é só **copiar e colar**. Todo o texto está pronto para ser usado diretamente no seu repositório ou onde você precisar!\n","size_bytes":1619},"monitoramento-lojas-varejo-main/create-relatorio/server.js":{"content":"// =================================================================\n// SISTEMA DE FLUXO \n// =================================================================\nconst express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst path = require('path');\nconst session = require('express-session');\nconst fs = require('fs');\nconst PDFDocument = require('pdfkit');\nconst ExcelJS = require('exceljs');\nconst multer = require('multer');\nconst pdf = require('pdf-parse');\n\n\nconst app = express();\nconst PORT = 3000;\n\n// --- CONFIGURAÇÃO GERAL ---\nconst dataDir = path.join(__dirname, 'data');\nif (!fs.existsSync(dataDir)) {\n    fs.mkdirSync(dataDir, { recursive: true });\n}\nconst DB_PATH = path.join(dataDir, 'relatorios.db');\napp.use(express.static(path.join(__dirname, 'public')));\napp.use(express.urlencoded({ extended: true }));\napp.use(express.json());\napp.use(session({\n    secret: 'chave-definitiva-123',\n    resave: false,\n    saveUninitialized: false,\n    cookie: { httpOnly: true, maxAge: 24 * 60 * 60 * 1000 }\n}));\n\n// --- CONFIGURAÇÃO DO MULTER ---\nconst upload = multer({ storage: multer.memoryStorage() });\n\n// --- MIDDLEWARES ---\nconst requirePageLogin = (req, res, next) => {\n    if (req.session && req.session.userId) {\n        return next();\n    }\n    res.redirect('/login');\n};\nconst requireAdmin = (req, res, next) => {\n    if (req.session && req.session.role === 'admin') {\n        return next();\n    }\n    res.status(403).json({ error: 'Acesso negado.' });\n};\n\n// --- BANCO DE DADOS ---\nlet db = new sqlite3.Database(DB_PATH, err => {\n    if (err) {\n        return console.error(\"Erro fatal ao conectar ao DB:\", err.message);\n    }\n    console.log(\"Conectado ao banco de dados SQLite.\");\n    db.serialize(() => {\n        db.run(`CREATE TABLE IF NOT EXISTS usuarios (id INTEGER PRIMARY KEY AUTOINCREMENT, username TEXT UNIQUE NOT NULL, password TEXT NOT NULL, role TEXT NOT NULL)`);\n        db.run(`CREATE TABLE IF NOT EXISTS lojas (id INTEGER PRIMARY KEY AUTOINCREMENT, nome TEXT UNIQUE NOT NULL, status TEXT, funcao_especial TEXT, observacoes TEXT)`);\n        db.run(`CREATE TABLE IF NOT EXISTS relatorios (\n            id INTEGER PRIMARY KEY AUTOINCREMENT, loja TEXT, data TEXT, hora_abertura TEXT, hora_fechamento TEXT,\n            gerente_entrada TEXT, gerente_saida TEXT, clientes_monitoramento INTEGER, vendas_monitoramento INTEGER,\n            clientes_loja INTEGER, vendas_loja INTEGER, total_vendas_dinheiro REAL, ticket_medio TEXT, pa TEXT,\n            quantidade_trocas INTEGER, nome_funcao_especial TEXT, quantidade_funcao_especial INTEGER,\n            quantidade_omni INTEGER, vendedores TEXT, nome_arquivo TEXT, enviado_por_usuario TEXT,\n            enviado_em DATETIME DEFAULT CURRENT_TIMESTAMP, vendas_cartao INTEGER, vendas_pix INTEGER, vendas_dinheiro INTEGER\n        )`);\n        db.run(`CREATE TABLE IF NOT EXISTS demandas (id INTEGER PRIMARY KEY AUTOINCREMENT, loja_nome TEXT NOT NULL, descricao TEXT NOT NULL, tag TEXT DEFAULT 'Normal', status TEXT DEFAULT 'pendente', criado_por_usuario TEXT, concluido_por_usuario TEXT, criado_em DATETIME DEFAULT CURRENT_TIMESTAMP, concluido_em DATETIME)`);\n        const adminUsername = 'admin';\n        const correctPassword = 'admin';\n        db.get('SELECT * FROM usuarios WHERE username = ?', [adminUsername], (err, row) => {\n            if (err) return;\n            if (!row) {\n                db.run('INSERT INTO usuarios (username, password, role) VALUES (?, ?, ?)', [adminUsername, correctPassword, 'admin']);\n            } else if (row.password !== correctPassword) {\n                db.run('UPDATE usuarios SET password = ? WHERE username = ?', [correctPassword, adminUsername]);\n            }\n        });\n    });\n});\n\n// --- ROTAS DE PÁGINAS ---\napp.get('/login', (req, res) => res.sendFile(path.join(__dirname, 'views', 'login.html')));\napp.get('/live', requirePageLogin, (req, res) => res.sendFile(path.join(__dirname, 'views', 'live.html')));\napp.get(['/', '/admin', '/consulta', '/demandas', '/gerenciar-lojas', '/novo-relatorio', '/gerenciar-usuarios'], requirePageLogin, (req, res) => {\n    res.sendFile(path.join(__dirname, 'views', 'index.html'));\n});\napp.get('/content/:page', requirePageLogin, (req, res) => {\n    const allowedPages = ['admin', 'consulta', 'demandas', 'gerenciar-lojas', 'novo-relatorio', 'gerenciar-usuarios'];\n    if (allowedPages.includes(req.params.page)) {\n        res.sendFile(path.join(__dirname, 'views', `${req.params.page}.html`));\n    } else {\n        res.status(404).send('Página não encontrada');\n    }\n});\n\n\n// --- ROTAS DE API ---\n\n// <<<---------------------------------------------------->>>\n// <<<                    leitura PDF                     >>>\n// <<<---------------------------------------------------->>>\napp.post('/api/process-pdf', requirePageLogin, upload.single('pdfFile'), async (req, res) => {\n    if (!req.file) {\n        return res.status(400).json({ error: \"Nenhum arquivo PDF enviado.\" });\n    }\n\n    try {\n        const data = await pdf(req.file.buffer);\n        const text = data.text;\n        const lines = text.split('\\n').map(line => line.trim()).filter(Boolean);\n\n        // Função para converter valores no formato \"1.234,56\" para número\n        const parseBrazilianNumber = (str) => {\n            if (!str) return 0;\n            return parseFloat(String(str).replace(/\\./g, '').replace(',', '.'));\n        };\n\n        let extractedData;\n\n        // VERIFICA O TIPO DE PDF\n        if (text.includes(\"Desempenho de vendedores\")) {\n            // --- LÓGICA PARA PDF TIPO OMNI ---\n            console.log(\"Processando PDF estilo Omni (Desempenho de vendedores)...\");\n\n            const linhaTotais = lines.find(l => l.startsWith('Totais:'));\n            if (!linhaTotais) {\n                throw new Error(\"Linha 'Totais:' não encontrada no PDF.\");\n            }\n\n            // Extrai todos os números da linha de totais\n            const valores = linhaTotais.replace('Totais:', '').trim().split(/\\s+/);\n            \n            // Mapeia os valores\n            const vendas_loja = Math.round(parseBrazilianNumber(valores[1])); // Total de Vendas\n            const pa = parseBrazilianNumber(valores[2]); // Peças/Venda\n            const total_vendas_dinheiro = parseBrazilianNumber(valores[3]); // Vl. Vendas\n            const ticket_medio = parseBrazilianNumber(valores[4]); // Ticket Médio\n            const clientes_loja = parseInt(valores[5], 10); // Abordagens\n\n            // Extrai dados \n            const storeNameMatch = text.match(/(\\d{1,}-\\d{6}-.+)/);\n            const storeName = storeNameMatch ? storeNameMatch[1].trim() : \"Loja não identificada\";\n            \n            const dateMatch = text.match(/Período: (\\d{2}\\/\\d{2}\\/\\d{4})/);\n            const reportDate = dateMatch ? new Date(dateMatch[1].split('/').reverse().join('-')).toISOString().split('T')[0] : null;\n\n            const vendorLines = lines.filter(line => line.match(/^\\d+\\s+.+\\s+\\(\\d+\\)/));\n            const vendedores = vendorLines.map(line => {\n                const nameMatch = line.match(/^\\d+\\s+(.*?)\\s+\\(\\d+\\)/);\n                const nome = nameMatch ? nameMatch[1].trim() : \"Desconhecido\";\n                \n                const statsPart = line.replace(nameMatch[0], '').trim();\n                const stats = statsPart.split(/\\s+/);\n                \n                const vendas = Math.round(parseBrazilianNumber(stats[1]));\n                const atendimentos = parseInt(stats[5], 10) || 0;\n                \n                return { nome, vendas, atendimentos };\n            });\n\n            extractedData = {\n                loja: storeName,\n                data: reportDate,\n                clientes_loja: clientes_loja,\n                vendas_loja: vendas_loja,\n                total_vendas_dinheiro: `R$ ${total_vendas_dinheiro.toFixed(2).replace('.', ',')}`,\n                ticket_medio: `R$ ${ticket_medio.toFixed(2).replace('.', ',')}`,\n                pa: pa.toFixed(2).replace('.', ','),\n                vendedores: vendedores\n            };\n\n        } else {\n            // --- LÓGICA PARA PDF TIPO BUSCA TÉCNICA ---\n            console.log(\"Processando PDF estilo Busca Técnica...\");\n            \n            const linhaTotais = lines.find(l => l.includes('Totais:'));\n            const idxTotais = lines.indexOf(linhaTotais);\n            const linhaDados = lines[idxTotais + 1] || '';\n            const linhaLimpa = linhaDados.replace(/(\\d{1,3})\\.(\\d{3},\\d{2})/g, '$1.$2 ').replace(/ +/g, ' ').trim();\n            const valoresTotais = linhaLimpa.match(/(\\d{1,3}(?:\\.\\d{3})*,\\d{2})|(\\d+\\.\\d{2})|(\\d+)/g);\n            \n            if (!valoresTotais || valoresTotais.length < 7) {\n                throw new Error(\"Não foi possível extrair os valores corretamente da linha Totais do PDF.\");\n            }\n            \n            const totalVendasValor = parseBrazilianNumber(valoresTotais[0]);\n            const pa = parseBrazilianNumber(valoresTotais[valoresTotais.length - 4]);\n            const ticketMedio = parseBrazilianNumber(valoresTotais[valoresTotais.length - 3]);\n            \n            const linhaSplitada = linhaLimpa.split(' ');\n            const indexDoValorTotal = linhaSplitada.findIndex(v => v.includes(valoresTotais[0]));\n            const totalAtendimentos = parseInt(linhaSplitada[indexDoValorTotal + 2], 10) || 0;\n            \n            const storeNameMatch = text.match(/^\\s*\\d{3}\\s*-\\s*(.+)/m);\n            const storeName = storeNameMatch ? storeNameMatch[1].trim().replace(/\\s+STORE$/, \"\") : \"Loja não identificada\";\n            \n            const dateMatch = text.match(/Período de (\\d{2}\\/\\d{2}\\/\\d{4}) a (\\d{2}\\/\\d{2}\\/\\d{4})/);\n            const reportDate = dateMatch ? new Date(dateMatch[1].split('/').reverse().join('-')).toISOString().split('T')[0] : null;\n\n            const vendorLines = lines.filter(line => /^\\d+º/.test(line));\n            const vendedores = vendorLines.map(line => {\n                const vendorParts = line.trim().split(/\\s+/);\n                const nome = vendorParts.slice(2, -7).join(' ');\n                const atendimentos = parseInt(vendorParts[vendorParts.length - 4], 10) || 0;\n                return { nome, vendas: atendimentos, atendimentos };\n            });\n\n            extractedData = {\n                loja: storeName,\n                data: reportDate,\n                clientes_loja: totalAtendimentos,\n                vendas_loja: totalAtendimentos,\n                total_vendas_dinheiro: `R$ ${totalVendasValor.toFixed(2).replace('.', ',')}`,\n                ticket_medio: `R$ ${ticketMedio.toFixed(2).replace('.', ',')}`,\n                pa: pa.toFixed(2).replace('.', ','),\n                vendedores: vendedores\n            };\n        }\n\n        res.json({ success: true, data: extractedData });\n\n    } catch (error) {\n        console.error(\"### ERRO NO PROCESSAMENTO DO PDF ###\", error);\n        res.status(500).json({ error: error.message || \"Erro ao processar o PDF.\" });\n    }\n});\n// <<<---------------------------------------------------->>>\n// <<<          FIM DA API DE PDF                         >>>\n// <<<---------------------------------------------------->>>\n\n\n// APIs DE SESSÃO E USUÁRIOS \napp.post('/api/login', (req, res) => { const { username, password } = req.body; db.get('SELECT * FROM usuarios WHERE username = ? AND password = ?', [username, password], (err, user) => { if (err || !user) return res.status(401).json({ message: 'Credenciais inválidas.' }); req.session.userId = user.id; req.session.username = user.username; req.session.role = user.role; res.json({ success: true }); }); });\napp.get('/logout', (req, res) => { req.session.destroy(() => res.redirect('/login')); });\napp.get('/api/session-info', requirePageLogin, (req, res) => { res.json({ id: req.session.userId, username: req.session.username, role: req.session.role }); });\napp.get('/api/usuarios', requirePageLogin, requireAdmin, (req, res) => { db.all(\"SELECT id, username, role FROM usuarios ORDER BY username\", (err, users) => { if (err) return res.status(500).json({ error: err.message }); res.json(users || []); }); });\napp.post('/api/usuarios', requirePageLogin, requireAdmin, (req, res) => { const { username, password, role } = req.body; if (!username || !password || !role) return res.status(400).json({ error: 'Todos os campos são obrigatórios.' }); db.run('INSERT INTO usuarios (username, password, role) VALUES (?, ?, ?)', [username, password, role], function (err) { if (err) return res.status(500).json({ error: 'Erro ao criar usuário. O nome de usuário já pode existir.' }); res.status(201).json({ success: true, id: this.lastID }); }); });\napp.put('/api/usuarios/:id', requirePageLogin, requireAdmin, (req, res) => { const { id } = req.params; const { username, password, role } = req.body; if (!username || !role) return res.status(400).json({ error: 'Username e Cargo são obrigatórios.' }); const sql = password ? 'UPDATE usuarios SET username = ?, password = ?, role = ? WHERE id = ?' : 'UPDATE usuarios SET username = ?, role = ? WHERE id = ?'; const params = password ? [username, password, role, id] : [username, role, id]; db.run(sql, params, function (err) { if (err) return res.status(500).json({ error: 'Erro ao atualizar usuário.' }); res.json({ success: true }); }); });\napp.delete('/api/usuarios/:id', requirePageLogin, requireAdmin, (req, res) => { const { id } = req.params; if (id == req.session.userId) return res.status(403).json({ error: 'Não é permitido excluir o próprio usuário logado.' }); db.run(\"DELETE FROM usuarios WHERE id = ?\", [id], function (err) { if (err) return res.status(500).json({ error: 'Erro ao excluir usuário.' }); if (this.changes === 0) return res.status(404).json({ error: \"Usuário não encontrado.\" }); res.json({ success: true }); }); });\n\n// APIs DE LOJAS \napp.get('/api/lojas', requirePageLogin, (req, res) => { let query = \"SELECT * FROM lojas\"; const params = []; if (req.query.status) { query += \" WHERE status = ?\"; params.push(req.query.status); } query += \" ORDER BY nome\"; db.all(query, params, (err, lojas) => { if (err) return res.status(500).json({ error: err.message }); res.json(lojas || []); }); });\napp.post('/api/lojas', requirePageLogin, (req, res) => { const { nome, status, funcao_especial, observacoes } = req.body; db.run('INSERT INTO lojas (nome, status, funcao_especial, observacoes) VALUES (?, ?, ?, ?)', [nome, status, funcao_especial, observacoes], function (err) { if (err) return res.status(500).json({ error: 'Erro ao criar loja. O nome já pode existir.' }); res.status(201).json({ success: true, id: this.lastID }); }); });\napp.put('/api/lojas/:id', requirePageLogin, (req, res) => { const { id } = req.params; const { nome, status, funcao_especial, observacoes } = req.body; db.run('UPDATE lojas SET nome = ?, status = ?, funcao_especial = ?, observacoes = ? WHERE id = ?', [nome, status, funcao_especial, observacoes, id], function (err) { if (err) return res.status(500).json({ error: 'Erro ao atualizar loja.' }); res.json({ success: true }); }); });\napp.delete('/api/lojas/:id', requirePageLogin, (req, res) => { db.run(\"DELETE FROM lojas WHERE id = ?\", [req.params.id], function (err) { if (err) return res.status(500).json({ error: 'Erro ao excluir loja.' }); if (this.changes === 0) return res.status(404).json({ error: \"Loja não encontrada.\" }); res.json({ success: true }); }); });\n\n// APIs DE RELATÓRIOS\nconst processarRelatorio = (r) => { if (!r) return null; const vendas_monitoramento_total = (parseInt(r.vendas_monitoramento, 10) || 0) + (parseInt(r.quantidade_omni, 10) || 0); const tx_conversao_monitoramento = (parseInt(r.clientes_monitoramento, 10) || 0) > 0 ? (vendas_monitoramento_total / r.clientes_monitoramento) * 100 : 0; const tx_conversao_loja = (parseInt(r.clientes_loja, 10) || 0) > 0 ? ((parseInt(r.vendas_loja, 10) || 0) / r.clientes_loja) * 100 : 0; let vendedores_processados = []; try { const vendedores = JSON.parse(r.vendedores || '[]'); vendedores_processados = vendedores.map(v => ({ ...v, tx_conversao: (v.atendimentos > 0 ? ((v.vendas / v.atendimentos) * 100) : 0).toFixed(2) })); } catch (e) {} return { ...r, vendas_monitoramento_total, tx_conversao_monitoramento: tx_conversao_monitoramento.toFixed(2), tx_conversao_loja: tx_conversao_loja.toFixed(2), vendedores_processados }; };\napp.get('/api/relatorios', requirePageLogin, (req, res) => { const whereClauses = []; const params = []; if (req.query.loja) { whereClauses.push(\"loja = ?\"); params.push(req.query.loja); } if (req.query.data_inicio) { whereClauses.push(\"data >= ?\"); params.push(req.query.data_inicio); } if (req.query.data_fim) { whereClauses.push(\"data <= ?\"); params.push(req.query.data_fim); } const whereString = whereClauses.length > 0 ? \" WHERE \" + whereClauses.join(\" AND \") : \"\"; const sortOrder = req.query.sortOrder === 'asc' ? 'ASC' : 'DESC'; db.get(`SELECT COUNT(*) as total FROM relatorios` + whereString, params, (err, row) => { if (err) return res.status(500).json({ error: err.message }); const total = row ? row.total : 0; const limit = parseInt(req.query.limit) || 20; const offset = parseInt(req.query.offset) || 0; const query = `SELECT id, loja, data, total_vendas_dinheiro FROM relatorios` + whereString + ` ORDER BY id ${sortOrder} LIMIT ? OFFSET ?`; db.all(query, [...params, limit, offset], (err, relatorios) => { if (err) return res.status(500).json({ error: err.message }); res.json({ relatorios: relatorios || [], total }); }); }); });\napp.post('/api/relatorios', requirePageLogin, (req, res) => { const d = req.body; const sql = `INSERT INTO relatorios (loja, data, hora_abertura, hora_fechamento, gerente_entrada, gerente_saida, clientes_monitoramento, vendas_monitoramento, clientes_loja, vendas_loja, total_vendas_dinheiro, ticket_medio, pa, quantidade_trocas, quantidade_omni, quantidade_funcao_especial, vendedores, enviado_por_usuario, vendas_cartao, vendas_pix, vendas_dinheiro) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)`; const params = [ d.loja, d.data, d.hora_abertura, d.hora_fechamento, d.gerente_entrada, d.gerente_saida, parseInt(d.clientes_monitoramento, 10) || 0, parseInt(d.vendas_monitoramento, 10) || 0, parseInt(d.clientes_loja, 10) || 0, parseInt(d.vendas_loja, 10) || 0, parseFloat(String(d.total_vendas_dinheiro).replace(/[R$\\s.]/g, '').replace(',', '.')) || 0, d.ticket_medio || 'R$ 0,00', d.pa || '0.00', parseInt(d.quantidade_trocas, 10) || 0, parseInt(d.quantidade_omni, 10) || 0, parseInt(d.quantidade_funcao_especial, 10) || 0, d.vendedores || '[]', req.session.username, parseInt(d.vendas_cartao, 10) || 0, parseInt(d.vendas_pix, 10) || 0, parseInt(d.vendas_dinheiro, 10) || 0 ]; db.run(sql, params, function (err) { if (err) { console.error(\"Erro ao inserir relatório:\", err.message); return res.status(500).json({ error: 'Falha ao salvar relatório.' }); } res.status(201).json({ success: true, id: this.lastID }); }); });\napp.get('/api/relatorios/:id', requirePageLogin, (req, res) => { db.get(\"SELECT * FROM relatorios WHERE id = ?\", [req.params.id], (err, relatorio) => { if (err) return res.status(500).json({ error: err.message }); if (!relatorio) return res.status(404).json({ error: \"Relatório não encontrado\" }); res.json({ relatorio }); }); });\napp.put('/api/relatorios/:id', requirePageLogin, (req, res) => { const { id } = req.params; const d = req.body; const sql = `UPDATE relatorios SET loja=?, data=?, hora_abertura=?, hora_fechamento=?, gerente_entrada=?, gerente_saida=?, clientes_monitoramento=?, vendas_monitoramento=?, clientes_loja=?, vendas_loja=?, total_vendas_dinheiro=?, ticket_medio=?, pa=?, quantidade_trocas=?, quantidade_omni=?, quantidade_funcao_especial=?, vendedores=?, vendas_cartao=?, vendas_pix=?, vendas_dinheiro=? WHERE id=?`; const params = [ d.loja, d.data, d.hora_abertura, d.hora_fechamento, d.gerente_entrada, d.gerente_saida, parseInt(d.clientes_monitoramento, 10) || 0, parseInt(d.vendas_monitoramento, 10) || 0, parseInt(d.clientes_loja, 10) || 0, parseInt(d.vendas_loja, 10) || 0, parseFloat(String(d.total_vendas_dinheiro).replace(/[R$\\s.]/g, '').replace(',', '.')) || 0, d.ticket_medio || 'R$ 0,00', d.pa || '0.00', parseInt(d.quantidade_trocas, 10) || 0, parseInt(d.quantidade_omni, 10) || 0, parseInt(d.quantidade_funcao_especial, 10) || 0, d.vendedores || '[]', parseInt(d.vendas_cartao, 10) || 0, parseInt(d.vendas_pix, 10) || 0, parseInt(d.vendas_dinheiro, 10) || 0, id ]; db.run(sql, params, function (err) { if (err) { console.error(\"Erro ao atualizar relatório:\", err.message); return res.status(500).json({ error: 'Falha ao atualizar o relatório.' }); } if (this.changes === 0) return res.status(404).json({ error: \"Relatório não encontrado.\" }); res.json({ success: true, id: id }); }); });\napp.delete('/api/relatorios/:id', requirePageLogin, (req, res) => { db.run(\"DELETE FROM relatorios WHERE id = ?\", [req.params.id], function (err) { if (err) return res.status(500).json({ error: err.message }); if (this.changes === 0) return res.status(404).json({ error: \"Relatório não encontrado\" }); res.json({ success: true, message: \"Relatório excluído.\" }); }); });\nconst formatCurrency = (value) => { const numberValue = Number(value) || 0; return new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(numberValue); };\nconst formatarRelatorioTexto = (r) => { const rp = processarRelatorio(r); if (!rp) return \"Erro ao processar relatório.\"; let equipeInfo = 'Nenhum vendedor registrado.\\n'; if (rp.vendedores_processados && rp.vendedores_processados.length > 0) { equipeInfo = rp.vendedores_processados.map(v => { return `${v.nome}: ${v.atendimentos} Atendimentos / ${v.vendas} Vendas / ${v.tx_conversao}%`; }).join('\\n'); } let funcaoEspecialInfo = ''; if (rp.funcao_especial === \"Omni\") { funcaoEspecialInfo = `Omni: ${rp.quantidade_omni || 0}\\n`; } else if (rp.funcao_especial === \"Busca por Assist. Tec.\") { funcaoEspecialInfo = `Busca por assist tec: ${rp.quantidade_funcao_especial || 0}\\n`; } const totalVendasQuantidade = (rp.vendas_cartao || 0) + (rp.vendas_pix || 0) + (rp.vendas_dinheiro || 0); const content = ` DATA: ${new Date(rp.data).toLocaleDateString('pt-BR', { timeZone: 'UTC' })} \\n\\nClientes: ${rp.clientes_monitoramento || 0}\\nBluve: ${rp.clientes_loja || 0}\\nVendas / Monitoramento: ${rp.vendas_monitoramento_total || 0}\\nVendas / Loja: ${rp.vendas_loja || 0}\\nTaxa de conversão da loja: ${rp.tx_conversao_loja || '0.00'}%\\nTaxa de conversão do monitoramento: ${rp.tx_conversao_monitoramento || '0.00'}%\\n\\nAbertura: ${rp.hora_abertura || '--:--'} - ${rp.hora_fechamento || '--:--'}\\nGerente: ${rp.gerente_entrada || '--:--'} - ${rp.gerente_saida || '--:--'}\\nVendas em Cartão: ${rp.vendas_cartao || 0}\\nVendas em Pix: ${rp.vendas_pix || 0}\\nVendas em Dinheiro: ${rp.vendas_dinheiro || 0}\\n${funcaoEspecialInfo}Total vendas: ${totalVendasQuantidade}\\nTroca/Devolução: ${rp.quantidade_trocas || 0}\\n\\nDesempenho Equipe:\\n\\n${equipeInfo}\\n\\nTM: ${rp.ticket_medio || 'R$ 0,00'} / P.A: ${rp.pa || '0.00'} / Total: ${formatCurrency(rp.total_vendas_dinheiro)} / `; return content.trim(); };\napp.get('/api/relatorios/:id/txt', requirePageLogin, (req, res) => { const sql = ` SELECT r.*, l.funcao_especial FROM relatorios r LEFT JOIN lojas l ON r.loja = l.nome WHERE r.id = ? `; db.get(sql, [req.params.id], (err, r) => { if (err || !r) return res.status(404).send('Relatório não encontrado'); res.setHeader('Content-disposition', `attachment; filename=relatorio_${r.loja.replace(/ /g, '_')}_${r.data}.txt`); res.setHeader('Content-type', 'text/plain; charset=utf-8'); res.send(formatarRelatorioTexto(r)); }); });\napp.get('/api/relatorios/:id/pdf', requirePageLogin, (req, res) => { const sql = ` SELECT r.*, l.funcao_especial FROM relatorios r LEFT JOIN lojas l ON r.loja = l.nome WHERE r.id = ? `; db.get(sql, [req.params.id], (err, r) => { if (err || !r) return res.status(404).send('Relatório não encontrado'); const doc = new PDFDocument({ margin: 50, size: 'A4' }); res.setHeader('Content-disposition', `inline; filename=\"relatorio_${r.loja.replace(/ /g, '_')}_${r.data}.pdf\"`); res.setHeader('Content-type', 'application/pdf'); doc.pipe(res); doc.fontSize(18).font('Helvetica-Bold').text(r.loja.toUpperCase(), { align: 'center' }).moveDown(1); doc.fontSize(11).font('Helvetica').text(formatarRelatorioTexto(r), { align: 'left' }); doc.end(); }); });\n\n\n// ROTA DE EXPORTAÇÃO PARA EXCEL \napp.get('/api/export/excel', requirePageLogin, async (req, res) => { const { month, year } = req.query; if (!month || !year) { return res.status(400).json({ error: 'Mês e ano são obrigatórios.' }); } const monthFormatted = month.toString().padStart(2, '0'); const sql = ` SELECT r.*, l.funcao_especial FROM relatorios r LEFT JOIN lojas l ON r.loja = l.nome WHERE strftime('%Y-%m', r.data) = ? ORDER BY r.loja, r.data `; db.all(sql, [`${year}-${monthFormatted}`], async (err, rows) => { if (err) { console.error(\"Erro ao buscar relatórios para Excel:\", err); return res.status(500).json({ error: 'Erro ao buscar relatórios.' }); } if (rows.length === 0) { return res.status(404).json({ error: 'Nenhum relatório encontrado para o período.' }); } const workbook = new ExcelJS.Workbook(); const safeParseFloat = (value) => { if (typeof value === 'number') { return value; } if (typeof value === 'string') { const cleaned = value.replace(/[R$\\s]/g, '').replace(/\\./g, '').replace(',', '.'); const num = parseFloat(cleaned); return isNaN(num) ? 0 : num; } return 0; }; const relatoriosPorLoja = rows.reduce((acc, row) => { const loja = row.loja; if (!acc[loja]) { acc[loja] = { funcao_especial: row.funcao_especial || 'Não definido', relatorios: [] }; } acc[loja].relatorios.push(processarRelatorio(row)); return acc; }, {}); for (const lojaNome in relatoriosPorLoja) { const lojaData = relatoriosPorLoja[lojaNome]; const worksheet = workbook.addWorksheet(lojaNome.substring(0, 30)); worksheet.mergeCells('A1:M1'); const tituloCell = worksheet.getCell('A1'); tituloCell.value = lojaNome.toUpperCase(); tituloCell.font = { name: 'Arial Black', size: 16, bold: true, color: { argb: 'FF44546A' } }; tituloCell.alignment = { vertical: 'middle', horizontal: 'center' }; worksheet.getRow(1).height = 30; const headers = [ 'DATA', 'BLUVE', 'VENDAS (L)', 'TX DE CONVERSÃO (L)', 'CLIENTES (M)', 'VENDAS (M)', 'TX DE CONVERSÃO (M)', 'P.A', 'TM', 'VALOR TOTAL', 'TROCAS' ]; let funcaoEspecialHeader = 'FUNÇÃO ESPECIAL'; if (lojaData.funcao_especial === 'Omni') { funcaoEspecialHeader = 'OMNI'; } else if (lojaData.funcao_especial === 'Busca por Assist. Tec.') { funcaoEspecialHeader = 'BUSCA P/ ASSIST. TEC.'; } headers.push(funcaoEspecialHeader); headers.push('ENVIADO POR'); const headerRow = worksheet.getRow(3); headerRow.values = headers; headerRow.height = 35; headerRow.eachCell(cell => { cell.font = { bold: true, color: { argb: 'FFFFFFFF' }, size: 10 }; cell.alignment = { vertical: 'middle', horizontal: 'center', wrapText: true }; cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF4472C4' } }; cell.border = { top: { style: 'thin', color: { argb: 'FFBFBFBF' } }, left: { style: 'thin', color: { argb: 'FFBFBFBF' } }, bottom: { style: 'thin', color: { argb: 'FFBFBFBF' } }, right: { style: 'thin', color: { argb: 'FFBFBFBF' } } }; }); lojaData.relatorios.forEach(r => { const rowData = [ new Date(r.data + 'T00:00:00'), parseInt(r.clientes_loja, 10) || 0, parseInt(r.vendas_loja, 10) || 0, parseFloat(r.tx_conversao_loja) / 100, parseInt(r.clientes_monitoramento, 10) || 0, parseInt(r.vendas_monitoramento_total, 10) || 0, parseFloat(r.tx_conversao_monitoramento) / 100, parseFloat(String(r.pa).replace(',', '.')) || 0, safeParseFloat(r.ticket_medio), r.total_vendas_dinheiro, parseInt(r.quantidade_trocas, 10) || 0 ]; if (lojaData.funcao_especial === 'Omni') { rowData.push(parseInt(r.quantidade_omni, 10) || 0); } else if (lojaData.funcao_especial === 'Busca por Assist. Tec.') { rowData.push(parseInt(r.quantidade_funcao_especial, 10) || 0); } else { rowData.push(0); } rowData.push(r.enviado_por_usuario || '-'); const row = worksheet.addRow(rowData); row.getCell(1).numFmt = 'DD/MM/YYYY'; row.getCell(4).numFmt = '0.00%'; row.getCell(7).numFmt = '0.00%'; row.getCell(8).numFmt = '0.00'; row.getCell(9).numFmt = 'R$ #,##0.00'; row.getCell(10).numFmt = 'R$ #,##0.00'; row.eachCell(cell => { cell.alignment = { vertical: 'middle', horizontal: 'center' }; }); }); worksheet.columns.forEach(column => { let maxLength = 0; column.eachCell({ includeEmpty: true }, cell => { const length = cell.value ? cell.value.toString().length : 10; if (length > maxLength) { maxLength = length; } }); column.width = Math.max(12, maxLength + 3); }); worksheet.getColumn(4).width = 20; worksheet.getColumn(7).width = 20; worksheet.getColumn(12).width = 22; } res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'); res.setHeader('Content-Disposition', `attachment; filename=\"Relatorios_${year}-${monthFormatted}.xlsx\"`); await workbook.xlsx.write(res); res.end(); }); });\n\n// APIs DE DASHBOARD, DEMANDAS, BACKUP E RESTORE \napp.get('/api/dashboard-data', requirePageLogin, (req, res) => { let whereClauses = []; let params = []; if (req.query.loja && req.query.loja !== 'todas') { whereClauses.push('loja = ?'); params.push(req.query.loja); } if (req.query.data_inicio) { whereClauses.push('data >= ?'); params.push(req.query.data_inicio); } if (req.query.data_fim) { whereClauses.push('data <= ?'); params.push(req.query.data_fim); } const whereString = whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : ''; const sql = `SELECT COALESCE(SUM(clientes_monitoramento),0) as total_clientes_monitoramento, COALESCE(SUM(vendas_monitoramento),0) as total_vendas_monitoramento, COALESCE(SUM(clientes_loja),0) as total_clientes_loja, COALESCE(SUM(vendas_loja),0) as total_vendas_loja, COALESCE(SUM(quantidade_omni),0) as total_omni FROM relatorios ${whereString}`; db.get(sql, params, (err, row) => { if (err) return res.status(500).json({ error: err.message }); const vendas_m_total = (row.total_vendas_monitoramento || 0) + (row.total_omni || 0); res.json({ ...row, tx_conversao_monitoramento: (row.total_clientes_monitoramento > 0 ? (vendas_m_total / row.total_clientes_monitoramento) * 100 : 0), tx_conversao_loja: (row.total_clientes_loja > 0 ? (row.total_vendas_loja / row.total_clientes_loja) * 100 : 0) }); }); });\napp.get('/api/ranking', requirePageLogin, (req, res) => { let whereClauses = []; let params = []; if (req.query.data_inicio) { whereClauses.push('r.data >= ?'); params.push(req.query.data_inicio); } if (req.query.data_fim) { whereClauses.push('r.data <= ?'); params.push(req.query.data_fim); } const joinCondition = whereClauses.length > 0 ? `AND ${whereClauses.join(' AND ')}` : ''; const sql = `SELECT l.nome as loja, COALESCE(SUM(r.clientes_loja), 0) as total_clientes_loja, COALESCE(SUM(r.vendas_loja), 0) as total_vendas_loja, COALESCE(SUM(r.clientes_monitoramento), 0) as total_clientes_monitoramento, COALESCE(SUM(r.vendas_monitoramento), 0) as total_vendas_monitoramento, COALESCE(SUM(r.quantidade_omni), 0) as total_omni FROM lojas l LEFT JOIN relatorios r ON l.nome = r.loja ${joinCondition} WHERE l.status = 'ativa' GROUP BY l.nome`; db.all(sql, params, (err, rows) => { if (err) return res.status(500).json({ error: err.message }); const ranking = rows.map(r => { const vendas_m_total = (r.total_vendas_monitoramento || 0) + (r.total_omni || 0); return { ...r, tx_loja: (r.total_clientes_loja > 0 ? (r.total_vendas_loja / r.total_clientes_loja) * 100 : 0), tx_monitoramento: (r.total_clientes_monitoramento > 0 ? (vendas_m_total / r.total_clientes_monitoramento) * 100 : 0) } }); res.json(ranking); }); });\napp.get('/api/dashboard/chart-data', requirePageLogin, (req, res) => { const { loja, data_inicio, data_fim } = req.query; let whereClauses = []; let params = []; if (loja && loja !== 'todas') { whereClauses.push('loja = ?'); params.push(loja); } if (data_inicio) { whereClauses.push('data >= ?'); params.push(data_inicio); } if (data_fim) { whereClauses.push('data <= ?'); params.push(data_fim); } if (whereClauses.length === 0) { const date = new Date(); date.setDate(date.getDate() - 30); const startDate = date.toISOString().slice(0, 10); whereClauses.push('data >= ?'); params.push(startDate); } const whereString = `WHERE ${whereClauses.join(' AND ')}`; const sql = `SELECT data, SUM(clientes_loja) as total_clientes_loja, SUM(vendas_loja) as total_vendas_loja, SUM(clientes_monitoramento) as total_clientes_monitoramento, SUM(vendas_monitoramento) as total_vendas_monitoramento, SUM(quantidade_omni) as total_omni FROM relatorios ${whereString} GROUP BY data ORDER BY data ASC`; db.all(sql, params, (err, rows) => { if (err) return res.status(500).json({ error: 'Erro ao buscar dados para o gráfico.' }); const labels = []; const txConversaoLoja = []; const txConversaoMonitoramento = []; rows.forEach(row => { labels.push(new Date(row.data).toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', timeZone: 'UTC' })); const vendas_m_total = (row.total_vendas_monitoramento || 0) + (row.total_omni || 0); const tx_m = row.total_clientes_monitoramento > 0 ? (vendas_m_total / row.total_clientes_monitoramento) * 100 : 0; const tx_l = row.total_clientes_loja > 0 ? (row.total_vendas_loja / row.total_clientes_loja) * 100 : 0; txConversaoLoja.push(tx_l.toFixed(2)); txConversaoMonitoramento.push(tx_m.toFixed(2)); }); res.json({ labels, txConversaoLoja, txConversaoMonitoramento }); }); });\napp.post('/api/demandas', requirePageLogin, (req, res) => { const { loja_nome, descricao, tag } = req.body; db.run('INSERT INTO demandas (loja_nome, descricao, tag, criado_por_usuario) VALUES (?, ?, ?, ?)', [loja_nome, descricao, tag, req.session.username], function (err) { if (err) return res.status(500).json({ error: 'Falha ao salvar demanda.' }); res.status(201).json({ success: true, id: this.lastID }); }); });\napp.get('/api/demandas/:status', requirePageLogin, (req, res) => { const status = req.params.status === 'pendentes' ? 'pendente' : 'concluido'; db.all(`SELECT * FROM demandas WHERE status = ? ORDER BY criado_em DESC`, [status], (err, demandas) => { if (err) return res.status(500).json({ error: err.message }); res.json(demandas || []); }); });\napp.put('/api/demandas/:id/concluir', requirePageLogin, (req, res) => { db.run(\"UPDATE demandas SET status = 'concluido', concluido_por_usuario = ?, concluido_em = CURRENT_TIMESTAMP WHERE id = ?\", [req.session.username, req.params.id], function (err) { if (err) return res.status(500).json({ error: 'Erro ao concluir demanda.' }); if (this.changes === 0) return res.status(404).json({ error: 'Demanda não encontrada.' }); res.json({ success: true }); }); });\napp.delete('/api/demandas/:id', requirePageLogin, (req, res) => { db.run(\"DELETE FROM demandas WHERE id = ?\", [req.params.id], function (err) { if (err) return res.status(500).json({ error: 'Erro ao excluir demanda.' }); if (this.changes === 0) return res.status(404).json({ error: \"Demanda não encontrada.\" }); res.json({ success: true }); }); });\napp.get('/api/backup/info', requirePageLogin, requireAdmin, (req, res) => {\n    try {\n        const stats = fs.statSync(DB_PATH);\n        const sizeMB = (stats.size / (1024 * 1024)).toFixed(2);\n        res.json({ sizeMB });\n    } catch (error) {\n        console.error(\"Erro ao obter informações do backup:\", error);\n        res.status(500).json({ error: 'Não foi possível obter informações do banco de dados.' });\n    }\n});\n\n// API para limpar tabelas específicas do banco de dados\napp.delete('/api/backup/clear', requirePageLogin, requireAdmin, (req, res) => {\n    db.serialize(() => {\n        db.run(\"DELETE FROM relatorios\", (err) => {\n            if (err) return res.status(500).json({ error: 'Erro ao limpar relatórios.' });\n        });\n        db.run(\"DELETE FROM demandas\", (err) => {\n            if (err) return res.status(500).json({ error: 'Erro ao limpar demandas.' });\n        });\n        res.json({ success: true, message: 'Relatórios e demandas foram limpos.' });\n    });\n});\napp.get('/api/backup/download', requirePageLogin, requireAdmin, (req, res) => { const date = new Date().toISOString().slice(0, 10); const fileName = `backup_reports_${date}.db`; res.download(DB_PATH, fileName, (err) => { if (err && !res.headersSent) { res.status(500).send(\"Não foi possível baixar o arquivo de backup.\"); } }); });\napp.post('/api/backup/restore', requirePageLogin, requireAdmin, upload.single('backupFile'), (req, res) => { if (!req.file) { return res.status(400).json({ error: \"Nenhum arquivo de backup foi enviado.\" }); } const backupBuffer = req.file.buffer; db.close((err) => { if (err) { console.error(\"Erro ao fechar o DB antes de restaurar:\", err.message); return res.status(500).json({ error: \"Não foi possível fechar a conexão com o banco de dados atual.\" }); } fs.writeFile(DB_PATH, backupBuffer, (err) => { if (err) { console.error(\"Falha ao escrever o arquivo de backup:\", err.message); db = new sqlite3.Database(DB_PATH); return res.status(500).json({ error: \"Falha ao substituir o arquivo de banco de dados.\" }); } db = new sqlite3.Database(DB_PATH, (err) => { if (err) { console.error(\"DB restaurado, mas falha ao reconectar:\", err.message); return res.status(500).json({ error: \"Banco de dados restaurado, mas falha ao reconectar. Reinicie o servidor.\" }); } console.log(\"Banco de dados restaurado e reconectado com sucesso.\"); res.json({ success: true, message: \"Banco de dados restaurado com sucesso. A página será recarregada.\" }); }); }); }); });\napp.get(\"/api/export/excel-all\", requirePageLogin, async (req, res) => {\n  try {\n    const ExcelJS = require(\"exceljs\");\n\n    const relatorios = await new Promise((resolve, reject) => {\n      db.all(\"SELECT * FROM relatorios ORDER BY data DESC\", (err, rows) => {\n        if (err) reject(err);\n        else resolve(rows);\n      });\n    });\n\n    if (!relatorios.length) {\n      return res.status(404).json({ error: \"Nenhum relatório encontrado.\" });\n    }\n\n    const workbook = new ExcelJS.Workbook();\n    const ws = workbook.addWorksheet(\"Relatórios\");\n\n    ws.columns = [\n      { header: \"ID\", key: \"id\", width: 8 },\n      { header: \"Loja\", key: \"loja\", width: 25 },\n      { header: \"Data\", key: \"data\", width: 15 },\n      { header: \"Total (R$)\", key: \"total_vendas\", width: 15 },\n      { header: \"Atendimentos\", key: \"atendimentos\", width: 15 },\n      { header: \"Taxa Conversão\", key: \"taxa_conversao\", width: 15 },\n    ];\n\n    relatorios.forEach(r => ws.addRow(r));\n\n    res.setHeader(\"Content-Type\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\");\n    res.setHeader(\"Content-Disposition\", \"attachment; filename=Relatorios_Completos.xlsx\");\n\n    await workbook.xlsx.write(res);\n    res.end();\n  } catch (error) {\n    console.error(\"Erro ao exportar todos os relatórios:\", error);\n    res.status(500).json({ error: \"Falha ao gerar o arquivo Excel.\" });\n  }\n});\n// =================================================================\n// INICIALIZAÇÃO DO SERVIDOR\n// =================================================================\napp.listen(PORT, () => console.log(`Servidor rodando em http://localhost:${PORT}`));","size_bytes":39189},"public/js/utils.js":{"content":"/**\n * Exibe uma notificação toast no canto da tela.\n * @param {string} title Título do toast.\n * @param {string} message Mensagem do corpo do toast.\n * @param {'success'|'danger'|'info'} type O tipo de notificação (muda a cor).\n */\nexport function showToast(title, message, type = 'success') {\n    const toastEl = document.getElementById('notificationToast');\n    if (!toastEl) return;\n    const toastHeader = toastEl.querySelector('.toast-header');\n    const toastTitle = document.getElementById('toast-title');\n    const toastBody = document.getElementById('toast-body');\n\n    toastTitle.textContent = title;\n    toastBody.textContent = message;\n\n    toastHeader.classList.remove('bg-success', 'bg-danger', 'bg-info');\n    if (type === 'success') toastHeader.classList.add('bg-success');\n    else if (type === 'danger') toastHeader.classList.add('bg-danger');\n    else toastHeader.classList.add('bg-info');\n\n    const toast = new bootstrap.Toast(toastEl);\n    toast.show();\n}\n\n/**\n * Exibe um modal de confirmação e retorna uma Promise que resolve como true ou false.\n * @param {string} message A pergunta a ser exibida no modal.\n * @returns {Promise<boolean>} Retorna true se o usuário clicar \"Sim\", senão false.\n */\nexport function showConfirmModal(message) {\n    return new Promise((resolve) => {\n        const confirmModalEl = document.getElementById('confirmModal');\n        if (!confirmModalEl) {\n            resolve(window.confirm(message));\n            return;\n        }\n\n        const confirmModal = new bootstrap.Modal(confirmModalEl);\n        document.getElementById('confirmModalBody').textContent = message;\n\n        const btnYes = document.getElementById('confirm-btn-yes');\n        const btnNo = document.getElementById('confirm-btn-no');\n        const btnClose = confirmModalEl.querySelector('.btn-close');\n\n        const handleResolve = (value) => {\n            btnYes.removeEventListener('click', onYesClick);\n            btnNo.removeEventListener('click', onNoClick);\n            btnClose.removeEventListener('click', onNoClick);\n            confirmModalEl.removeEventListener('hidden.bs.modal', onHidden);\n\n            if (confirmModal._isShown) {\n                confirmModal.hide();\n            }\n            resolve(value);\n        };\n\n        const onYesClick = () => handleResolve(true);\n        const onNoClick = () => handleResolve(false);\n        const onHidden = () => handleResolve(false);\n\n        btnYes.addEventListener('click', onYesClick, { once: true });\n        btnNo.addEventListener('click', onNoClick, { once: true });\n        btnClose.addEventListener('click', onNoClick, { once: true });\n        confirmModalEl.addEventListener('hidden.bs.modal', onHidden, { once: true });\n\n        confirmModal.show();\n    });\n}\n\n/**\n * Inicializa animações de scroll para elementos\n * Adiciona a classe 'fade-in-up' aos elementos que entram na viewport\n */\nexport function initScrollAnimations() {\n    const observerOptions = {\n        threshold: 0.1,\n        rootMargin: '0px 0px -50px 0px'\n    };\n\n    const observer = new IntersectionObserver((entries) => {\n        entries.forEach(entry => {\n            if (entry.isIntersecting) {\n                entry.target.classList.add('animate-in');\n                observer.unobserve(entry.target);\n            }\n        });\n    }, observerOptions);\n\n    const animateElements = document.querySelectorAll('.card, .animate-on-scroll');\n    animateElements.forEach(el => {\n        el.classList.add('will-animate');\n        observer.observe(el);\n    });\n}\n\n/**\n * Adiciona efeito de loading suave em botões\n * @param {HTMLElement} button O botão a ser modificado\n * @param {boolean} isLoading Se está carregando ou não\n */\nexport function setButtonLoading(button, isLoading) {\n    if (isLoading) {\n        button.dataset.originalText = button.innerHTML;\n        button.disabled = true;\n        button.innerHTML = '<span class=\"spinner-border spinner-border-sm me-2\" role=\"status\" aria-hidden=\"true\"></span>Carregando...';\n    } else {\n        button.disabled = false;\n        button.innerHTML = button.dataset.originalText || button.innerHTML;\n    }\n}\n\n/**\n * Inicializa animações globais da página\n */\nexport function initPageAnimations() {\n    document.body.classList.add('page-loaded');\n    \n    setTimeout(() => {\n        initScrollAnimations();\n    }, 100);\n}\n\nlet cachedCsrfToken = null;\n\n/**\n * Obtém o token CSRF do servidor e armazena em cache\n * @returns {Promise<string>} O token CSRF\n */\nexport async function getCsrfToken() {\n    if (cachedCsrfToken) {\n        return cachedCsrfToken;\n    }\n    \n    try {\n        const response = await fetch('/api/csrf-token');\n        const data = await response.json();\n        cachedCsrfToken = data.csrfToken;\n        return cachedCsrfToken;\n    } catch (error) {\n        console.error('Failed to fetch CSRF token:', error);\n        return null;\n    }\n}\n\n/**\n * Cria headers padrão para requisições fetch incluindo CSRF token\n * @param {Object} additionalHeaders Headers adicionais\n * @returns {Promise<Object>} Headers com CSRF token\n */\nexport async function getAuthHeaders(additionalHeaders = {}) {\n    const csrfToken = await getCsrfToken();\n    return {\n        'Content-Type': 'application/json',\n        'x-csrf-token': csrfToken,\n        ...additionalHeaders\n    };\n}","size_bytes":5322},"RESUMO_MELHORIAS.md":{"content":"# ✨ Resumo das Melhorias no Dashboard\n\n## 🎯 O que foi feito?\n\nSeu dashboard agora está **muito mais completo e visual**! Adicionei novos gráficos comparativos, cards informativos e corrigi todos os problemas de espaçamento e alinhamento.\n\n---\n\n## 📊 Novidades Visuais\n\n### 1. Cards de Visão Geral (Novo!)\nNo topo do dashboard, 4 cards mostram:\n- 🏢 **Total de Lojas Ativas**\n- 🏆 **Melhor Loja** (com taxa de conversão)\n- 📈 **Média de Conversão** de todas as lojas\n- 🛒 **Total de Vendas** do período\n\n### 2. Gráfico de Barras Comparativo (Novo!)\n- Compare lojas por **Vendas**, **Clientes** ou **Conversão**\n- Mostra as **top 10 lojas**\n- Selector interativo para trocar a métrica\n\n### 3. Gráfico Donut (Novo!)\n- Visualização em pizza das **top 5 lojas**\n- Mostra distribuição de taxa de conversão\n- Cores vibrantes e legenda na parte inferior\n\n### 4. Gráfico de Ranking Horizontal (Novo!)\n- **Barras horizontais** ordenadas por conversão\n- Cores dinâmicas:\n  - 🟢 Verde: Conversão ≥ 70% (excelente!)\n  - 🟠 Laranja: Conversão ≥ 50% (bom)\n  - 🔴 Vermelho: Conversão < 50% (precisa melhorar)\n- Top 10 lojas mais performáticas\n\n### 5. Melhorias na Tabela de Ranking\n- 🥇🥈🥉 **Medalhas** para os 3 primeiros lugares\n- **Cabeçalho fixo** ao fazer scroll\n- **Hover effects** nas linhas\n\n---\n\n## 🔧 Correções de Layout\n\n✅ **Espaçamento consistente** entre todos os elementos  \n✅ **Botões alinhados** perfeitamente  \n✅ **Ícones adicionados** em todos os títulos e labels  \n✅ **Grid responsivo** funciona perfeitamente em mobile  \n✅ **Min-height** em comparações evita elementos \"pulando\"  \n\n---\n\n## 🎨 Ícones Incluídos\n\nTodos os ícones são **placeholders** do Bootstrap Icons. Você pode facilmente substituir por ícones customizados se quiser!\n\nExemplos de ícones adicionados:\n- 🏪 Lojas\n- 📅 Calendário  \n- 🎛️ Dashboard\n- 📊 Gráficos\n- 🏆 Ranking\n- 🛒 Vendas\n- E muitos mais...\n\n---\n\n## 🚀 Como Testar\n\n1. **Faça login** com `admin` / `admin`\n2. **Clique em \"Dashboard\"** no menu\n3. **Crie algumas lojas** em \"Gerenciar Lojas\" (se ainda não tiver)\n4. **Adicione relatórios** em \"Novo Relatório\"\n5. **Volte ao Dashboard** e veja tudo funcionando!\n\n### Funcionalidades para Testar:\n- ✅ Filtros de período (Hoje, 7 dias, Este Mês, etc.)\n- ✅ Seletor de loja\n- ✅ Comparação com período anterior/ano anterior\n- ✅ Troca de métrica no gráfico de barras\n- ✅ Ordenação da tabela de ranking\n- ✅ Todas as visualizações de gráficos\n\n---\n\n## 📁 Arquivos Modificados\n\n1. **`views/admin.html`** - Estrutura HTML do dashboard\n2. **`public/js/pages/admin.js`** - Lógica JavaScript e gráficos\n3. **`DASHBOARD_IMPROVEMENTS.md`** - Documentação técnica completa\n\n---\n\n## 📚 Documentação Completa\n\nPara detalhes técnicos completos, veja o arquivo:\n**`DASHBOARD_IMPROVEMENTS.md`**\n\nEle contém:\n- Código de exemplo de cada gráfico\n- Como personalizar ícones\n- Estrutura de dados das APIs\n- Troubleshooting de problemas comuns\n- Sugestões de próximos passos\n\n---\n\n## 💡 Dica Importante\n\nSe ao acessar o dashboard aparecer \"Erro ao analisar dados\", significa que o banco está vazio. Basta:\n1. Criar algumas lojas em \"Gerenciar Lojas\"\n2. Adicionar relatórios em \"Novo Relatório\"  \n3. Voltar ao Dashboard\n\nOs gráficos irão popular automaticamente com os dados reais!\n\n---\n\n**Pronto! Seu dashboard está muito mais completo e profissional! 🎉**\n","size_bytes":3472},"public/css/style.css":{"content":"@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap');\n\n/* ============================================================\n   VARIÁVEIS - TEMA APPLE + LOFT DESIGN\n============================================================ */\n:root {\n    --sidebar-width: 220px;\n    \n    /* Modo Claro - Cores REAIS da Loft (branco + cinza pastel + laranja) */\n    --main-bg-light: #ffffff;\n    --content-bg-light: #f8f8f8;\n    --hover-bg-light: #f0f0f0;\n    --border-color-light: #e0e0e0;\n    --text-primary-light: #2c2c2c;\n    --text-secondary-light: #757575;\n    --text-tertiary-light: #9e9e9e;\n    \n    /* Modo Escuro - Cinza escuro com toques de laranja */\n    --main-bg-dark: #1a1a1a;\n    --content-bg-dark: #2a2a2a;\n    --hover-bg-dark: #353535;\n    --border-color-dark: #404040;\n    --text-primary-dark: #f5f5f5;\n    --text-secondary-dark: #b0b0b0;\n    --text-tertiary-dark: #808080;\n    \n    /* Cor de Destaque - Laranja Pastel da Loft */\n    --accent-primary: #ff8c42;\n    --accent-secondary: #ff7733;\n    --accent-hover: #ff9d5c;\n    \n    /* Cores Chamativas e Claras para Dashboard */\n    --color-success: #4ade80;\n    --color-warning: #fbbf24;\n    --color-error: #fb7185;\n    --color-info: #60a5fa;\n    --color-purple: #a78bfa;\n    --color-pink: #f472b6;\n    --color-yellow: #fde047;\n    --color-blue: #38bdf8;\n    \n    /* Propriedades Dinâmicas (alternam com tema) */\n    --main-bg: var(--main-bg-light);\n    --content-bg: var(--content-bg-light);\n    --hover-bg: var(--hover-bg-light);\n    --border-color: var(--border-color-light);\n    --text-primary: var(--text-primary-light);\n    --text-secondary: var(--text-secondary-light);\n    --text-tertiary: var(--text-tertiary-light);\n    \n    /* Design */\n    --border-radius-xl: 20px;\n    --border-radius-large: 16px;\n    --border-radius-medium: 12px;\n    --border-radius-small: 8px;\n    --transition-speed: 0.3s;\n    --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.04);\n    --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.08);\n    --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.12);\n}\n\n/* Tema Escuro */\n[data-theme=\"dark\"] {\n    --main-bg: var(--main-bg-dark);\n    --content-bg: var(--content-bg-dark);\n    --hover-bg: var(--hover-bg-dark);\n    --border-color: var(--border-color-dark);\n    --text-primary: var(--text-primary-dark);\n    --text-secondary: var(--text-secondary-dark);\n    --text-tertiary: var(--text-tertiary-dark);\n    --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);\n    --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.4);\n    --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.5);\n}\n\n/* ============================================================\n   SOBRESCREVER CORES DO BOOTSTRAP (CLARAS E CHAMATIVAS)\n============================================================ */\n.text-success { color: var(--color-success) !important; }\n.text-warning { color: var(--color-warning) !important; }\n.text-danger { color: var(--color-error) !important; }\n.text-info { color: var(--color-info) !important; }\n\n.bg-success { background-color: var(--color-success) !important; }\n.bg-warning { background-color: var(--color-warning) !important; }\n.bg-danger { background-color: var(--color-error) !important; }\n.bg-info { background-color: var(--color-info) !important; }\n\n.btn-success {\n    background-color: var(--color-success) !important;\n    border-color: var(--color-success) !important;\n    color: white !important;\n}\n\n.btn-success:hover {\n    background-color: #22c55e !important;\n    border-color: #22c55e !important;\n}\n\n.btn-warning {\n    background-color: var(--color-warning) !important;\n    border-color: var(--color-warning) !important;\n    color: #78350f !important;\n}\n\n.btn-warning:hover {\n    background-color: #f59e0b !important;\n    border-color: #f59e0b !important;\n}\n\n.btn-danger {\n    background-color: var(--color-error) !important;\n    border-color: var(--color-error) !important;\n    color: white !important;\n}\n\n.btn-danger:hover {\n    background-color: #f43f5e !important;\n    border-color: #f43f5e !important;\n}\n\n.btn-info {\n    background-color: var(--color-info) !important;\n    border-color: var(--color-info) !important;\n    color: white !important;\n}\n\n.btn-info:hover {\n    background-color: #3b82f6 !important;\n    border-color: #3b82f6 !important;\n}\n\n.btn-excel {\n    background-color: #217346 !important;\n    border-color: #217346 !important;\n    color: white !important;\n}\n\n.btn-excel:hover {\n    background-color: #1a5c37 !important;\n    border-color: #1a5c37 !important;\n}\n\n.badge.bg-success { background-color: var(--color-success) !important; }\n.badge.bg-warning { background-color: var(--color-warning) !important; color: #78350f !important; }\n.badge.bg-danger { background-color: var(--color-error) !important; }\n.badge.bg-info { background-color: var(--color-info) !important; }\n\n/* Gradiente primário (laranja) */\n.bg-gradient-primary {\n    background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%) !important;\n    border-bottom: none !important;\n}\n\n/* Utilitários de opacidade */\n.opacity-90 {\n    opacity: 0.9 !important;\n}\n\n.opacity-50 {\n    opacity: 0.5 !important;\n}\n\n/* Cores de tipo de usuário - apenas texto colorido */\n.user-role-consultor {\n    color: #fbbf24 !important;\n}\n\n.user-role-admin {\n    color: #ff8c42 !important;\n}\n\n.user-role-gerente {\n    color: #4ade80 !important;\n}\n\n.user-role-monitoramento {\n    color: #60a5fa !important;\n}\n\n.user-role-dev {\n    color: #ef4444 !important;\n}\n\n/* ============================================================\n   ESTRUTURA PRINCIPAL E ESTILOS GLOBAIS\n============================================================ */\n* {\n    transition: background-color var(--transition-speed) ease, \n                color var(--transition-speed) ease,\n                border-color var(--transition-speed) ease;\n}\n\nbody { \n    background-color: var(--main-bg) !important; \n    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;\n    font-weight: 400;\n    line-height: 1.6;\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n}\n\n.main-content { \n    padding: 2rem; \n    height: 100vh; \n    overflow-y: auto; \n}\n\n#page-content { \n    max-width: 1600px; \n    margin: 0 auto; \n}\n\nbody, body * { \n    color: var(--text-primary) !important; \n}\n\nsmall, .text-muted { \n    color: var(--text-secondary) !important; \n}\n\n.text-tertiary {\n    color: var(--text-tertiary) !important;\n}\n\n/* Títulos com estilo Apple */\nh1, h2, h3, h4, h5, h6 {\n    font-weight: 600;\n    letter-spacing: -0.02em;\n}\n\nh4.mb-3 {\n    font-weight: 600;\n    font-size: 1.5rem;\n    padding-bottom: 1rem;\n    position: relative;\n    border-bottom: 1px solid var(--border-color);\n    margin-bottom: 1.5rem !important;\n    letter-spacing: -0.02em;\n}\n\nh4.mb-3::after {\n    content: '';\n    position: absolute;\n    bottom: -1px;\n    left: 0;\n    width: 60px;\n    height: 2px;\n    background: var(--accent-primary);\n}\n\n/* ============================================================\n   ANIMAÇÕES GLOBAIS - Scroll e Page Load\n============================================================ */\n\n@keyframes fadeInUp {\n    from {\n        opacity: 0;\n        transform: translateY(30px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n@keyframes fadeIn {\n    from { opacity: 0; }\n    to { opacity: 1; }\n}\n\n@keyframes slideInLeft {\n    from {\n        opacity: 0;\n        transform: translateX(-20px);\n    }\n    to {\n        opacity: 1;\n        transform: translateX(0);\n    }\n}\n\nbody {\n    opacity: 0;\n    animation: fadeIn 0.5s ease-in-out forwards;\n}\n\nbody.page-loaded {\n    opacity: 1;\n}\n\n.will-animate {\n    opacity: 0;\n    transform: translateY(30px);\n    transition: opacity 0.6s cubic-bezier(0.16, 1, 0.3, 1),\n                transform 0.6s cubic-bezier(0.16, 1, 0.3, 1);\n}\n\n.will-animate.animate-in {\n    opacity: 1;\n    transform: translateY(0);\n}\n\n.spinner-border {\n    display: inline-block;\n    width: 1rem;\n    height: 1rem;\n    vertical-align: -0.125em;\n    border: 0.15em solid currentColor;\n    border-right-color: transparent;\n    border-radius: 50%;\n    animation: spinner-border-spin 0.75s linear infinite;\n}\n\n.spinner-border-sm {\n    width: 0.875rem;\n    height: 0.875rem;\n    border-width: 0.12em;\n}\n\n@keyframes spinner-border-spin {\n    100% { transform: rotate(360deg); }\n}\n\n/* ============================================================\n   SIDEBAR DESKTOP - Estilo Apple/Loft\n============================================================ */\n.sidebar-desktop {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: var(--sidebar-width);\n    height: 100vh;\n    background-color: var(--content-bg);\n    border-right: 1px solid var(--border-color);\n    padding: 2rem 1.5rem;\n    z-index: 1000;\n    display: flex;\n    flex-direction: column;\n    box-shadow: var(--shadow-sm);\n    transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);\n}\n\n.sidebar-header {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 0.5rem;\n    font-size: 1.4rem;\n    font-weight: 600;\n    padding-bottom: 1.5rem;\n    border-bottom: 1px solid var(--border-color);\n    letter-spacing: -0.03em;\n    width: 100%;\n}\n\n.sidebar-header .logo-container {\n    display: flex;\n    align-items: center;\n    gap: 0.625rem;\n    flex: 1;\n    min-width: 0;\n}\n\n.sidebar-header .sidebar-text {\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n\n.sidebar-header i {\n    color: var(--text-primary) !important;\n    font-size: 1.6rem;\n    flex-shrink: 0;\n}\n\n.sidebar-controls {\n    display: flex;\n    gap: 0.375rem;\n    flex-shrink: 0;\n    align-items: center;\n}\n\n/* Botão Dark/Light Mode e Toggle Sidebar - REDESIGNED */\n.theme-toggle {\n    background: var(--hover-bg);\n    border: 1px solid var(--border-color);\n    border-radius: 10px;\n    padding: 0;\n    cursor: pointer;\n    transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    width: 36px;\n    height: 36px;\n    flex-shrink: 0;\n}\n\n.theme-toggle:hover {\n    background: var(--border-color);\n    transform: scale(1.08);\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);\n}\n\n.theme-toggle:active {\n    transform: scale(0.92);\n}\n\n.theme-toggle i {\n    font-size: 1.1rem;\n    color: var(--text-primary) !important;\n    transition: transform 0.3s ease;\n    line-height: 1;\n}\n\n/* Sidebar oculta */\n.sidebar-desktop.sidebar-hidden {\n    transform: translateX(-100%);\n}\n\n.sidebar-desktop.sidebar-hidden .sidebar-text {\n    opacity: 0;\n}\n\n/* Botão flutuante para mostrar sidebar */\n.sidebar-show-btn {\n    position: fixed;\n    top: 2rem;\n    left: 1rem;\n    width: 48px;\n    height: 48px;\n    background: var(--content-bg);\n    border: 1px solid var(--border-color);\n    border-radius: 12px;\n    display: none;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    z-index: 999;\n    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);\n    transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);\n    opacity: 0;\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.sidebar-show-btn i {\n    font-size: 1.3rem;\n    color: var(--text-primary) !important;\n}\n\n.sidebar-show-btn:hover {\n    background: var(--hover-bg);\n    transform: scale(1.05);\n    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);\n}\n\n.sidebar-show-btn:active {\n    transform: scale(0.95);\n}\n\n.sidebar-show-btn.visible {\n    display: flex;\n    opacity: 1;\n    animation: slideInLeft 0.4s cubic-bezier(0.16, 1, 0.3, 1);\n}\n\n/* Botão flutuante de tema (canto superior direito) */\n.theme-toggle-floating {\n    position: fixed;\n    top: 1.25rem;\n    right: 1.25rem;\n    width: 36px;\n    height: 36px;\n    background: var(--content-bg);\n    border: 1px solid var(--border-color);\n    border-radius: 10px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    z-index: 999;\n    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);\n    transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.theme-toggle-floating i {\n    font-size: 1.1rem;\n    color: var(--text-primary) !important;\n    transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);\n}\n\n.theme-toggle-floating:hover {\n    background: var(--hover-bg);\n    transform: scale(1.05) rotate(5deg);\n    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);\n}\n\n.theme-toggle-floating:hover i {\n    transform: rotate(15deg) scale(1.1);\n}\n\n.theme-toggle-floating:active {\n    transform: scale(0.95);\n}\n\n.sidebar-nav {\n    list-style: none !important;\n    padding: 0 !important;\n    margin: 2rem 0;\n    flex-grow: 1;\n}\n\n.sidebar-nav .nav-item {\n    margin-bottom: 0.25rem !important;\n    position: relative;\n}\n\n.nav-link {\n    display: flex;\n    align-items: center;\n    gap: 0.75rem;\n    padding: 0.625rem 1rem;\n    border-radius: 8px;\n    color: var(--text-secondary) !important;\n    text-decoration: none;\n    transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);\n    font-weight: 500;\n    font-size: 0.875rem;\n    position: relative;\n    overflow: hidden;\n}\n\n.nav-link::before {\n    content: '';\n    position: absolute;\n    left: 0;\n    top: 50%;\n    transform: translateY(-50%);\n    width: 3px;\n    height: 0;\n    background: var(--accent-primary);\n    border-radius: 0 2px 2px 0;\n    transition: height 0.3s cubic-bezier(0.16, 1, 0.3, 1);\n}\n\n.nav-link i {\n    transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);\n}\n\n.nav-link:hover {\n    color: var(--text-primary) !important;\n    background-color: var(--hover-bg);\n    transform: translateX(4px);\n}\n\n.nav-link:hover i {\n    transform: scale(1.1);\n}\n\n.nav-link:hover::before {\n    height: 60%;\n}\n\n.nav-item.active .nav-link {\n    color: var(--text-primary) !important;\n    background-color: var(--hover-bg);\n    font-weight: 600;\n}\n\n.nav-item.active .nav-link::before {\n    height: 70%;\n}\n\n.nav-item.active .nav-link i {\n    color: var(--accent-primary) !important;\n    transform: scale(1.05);\n}\n\n/* Submenu de Configurações */\n.submenu-link {\n    font-size: 0.825rem !important;\n    padding: 0.5rem 1rem 0.5rem 2.5rem !important;\n    color: var(--text-tertiary) !important;\n}\n\n.submenu-link:hover {\n    color: var(--text-primary) !important;\n    background-color: var(--hover-bg);\n}\n\n.nav-link.dropdown-toggle::after {\n    margin-left: auto;\n    transition: transform 0.3s ease;\n}\n\n.nav-link.dropdown-toggle[aria-expanded=\"true\"]::after {\n    transform: rotate(180deg);\n}\n\n.dropdown-menu-dark {\n    background-color: var(--content-bg) !important;\n    border: 1px solid var(--border-color) !important;\n    border-radius: 10px !important;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n    margin-top: 0.5rem;\n}\n\n.dropdown-menu-dark .dropdown-item {\n    color: var(--text-secondary) !important;\n    padding: 0.625rem 1rem;\n    transition: all 0.2s ease;\n}\n\n.dropdown-menu-dark .dropdown-item:hover {\n    background-color: var(--hover-bg) !important;\n    color: var(--text-primary) !important;\n}\n\n.sidebar-footer {\n    margin-top: auto;\n    padding-top: 1.5rem;\n    border-top: 1px solid var(--border-color);\n}\n\n#user-info-container {\n    display: flex;\n    flex-direction: column;\n    gap: 1rem;\n}\n\n#user-info-container .user-info {\n    font-weight: 600;\n    font-size: 0.875rem;\n    color: var(--text-primary) !important;\n}\n\n#user-info-container .user-role {\n    font-size: 0.75rem;\n    color: var(--text-secondary) !important;\n    font-weight: 500;\n}\n\n#user-info-container .user-actions {\n    display: flex;\n    gap: 0.5rem;\n}\n\n#user-info-container .btn {\n    background-color: transparent !important;\n    border: 1px solid var(--border-color) !important;\n    color: var(--text-secondary) !important;\n    padding: 0.5rem 0.75rem;\n    font-size: 0.875rem;\n    border-radius: var(--border-radius-small);\n    transition: all var(--transition-speed);\n}\n\n#user-info-container .btn:hover {\n    background-color: var(--hover-bg) !important;\n    color: var(--text-primary) !important;\n    border-color: var(--text-primary) !important;\n}\n\n/* ============================================================\n   COMPONENTES GERAIS (Cards, Forms, Botões) - Estilo Apple/Loft\n============================================================ */\n\n/* Cards Redesenhados - Visual Moderno e Profissional */\n.card, .alert, .list-group-item {\n    background-color: var(--content-bg) !important;\n    border-radius: 14px !important;\n    border: 1px solid var(--border-color) !important;\n    margin-bottom: 1.5rem;\n    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.04),\n                0 1px 3px rgba(0, 0, 0, 0.06);\n    transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);\n    backdrop-filter: blur(12px);\n    -webkit-backdrop-filter: blur(12px);\n    overflow: hidden;\n}\n\n.card:hover {\n    border-color: rgba(255, 140, 66, 0.3);\n    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08),\n                0 2px 6px rgba(0, 0, 0, 0.06);\n    transform: translateY(-3px);\n}\n\n#page-content > .container-fluid > .card:first-of-type {\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.06),\n                0 2px 8px rgba(0, 0, 0, 0.04);\n}\n\n.card-header {\n    font-weight: 600;\n    background-color: transparent !important;\n    border-bottom: 1px solid var(--border-color) !important;\n    padding: 1.125rem 1.5rem;\n    font-size: 1rem;\n    letter-spacing: -0.02em;\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n}\n\n.card-header i {\n    color: var(--accent-primary) !important;\n    font-size: 1.1rem;\n}\n\n.card-body {\n    padding: 1.5rem !important;\n}\n\n/* Cards Elaborados com Efeitos Especiais */\n.card-hover-effect {\n    transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);\n    position: relative;\n    overflow: visible;\n}\n\n.card-hover-effect::before {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    border-radius: 14px;\n    background: linear-gradient(135deg, rgba(255, 140, 66, 0.05), rgba(255, 140, 66, 0));\n    opacity: 0;\n    transition: opacity 0.4s ease;\n    pointer-events: none;\n}\n\n.card-hover-effect:hover::before {\n    opacity: 1;\n}\n\n.card-hover-effect:hover {\n    transform: translateY(-6px) scale(1.02);\n    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.12),\n                0 4px 12px rgba(255, 140, 66, 0.15);\n}\n\n.icon-badge {\n    width: 48px;\n    height: 48px;\n    border-radius: 12px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    color: white;\n    font-size: 1.5rem;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n    transition: all 0.3s ease;\n}\n\n.card-hover-effect:hover .icon-badge {\n    transform: rotate(10deg) scale(1.1);\n    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);\n}\n\n.bg-purple {\n    background-color: var(--color-purple) !important;\n    color: white !important;\n}\n\n/* Formulários Redesenhados - Elegantes e Modernos */\n.form-label {\n    font-weight: 600;\n    font-size: 0.875rem;\n    color: var(--text-secondary) !important;\n    margin-bottom: 0.5rem;\n    letter-spacing: -0.01em;\n}\n\n.form-control, .form-select {\n    background-color: var(--hover-bg) !important;\n    border: 1.5px solid var(--border-color) !important;\n    color: var(--text-primary) !important;\n    border-radius: 10px;\n    padding: 0.625rem 1rem;\n    font-size: 0.9375rem;\n    transition: all 0.25s cubic-bezier(0.16, 1, 0.3, 1);\n    line-height: 1.5;\n}\n\n.form-control:hover, .form-select:hover {\n    border-color: var(--text-tertiary);\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);\n}\n\n.form-control:focus, .form-select:focus {\n    background-color: var(--content-bg) !important;\n    border-color: var(--accent-primary) !important;\n    box-shadow: 0 0 0 4px rgba(255, 140, 66, 0.12),\n                0 4px 12px rgba(0, 0, 0, 0.06) !important;\n    outline: none;\n    transform: translateY(-1px);\n}\n\n.form-control-sm, .form-select-sm {\n    padding: 0.5rem 0.875rem;\n    font-size: 0.875rem;\n    border-radius: 8px;\n}\n\n.form-control-lg, .form-select-lg {\n    padding: 0.75rem 1.25rem;\n    font-size: 1rem;\n    border-radius: 12px;\n}\n\ninput[type=\"date\"]::-webkit-calendar-picker-indicator {\n    filter: brightness(0.5);\n    opacity: 0.7;\n    cursor: pointer;\n}\n\n[data-theme=\"dark\"] input[type=\"date\"]::-webkit-calendar-picker-indicator {\n    filter: invert(1);\n}\n\n/* Botões Redesenhados - Proporções Perfeitas e Consistentes */\n.btn {\n    transition: all 0.25s cubic-bezier(0.16, 1, 0.3, 1);\n    font-weight: 500;\n    border-radius: 10px;\n    padding: 0.625rem 1.125rem;\n    font-size: 0.875rem;\n    letter-spacing: -0.01em;\n    border: none;\n    position: relative;\n    overflow: hidden;\n    line-height: 1.5;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    gap: 0.5rem;\n    white-space: nowrap;\n}\n\n.btn::before {\n    content: '';\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    width: 0;\n    height: 0;\n    border-radius: 50%;\n    background: rgba(255, 255, 255, 0.15);\n    transform: translate(-50%, -50%);\n    transition: width 0.5s ease, height 0.5s ease;\n    pointer-events: none;\n}\n\n.btn:hover::before {\n    width: 300px;\n    height: 300px;\n}\n\n.btn:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);\n}\n\n.btn:active {\n    transform: translateY(0) scale(0.98);\n    transition: all 0.1s;\n}\n\n.btn i {\n    font-size: 1em;\n    line-height: 1;\n}\n\n/* Button Sizes - Standardized */\n.btn-sm {\n    padding: 0.5rem 0.875rem;\n    font-size: 0.8125rem;\n    border-radius: 8px;\n}\n\n.btn-lg {\n    padding: 0.75rem 1.5rem;\n    font-size: 1rem;\n    border-radius: 12px;\n}\n\n.btn-primary {\n    background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%) !important;\n    color: #ffffff !important;\n    border: none !important;\n    box-shadow: 0 2px 12px rgba(255, 140, 66, 0.25);\n    font-weight: 600;\n}\n\n.btn-primary:hover {\n    background: linear-gradient(135deg, var(--accent-hover) 0%, var(--accent-primary) 100%) !important;\n    box-shadow: 0 6px 20px rgba(255, 140, 66, 0.35);\n    transform: translateY(-2px);\n}\n\n.btn-primary:active {\n    transform: translateY(0) scale(0.98);\n    box-shadow: 0 2px 8px rgba(255, 140, 66, 0.3);\n}\n\n.btn-secondary {\n    background-color: var(--content-bg) !important;\n    color: var(--text-primary) !important;\n    border: 1.5px solid var(--border-color) !important;\n    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.04);\n}\n\n.btn-secondary:hover {\n    background-color: var(--hover-bg) !important;\n    border-color: var(--text-tertiary) !important;\n    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08);\n}\n\n.btn-outline-secondary {\n    background-color: transparent !important;\n    border: 1.5px solid var(--border-color) !important;\n    color: var(--text-secondary) !important;\n}\n\n.btn-outline-secondary:hover {\n    background-color: var(--hover-bg) !important;\n    color: var(--text-primary) !important;\n    border-color: var(--text-primary) !important;\n}\n\n.btn-outline-primary {\n    background-color: transparent !important;\n    border: 1.5px solid var(--accent-primary) !important;\n    color: var(--accent-primary) !important;\n}\n\n.btn-outline-primary:hover {\n    background-color: var(--accent-primary) !important;\n    color: #ffffff !important;\n    box-shadow: 0 4px 12px rgba(255, 140, 66, 0.25);\n}\n\n/* ============================================================\n   LAYOUT RESPONSIVO\n============================================================ */\n@media (min-width: 992px) { \n    .main-content { \n        margin-left: var(--sidebar-width);\n        transition: margin-left 0.4s cubic-bezier(0.16, 1, 0.3, 1);\n    }\n    \n    .main-content.sidebar-hidden {\n        margin-left: 0;\n    }\n}\n\n@media (max-width: 991.98px) { \n    .main-content { padding: 1.25rem; padding-top: 75px; }\n    \n    /* Botões mantém bom tamanho em mobile */\n    .btn {\n        font-size: 0.875rem;\n        padding: 0.625rem 1rem;\n    }\n    \n    .btn-sm {\n        padding: 0.5rem 0.875rem;\n        font-size: 0.8125rem;\n    }\n    \n    /* Botões flex-fill em mobile */\n    .d-flex.flex-wrap .flex-fill {\n        min-width: calc(50% - 0.5rem);\n    }\n    \n    /* Cards bem proporcionados em mobile */\n    .card-header {\n        padding: 1rem 1.25rem;\n        font-size: 0.9375rem;\n    }\n    \n    .card-body {\n        padding: 1.25rem !important;\n    }\n    \n    /* Tabelas responsivas */\n    .table {\n        font-size: 0.875rem;\n    }\n    \n    .table th, .table td {\n        padding: 0.75rem 0.5rem;\n    }\n    \n    /* Formulários bem dimensionados */\n    .form-control, .form-select {\n        font-size: 0.9375rem;\n        padding: 0.625rem 0.875rem;\n    }\n}\n\n@media (max-width: 767.98px) {\n    .main-content { padding: 1rem; padding-top: 75px; }\n    \n    h4.mb-3 {\n        font-size: 1.3rem;\n        padding-bottom: 0.75rem;\n        margin-bottom: 1.25rem !important;\n    }\n    \n    h1, h2 {\n        font-size: 1.5rem;\n    }\n    \n    h3 {\n        font-size: 1.25rem;\n    }\n    \n    /* Botões em linha que quebram para coluna */\n    .btn-group-vertical .btn,\n    .d-flex.gap-2 {\n        flex-wrap: wrap;\n    }\n    \n    /* Cards mais compactos em mobile pequeno */\n    .card-header {\n        padding: 0.875rem 1rem;\n        font-size: 0.9rem;\n    }\n    \n    .card-body {\n        padding: 1rem !important;\n    }\n}\n\n/* ============================================================\n   HEADER E MENU MOBILE (MODAL) - Estilo Apple/Loft\n============================================================ */\n.mobile-header {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 60px;\n    background-color: rgba(var(--content-bg-rgb, 248, 248, 248), 0.95);\n    backdrop-filter: blur(20px);\n    -webkit-backdrop-filter: blur(20px);\n    border-bottom: 1px solid var(--border-color);\n    display: flex;\n    align-items: center;\n    padding: 0 1rem;\n    z-index: 1030;\n    box-shadow: 0 2px 12px rgba(0, 0, 0, 0.04);\n}\n\n[data-theme=\"dark\"] .mobile-header {\n    background-color: rgba(42, 42, 42, 0.95);\n}\n\n.mobile-header .btn {\n    font-size: 1.4rem;\n    color: var(--text-primary) !important;\n    background: transparent;\n    padding: 0.5rem;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    transition: all 0.25s cubic-bezier(0.16, 1, 0.3, 1);\n    border-radius: 10px;\n    width: 40px;\n    height: 40px;\n}\n\n.mobile-header .btn:hover {\n    background-color: var(--hover-bg);\n    transform: scale(1.05);\n}\n\n.mobile-header .btn:active {\n    transform: scale(0.92);\n    transition: all 0.1s;\n}\n\n.mobile-header-title {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n    font-size: 1.15rem;\n    font-weight: 600;\n    margin-left: 0.75rem;\n    letter-spacing: -0.03em;\n    flex: 1;\n}\n\n.mobile-header-title i {\n    color: var(--text-primary) !important;\n    font-size: 1.3rem;\n}\n\n.mobile-header .theme-toggle {\n    margin-left: auto;\n}\n\n.modal-content.mobile-menu-content {\n    background-color: var(--content-bg);\n    border: none;\n    backdrop-filter: blur(20px);\n    -webkit-backdrop-filter: blur(20px);\n}\n\n.mobile-menu-content .modal-header {\n    border-bottom-color: var(--border-color);\n    padding: 1.5rem;\n}\n\n.mobile-menu-content .modal-header .modal-title {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n    font-weight: 600;\n    font-size: 1.2rem;\n}\n\n.mobile-menu-content .modal-header .modal-title i {\n    color: var(--text-primary) !important;\n}\n\n.mobile-menu-content .modal-body {\n    padding: 2rem 1.5rem;\n}\n\n.mobile-menu-content .nav-link {\n    font-size: 1rem;\n    padding: 1rem 1.25rem;\n    margin-bottom: 0.5rem;\n    border-radius: 10px;\n    transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);\n}\n\n.mobile-menu-content .nav-link:active {\n    transform: scale(0.98);\n    transition: all 0.1s;\n}\n\n/* Animação do modal mobile com efeito suave */\n.modal.fade .modal-dialog {\n    transform: translateX(-100%);\n    opacity: 0;\n    transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1),\n                opacity 0.4s ease;\n}\n\n.modal.show .modal-dialog {\n    transform: translateX(0);\n    opacity: 1;\n}\n\n.modal-backdrop {\n    backdrop-filter: blur(8px);\n    -webkit-backdrop-filter: blur(8px);\n}\n\n/* ============================================================\n   CORREÇÕES DE COMPONENTES (Tabelas, Modais, Abas)\n============================================================ */\n.card .table-responsive, .card .table { background-color: transparent; }\n.card .table { --bs-table-bg: transparent; --bs-table-striped-bg: rgba(0, 0, 0, 0.05); }\n.modal-content { background-color: var(--content-bg) !important; border-radius: var(--border-radius-large) !important; border: 1px solid var(--border-color) !important; -webkit-backdrop-filter: blur(12px); backdrop-filter: blur(12px); }\n.modal-header { border-bottom-color: var(--border-color) !important; }\n.modal-footer { border-top-color: var(--border-color) !important; }\n.nav-tabs {\n    border-bottom: 2px solid var(--border-color) !important;\n}\n\n.nav-tabs .nav-link {\n    background: transparent !important;\n    border: none !important;\n    border-bottom: 3px solid transparent !important;\n    color: var(--text-secondary) !important;\n    margin-bottom: -2px;\n    font-weight: 500;\n    transition: all var(--transition-speed);\n}\n\n.nav-tabs .nav-link:hover {\n    border-bottom-color: var(--border-color) !important;\n    color: var(--text-primary) !important;\n}\n\n.nav-tabs .nav-link.active {\n    color: var(--text-primary) !important;\n    font-weight: 600;\n    border-bottom-color: var(--accent-primary) !important;\n}\n\n/* ============================================================\n   REFORMULAÇÃO DO FORMULÁRIO DE FILTROS DO DASHBOARD\n============================================================ */\n#form-filtros-dashboard .form-label {\n    font-size: 0.8rem;\n    font-weight: 500;\n    color: var(--text-muted);\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n    margin-bottom: 0.5rem; /* Espaçamento consistente */\n}\n\n/* Container do controle segmentado */\n#form-filtros-dashboard .btn-group {\n    border: 1px solid var(--border-color);\n    border-radius: var(--border-radius-small);\n    padding: 3px;\n    background-color: var(--main-bg);\n}\n\n/* Botões individuais dentro do controle */\n#form-filtros-dashboard .btn-group .btn {\n    background-color: transparent !important;\n    border: none !important;\n    color: var(--text-muted) !important;\n    font-weight: 500;\n    box-shadow: none !important;\n    transition: all 0.2s ease-in-out;\n    border-radius: 6px !important; /* Bordas arredondadas para todos */\n    padding-top: 0.375rem; /* Ajuste para alinhamento vertical */\n    padding-bottom: 0.375rem;\n}\n\n#form-filtros-dashboard .btn-group .btn:hover {\n    color: var(--text-light) !important;\n    background-color: rgba(255, 255, 255, 0.05) !important;\n}\n\n/* Botão ATIVO no controle */\n#form-filtros-dashboard .btn-group .btn.active {\n    background-color: var(--hover-bg) !important;\n    color: var(--text-light) !important;\n    font-weight: 600;\n    box-shadow: 0 2px 8px rgba(0,0,0,0.3) !important;\n}\n\n.input-group-text {\n    background-color: var(--border-color) !important; /* Um cinza um pouco mais escuro para destaque */\n    border-color: var(--border-color) !important;\n    color: var(--text-muted) !important;\n    font-weight: 600;\n}\n\n.btn:hover {\n    transform: translateY(-2px);\n    opacity: 0.95;\n}\n\n/* Aplica o brilho laranja ao passar o mouse sobre botões primários */\n.btn-primary:hover {\n    box-shadow: 0 0 12px var(--glow-color);\n}\n\n/* Aplica um brilho verde ao passar o mouse sobre botões de sucesso */\n.btn-success:hover {\n    box-shadow: 0 0 12px rgba(46, 160, 67, 0.6);\n}\n\n/* Aplica um brilho vermelho ao passar o mouse sobre botões de perigo */\n.btn-danger:hover, .btn-outline-danger:hover {\n    box-shadow: 0 0 12px rgba(248, 113, 113, 0.6);\n}\n\n/* Aplica um brilho cinza ao passar o mouse sobre botões secundários */\n.btn-secondary:hover, .btn-outline-secondary:hover {\n    box-shadow: 0 0 12px rgba(108, 117, 125, 0.4);\n}\n\n/* ============================================================\n   RESPONSIVIDADE AVANÇADA - MOBILE E TABLET\n============================================================ */\n\n/* TABLET (768px - 991px) */\n@media (max-width: 991.98px) and (min-width: 768px) {\n    .main-content { padding: 1.5rem; }\n    #page-content { max-width: 100%; }\n    \n    /* Cards do dashboard em 2 colunas */\n    .row .col-md-3 { flex: 0 0 50%; max-width: 50%; }\n    .row .col-md-6 { flex: 0 0 100%; max-width: 100%; }\n    \n    /* Ajustar títulos */\n    h1, h4 { font-size: 1.5rem; }\n    .h3 { font-size: 1.3rem; }\n}\n\n/* MOBILE (até 767px) */\n@media (max-width: 767.98px) {\n    /* Layout geral */\n    .main-content { padding: 1rem; padding-top: 70px; }\n    #page-content { max-width: 100%; }\n    \n    /* Cards do dashboard empilhados */\n    .row .col-md-3,\n    .row .col-md-6,\n    .row .col-lg-4,\n    .row .col-lg-6,\n    .row .col-lg-8 {\n        flex: 0 0 100%;\n        max-width: 100%;\n        margin-bottom: 1rem;\n    }\n    \n    /* Títulos menores */\n    h1 { font-size: 1.3rem; }\n    .h3 { font-size: 1.2rem; }\n    h4 { font-size: 1.1rem; }\n    .h5 { font-size: 1rem; }\n    \n    /* Cards mais compactos */\n    .card-body { padding: 1rem !important; }\n    .card-header { padding: 0.75rem 1rem; font-size: 0.9rem; }\n    \n    /* Botões responsivos */\n    .btn { font-size: 0.9rem; padding: 0.5rem 0.75rem; }\n    .btn-sm { font-size: 0.8rem; padding: 0.3rem 0.5rem; }\n    \n    /* Tabelas com scroll horizontal */\n    .table-responsive {\n        overflow-x: auto;\n        -webkit-overflow-scrolling: touch;\n    }\n    \n    .table {\n        font-size: 0.85rem;\n        min-width: 600px; /* Força scroll se precisar */\n    }\n    \n    .table th,\n    .table td {\n        padding: 0.5rem;\n        white-space: nowrap;\n    }\n    \n    /* Formulários responsivos */\n    .form-label {\n        font-size: 0.85rem;\n        margin-bottom: 0.3rem;\n    }\n    \n    .form-control,\n    .form-select {\n        font-size: 0.9rem;\n        padding: 0.5rem;\n    }\n    \n    /* Modais em tela cheia no mobile */\n    .modal-dialog {\n        margin: 0.5rem;\n        max-width: calc(100% - 1rem);\n    }\n    \n    .modal-dialog-centered {\n        min-height: calc(100% - 1rem);\n    }\n    \n    .modal-lg,\n    .modal-xl {\n        max-width: calc(100% - 1rem);\n    }\n    \n    .modal-body {\n        padding: 1rem;\n    }\n    \n    /* Inputs de data e select menores */\n    .input-group .form-control,\n    .input-group .form-select {\n        font-size: 0.85rem;\n    }\n    \n    /* Badges e tags menores */\n    .badge {\n        font-size: 0.75rem;\n        padding: 0.25em 0.5em;\n    }\n    \n    /* Tabelas de vendedores */\n    .table-hover tbody tr {\n        display: table-row;\n    }\n    \n    /* Ajustar dropdown de filtros */\n    .btn-group {\n        display: flex;\n        flex-wrap: wrap;\n    }\n    \n    .btn-group .btn {\n        flex: 1 1 auto;\n        font-size: 0.8rem;\n    }\n    \n    /* Gráficos responsivos */\n    canvas {\n        max-height: 250px !important;\n    }\n    \n    /* Ajustar espaçamentos */\n    .mb-3 { margin-bottom: 0.75rem !important; }\n    .mb-4 { margin-bottom: 1rem !important; }\n    .mt-3 { margin-top: 0.75rem !important; }\n    .mt-4 { margin-top: 1rem !important; }\n    \n    /* Ajustar header de páginas */\n    .d-flex.justify-content-between {\n        flex-direction: column;\n        gap: 0.75rem;\n    }\n    \n    .d-flex.justify-content-between .btn {\n        width: 100%;\n    }\n}\n\n/* MOBILE PEQUENO (até 480px) */\n@media (max-width: 480px) {\n    .main-content { padding: 0.75rem; padding-top: 70px; }\n    \n    /* Fontes ainda menores */\n    h1 { font-size: 1.2rem; }\n    .h3 { font-size: 1.1rem; }\n    h4 { font-size: 1rem; }\n    \n    /* Cards super compactos */\n    .card-body { padding: 0.75rem !important; }\n    .card-header { padding: 0.5rem 0.75rem; font-size: 0.85rem; }\n    \n    /* Botões pequenos */\n    .btn { font-size: 0.85rem; padding: 0.4rem 0.6rem; }\n    \n    /* Tabelas ainda menores */\n    .table { font-size: 0.8rem; }\n    .table th, .table td { padding: 0.4rem; }\n    \n    /* Formulários compactos */\n    .form-control, .form-select { font-size: 0.85rem; padding: 0.4rem; }\n    .form-label { font-size: 0.8rem; }\n    \n    /* Modais quase tela cheia */\n    .modal-dialog { margin: 0.25rem; max-width: calc(100% - 0.5rem); }\n    .modal-body { padding: 0.75rem; }\n    \n    /* Gráficos menores */\n    canvas { max-height: 200px !important; }\n}\n\n/* ============================================================\n   MELHORIAS ESPECÍFICAS PARA COMPONENTES\n============================================================ */\n\n/* Tornar selects e inputs sempre responsivos */\n.form-control,\n.form-select {\n    max-width: 100%;\n}\n\n/* Garantir que imagens não quebrem layout */\nimg {\n    max-width: 100%;\n    height: auto;\n}\n\n/* Ajustar nav-tabs em mobile */\n@media (max-width: 767.98px) {\n    .nav-tabs {\n        overflow-x: auto;\n        overflow-y: hidden;\n        flex-wrap: nowrap;\n        -webkit-overflow-scrolling: touch;\n    }\n    \n    .nav-tabs .nav-link {\n        white-space: nowrap;\n        font-size: 0.9rem;\n        padding: 0.5rem 1rem;\n    }\n}\n\n/* Melhorar visualização de cards de estatística */\n@media (max-width: 767.98px) {\n    .card h3 {\n        font-size: 1.5rem;\n    }\n    \n    .card .display-4 {\n        font-size: 2rem;\n    }\n    \n    .card .display-5 {\n        font-size: 1.5rem;\n    }\n}\n\n/* ============================================================\n   CARDS DE VENDEDOR - NOVO RELATÓRIO (ULTRA COMPACTO)\n============================================================ */\n.vendedor-card {\n    background: var(--content-bg);\n    border: 1px solid var(--border-color);\n    border-radius: 6px;\n    padding: 0.4rem 0.6rem;\n    margin-bottom: 0.4rem;\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n    transition: all 0.15s;\n}\n\n.vendedor-card:hover {\n    border-color: var(--accent-primary);\n}\n\n.vendedor-numero {\n    font-weight: 600;\n    font-size: 0.7rem;\n    color: var(--text-tertiary);\n    min-width: 18px;\n}\n\n.vendedor-card .form-control,\n.vendedor-card .form-select {\n    padding: 0.25rem 0.4rem;\n    font-size: 0.8rem;\n    height: 28px;\n    border-radius: 4px;\n}\n\n.vendedor-field {\n    display: flex;\n    flex-direction: column;\n    gap: 0.1rem;\n}\n\n.vendedor-field label {\n    font-size: 0.65rem;\n    margin: 0;\n    color: var(--text-tertiary);\n    line-height: 1;\n}\n\n.vendedor-field.vendedor-nome {\n    min-width: 160px;\n}\n\n.vendedor-field.vendedor-atend,\n.vendedor-field.vendedor-vendas {\n    width: 75px;\n}\n\n.vendedor-taxa-conversao {\n    padding: 0.2rem 0.5rem;\n    background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);\n    border-radius: 10px;\n    font-size: 0.7rem;\n    font-weight: 600;\n    color: white;\n    white-space: nowrap;\n    line-height: 1;\n}\n\n.btn-remove-vendedor {\n    background: none;\n    border: none;\n    color: var(--text-tertiary);\n    cursor: pointer;\n    padding: 0.2rem 0.3rem;\n    border-radius: 4px;\n    transition: all 0.15s;\n    font-size: 1.1rem;\n    line-height: 1;\n    margin-left: auto;\n}\n\n.btn-remove-vendedor:hover {\n    color: #dc2626;\n    background: rgba(220, 38, 38, 0.1);\n}\n\n[data-theme=\"dark\"] .btn-remove-vendedor:hover {\n    color: #fca5a5;\n}\n\n.vendedor-list-container {\n    overflow-y: auto;\n    max-height: 350px;\n}\n\n.vendedor-list-container::-webkit-scrollbar {\n    width: 3px;\n}\n\n.vendedor-list-container::-webkit-scrollbar-track {\n    background: transparent;\n}\n\n.vendedor-list-container::-webkit-scrollbar-thumb {\n    background: var(--border-color);\n    border-radius: 2px;\n}\n\n/* ============================================================\n   SCROLL MINIMALISTA PARA CARDS\n============================================================ */\n.scrollable-card-content {\n    overflow-y: auto;\n    max-height: 400px;\n}\n\n.scrollable-card-content::-webkit-scrollbar {\n    width: 4px;\n}\n\n.scrollable-card-content::-webkit-scrollbar-track {\n    background: transparent;\n}\n\n.scrollable-card-content::-webkit-scrollbar-thumb {\n    background: var(--border-color);\n    border-radius: 2px;\n    transition: background 0.2s ease;\n}\n\n.scrollable-card-content::-webkit-scrollbar-thumb:hover {\n    background: var(--accent-primary);\n}\n\n/* Para tabelas dentro de cards com scroll */\n.scrollable-table-wrapper {\n    overflow-y: auto;\n    max-height: 500px;\n}\n\n.scrollable-table-wrapper::-webkit-scrollbar {\n    width: 4px;\n}\n\n.scrollable-table-wrapper::-webkit-scrollbar-track {\n    background: transparent;\n}\n\n.scrollable-table-wrapper::-webkit-scrollbar-thumb {\n    background: var(--border-color);\n    border-radius: 2px;\n    transition: background 0.2s ease;\n}\n\n.scrollable-table-wrapper::-webkit-scrollbar-thumb:hover {\n    background: var(--accent-primary);\n}\n\n/* Custom scrollbar for assistance tickets container */\n#assist-tickets-container {\n    scrollbar-width: thin;\n    scrollbar-color: var(--border-color) transparent;\n}\n\n#assist-tickets-container::-webkit-scrollbar {\n    width: 8px;\n}\n\n#assist-tickets-container::-webkit-scrollbar-track {\n    background: transparent;\n    border-radius: 4px;\n}\n\n#assist-tickets-container::-webkit-scrollbar-thumb {\n    background: var(--border-color);\n    border-radius: 4px;\n    transition: background 0.3s ease;\n}\n\n#assist-tickets-container::-webkit-scrollbar-thumb:hover {\n    background: var(--accent-primary);\n}\n\n/* Responsivo */\n@media (max-width: 767.98px) {\n    .vendedor-card {\n        flex-wrap: wrap;\n        gap: 0.4rem;\n    }\n    \n    .vendedor-field.vendedor-nome,\n    .vendedor-field.vendedor-atend,\n    .vendedor-field.vendedor-vendas {\n        width: calc(50% - 0.2rem) !important;\n        min-width: auto !important;\n    }\n    \n    .scrollable-card-content {\n        max-height: 300px;\n    }\n    \n    .scrollable-table-wrapper {\n        max-height: 400px;\n    }\n    \n    #assist-tickets-container {\n        max-height: 300px !important;\n    }\n}","size_bytes":41703},"monitoramento-lojas-varejo-main/create-relatorio/public/js/pages/novo-relatorio.js":{"content":"import { showToast } from '../utils.js';\n\nexport function initNovoRelatorioPage() {\n    const form = document.getElementById('form-novo-relatorio');\n    if (!form) return;\n\n    // --- Seleção de Elementos ---\n    const btnImportarPdf = document.getElementById(\"btn-importar-pdf\");\n    const pdfFileInput = document.getElementById(\"pdf-file-input\");\n    const btnSalvarTudo = document.getElementById(\"btn-salvar-tudo\");\n    const btnLimparFormulario = document.getElementById(\"btn-limpar-formulario\");\n    const btnAddVendedor = document.getElementById(\"btn-add-vendedor\");\n    const containerVendedores = document.getElementById(\"container-vendedores\");\n    const placeholderVendedores = document.getElementById(\"vendedores-placeholder\");\n    const lojaSelect = document.getElementById(\"loja\");\n    const dataInput = document.getElementById(\"data\");\n    const resultadosPdfContainer = document.getElementById('resultados-pdf-container');\n    const totalVendasDinheiroInput = form.querySelector('[name=\"total_vendas_dinheiro\"]');\n    const ticketMedioInput = form.querySelector('[name=\"ticket_medio\"]');\n    const paInput = form.querySelector('[name=\"pa\"]');\n    const clientesMonitoramentoInput = document.getElementById('clientes_monitoramento_input');\n    const vendasMonitoramentoInput = document.getElementById('vendas_monitoramento_input');\n    const clientesLojaInput = document.getElementById('clientes_loja_input');\n    const vendasLojaInput = document.getElementById('vendas_loja_input');\n    const omniInput = document.getElementById('quantidade_omni_input');\n    const monitoramentoDonutCanvas = document.getElementById('monitoramento-donut-chart');\n    const lojaDonutCanvas = document.getElementById('loja-donut-chart');\n    \n    // ADICIONADO: Selecionar os novos inputs de pagamento\n    const vendasCartaoInput = document.getElementById('vendas_cartao_input');\n    const vendasPixInput = document.getElementById('vendas_pix_input');\n    const vendasDinheiroInput = document.getElementById('vendas_dinheiro_input');\n    const vendasTotalPagamentoInput = document.getElementById('vendas_total_pagamento_input');\n\n    // --- Variáveis de Estado ---\n    let lojasCache = [];\n    const urlParams = new URLSearchParams(window.location.search);\n    const reportId = urlParams.get('edit');\n    let monitoramentoDonutChart = null;\n    let lojaDonutChart = null;\n    const DRAFT_KEY = 'draftRelatorio';\n\n    // --- Funções de Gerenciamento de Rascunho ---\n    function salvarRascunho() {\n        if (reportId) return;\n        const formData = new FormData(form);\n        const data = Object.fromEntries(formData.entries());\n        const nomes = formData.getAll('vendedor_nome');\n        const atendimentos = formData.getAll('vendedor_atendimentos');\n        const vendas = formData.getAll('vendedor_vendas');\n        data.vendedores = nomes.map((nome, index) => ({ nome: nome.trim(), atendimentos: atendimentos[index] || 0, vendas: vendas[index] || 0 }));\n        data.pdfSectionVisible = resultadosPdfContainer.style.display === 'block';\n        sessionStorage.setItem(DRAFT_KEY, JSON.stringify(data));\n    }\n\n    function carregarRascunho() {\n        if (reportId) return;\n        const draft = sessionStorage.getItem(DRAFT_KEY);\n        if (!draft) return;\n        const data = JSON.parse(draft);\n        for (const key in data) {\n            const input = form.querySelector(`[name=\"${key}\"]`);\n            if (input && key !== 'vendedores') input.value = data[key];\n        }\n        if (data.vendedores && Array.isArray(data.vendedores)) {\n            containerVendedores.innerHTML = '';\n            data.vendedores.forEach(vendedor => adicionarVendedor(vendedor));\n        }\n        if (data.pdfSectionVisible && resultadosPdfContainer) {\n            resultadosPdfContainer.style.display = 'block';\n        }\n        updateVendedoresPlaceholder();\n        handleSelecaoDeLoja();\n        calcularEAtualizarGraficos();\n        calcularTotalVendasPagamento(); // Adicionado para atualizar o total ao carregar rascunho\n        showToast(\"Rascunho Carregado\", \"Seu relatório não salvo foi restaurado.\", \"info\");\n    }\n\n    function limparRascunhoEFormulario() {\n        form.reset();\n        sessionStorage.removeItem(DRAFT_KEY);\n        const hoje = new Date();\n        const offset = hoje.getTimezoneOffset();\n        dataInput.value = new Date(hoje.getTime() - (offset * 60 * 1000)).toISOString().split('T')[0];\n        containerVendedores.innerHTML = '';\n        if(resultadosPdfContainer) resultadosPdfContainer.style.display = 'none';\n        updateVendedoresPlaceholder();\n        handleSelecaoDeLoja();\n        calcularEAtualizarGraficos();\n        calcularTotalVendasPagamento(); // Adicionado para resetar o total ao limpar\n        showToast(\"Formulário Limpo\", \"Todos os campos foram resetados.\", \"success\");\n    }\n\n    // --- Funções de UI e Lógica ---\n    const getCssVar = (varName) => getComputedStyle(document.documentElement).getPropertyValue(varName).trim();\n    \n    function renderDonutChart(canvas, percentage, color) {\n        if (!canvas) return null;\n        const textElement = document.getElementById(canvas.id.replace('chart', 'text'));\n        if (textElement) textElement.textContent = `${parseFloat(percentage).toFixed(1)}%`;\n        const data = { datasets: [{ data: [percentage, 100 - percentage > 0 ? 100 - percentage : 0], backgroundColor: [color, '#333333'], borderColor: getCssVar('--content-bg'), borderWidth: 3, cutout: '75%' }] };\n        const options = { responsive: true, maintainAspectRatio: true, plugins: { legend: { display: false }, tooltip: { enabled: false } } };\n        const ctx = canvas.getContext('2d');\n        if (canvas.chart) canvas.chart.destroy();\n        canvas.chart = new Chart(ctx, { type: 'doughnut', data, options });\n        return canvas.chart;\n    }\n\n    function updateDonutChart(chartInstance, percentage) {\n        if (!chartInstance) return;\n        const textElement = document.getElementById(chartInstance.canvas.id.replace('chart', 'text'));\n        if (textElement) textElement.textContent = `${parseFloat(percentage).toFixed(1)}%`;\n        chartInstance.data.datasets[0].data[0] = percentage;\n        chartInstance.data.datasets[0].data[1] = 100 - percentage > 0 ? 100 - percentage : 0;\n        chartInstance.update();\n    }\n    \n    // ADICIONADO: Nova função para somar os totais de pagamento\n    function calcularTotalVendasPagamento() {\n        const cartao = Number(vendasCartaoInput.value) || 0;\n        const pix = Number(vendasPixInput.value) || 0;\n        const dinheiro = Number(vendasDinheiroInput.value) || 0;\n        vendasTotalPagamentoInput.value = cartao + pix + dinheiro;\n    }\n\n    function calcularEAtualizarGraficos() {\n        const clientesM = Number(clientesMonitoramentoInput.value) || 0;\n        const vendasM = Number(vendasMonitoramentoInput.value) || 0;\n        const omni = omniInput ? (Number(omniInput.value) || 0) : 0;\n        const totalVendasM = vendasM + omni;\n        const txMonitoramento = clientesM > 0 ? (totalVendasM / clientesM) * 100 : 0;\n        updateDonutChart(monitoramentoDonutChart, txMonitoramento);\n        \n        const clientesL = Number(clientesLojaInput.value) || 0;\n        const vendasL = Number(vendasLojaInput.value) || 0;\n        const txLoja = clientesL > 0 ? (vendasL / clientesL) * 100 : 0;\n        updateDonutChart(lojaDonutChart, txLoja);\n    }\n\n    function updateVendedoresPlaceholder() { if(placeholderVendedores) placeholderVendedores.style.display = containerVendedores.children.length === 0 ? \"block\" : \"none\"; };\n    \n    async function carregarLojas() {\n        try {\n            const response = await fetch(\"/api/lojas\");\n            if (!response.ok) throw new Error('Falha ao carregar lojas.');\n            lojasCache = await response.json();\n            lojaSelect.innerHTML = '<option value=\"\" disabled selected>Selecione uma loja</option>';\n            const lojasFiltradas = reportId ? lojasCache : lojasCache.filter(l => l.status === 'ativa');\n            lojasFiltradas.forEach(l => lojaSelect.add(new Option(l.nome, l.nome)));\n        } catch (e) { console.error(\"Erro ao carregar lojas\", e); }\n    }\n    \n    function handleSelecaoDeLoja() {\n        const lojaSelecionada = lojasCache.find(loja => loja.nome === lojaSelect.value);\n        const containerEspecial = document.getElementById('container-funcao-especial');\n        const campoOmni = document.getElementById('campo-omni');\n        const campoBuscaAssist = document.getElementById('campo-busca-assist');\n\n        if(containerEspecial) containerEspecial.style.display = \"none\";\n        if(campoOmni) campoOmni.style.display = \"none\";\n        if(campoBuscaAssist) campoBuscaAssist.style.display = \"none\";\n\n        if (!lojaSelecionada || !lojaSelecionada.funcao_especial) {\n            calcularEAtualizarGraficos();\n            return;\n        }\n        containerEspecial.style.display = \"block\";\n        if (lojaSelecionada.funcao_especial === \"Omni\") campoOmni.style.display = \"block\";\n        else if (lojaSelecionada.funcao_especial === \"Busca por Assist. Tec.\") campoBuscaAssist.style.display = \"block\";\n        \n        calcularEAtualizarGraficos();\n    }\n    \n    function adicionarVendedor(vendedor = { nome: '', atendimentos: 0, vendas: 0 }) {\n        const div = document.createElement(\"div\");\n        div.className = \"input-group input-group-sm mb-2\";\n        div.innerHTML = `<input type=\"text\" class=\"form-control\" name=\"vendedor_nome\" placeholder=\"Nome do Vendedor\" value=\"${vendedor.nome||''}\" required><input type=\"number\" class=\"form-control\" name=\"vendedor_atendimentos\" value=\"${vendedor.atendimentos||0}\" min=\"0\" title=\"Atendimentos\"><input type=\"number\" class=\"form-control\" name=\"vendedor_vendas\" value=\"${vendedor.vendas||0}\" min=\"0\" title=\"Vendas\"><button type=\"button\" class=\"btn btn-outline-danger\" data-action=\"remover-vendedor\"><i class=\"bi bi-trash\"></i></button>`;\n        containerVendedores.appendChild(div);\n        updateVendedoresPlaceholder();\n    }\n    \n    async function carregarDadosParaEdicao() {\n        showToast(\"Modo de Edição\", \"Carregando dados do relatório...\", \"info\");\n        await carregarLojas();\n        try {\n            const response = await fetch(`/api/relatorios/${reportId}`);\n            if (!response.ok) throw new Error('Relatório não encontrado.');\n            const { relatorio } = await response.json();\n\n            if(resultadosPdfContainer && relatorio.total_vendas_dinheiro && parseFloat(String(relatorio.total_vendas_dinheiro).replace(/[R$\\s.]/g, '').replace(',', '.')) > 0) {\n                resultadosPdfContainer.style.display = 'block';\n            }\n            \n            const vendedores = JSON.parse(relatorio.vendedores||'[]');\n            for (const key in relatorio) { \n                const input = form.querySelector(`[name=\"${key}\"]`); \n                if (input) input.value = relatorio[key]; \n            }\n            containerVendedores.innerHTML = '';\n            vendedores.forEach(vend => adicionarVendedor(vend));\n            \n            updateVendedoresPlaceholder();\n            handleSelecaoDeLoja();\n            btnSalvarTudo.textContent = 'SALVAR ALTERAÇÕES';\n            calcularEAtualizarGraficos();\n            calcularTotalVendasPagamento(); // Adicionado para calcular o total ao carregar para edição\n        } catch(e) { showToast(\"Erro\", \"Não foi possível carregar os dados para edição.\", \"danger\"); }\n    }\n    \n    async function handleSalvarTudo() {\n        if (!form.checkValidity()) { \n            form.reportValidity(); \n            showToast(\"Campos Inválidos\", \"Por favor, preencha todos os campos obrigatórios.\", \"danger\");\n            return;\n        }\n        \n        const fd = new FormData(form);\n        const data = Object.fromEntries(fd.entries());\n        const n = fd.getAll('vendedor_nome'), a = fd.getAll('vendedor_atendimentos'), v = fd.getAll('vendedor_vendas');\n        data.vendedores = JSON.stringify(n.map((nome, i) => ({ nome: nome.trim(), atendimentos: parseInt(a[i],10)||0, vendas: parseInt(v[i],10)||0 })).filter(vend => vend.nome));\n        \n        const method = reportId ? 'PUT' : 'POST';\n        const url = reportId ? `/api/relatorios/${reportId}` : '/api/relatorios';\n        \n        btnSalvarTudo.disabled = true;\n        btnSalvarTudo.innerHTML = '<span class=\"spinner-border spinner-border-sm me-2\"></span>Salvando...';\n        try {\n            const response = await fetch(url, { method, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) });\n            const result = await response.json();\n            if (!response.ok) throw new Error(result.error || 'Erro desconhecido ao salvar.');\n            showToast('Sucesso!', reportId ? 'Relatório atualizado com sucesso!' : 'Relatório salvo com sucesso!', 'success');\n            \n            if (reportId) {\n                setTimeout(() => window.location.href = '/consulta', 1000);\n            } else {\n                limparRascunhoEFormulario();\n            }\n        } catch (e) {\n            showToast('Falha ao Salvar', e.message, 'danger');\n        } finally {\n            btnSalvarTudo.disabled = false;\n            btnSalvarTudo.textContent = reportId ? 'SALVAR ALTERAÇÕES' : 'SALVAR RELATÓRIO COMPLETO';\n        }\n    }\n    \n    // --- Lógica de Importação de PDF ---\n    btnImportarPdf.addEventListener('click', () => pdfFileInput.click());\n    pdfFileInput.addEventListener('change', async (event) => {\n        const file = event.target.files[0];\n        if (!file) return;\n\n        btnImportarPdf.disabled = true;\n        btnImportarPdf.innerHTML = '<span class=\"spinner-border spinner-border-sm me-2\"></span>Processando...';\n\n        try {\n            const formData = new FormData();\n            formData.append('pdfFile', file);\n            const response = await fetch('/api/process-pdf', { method: 'POST', body: formData });\n            const result = await response.json();\n            if (!response.ok) throw new Error(result.error || 'Erro ao processar PDF.');\n            \n            const { data: extractedData } = result;\n            \n            // PREENCHIMENTO EXPLÍCITO CORRIGIDO\n            if (extractedData.total_vendas_dinheiro) totalVendasDinheiroInput.value = extractedData.total_vendas_dinheiro;\n            if (extractedData.ticket_medio) ticketMedioInput.value = extractedData.ticket_medio;\n            if (extractedData.pa) paInput.value = extractedData.pa;\n            if (extractedData.data) dataInput.value = extractedData.data;\n            if (extractedData.loja) {\n                const storeExists = Array.from(lojaSelect.options).some(option => option.text.trim().toUpperCase() === extractedData.loja.trim().toUpperCase());\n                if (storeExists) {\n                    lojaSelect.value = Array.from(lojaSelect.options).find(option => option.text.trim().toUpperCase() === extractedData.loja.trim().toUpperCase()).value;\n                } else {\n                    showToast(\"Atenção\", `A loja \"${extractedData.loja}\" do PDF não foi encontrada no sistema.`, \"danger\");\n                }\n            }\n            containerVendedores.innerHTML = '';\n            if (extractedData.vendedores && extractedData.vendedores.length > 0) {\n                extractedData.vendedores.forEach(vendedor => adicionarVendedor(vendedor));\n            }\n            \n            if(resultadosPdfContainer) resultadosPdfContainer.style.display = 'block';\n            \n            // ATUALIZAÇÃO DA UI\n            updateVendedoresPlaceholder();\n            handleSelecaoDeLoja();\n            calcularEAtualizarGraficos();\n            salvarRascunho();\n            showToast(\"Sucesso!\", \"Dados do PDF importados com sucesso.\", \"success\");\n\n        } catch (error) {\n            showToast(\"Erro na Importação\", error.message, \"danger\");\n        } finally {\n            btnImportarPdf.disabled = false;\n            btnImportarPdf.innerHTML = '<i class=\"bi bi-file-earmark-arrow-up-fill me-2\"></i>Importar de PDF';\n            pdfFileInput.value = '';\n        }\n    });\n\n    // --- Inicialização dos Event Listeners ---\n    btnAddVendedor.addEventListener(\"click\", () => adicionarVendedor());\n    btnSalvarTudo.addEventListener(\"click\", handleSalvarTudo);\n    btnLimparFormulario.addEventListener(\"click\", limparRascunhoEFormulario);\n    lojaSelect.addEventListener(\"change\", handleSelecaoDeLoja);\n\n    form.addEventListener('input', () => {\n        calcularEAtualizarGraficos();\n        salvarRascunho();\n    });\n\n    // ADICIONADO: Event listeners para os novos campos de pagamento\n    vendasCartaoInput.addEventListener('input', calcularTotalVendasPagamento);\n    vendasPixInput.addEventListener('input', calcularTotalVendasPagamento);\n    vendasDinheiroInput.addEventListener('input', calcularTotalVendasPagamento);\n\n    containerVendedores.addEventListener(\"click\", e => {\n        if (e.target.closest('button[data-action=\"remover-vendedor\"]')) {\n            e.target.closest(\".input-group\").remove();\n            updateVendedoresPlaceholder();\n            salvarRascunho();\n        }\n    });\n\n    // --- Lógica de Inicialização da Página ---\n    monitoramentoDonutChart = renderDonutChart(monitoramentoDonutCanvas, 0, getCssVar('--accent-color'));\n    lojaDonutChart = renderDonutChart(lojaDonutCanvas, 0, getCssVar('--color-success'));\n\n    if (reportId) {\n        document.querySelector('h4.mb-0').textContent = 'Editar Relatório Existente';\n        carregarDadosParaEdicao();\n    } else {\n        carregarLojas();\n        updateVendedoresPlaceholder();\n        carregarRascunho();\n    }\n}","size_bytes":17636},"monitoramento-lojas-varejo-main/create-relatorio/public/js/pages/consulta.js":{"content":"import { showToast, showConfirmModal } from '../utils.js';\n\nlet eventController;\n\nexport function initConsultaPage() {\n    \n    const formFiltros = document.getElementById('form-filtros-consulta');\n    const tableBody = document.getElementById('tabela-relatorios-corpo');\n    const filtroLoja = document.getElementById('filtro-loja');\n    const filtroInicio = document.getElementById('filtro-data-inicio');\n    const filtroFim = document.getElementById('filtro-data-fim');\n    // ADICIONADO: Seleção do novo filtro de ordem\n    const filtroOrdem = document.getElementById('filtro-ordem');\n    const btnLimpar = document.getElementById('btn-limpar-filtros');\n    const btnCarregarMais = document.getElementById('btn-carregar-mais');\n    const modalViewEl = document.getElementById('modal-visualizar-relatorio');\n    const pageContent = document.getElementById('page-content');\n\n    if (!formFiltros || !modalViewEl) return;\n    const modalView = new bootstrap.Modal(modalViewEl);\n\n    let currentOffset = 0;\n    const limit = 20;\n    let currentReportId = null;\n    let totalReportsCount = 0;\n\n    if (eventController) {\n        eventController.abort();\n    }\n    eventController = new AbortController();\n\n    async function carregarRelatorios(isNewSearch = true) {\n        if (isNewSearch) {\n            currentOffset = 0;\n            tableBody.innerHTML = '<tr><td colspan=\"5\" class=\"text-center\">Carregando...</td></tr>';\n        }\n        btnCarregarMais.disabled = true;\n        btnCarregarMais.innerHTML = '<span class=\"spinner-border spinner-border-sm\" role=\"status\" aria-hidden=\"true\"></span> Carregando...';\n\n        const params = new URLSearchParams();\n        if (filtroLoja.value) params.append('loja', filtroLoja.value);\n        if (filtroInicio.value) params.append('data_inicio', filtroInicio.value);\n        if (filtroFim.value) params.append('data_fim', filtroFim.value);\n        // ADICIONADO: Envio do parâmetro de ordenação para a API\n        params.append('sortOrder', filtroOrdem.value);\n        params.append('limit', limit);\n        params.append('offset', currentOffset);\n\n        try {\n            const response = await fetch(`/api/relatorios?${params.toString()}`);\n            const { relatorios, total } = await response.json();\n\n            if (isNewSearch) {\n                totalReportsCount = total;\n            }\n\n            const formatCurrency = (value) => {\n                const numberValue = Number(value) || 0;\n                return new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(numberValue);\n            };\n\n            const newRowsHtml = relatorios.map((r, index) => {\n                // ALTERAÇÃO: Lógica para criar um ID sequencial contínuo\n                const isDescending = filtroOrdem.value === 'desc';\n                const sequentialId = isDescending\n                    ? totalReportsCount - currentOffset - index\n                    : currentOffset + index + 1;\n\n                return `\n                    <tr>\n                        <td class=\"ps-3\">${sequentialId}</td>\n                        <td>${r.loja}</td>\n                        <td>${new Date(r.data).toLocaleDateString('pt-BR', {timeZone: 'UTC'})}</td>\n                        <td>${formatCurrency(r.total_vendas_dinheiro)}</td>\n                        <td class=\"text-end pe-3\">\n                            <div class=\"btn-group btn-group-sm\" role=\"group\">\n                                <button type=\"button\" class=\"btn btn-outline-primary\" data-action=\"visualizar\" data-id=\"${r.id}\" title=\"Visualizar\"><i class=\"bi bi-eye\"></i></button>\n                                <a href=\"/novo-relatorio?edit=${r.id}\" class=\"btn btn-outline-secondary\" title=\"Editar\"><i class=\"bi bi-pencil-fill\"></i></a>\n                                <button type=\"button\" class=\"btn btn-outline-danger\" data-action=\"excluir\" data-id=\"${r.id}\" title=\"Excluir\"><i class=\"bi bi-trash\"></i></button>\n                            </div>\n                        </td>\n                    </tr>\n                `;\n            }).join('');\n\n            if (isNewSearch) {\n                tableBody.innerHTML = relatorios.length > 0 ? newRowsHtml : '<tr><td colspan=\"5\" class=\"text-center\">Nenhum relatório encontrado.</td></tr>';\n            } else {\n                tableBody.insertAdjacentHTML('beforeend', newRowsHtml);\n            }\n\n            currentOffset += relatorios.length;\n            btnCarregarMais.classList.toggle('d-none', currentOffset >= totalReportsCount);\n\n        } catch (e) {\n            tableBody.innerHTML = '<tr><td colspan=\"5\" class=\"text-center text-danger\">Erro ao carregar relatórios.</td></tr>';\n        } finally {\n            btnCarregarMais.disabled = false;\n            btnCarregarMais.innerHTML = 'Carregar Mais Relatórios';\n        }\n    }\n\n    async function visualizarRelatorio(id) {\n        currentReportId = id;\n        const modalBody = document.getElementById('modal-body-content');\n        const modalLabel = document.getElementById('modal-visualizar-label');\n        modalLabel.textContent = `Carregando Relatório...`;\n        modalBody.innerHTML = '<div class=\"d-flex justify-content-center p-5\"><div class=\"spinner-border\" role=\"status\"></div></div>';\n        modalView.show();\n\n        try {\n            const response = await fetch(`/api/relatorios/${id}/pdf`);\n            if (!response.ok) throw new Error(\"Não foi possível gerar a visualização do PDF.\");\n            const fileBlob = await response.blob();\n            const fileURL = URL.createObjectURL(fileBlob);\n            modalLabel.textContent = `Visualizar Relatório #${id}`;\n            modalBody.innerHTML = `<iframe src=\"${fileURL}\" style=\"width: 100%; height: 70vh; border: none;\"></iframe>`;\n        } catch (e) {\n            modalBody.innerHTML = `<div class=\"p-3 text-center text-danger\"><h3>Oops!</h3><p>Não foi possível carregar a visualização.</p></div>`;\n            showToast('Erro', e.message, 'danger');\n        }\n    }\n\n    async function excluirRelatorio(id) {\n        const confirmed = await showConfirmModal(`Tem certeza que deseja excluir o relatório #${id}?`);\n        if (!confirmed) return;\n        try {\n            const response = await fetch(`/api/relatorios/${id}`, { method: 'DELETE' });\n            if (!response.ok) throw new Error('Falha ao excluir o relatório.');\n            showToast('Sucesso', 'Relatório excluído com sucesso.', 'success');\n            carregarRelatorios(true);\n        } catch (e) {\n            showToast('Erro', 'Não foi possível excluir o relatório.', 'danger');\n        }\n    }\n\n    async function carregarLojasNoFiltro() {\n        try {\n            const response = await fetch('/api/lojas');\n            const lojas = await response.json();\n            filtroLoja.innerHTML = '<option value=\"\">Todas as Lojas</option>';\n            lojas.forEach(loja => filtroLoja.add(new Option(loja.nome, loja.nome)));\n        } catch (e) {\n            console.error(\"Erro ao carregar lojas:\", e);\n        }\n    }\n    \n    // --- Event Listeners ---\n    document.getElementById('btn-copiar-texto-modal')?.addEventListener('click', async () => {\n    if (!currentReportId) return;\n    try {\n        const response = await fetch(`/api/relatorios/${currentReportId}/txt`);\n        if (!response.ok) throw new Error(\"Falha ao buscar texto para cópia.\");\n        const textToCopy = await response.text();\n        await navigator.clipboard.writeText(textToCopy);\n        showToast('Sucesso!', 'Texto copiado.', 'success');\n    } catch (err) {\n        showToast('Erro', 'Não foi possível copiar o texto.', 'danger');\n    }\n}, { signal: eventController.signal });\n\n    document.getElementById('btn-gerar-pdf-modal')?.addEventListener('click', () => {\n        if (!currentReportId) return;\n        window.open(`/api/relatorios/${currentReportId}/pdf`, '_blank');\n    }, { signal: eventController.signal });\n\n    formFiltros.addEventListener('submit', (e) => { e.preventDefault(); carregarRelatorios(true); }, { signal: eventController.signal });\n    \n    // ADICIONADO: Resetar o filtro de ordem ao limpar\n    btnLimpar.addEventListener('click', () => { \n        formFiltros.reset(); \n        filtroOrdem.value = 'desc'; // Garante que o padrão seja selecionado\n        carregarRelatorios(true); \n    }, { signal: eventController.signal });\n    \n    btnCarregarMais.addEventListener('click', () => carregarRelatorios(false), { signal: eventController.signal });\n\n    pageContent.addEventListener('click', (e) => {\n        const button = e.target.closest('button[data-action]');\n        if (!button || !button.closest('#tabela-relatorios-corpo')) return;\n        const id = button.dataset.id;\n        const action = button.dataset.action;\n        if (action === 'visualizar') visualizarRelatorio(id);\n        if (action === 'excluir') excluirRelatorio(id);\n    }, { signal: eventController.signal });\n    \n    // ADICIONADO: Event listener para o novo filtro de ordem\n    filtroOrdem.addEventListener('change', () => carregarRelatorios(true), { signal: eventController.signal });\n\n    const formExport = document.getElementById('form-export-excel');\n    const btnExportarTudo = document.getElementById('btn-exportar-tudo');\n\nbtnExportarTudo?.addEventListener('click', async () => {\n  btnExportarTudo.disabled = true;\n  const originalText = btnExportarTudo.innerHTML;\n  btnExportarTudo.innerHTML = `<span class=\"spinner-border spinner-border-sm\"></span> Gerando...`;\n\n  try {\n    const response = await fetch('/api/export/excel-all');\n    if (!response.ok) throw new Error(\"Erro ao gerar o arquivo.\");\n\n    const blob = await response.blob();\n    const url = window.URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `Relatorios_Completos_${new Date().toLocaleDateString('pt-BR')}.xlsx`;\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n    window.URL.revokeObjectURL(url);\n\n    showToast(\"Sucesso\", \"Arquivo de todos os relatórios gerado com sucesso!\", \"success\");\n  } catch (err) {\n    console.error(err);\n    showToast(\"Erro\", \"Não foi possível gerar o Excel completo.\", \"danger\");\n  } finally {\n    btnExportarTudo.disabled = false;\n    btnExportarTudo.innerHTML = originalText;\n  }\n});\n    const exportMonthSelect = document.getElementById('export-month');\n    const exportYearSelect = document.getElementById('export-year');\n    \n    if (exportYearSelect.options.length <= 1) {\n        const currentYear = new Date().getFullYear();\n        for (let i = 0; i < 5; i++) {\n            const year = currentYear - i;\n            exportYearSelect.add(new Option(year, year));\n        }\n    }\n    exportMonthSelect.value = new Date().getMonth() + 1;\n\n    formExport.addEventListener('submit', async (e) => {\n        e.preventDefault();\n        const btn = e.target.querySelector('button');\n        const originalText = btn.innerHTML;\n        btn.disabled = true;\n        btn.innerHTML = `<span class=\"spinner-border spinner-border-sm\"></span> Gerando...`;\n        \n        try {\n            const response = await fetch(`/api/export/excel?month=${exportMonthSelect.value}&year=${exportYearSelect.value}`);\n            if (response.ok) {\n                const blob = await response.blob();\n                const url = window.URL.createObjectURL(blob);\n                const a = document.createElement('a');\n                const monthName = new Date(exportYearSelect.value, exportMonthSelect.value - 1).toLocaleString('pt-BR', { month: 'long' });\n                a.download = `Relatorios_${monthName}_${exportYearSelect.value}.xlsx`;\n                a.href = url;\n                a.click();\n                window.URL.revokeObjectURL(url);\n            } else {\n                const result = await response.json();\n                showToast(\"Erro ao Exportar\", result.error || \"Não foi possível gerar.\", \"danger\");\n            }\n        } catch (err) {\n            showToast(\"Erro\", \"Falha na exportação.\", \"danger\");\n        } finally {\n            btn.disabled = false;\n            btn.innerHTML = originalText;\n        }\n    }, { signal: eventController.signal });\n\n    carregarLojasNoFiltro().then(() => carregarRelatorios(true));\n}","size_bytes":12214},"public/js/pages/gerenciar-usuarios.js":{"content":"import { showToast, showConfirmModal, getAuthHeaders } from '../utils.js';\n\nexport function initGerenciarUsuariosPage(currentUser) {\n    initUsuarios(currentUser);\n    initBackup();\n}\n\n// --- LÓGICA DE GERENCIAMENTO DE USUÁRIOS ---\nfunction initUsuarios(currentUser) {\n    const tableBody = document.getElementById('tabela-usuarios-corpo');\n    const btnAdicionar = document.getElementById('btn-adicionar-usuario');\n    const modalEl = document.getElementById('modal-usuario');\n    \n    if (!tableBody || !btnAdicionar || !modalEl) return;\n\n    const modal = new bootstrap.Modal(modalEl);\n    const modalForm = document.getElementById('form-usuario');\n    const modalTitle = document.getElementById('modalUsuarioLabel');\n    const roleSelect = document.getElementById('usuario-role');\n    const campoLojaGerente = document.getElementById('campo-loja-gerente');\n    const campoLojasConsultor = document.getElementById('campo-lojas-consultor');\n    const campoLojaTecnico = document.getElementById('campo-loja-tecnico');\n    const selectLojaGerente = document.getElementById('usuario-loja-gerente');\n    const selectLojasConsultor = document.getElementById('usuario-lojas-consultor');\n    const selectLojaTecnico = document.getElementById('usuario-loja-tecnico');\n    \n    let usuariosCache = [];\n    let lojasCache = [];\n\n    const roleNames = {\n        'gerente': 'Gerente',\n        'consultor': 'Consultor',\n        'monitoramento': 'Monitoramento',\n        'tecnico': 'Técnico',\n        'admin': 'Administrador',\n        'dev': 'Desenvolvedor'\n    };\n\n    async function carregarLojas() {\n        try {\n            const response = await fetch('/api/lojas');\n            if (!response.ok) throw new Error('Falha ao carregar lojas.');\n            lojasCache = await response.json();\n            \n            // Preencher selects\n            selectLojaGerente.innerHTML = '<option value=\"\">Selecione uma loja</option>' + \n                lojasCache.map(loja => `<option value=\"${loja.nome}\">${loja.nome}</option>`).join('');\n            \n            selectLojasConsultor.innerHTML = \n                lojasCache.map(loja => `<option value=\"${loja.nome}\">${loja.nome}</option>`).join('');\n            \n            selectLojaTecnico.innerHTML = '<option value=\"\">Selecione uma loja</option>' + \n                lojasCache.map(loja => `<option value=\"${loja.nome}\">${loja.nome}</option>`).join('');\n        } catch(e) {\n            console.error('Erro ao carregar lojas:', e);\n        }\n    }\n\n    function mostrarCamposLojas(role) {\n        campoLojaGerente.style.display = role === 'gerente' ? 'block' : 'none';\n        campoLojasConsultor.style.display = role === 'consultor' ? 'block' : 'none';\n        campoLojaTecnico.style.display = role === 'tecnico' ? 'block' : 'none';\n        \n        // Resetar valores ao mudar de role\n        if (role !== 'gerente') selectLojaGerente.value = '';\n        if (role !== 'consultor') {\n            Array.from(selectLojasConsultor.options).forEach(opt => opt.selected = false);\n        }\n        if (role !== 'tecnico') selectLojaTecnico.value = '';\n    }\n\n    roleSelect.addEventListener('change', (e) => {\n        mostrarCamposLojas(e.target.value);\n    });\n\n    async function carregarUsuarios() {\n        tableBody.innerHTML = '<tr><td colspan=\"5\" class=\"text-center\">Carregando...</td></tr>';\n        try {\n            const response = await fetch('/api/usuarios');\n            if (!response.ok) throw new Error('Falha ao carregar usuários.');\n            usuariosCache = await response.json();\n            \n            if (usuariosCache.length === 0) {\n                tableBody.innerHTML = '<tr><td colspan=\"5\" class=\"text-center\">Nenhum usuário cadastrado.</td></tr>';\n                return;\n            }\n            \n            tableBody.innerHTML = usuariosCache.map(user => {\n                const isCurrentUser = user.id === currentUser.id;\n                const deleteButton = isCurrentUser ? \n                    `<button class=\"btn btn-sm btn-outline-secondary\" disabled title=\"Não é possível excluir o próprio usuário\"><i class=\"bi bi-trash\"></i></button>` : \n                    `<button class=\"btn btn-sm btn-outline-danger\" data-action=\"excluir\" data-id=\"${user.id}\" title=\"Excluir\"><i class=\"bi bi-trash\"></i></button>`;\n                \n                // Determinar lojas vinculadas\n                let lojasVinculadas = '-';\n                if (user.role === 'gerente' && user.loja_gerente) {\n                    lojasVinculadas = `<span class=\"badge bg-info\">${user.loja_gerente}</span>`;\n                } else if (user.role === 'consultor' && user.lojas_consultor) {\n                    const lojas = user.lojas_consultor.split(',').filter(l => l);\n                    lojasVinculadas = lojas.map(l => `<span class=\"badge bg-info me-1\">${l.trim()}</span>`).join('');\n                } else if (user.role === 'tecnico' && user.loja_tecnico) {\n                    lojasVinculadas = `<span class=\"badge bg-info\">${user.loja_tecnico}</span>`;\n                }\n                \n                const roleBadgeColor = {\n                    'dev': 'bg-danger',\n                    'admin': 'bg-primary',\n                    'monitoramento': 'bg-success',\n                    'consultor': 'bg-warning',\n                    'gerente': 'bg-secondary',\n                    'tecnico': 'bg-secondary'\n                };\n                \n                return `<tr>\n                    <td class=\"ps-3\">${user.id}</td>\n                    <td>${user.username}</td>\n                    <td><span class=\"badge ${roleBadgeColor[user.role] || 'bg-secondary'}\">${roleNames[user.role] || user.role}</span></td>\n                    <td>${lojasVinculadas}</td>\n                    <td class=\"text-end pe-3\">\n                        <button class=\"btn btn-sm btn-outline-secondary\" data-action=\"editar\" data-id=\"${user.id}\" title=\"Editar\"><i class=\"bi bi-pencil\"></i></button>\n                        ${deleteButton}\n                    </td>\n                </tr>`;\n            }).join('');\n        } catch(e) {\n            tableBody.innerHTML = `<tr><td colspan=\"5\" class=\"text-center text-danger\">Erro ao carregar usuários.</td></tr>`;\n        }\n    }\n\n    function abrirModalParaAdicionar() {\n        modalForm.reset();\n        modalTitle.textContent = 'Adicionar Novo Usuário';\n        document.getElementById('usuario-id').value = '';\n        document.getElementById('usuario-password').required = true;\n        document.getElementById('usuario-password-label').textContent = 'Senha *';\n        \n        // Admin não pode criar Dev\n        const devOption = roleSelect.querySelector('option[value=\"dev\"]');\n        if (devOption) {\n            devOption.style.display = currentUser.role === 'admin' ? 'none' : 'block';\n        }\n        \n        mostrarCamposLojas('gerente'); // Padrão\n        modal.show();\n    }\n\n    function abrirModalParaEditar(id) {\n        const user = usuariosCache.find(u => u.id === id);\n        if (!user) return;\n        modalForm.reset();\n        modalTitle.textContent = 'Editar Usuário';\n        document.getElementById('usuario-id').value = user.id;\n        document.getElementById('usuario-username').value = user.username;\n        document.getElementById('usuario-role').value = user.role;\n        \n        // Admin não pode alterar para Dev\n        const devOption = roleSelect.querySelector('option[value=\"dev\"]');\n        if (devOption) {\n            devOption.style.display = currentUser.role === 'admin' ? 'none' : 'block';\n        }\n        \n        // Preencher lojas\n        if (user.role === 'gerente' && user.loja_gerente) {\n            selectLojaGerente.value = user.loja_gerente;\n        }\n        if (user.role === 'consultor' && user.lojas_consultor) {\n            const lojas = user.lojas_consultor.split(',').map(l => l.trim()).filter(l => l);\n            Array.from(selectLojasConsultor.options).forEach(opt => {\n                opt.selected = lojas.includes(opt.value);\n            });\n        }\n        if (user.role === 'tecnico' && user.loja_tecnico) {\n            selectLojaTecnico.value = user.loja_tecnico;\n        }\n        \n        mostrarCamposLojas(user.role);\n        document.getElementById('usuario-password').required = false;\n        document.getElementById('usuario-password-label').textContent = 'Nova Senha (deixe em branco para não alterar)';\n        modal.show();\n    }\n\n    async function excluirUsuario(id) {\n        const confirmed = await showConfirmModal(`Tem certeza que deseja excluir o usuário #${id}?`);\n        if (!confirmed) return;\n        try { \n            const response = await fetch(`/api/usuarios/${id}`, { \n                method: 'DELETE',\n                headers: await getAuthHeaders()\n            });\n            const result = await response.json();\n            if (!response.ok) throw new Error(result.error);\n            showToast('Sucesso', 'Usuário excluído com sucesso.', 'success');\n            carregarUsuarios();\n        } catch (e) {\n            showToast('Erro', e.message || 'Não foi possível excluir o usuário.', 'danger');\n        }\n    }\n    \n    modalForm.addEventListener('submit', async (e) => {\n        e.preventDefault();\n        const id = document.getElementById('usuario-id').value;\n        const role = document.getElementById('usuario-role').value;\n        \n        const data = { \n            username: document.getElementById('usuario-username').value,\n            password: document.getElementById('usuario-password').value,\n            role: role\n        };\n        \n        // Adicionar lojas baseado no role\n        if (role === 'gerente') {\n            data.loja_gerente = selectLojaGerente.value || null;\n            data.lojas_consultor = '';\n            data.loja_tecnico = null;\n        } else if (role === 'consultor') {\n            data.loja_gerente = null;\n            const lojasSelected = Array.from(selectLojasConsultor.selectedOptions).map(opt => opt.value);\n            data.lojas_consultor = lojasSelected;\n            data.loja_tecnico = null;\n        } else if (role === 'tecnico') {\n            data.loja_gerente = null;\n            data.lojas_consultor = '';\n            data.loja_tecnico = selectLojaTecnico.value || null;\n        } else {\n            data.loja_gerente = null;\n            data.lojas_consultor = '';\n            data.loja_tecnico = null;\n        }\n        \n        if (!data.password) delete data.password;\n        const method = id ? 'PUT' : 'POST';\n        const url = id ? `/api/usuarios/${id}` : '/api/usuarios';\n        \n        try {\n            const response = await fetch(url, { \n                method, \n                headers: await getAuthHeaders(), \n                body: JSON.stringify(data) \n            });\n            const result = await response.json();\n            if (!response.ok) throw new Error(result.error);\n            showToast('Sucesso', `Usuário ${id ? 'atualizado' : 'adicionado'} com sucesso.`, 'success');\n            modal.hide();\n            carregarUsuarios();\n        } catch(e) {\n            showToast('Erro', e.message || 'Não foi possível salvar o usuário.', 'danger');\n        }\n    });\n\n    btnAdicionar.addEventListener('click', abrirModalParaAdicionar);\n    \n    tableBody.addEventListener('click', (e) => {\n        const button = e.target.closest('button[data-action]');\n        if (!button) return;\n        const id = parseInt(button.dataset.id, 10);\n        const action = button.dataset.action;\n        if (action === 'editar') abrirModalParaEditar(id);\n        if (action === 'excluir') excluirUsuario(id);\n    });\n    \n    carregarLojas();\n    carregarUsuarios();\n}\n\n// --- LÓGICA DE BACKUP E RESTAURAÇÃO ---\nfunction initBackup() {\n    const dbSizeSpan = document.getElementById('db-size');\n    const btnLimparDb = document.getElementById('btn-limpar-db');\n    const btnRestaurarBackup = document.getElementById('btn-restaurar-backup');\n    const backupFileInput = document.getElementById('backup-file-input');\n\n    async function carregarInfoBackup() {\n        try {\n            const response = await fetch('/api/backup/info');\n            const data = await response.json();\n            dbSizeSpan.textContent = `${data.sizeMB} MB`;\n        } catch (error) {\n            dbSizeSpan.textContent = 'Erro ao carregar';\n            dbSizeSpan.classList.add('text-danger');\n        }\n    }\n\n    btnLimparDb.addEventListener('click', async () => {\n        const confirmed = await showConfirmModal('Você tem CERTEZA ABSOLUTA que deseja limpar todos os relatórios e demandas? Esta ação é IRREVERSÍVEL.');\n        if (!confirmed) return;\n\n        btnLimparDb.disabled = true;\n        btnLimparDb.innerHTML = '<span class=\"spinner-border spinner-border-sm\"></span> Limpando...';\n        try {\n            const response = await fetch('/api/backup/clear', { \n                method: 'DELETE',\n                headers: await getAuthHeaders()\n            });\n            const result = await response.json();\n            if (!response.ok) throw new Error(result.error);\n            showToast('Sucesso', 'Banco de dados limpo com sucesso.', 'success');\n            carregarInfoBackup();\n        } catch (error) {\n            showToast('Erro', error.message, 'danger');\n        } finally {\n            btnLimparDb.disabled = false;\n            btnLimparDb.innerHTML = '<i class=\"bi bi-trash3-fill me-2\"></i>Limpar Relatórios e Demandas';\n        }\n    });\n\n    backupFileInput.addEventListener('change', () => {\n        btnRestaurarBackup.disabled = !backupFileInput.files.length;\n    });\n\n    btnRestaurarBackup.addEventListener('click', async () => {\n        const file = backupFileInput.files[0];\n        if (!file) {\n            showToast('Atenção', 'Selecione um arquivo de backup (.db) primeiro.', 'info');\n            return;\n        }\n\n        const confirmed = await showConfirmModal('Você está prestes a SUBSTITUIR TODO o banco de dados atual. O sistema atual será perdido para sempre. Deseja continuar?');\n        if (!confirmed) return;\n\n        const formData = new FormData();\n        formData.append('backupFile', file);\n\n        btnRestaurarBackup.disabled = true;\n        btnRestaurarBackup.innerHTML = '<span class=\"spinner-border spinner-border-sm\"></span> Restaurando...';\n\n        try {\n            const response = await fetch('/api/backup/restore', {\n                method: 'POST',\n                body: formData\n            });\n            const result = await response.json();\n            if (!response.ok) throw new Error(result.error);\n            showToast('Sucesso!', result.message, 'success');\n            setTimeout(() => window.location.reload(), 2000);\n        } catch (error) {\n            showToast('Erro na Restauração', error.message, 'danger');\n            btnRestaurarBackup.disabled = false;\n            btnRestaurarBackup.innerHTML = '<i class=\"bi bi-upload me-2\"></i>Restaurar';\n        }\n    });\n    \n    carregarInfoBackup();\n}\n","size_bytes":14975},"monitoramento-lojas-varejo-main/create-relatorio/public/js/pages/gerenciar-lojas.js":{"content":"import { showToast, showConfirmModal } from '../utils.js';\n\nexport function initGerenciarLojasPage() {\n    const tableBody = document.getElementById('tabela-lojas-corpo');\n    const btnAdicionar = document.getElementById('btn-adicionar-loja');\n    const modalEl = document.getElementById('modal-loja');\n    \n    if (!tableBody || !btnAdicionar || !modalEl) return;\n    \n    const modal = new bootstrap.Modal(modalEl);\n    const modalForm = document.getElementById('form-loja');\n    const modalTitle = document.getElementById('modalLojaLabel');\n    let lojasCache = [];\n\n    async function carregarLojas() {\n        tableBody.innerHTML = '<tr><td colspan=\"5\" class=\"text-center\">Carregando...</td></tr>';\n        try {\n            const response = await fetch('/api/lojas');\n            lojasCache = await response.json();\n            if (lojasCache.length === 0) {\n                tableBody.innerHTML = '<tr><td colspan=\"5\" class=\"text-center\">Nenhuma loja cadastrada.</td></tr>';\n                return;\n            }\n            tableBody.innerHTML = lojasCache.map(loja => {\n                const statusBadge = loja.status === 'ativa' ? `<span class=\"badge bg-success\">Ativa</span>` : `<span class=\"badge bg-secondary\">Inativa</span>`;\n                return `<tr><td>${loja.nome}</td><td>${statusBadge}</td><td>${loja.funcao_especial || '-'}</td><td>${loja.observacoes || '-'}</td><td class=\"text-end pe-3\"><button class=\"btn btn-sm btn-outline-secondary\" data-action=\"editar\" data-id=\"${loja.id}\"><i class=\"bi bi-pencil\"></i></button> <button class=\"btn btn-sm btn-outline-danger\" data-action=\"excluir\" data-id=\"${loja.id}\"><i class=\"bi bi-trash\"></i></button></td></tr>`;\n            }).join('');\n        } catch (e) {\n            tableBody.innerHTML = '<tr><td colspan=\"5\" class=\"text-center text-danger\">Erro ao carregar.</td></tr>';\n        }\n    }\n\n    function abrirModalParaAdicionar() {\n        modalForm.reset();\n        modalTitle.textContent = 'Adicionar Nova Loja';\n        document.getElementById('loja-id').value = '';\n        modal.show();\n    }\n\n    function abrirModalParaEditar(id) {\n        const loja = lojasCache.find(l => l.id === id);\n        if (!loja) return;\n        modalForm.reset();\n        modalTitle.textContent = 'Editar Loja';\n        document.getElementById('loja-id').value = loja.id;\n        document.getElementById('loja-nome').value = loja.nome;\n        document.getElementById('loja-status').value = loja.status;\n        document.getElementById('loja-funcao-especial').value = loja.funcao_especial || '';\n        document.getElementById('loja-observacoes').value = loja.observacoes || '';\n        modal.show();\n    }\n\n    async function excluirLoja(id) {\n        const confirmed = await showConfirmModal(`Tem certeza que deseja excluir esta loja?`);\n        if (!confirmed) return;\n        try {\n            const response = await fetch(`/api/lojas/${id}`, { method: 'DELETE' });\n            if (!response.ok) throw new Error('Falha ao excluir.');\n            showToast('Sucesso', 'Loja excluída.', 'success');\n            carregarLojas();\n        } catch (e) {\n            showToast('Erro', 'Não foi possível excluir a loja.', 'danger');\n        }\n    }\n\n    modalForm.addEventListener('submit', async (e) => {\n        e.preventDefault();\n        const id = document.getElementById('loja-id').value;\n        const data = { nome: document.getElementById('loja-nome').value, status: document.getElementById('loja-status').value, funcao_especial: document.getElementById('loja-funcao-especial').value, observacoes: document.getElementById('loja-observacoes').value };\n        const method = id ? 'PUT' : 'POST';\n        const url = id ? `/api/lojas/${id}` : '/api/lojas';\n        try {\n            const response = await fetch(url, { method, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) });\n            if (!response.ok) throw new Error('Falha ao salvar. Nome já existe?');\n            showToast('Sucesso', `Loja salva.`, 'success');\n            modal.hide();\n            carregarLojas();\n        } catch(e) { showToast('Erro', e.message, 'danger'); }\n    });\n\n    btnAdicionar.addEventListener('click', abrirModalParaAdicionar);\n    tableBody.addEventListener('click', (e) => {\n        const button = e.target.closest('button[data-action]');\n        if (!button) return;\n        const id = parseInt(button.dataset.id, 10);\n        const action = button.dataset.action;\n        if (action === 'editar') abrirModalParaEditar(id);\n        if (action === 'excluir') excluirLoja(id);\n    });\n    carregarLojas();\n}","size_bytes":4587},"public/js/theme.js":{"content":"// ============================================================\n// GERENCIADOR DE TEMA DARK/LIGHT MODE\n// Inspirado no estilo Apple com transições suaves\n// ============================================================\n\nclass ThemeManager {\n    constructor() {\n        this.THEME_KEY = 'theme-preference';\n        this.currentTheme = this.getStoredTheme() || 'light';\n        this.init();\n    }\n\n    init() {\n        // Aplica tema inicial sem transição\n        document.documentElement.setAttribute('data-theme', this.currentTheme);\n        \n        // Aguarda o DOM estar pronto\n        if (document.readyState === 'loading') {\n            document.addEventListener('DOMContentLoaded', () => this.setupToggleButton());\n        } else {\n            this.setupToggleButton();\n        }\n    }\n\n    setupToggleButton() {\n        const toggleBtnDesktop = document.getElementById('theme-toggle-desktop');\n        const toggleBtnMobile = document.getElementById('theme-toggle-mobile');\n        \n        if (toggleBtnDesktop && !toggleBtnDesktop.dataset.themeInitialized) {\n            this.updateButtonIcon(toggleBtnDesktop);\n            toggleBtnDesktop.addEventListener('click', () => this.toggle());\n            toggleBtnDesktop.dataset.themeInitialized = 'true';\n        } else if (toggleBtnDesktop) {\n            // Apenas atualiza o ícone se já foi inicializado\n            this.updateButtonIcon(toggleBtnDesktop);\n        }\n        \n        if (toggleBtnMobile && !toggleBtnMobile.dataset.themeInitialized) {\n            this.updateButtonIcon(toggleBtnMobile);\n            toggleBtnMobile.addEventListener('click', () => this.toggle());\n            toggleBtnMobile.dataset.themeInitialized = 'true';\n        } else if (toggleBtnMobile) {\n            // Apenas atualiza o ícone se já foi inicializado\n            this.updateButtonIcon(toggleBtnMobile);\n        }\n    }\n\n    toggle() {\n        this.currentTheme = this.currentTheme === 'light' ? 'dark' : 'light';\n        document.documentElement.setAttribute('data-theme', this.currentTheme);\n        this.saveTheme();\n        this.updateAllButtons();\n    }\n\n    updateButtonIcon(button) {\n        const icon = button.querySelector('i');\n        if (icon) {\n            if (this.currentTheme === 'dark') {\n                icon.className = 'bi bi-sun-fill';\n            } else {\n                icon.className = 'bi bi-moon-fill';\n            }\n        }\n    }\n\n    updateAllButtons() {\n        const toggleBtnDesktop = document.getElementById('theme-toggle-desktop');\n        const toggleBtnMobile = document.getElementById('theme-toggle-mobile');\n        \n        if (toggleBtnDesktop) this.updateButtonIcon(toggleBtnDesktop);\n        if (toggleBtnMobile) this.updateButtonIcon(toggleBtnMobile);\n    }\n\n    getStoredTheme() {\n        return localStorage.getItem(this.THEME_KEY);\n    }\n\n    saveTheme() {\n        localStorage.setItem(this.THEME_KEY, this.currentTheme);\n    }\n\n    getTheme() {\n        return this.currentTheme;\n    }\n}\n\n// Inicializa o gerenciador de tema\nconst themeManager = new ThemeManager();\n\n// Exporta para uso global\nwindow.themeManager = themeManager;\n","size_bytes":3136},"server.js":{"content":"// =================================================================\n// SISTEMA DE FLUXO - teste\n// =================================================================\nrequire('dotenv').config();\nconst express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst path = require('path');\nconst session = require('express-session');\nconst fs = require('fs');\nconst crypto = require('crypto');\nconst PDFDocument = require('pdfkit');\nconst ExcelJS = require('exceljs');\nconst multer = require('multer');\nconst pdf = require('pdf-parse');\nconst bcrypt = require('bcrypt');\nconst helmet = require('helmet');\nconst rateLimit = require('express-rate-limit');\nconst { body, validationResult } = require('express-validator');\nconst { requireAuth, requireAuthPage, getLojaFilter, getPermissions } = require('./middleware/roleAuth');\nconst jwt = require('jsonwebtoken');\nconst DVRService = require('./services/dvrService');\n\nconst app = express();\nconst PORT = process.env.PORT || 5000;\n\napp.set('trust proxy', true);\n\nconst SESSION_SECRET = process.env.SESSION_SECRET || crypto.randomBytes(64).toString('hex');\nif (!process.env.SESSION_SECRET) {\n    console.warn('⚠️  ATENÇÃO: SESSION_SECRET não configurado. Usando um secret gerado automaticamente.');\n    console.warn('⚠️  Para produção, configure a variável de ambiente SESSION_SECRET.');\n}\n\nconst JWT_SECRET = process.env.JWT_SECRET || crypto.randomBytes(64).toString('hex');\nif (!process.env.JWT_SECRET) {\n    console.warn('⚠️  ATENÇÃO: JWT_SECRET não configurado. Usando um secret gerado automaticamente.');\n    console.warn('⚠️  Para produção, configure a variável de ambiente JWT_SECRET.');\n}\n\nconst DEV_TEMP_ACCESS_ENABLED = process.env.DEV_TEMP_ACCESS === 'true' && (process.env.NODE_ENV === 'development' || !process.env.NODE_ENV);\nif (DEV_TEMP_ACCESS_ENABLED) {\n    console.log('🔓 Acesso temporário de desenvolvimento HABILITADO');\n    console.warn('⚠️  ATENÇÃO: Desabilite DEV_TEMP_ACCESS antes de fazer deploy em produção!');\n} else {\n    console.log('🔒 Acesso temporário de desenvolvimento DESABILITADO');\n}\n\n// --- CONFIGURAÇÃO GERAL ---\nconst dataDir = path.join(__dirname, 'data');\nif (!fs.existsSync(dataDir)) {\n    fs.mkdirSync(dataDir, { recursive: true });\n}\n// Caminho configurável do banco de dados (pode ser sobrescrito por variável de ambiente)\nconst DB_FILENAME = process.env.DB_PATH || 'database.db';\nconst DB_PATH = path.join(dataDir, DB_FILENAME);\nconsole.log(`📁 Usando banco de dados: ${DB_PATH}`);\n\napp.use(helmet({\n    contentSecurityPolicy: {\n        directives: {\n            defaultSrc: [\"'self'\"],\n            scriptSrc: [\"'self'\", \"'unsafe-inline'\", \"https://cdn.jsdelivr.net\"],\n            styleSrc: [\"'self'\", \"'unsafe-inline'\", \"https://cdn.jsdelivr.net\", \"https://fonts.googleapis.com\"],\n            imgSrc: [\"'self'\", \"data:\", \"https:\"],\n            connectSrc: [\"'self'\"],\n            fontSrc: [\"'self'\", \"https://cdn.jsdelivr.net\", \"https://fonts.gstatic.com\"],\n            objectSrc: [\"'none'\"],\n            mediaSrc: [\"'self'\"],\n            frameSrc: [\"'self'\", \"blob:\"],\n        },\n    },\n    crossOriginEmbedderPolicy: false,\n}));\n\napp.use(express.static(path.join(__dirname, 'public')));\napp.use(express.urlencoded({ extended: true }));\napp.use(express.json());\napp.use(session({\n    secret: SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n    cookie: { \n        httpOnly: true, \n        secure: false,\n        sameSite: 'lax',\n        maxAge: 24 * 60 * 60 * 1000\n    },\n    name: 'sessionId',\n    proxy: true\n}));\n\n// --- CONFIGURAÇÃO DO MULTER ---\nconst upload = multer({ storage: multer.memoryStorage() });\n\n// --- MIDDLEWARES ---\nconst generateCsrfToken = () => crypto.randomBytes(32).toString('hex');\n\nconst csrfProtection = (req, res, next) => {\n    if (!req.session.csrfToken) {\n        req.session.csrfToken = generateCsrfToken();\n    }\n    next();\n};\n\nconst validateCsrf = (req, res, next) => {\n    // CSRF DESATIVADO - apenas passa adiante\n    next();\n};\n\nconst auditMiddleware = (req, res, next) => {\n    const mutatingMethods = ['POST', 'PUT', 'DELETE'];\n    \n    if (req.session && req.session.username) {\n        if (mutatingMethods.includes(req.method) && !req.path.includes('/api/login')) {\n            const action = `${req.method} ${req.path}`;\n            const details = `Ação executada por usuário autenticado`;\n            logEvent('audit', req.session.username, action, details, req);\n        }\n    }\n    next();\n};\n\n// CSRF DESATIVADO\n// app.use(csrfProtection);\napp.use(auditMiddleware);\n\nconst requirePageLogin = (req, res, next) => {\n    if (req.session && req.session.userId) {\n        return next();\n    }\n    res.redirect('/login');\n};\n\n// --- BANCO DE DADOS ---\nlet db = new sqlite3.Database(DB_PATH, err => {\n    if (err) {\n        return console.error(\"Erro fatal ao conectar ao DB:\", err.message);\n    }\n    console.log(\"Conectado ao banco de dados SQLite.\");\n    db.serialize(() => {\n        db.run(`CREATE TABLE IF NOT EXISTS usuarios (\n            id INTEGER PRIMARY KEY AUTOINCREMENT, \n            username TEXT UNIQUE NOT NULL, \n            password TEXT NOT NULL, \n            role TEXT NOT NULL,\n            loja_gerente TEXT,\n            lojas_consultor TEXT\n        )`);\n        db.run(`CREATE TABLE IF NOT EXISTS lojas (id INTEGER PRIMARY KEY AUTOINCREMENT, nome TEXT UNIQUE NOT NULL, status TEXT, funcao_especial TEXT, observacoes TEXT)`);\n        db.run(`CREATE TABLE IF NOT EXISTS relatorios (\n            id INTEGER PRIMARY KEY AUTOINCREMENT, loja TEXT, data TEXT, hora_abertura TEXT, hora_fechamento TEXT,\n            gerente_entrada TEXT, gerente_saida TEXT, clientes_monitoramento INTEGER, vendas_monitoramento INTEGER,\n            clientes_loja INTEGER, vendas_loja INTEGER, total_vendas_dinheiro REAL, ticket_medio TEXT, pa TEXT,\n            quantidade_trocas INTEGER, nome_funcao_especial TEXT, quantidade_funcao_especial INTEGER,\n            quantidade_omni INTEGER, vendedores TEXT, nome_arquivo TEXT, enviado_por_usuario TEXT,\n            enviado_em DATETIME DEFAULT CURRENT_TIMESTAMP, vendas_cartao INTEGER, vendas_pix INTEGER, vendas_dinheiro INTEGER\n        )`);\n        db.run(`CREATE TABLE IF NOT EXISTS demandas (id INTEGER PRIMARY KEY AUTOINCREMENT, loja_nome TEXT NOT NULL, descricao TEXT NOT NULL, tag TEXT DEFAULT 'Normal', status TEXT DEFAULT 'pendente', criado_por_usuario TEXT, concluido_por_usuario TEXT, criado_em DATETIME DEFAULT CURRENT_TIMESTAMP, concluido_em DATETIME)`);\n        db.run(`CREATE TABLE IF NOT EXISTS vendedores (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            loja_id INTEGER NOT NULL,\n            nome TEXT NOT NULL,\n            telefone TEXT NOT NULL,\n            data_entrada TEXT NOT NULL,\n            data_demissao TEXT,\n            previsao_entrada TEXT,\n            previsao_saida TEXT,\n            ativo INTEGER DEFAULT 1,\n            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n            FOREIGN KEY (loja_id) REFERENCES lojas(id) ON DELETE CASCADE\n        )`);\n        db.run(`CREATE TABLE IF NOT EXISTS logs (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\n            type TEXT NOT NULL,\n            username TEXT,\n            action TEXT,\n            details TEXT\n        )`);\n        \n        db.run(`CREATE TABLE IF NOT EXISTS temp_tokens (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            token_hash TEXT UNIQUE NOT NULL,\n            role TEXT DEFAULT 'dev',\n            expira_em DATETIME NOT NULL,\n            ip_origem TEXT,\n            ip_restrito TEXT,\n            revogado INTEGER DEFAULT 0,\n            criado_por TEXT,\n            criado_em DATETIME DEFAULT CURRENT_TIMESTAMP,\n            usado_em DATETIME,\n            revogado_em DATETIME,\n            revogado_por TEXT\n        )`);\n        \n        // Tabelas de Assistência Técnica\n        db.run(`CREATE TABLE IF NOT EXISTS estoque_tecnico (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            nome_peca TEXT NOT NULL,\n            codigo_interno TEXT UNIQUE NOT NULL,\n            quantidade INTEGER DEFAULT 0,\n            valor_custo REAL DEFAULT 0,\n            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n        )`);\n        \n        db.run(`CREATE TABLE IF NOT EXISTS assistencias (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            cliente_nome TEXT NOT NULL,\n            cliente_cpf TEXT NOT NULL,\n            numero_pedido TEXT,\n            data_entrada TEXT NOT NULL,\n            data_conclusao TEXT,\n            valor_peca_loja REAL DEFAULT 0,\n            valor_servico_cliente REAL DEFAULT 0,\n            aparelho TEXT NOT NULL,\n            peca_id INTEGER,\n            peca_nome TEXT,\n            observacoes TEXT,\n            status TEXT DEFAULT 'Em andamento',\n            tecnico_responsavel TEXT,\n            loja TEXT,\n            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n            FOREIGN KEY (peca_id) REFERENCES estoque_tecnico(id)\n        )`);\n        \n        // Tabela para armazenar PDFs de Ticket Dia\n        db.run(`CREATE TABLE IF NOT EXISTS pdf_tickets (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            loja TEXT NOT NULL,\n            data TEXT NOT NULL,\n            filename TEXT NOT NULL,\n            filepath TEXT NOT NULL,\n            uploaded_by TEXT NOT NULL,\n            uploaded_at DATETIME DEFAULT CURRENT_TIMESTAMP\n        )`);\n        \n        // Tabela para armazenar PDFs de Ranking\n        db.run(`CREATE TABLE IF NOT EXISTS pdf_rankings (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            loja TEXT NOT NULL,\n            data TEXT NOT NULL,\n            filename TEXT NOT NULL,\n            filepath TEXT NOT NULL,\n            pa TEXT,\n            preco_medio TEXT,\n            atendimento_medio TEXT,\n            uploaded_by TEXT,\n            uploaded_at DATETIME DEFAULT CURRENT_TIMESTAMP\n        )`);\n        \n        // Tabelas para Módulo DVR/NVR Intelbras\n        db.run(`CREATE TABLE IF NOT EXISTS dvr_dispositivos (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            nome TEXT NOT NULL,\n            loja_id INTEGER,\n            loja_nome TEXT,\n            ip_address TEXT NOT NULL,\n            porta INTEGER DEFAULT 37777,\n            usuario TEXT,\n            modelo TEXT,\n            canais_total INTEGER DEFAULT 0,\n            status TEXT DEFAULT 'offline',\n            ultima_conexao DATETIME,\n            observacoes TEXT,\n            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n            FOREIGN KEY (loja_id) REFERENCES lojas(id) ON DELETE SET NULL\n        )`);\n        \n        db.run(`CREATE TABLE IF NOT EXISTS dvr_logs (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            dvr_id INTEGER NOT NULL,\n            dvr_nome TEXT,\n            loja_nome TEXT,\n            tipo_evento TEXT NOT NULL,\n            descricao TEXT,\n            canal INTEGER,\n            severidade TEXT DEFAULT 'info',\n            data_hora DATETIME DEFAULT CURRENT_TIMESTAMP,\n            detalhes_json TEXT,\n            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n            FOREIGN KEY (dvr_id) REFERENCES dvr_dispositivos(id) ON DELETE CASCADE\n        )`);\n        \n        db.run(`CREATE TABLE IF NOT EXISTS dvr_arquivos (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            dvr_id INTEGER NOT NULL,\n            dvr_nome TEXT,\n            loja_nome TEXT,\n            tipo_arquivo TEXT NOT NULL,\n            nome_arquivo TEXT NOT NULL,\n            caminho_arquivo TEXT NOT NULL,\n            tamanho_bytes INTEGER,\n            data_geracao DATETIME,\n            canal INTEGER,\n            inicio_gravacao DATETIME,\n            fim_gravacao DATETIME,\n            descricao TEXT,\n            uploaded_by TEXT,\n            uploaded_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n            FOREIGN KEY (dvr_id) REFERENCES dvr_dispositivos(id) ON DELETE CASCADE\n        )`);\n        \n        // Adicionar colunas caso não existam (migração)\n        db.run(`ALTER TABLE usuarios ADD COLUMN loja_gerente TEXT`, (err) => {\n            if (err && !err.message.includes('duplicate column')) console.error('Erro ao adicionar loja_gerente:', err.message);\n        });\n        db.run(`ALTER TABLE usuarios ADD COLUMN lojas_consultor TEXT`, (err) => {\n            if (err && !err.message.includes('duplicate column')) console.error('Erro ao adicionar lojas_consultor:', err.message);\n        });\n        db.run(`ALTER TABLE usuarios ADD COLUMN loja_tecnico TEXT`, (err) => {\n            if (err && !err.message.includes('duplicate column')) console.error('Erro ao adicionar loja_tecnico:', err.message);\n        });\n        db.run(`ALTER TABLE lojas ADD COLUMN tecnico_username TEXT`, (err) => {\n            if (err && !err.message.includes('duplicate column')) console.error('Erro ao adicionar tecnico_username:', err.message);\n        });\n        db.run(`ALTER TABLE lojas ADD COLUMN cargo TEXT`, (err) => {\n            if (err && !err.message.includes('duplicate column')) console.error('Erro ao adicionar cargo:', err.message);\n        });\n        db.run(`ALTER TABLE lojas ADD COLUMN cep TEXT`, (err) => {\n            if (err && !err.message.includes('duplicate column')) console.error('Erro ao adicionar cep:', err.message);\n        });\n        db.run(`ALTER TABLE lojas ADD COLUMN numero_contato TEXT`, (err) => {\n            if (err && !err.message.includes('duplicate column')) console.error('Erro ao adicionar numero_contato:', err.message);\n        });\n        db.run(`ALTER TABLE lojas ADD COLUMN gerente TEXT`, (err) => {\n            if (err && !err.message.includes('duplicate column')) console.error('Erro ao adicionar gerente:', err.message);\n        });\n        db.run(`ALTER TABLE estoque_tecnico ADD COLUMN loja TEXT`, (err) => {\n            if (err && !err.message.includes('duplicate column')) console.error('Erro ao adicionar loja em estoque_tecnico:', err.message);\n        });\n        \n        db.run(`ALTER TABLE usuarios ADD COLUMN password_hashed INTEGER DEFAULT 0`, (err) => {\n            if (err && !err.message.includes('duplicate column')) console.error('Erro ao adicionar password_hashed:', err.message);\n        });\n        \n        db.run(`ALTER TABLE logs ADD COLUMN ip_address TEXT`, (err) => {\n            if (err && !err.message.includes('duplicate column')) console.error('Erro ao adicionar ip_address em logs:', err.message);\n        });\n        db.run(`ALTER TABLE logs ADD COLUMN user_agent TEXT`, (err) => {\n            if (err && !err.message.includes('duplicate column')) console.error('Erro ao adicionar user_agent em logs:', err.message);\n        });\n        db.run(`ALTER TABLE logs ADD COLUMN event_type TEXT`, (err) => {\n            if (err && !err.message.includes('duplicate column')) console.error('Erro ao adicionar event_type em logs:', err.message);\n        });\n        db.run(`ALTER TABLE logs ADD COLUMN route TEXT`, (err) => {\n            if (err && !err.message.includes('duplicate column')) console.error('Erro ao adicionar route em logs:', err.message);\n        });\n        db.run(`ALTER TABLE logs ADD COLUMN payload_hash TEXT`, (err) => {\n            if (err && !err.message.includes('duplicate column')) console.error('Erro ao adicionar payload_hash em logs:', err.message);\n        });\n        \n        // Adicionar coluna de permissões customizadas\n        db.run(`ALTER TABLE usuarios ADD COLUMN custom_permissions TEXT`, (err) => {\n            if (err && !err.message.includes('duplicate column')) console.error('Erro ao adicionar custom_permissions:', err.message);\n        });\n        \n        const adminUsername = 'admin';\n        const correctPassword = 'admin';\n        db.get('SELECT * FROM usuarios WHERE username = ?', [adminUsername], (err, row) => {\n            if (err) return;\n            if (!row) {\n                db.run('INSERT INTO usuarios (username, password, role) VALUES (?, ?, ?)', [adminUsername, correctPassword, 'admin']);\n            } else if (row.password !== correctPassword) {\n                db.run('UPDATE usuarios SET password = ? WHERE username = ?', [correctPassword, adminUsername]);\n            }\n        });\n    });\n});\n\n// Inicializar serviço DVR após conexão do banco\nlet dvrService;\nif (db) {\n    dvrService = new DVRService(db);\n}\n\n// =================================================================\n// SISTEMA DE TOKENS JWT TEMPORÁRIOS PARA DESENVOLVIMENTO\n// =================================================================\n\nfunction generateTempToken(expiresInHours = 1, ipRestricted = null) {\n    const tokenId = crypto.randomBytes(16).toString('hex');\n    const payload = {\n        tokenId,\n        role: 'dev',\n        type: 'temp_access',\n        iat: Math.floor(Date.now() / 1000)\n    };\n    \n    const token = jwt.sign(payload, JWT_SECRET, { \n        expiresIn: `${expiresInHours}h`,\n        issuer: 'dev-temp-access'\n    });\n    \n    const tokenHash = crypto.createHash('sha256').update(token).digest('hex');\n    \n    return { token, tokenHash, tokenId, expiresInHours };\n}\n\nfunction verifyTempToken(token) {\n    try {\n        const decoded = jwt.verify(token, JWT_SECRET, { \n            issuer: 'dev-temp-access' \n        });\n        return { valid: true, decoded };\n    } catch (error) {\n        return { valid: false, error: error.message };\n    }\n}\n\nasync function saveTempTokenToDb(tokenHash, expiresInHours, ipOrigem, ipRestrito, criadoPor) {\n    return new Promise((resolve, reject) => {\n        const expiraEm = new Date(Date.now() + expiresInHours * 60 * 60 * 1000).toISOString();\n        \n        db.run(\n            `INSERT INTO temp_tokens (token_hash, role, expira_em, ip_origem, ip_restrito, criado_por) \n             VALUES (?, ?, ?, ?, ?, ?)`,\n            [tokenHash, 'dev', expiraEm, ipOrigem, ipRestrito, criadoPor],\n            function(err) {\n                if (err) reject(err);\n                else resolve(this.lastID);\n            }\n        );\n    });\n}\n\nasync function validateTempTokenInDb(token, currentIp) {\n    return new Promise((resolve, reject) => {\n        const tokenHash = crypto.createHash('sha256').update(token).digest('hex');\n        \n        db.get(\n            `SELECT * FROM temp_tokens WHERE token_hash = ? AND revogado = 0 AND datetime(expira_em) > datetime('now')`,\n            [tokenHash],\n            (err, row) => {\n                if (err) return reject(err);\n                if (!row) return resolve({ valid: false, reason: 'Token não encontrado ou expirado' });\n                \n                if (row.ip_restrito && row.ip_restrito !== currentIp) {\n                    return resolve({ valid: false, reason: 'IP não autorizado' });\n                }\n                \n                db.run(\n                    `UPDATE temp_tokens SET usado_em = datetime('now') WHERE id = ?`,\n                    [row.id],\n                    (err) => {\n                        if (err) console.error('Erro ao atualizar usado_em:', err);\n                    }\n                );\n                \n                resolve({ valid: true, tokenData: row });\n            }\n        );\n    });\n}\n\nconst tempTokenAuthMiddleware = async (req, res, next) => {\n    const authHeader = req.headers.authorization;\n    \n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n        return next();\n    }\n    \n    const token = authHeader.substring(7);\n    \n    const jwtVerification = verifyTempToken(token);\n    if (!jwtVerification.valid) {\n        return res.status(401).json({ error: 'Token inválido ou expirado' });\n    }\n    \n    const currentIp = getClientIp(req);\n    const dbValidation = await validateTempTokenInDb(token, currentIp);\n    \n    if (!dbValidation.valid) {\n        logEvent('security', 'temp_token', 'token_rejected', dbValidation.reason, req);\n        return res.status(401).json({ error: dbValidation.reason });\n    }\n    \n    req.session.userId = -1;\n    req.session.username = 'temp_dev_access';\n    req.session.tempToken = true;\n    \n    logEvent('auth', 'temp_dev_access', 'temp_token_used', `Token temporário utilizado (IP: ${currentIp})`, req);\n    \n    next();\n};\n\nfunction getClientIp(req) {\n    return req.headers['x-forwarded-for']?.split(',')[0].trim() || \n           req.headers['x-real-ip'] || \n           req.connection?.remoteAddress || \n           req.socket?.remoteAddress ||\n           'unknown';\n}\n\napp.use(tempTokenAuthMiddleware);\n\n// --- ROTAS DE PÁGINAS ---\napp.get('/login', (req, res) => res.sendFile(path.join(__dirname, 'views', 'login.html')));\napp.get('/403', (req, res) => res.sendFile(path.join(__dirname, 'views', '403.html')));\napp.get('/live', requirePageLogin, (req, res) => res.sendFile(path.join(__dirname, 'views', 'live.html')));\n\n// Dashboard - todos podem acessar\napp.get(['/', '/admin'], requirePageLogin, (req, res) => {\n    res.sendFile(path.join(__dirname, 'views', 'index.html'));\n});\n\n// Consulta - todos podem acessar\napp.get('/consulta', requirePageLogin, (req, res) => {\n    res.sendFile(path.join(__dirname, 'views', 'index.html'));\n});\n\n// Novo Relatório - apenas monitoramento, admin e dev\napp.get('/novo-relatorio', requirePageLogin, (req, res) => {\n    res.sendFile(path.join(__dirname, 'views', 'index.html'));\n});\n\n// Lojas - todos exceto consultor (mas consultor pode via demandas)\napp.get('/gerenciar-lojas', requirePageLogin, (req, res) => {\n    res.sendFile(path.join(__dirname, 'views', 'index.html'));\n});\n\n// Demandas - todos podem acessar\napp.get('/demandas', requirePageLogin, (req, res) => {\n    res.sendFile(path.join(__dirname, 'views', 'index.html'));\n});\n\n// Gerenciar Usuários - apenas admin e dev\napp.get('/gerenciar-usuarios', requirePageLogin, (req, res) => {\n    res.sendFile(path.join(__dirname, 'views', 'index.html'));\n});\n\n// Logs - apenas dev\napp.get('/logs', requirePageLogin, (req, res) => {\n    res.sendFile(path.join(__dirname, 'views', 'index.html'));\n});\n\n// DVR/NVR Monitor - todos podem acessar\napp.get('/dvr-monitor', requirePageLogin, (req, res) => {\n    res.sendFile(path.join(__dirname, 'views', 'index.html'));\n});\n\n// Backup - apenas admin e dev\napp.get('/backup', requirePageLogin, (req, res) => {\n    res.sendFile(path.join(__dirname, 'views', 'index.html'));\n});\n\napp.get('/dev/system', requirePageLogin, (req, res) => {\n    logEvent('dev_access', req.session.username, 'system_access', 'Usuário acessou painel de sistema', req);\n    res.sendFile(path.join(__dirname, 'views', 'index.html'));\n});\n\napp.get('/content/:page', requirePageLogin, (req, res) => {\n    const allowedPages = ['admin', 'consulta', 'demandas', 'gerenciar-lojas', 'assistencia', 'alertas-tecnico', 'novo-relatorio', 'gerenciar-usuarios', 'logs', 'dvr-monitor'];\n    if (allowedPages.includes(req.params.page)) {\n        res.sendFile(path.join(__dirname, 'views', `${req.params.page}.html`));\n    } else {\n        res.status(404).send('Página não encontrada');\n    }\n});\n\n\n// --- ROTAS DE API ---\n\n// <<<---------------------------------------------------->>>\n// <<<                    leitura PDF                     >>>\n// <<<---------------------------------------------------->>>\napp.post('/api/process-pdf', requirePageLogin, upload.single('pdfFile'), async (req, res) => {\n    if (!req.file) {\n        return res.status(400).json({ error: \"Nenhum arquivo PDF enviado.\" });\n    }\n\n    try {\n        const data = await pdf(req.file.buffer);\n        const text = data.text;\n        const lines = text.split('\\n').map(line => line.trim()).filter(Boolean);\n\n        // Função para converter valores no formato \"1.234,56\" para número\n        const parseBrazilianNumber = (str) => {\n            if (!str) return 0;\n            return parseFloat(String(str).replace(/\\./g, '').replace(',', '.'));\n        };\n\n        let extractedData;\n\n        // VERIFICA O TIPO DE PDF\n        if (text.includes(\"Desempenho de vendedores\")) {\n            // --- LÓGICA PARA PDF TIPO OMNI ---\n            console.log(\"Processando PDF estilo Omni (Desempenho de vendedores)...\");\n\n            const linhaTotais = lines.find(l => l.startsWith('Totais:'));\n            if (!linhaTotais) {\n                throw new Error(\"Linha 'Totais:' não encontrada no PDF.\");\n            }\n\n            // Extrai todos os números da linha de totais\n            const valores = linhaTotais.replace('Totais:', '').trim().split(/\\s+/);\n            \n            // CORREÇÃO: Procura o cabeçalho para identificar as colunas corretamente\n            const headerLine = lines.find(l => l.includes('Peças/Venda') || l.includes('P.A'));\n            \n            // Mapeia os valores com validação melhorada\n            const vendas_loja = Math.round(parseBrazilianNumber(valores[1])); // Total de Vendas\n            \n            // CORREÇÃO PARA PA = 1: Procura por valores decimais pequenos (PA geralmente é entre 0.5 e 5.0)\n            let pa = parseBrazilianNumber(valores[2]); // Posição padrão\n            \n            // Validação: se o PA não está em um range razoável, procura no array\n            if (pa < 0.3 || pa > 10) {\n                // Procura um valor decimal entre 0.3 e 10 (range típico de PA)\n                for (let i = 0; i < valores.length; i++) {\n                    const valor = parseBrazilianNumber(valores[i]);\n                    if (valor >= 0.3 && valor <= 10 && valores[i].includes(',')) {\n                        pa = valor;\n                        console.log(`PA ajustado de ${valores[2]} para ${valores[i]} (valor: ${pa})`);\n                        break;\n                    }\n                }\n            }\n            \n            const total_vendas_dinheiro = parseBrazilianNumber(valores[3]); // Vl. Vendas\n            const ticket_medio = parseBrazilianNumber(valores[4]); // Ticket Médio\n            const clientes_loja = parseInt(valores[5], 10); // Abordagens\n\n            // Extrai dados \n            const storeNameMatch = text.match(/(\\d{1,}-\\d{6}-.+)/);\n            const storeName = storeNameMatch ? storeNameMatch[1].trim() : \"Loja não identificada\";\n            \n            const dateMatch = text.match(/Período: (\\d{2}\\/\\d{2}\\/\\d{4})/);\n            const reportDate = dateMatch ? new Date(dateMatch[1].split('/').reverse().join('-')).toISOString().split('T')[0] : null;\n\n            const vendorLines = lines.filter(line => line.match(/^\\d+\\s+.+\\s+\\(\\d+\\)/));\n            const vendedores = vendorLines.map(line => {\n                const nameMatch = line.match(/^\\d+\\s+(.*?)\\s+\\(\\d+\\)/);\n                const nome = nameMatch ? nameMatch[1].trim() : \"Desconhecido\";\n                \n                const statsPart = line.replace(nameMatch[0], '').trim();\n                const stats = statsPart.split(/\\s+/);\n                \n                const vendas = Math.round(parseBrazilianNumber(stats[1]));\n                const atendimentos = parseInt(stats[5], 10) || 0;\n                \n                return { nome, vendas, atendimentos };\n            });\n\n            extractedData = {\n                loja: storeName,\n                data: reportDate,\n                clientes_loja: clientes_loja,\n                vendas_loja: vendas_loja,\n                total_vendas_dinheiro: `R$ ${total_vendas_dinheiro.toFixed(2).replace('.', ',')}`,\n                ticket_medio: `R$ ${ticket_medio.toFixed(2).replace('.', ',')}`,\n                pa: pa.toFixed(2).replace('.', ','),\n                vendedores: vendedores\n            };\n\n        } else {\n            // --- LÓGICA PARA PDF TIPO BUSCA TÉCNICA ---\n            console.log(\"Processando PDF estilo Busca Técnica...\");\n            \n            const linhaTotais = lines.find(l => l.includes('Totais:'));\n            const idxTotais = lines.indexOf(linhaTotais);\n            const linhaDados = lines[idxTotais + 1] || '';\n            const linhaLimpa = linhaDados.replace(/(\\d{1,3})\\.(\\d{3},\\d{2})/g, '$1.$2 ').replace(/ +/g, ' ').trim();\n            const valoresTotais = linhaLimpa.match(/(\\d{1,3}(?:\\.\\d{3})*,\\d{2})|(\\d+\\.\\d{2})|(\\d+,\\d{2})|(\\d+)/g);\n            \n            if (!valoresTotais || valoresTotais.length < 7) {\n                throw new Error(\"Não foi possível extrair os valores corretamente da linha Totais do PDF.\");\n            }\n            \n            const totalVendasValor = parseBrazilianNumber(valoresTotais[0]);\n            \n            // CORREÇÃO PARA PA = 1: Busca valores decimais típicos de PA\n            let pa = parseBrazilianNumber(valoresTotais[valoresTotais.length - 4]); // Posição padrão\n            let ticketMedio = parseBrazilianNumber(valoresTotais[valoresTotais.length - 3]);\n            \n            // Validação inteligente do PA\n            // PA geralmente está entre 0.3 e 10, e tem formato decimal (ex: 1,00 ou 2,50)\n            const possiveisPAs = valoresTotais\n                .map((v, idx) => ({ valor: parseBrazilianNumber(v), original: v, index: idx }))\n                .filter(item => {\n                    // Filtra valores que parecem PA: decimal entre 0.3 e 10\n                    return item.valor >= 0.3 && item.valor <= 10 && \n                           (item.original.includes(',') || item.original.includes('.'));\n                });\n            \n            // Se encontrou candidatos a PA, pega o mais provável\n            if (possiveisPAs.length > 0 && (pa < 0.3 || pa > 10)) {\n                // Prefere valores próximos ao final do array (geralmente onde está o PA)\n                pa = possiveisPAs[possiveisPAs.length - 1].valor;\n                console.log(`PA ajustado para: ${pa} (encontrado em possiveisPAs)`);\n            }\n            \n            // Validação do Ticket Médio (geralmente é um valor maior, acima de 50 reais)\n            if (ticketMedio < 10) {\n                // Procura um valor maior que pareça ticket médio\n                const possivelTicket = valoresTotais\n                    .map(v => parseBrazilianNumber(v))\n                    .filter(v => v >= 10 && v <= 10000)\n                    .find(v => v > 50); // Ticket médio geralmente > 50 reais\n                \n                if (possivelTicket) {\n                    ticketMedio = possivelTicket;\n                    console.log(`Ticket médio ajustado para: ${ticketMedio}`);\n                }\n            }\n            \n            const linhaSplitada = linhaLimpa.split(' ');\n            const indexDoValorTotal = linhaSplitada.findIndex(v => v.includes(valoresTotais[0]));\n            const totalAtendimentos = parseInt(linhaSplitada[indexDoValorTotal + 2], 10) || 0;\n            \n            const storeNameMatch = text.match(/^\\s*\\d{3}\\s*-\\s*(.+)/m);\n            const storeName = storeNameMatch ? storeNameMatch[1].trim().replace(/\\s+STORE$/, \"\") : \"Loja não identificada\";\n            \n            const dateMatch = text.match(/Período de (\\d{2}\\/\\d{2}\\/\\d{4}) a (\\d{2}\\/\\d{2}\\/\\d{4})/);\n            const reportDate = dateMatch ? new Date(dateMatch[1].split('/').reverse().join('-')).toISOString().split('T')[0] : null;\n\n            const vendorLines = lines.filter(line => /^\\d+º/.test(line));\n            const vendedores = vendorLines.map(line => {\n                const vendorParts = line.trim().split(/\\s+/);\n                const nome = vendorParts.slice(2, -7).join(' ');\n                const atendimentos = parseInt(vendorParts[vendorParts.length - 4], 10) || 0;\n                return { nome, vendas: atendimentos, atendimentos };\n            });\n\n            extractedData = {\n                loja: storeName,\n                data: reportDate,\n                clientes_loja: totalAtendimentos,\n                vendas_loja: totalAtendimentos,\n                total_vendas_dinheiro: `R$ ${totalVendasValor.toFixed(2).replace('.', ',')}`,\n                ticket_medio: `R$ ${ticketMedio.toFixed(2).replace('.', ',')}`,\n                pa: pa.toFixed(2).replace('.', ','),\n                vendedores: vendedores\n            };\n        }\n\n        res.json({ success: true, data: extractedData });\n\n    } catch (error) {\n        console.error(\"### ERRO NO PROCESSAMENTO DO PDF ###\", error);\n        res.status(500).json({ error: error.message || \"Erro ao processar o PDF.\" });\n    }\n});\n// <<<---------------------------------------------------->>>\n// <<<          FIM DA API DE PDF                         >>>\n// <<<---------------------------------------------------->>>\n\n\n// APIs DE SESSÃO E USUÁRIOS\napp.get('/api/csrf-token', (req, res) => {\n    // Garantir que a sessão seja salva antes de retornar o token\n    if (!req.session.csrfToken) {\n        req.session.csrfToken = generateCsrfToken();\n    }\n    \n    console.log('🔐 Token CSRF gerado:', req.session.csrfToken.substring(0, 10) + '...');\n    console.log('🍪 Session ID:', req.sessionID);\n    \n    req.session.save((err) => {\n        if (err) {\n            console.error('❌ Erro ao salvar sessão CSRF:', err);\n            return res.status(500).json({ error: 'Erro ao gerar token de segurança' });\n        }\n        console.log('✓ Sessão CSRF salva com sucesso');\n        res.json({ csrfToken: req.session.csrfToken });\n    });\n});\n\nconst loginLimiter = rateLimit({\n    windowMs: 15 * 60 * 1000,\n    max: 50,\n    message: { message: 'Muitas tentativas de login. Tente novamente em 15 minutos.' },\n    standardHeaders: true,\n    legacyHeaders: false,\n    skip: () => true,\n});\n\napp.post('/api/login', loginLimiter, validateCsrf, async (req, res) => { \n    const { username, password } = req.body; \n    \n    if (!username || !password) {\n        logEvent('security', username || 'unknown', 'login_failed', 'Tentativa de login sem credenciais', req);\n        return res.status(400).json({ message: 'Username e senha são obrigatórios.' });\n    }\n    \n    db.get('SELECT * FROM usuarios WHERE username = ?', [username], async (err, user) => { \n        if (err) {\n            logEvent('error', username, 'login_error', `Erro no banco de dados: ${err.message}`, req);\n            return res.status(500).json({ message: 'Erro interno do servidor.' }); \n        }\n        \n        if (!user) {\n            logEvent('security', username, 'login_failed', 'Usuário não encontrado', req);\n            return res.status(401).json({ message: 'Credenciais inválidas.' }); \n        }\n        \n        try {\n            let passwordMatch = false;\n            \n            if (user.password_hashed === 1) {\n                passwordMatch = await bcrypt.compare(password, user.password);\n            } else {\n                passwordMatch = (user.password === password);\n                \n                if (passwordMatch) {\n                    const hashedPassword = await bcrypt.hash(password, 10);\n                    db.run('UPDATE usuarios SET password = ?, password_hashed = 1 WHERE id = ?', \n                        [hashedPassword, user.id], \n                        (err) => {\n                            if (err) console.error('Erro ao migrar senha para hash:', err.message);\n                            else console.log(`✓ Senha do usuário ${username} migrada para bcrypt`);\n                        }\n                    );\n                }\n            }\n            \n            if (!passwordMatch) {\n                logEvent('security', username, 'login_failed', 'Senha incorreta', req);\n                return res.status(401).json({ message: 'Credenciais inválidas.' }); \n            }\n            \n            req.session.userId = user.id; \n            req.session.username = user.username;\n            \n            req.session.save((err) => {\n                if (err) {\n                    console.error('❌ Erro ao salvar sessão:', err);\n                    logEvent('error', username, 'login_error', `Erro ao salvar sessão: ${err.message}`, req);\n                    return res.status(500).json({ message: 'Erro ao salvar sessão.' });\n                }\n                console.log(`✓ Login bem-sucedido - Usuário: ${user.username}, Session ID: ${req.sessionID}`);\n                logEvent('access', user.username, 'login_success', `Usuário ${user.username} fez login com sucesso`, req);\n                res.json({ success: true });\n            }); \n        } catch (error) {\n            logEvent('error', username, 'login_error', `Erro ao processar login: ${error.message}`, req);\n            res.status(500).json({ message: 'Erro ao processar login.' });\n        }\n    }); \n});\napp.get('/logout', (req, res) => { \n    const username = req.session?.username;\n    if (username) {\n        logEvent('access', username, 'logout', `Usuário ${username} fez logout`, req);\n    }\n    req.session.destroy(() => res.redirect('/login')); \n});\n\n// =================================================================\n// ENDPOINTS DE GERENCIAMENTO DE TOKENS TEMPORÁRIOS\n// =================================================================\n\napp.post('/api/dev/generate-temp-token', requirePageLogin, async (req, res) => {\n    if (!DEV_TEMP_ACCESS_ENABLED) {\n        return res.status(403).json({ \n            error: 'Acesso temporário desabilitado',\n            message: 'Configure DEV_TEMP_ACCESS=true em ambiente de desenvolvimento'\n        });\n    }\n    \n    try {\n        const { expiresInHours = 1, ipRestricted = null } = req.body;\n        \n        if (expiresInHours < 0.1 || expiresInHours > 24) {\n            return res.status(400).json({ \n                error: 'Validade inválida. Use entre 0.1 e 24 horas.' \n            });\n        }\n        \n        const currentIp = getClientIp(req);\n        const { token, tokenHash } = generateTempToken(expiresInHours, ipRestricted);\n        \n        await saveTempTokenToDb(\n            tokenHash, \n            expiresInHours, \n            currentIp, \n            ipRestricted, \n            req.session.username\n        );\n        \n        logEvent('security', req.session.username, 'temp_token_generated', \n            `Token temporário gerado (validade: ${expiresInHours}h, IP restrito: ${ipRestricted || 'não'})`, \n            req\n        );\n        \n        res.json({\n            success: true,\n            token,\n            expiresInHours,\n            ipRestricted,\n            usage: `Authorization: Bearer ${token}`,\n            warning: 'Este token tem acesso completo de desenvolvedor. Mantenha-o seguro!'\n        });\n    } catch (error) {\n        console.error('Erro ao gerar token temporário:', error);\n        logEvent('error', req.session.username, 'temp_token_error', error.message, req);\n        res.status(500).json({ error: 'Erro ao gerar token temporário' });\n    }\n});\n\napp.delete('/api/dev/revoke-temp-token', requirePageLogin, async (req, res) => {\n    if (!DEV_TEMP_ACCESS_ENABLED) {\n        return res.status(403).json({ error: 'Acesso temporário desabilitado' });\n    }\n    \n    try {\n        const { tokenId } = req.body;\n        \n        if (!tokenId) {\n            return res.status(400).json({ error: 'ID do token não fornecido' });\n        }\n        \n        db.run(\n            `UPDATE temp_tokens SET revogado = 1, revogado_em = datetime('now'), revogado_por = ? WHERE id = ?`,\n            [req.session.username, tokenId],\n            function(err) {\n                if (err) {\n                    console.error('Erro ao revogar token:', err);\n                    return res.status(500).json({ error: 'Erro ao revogar token' });\n                }\n                \n                if (this.changes === 0) {\n                    return res.status(404).json({ error: 'Token não encontrado' });\n                }\n                \n                logEvent('security', req.session.username, 'temp_token_revoked', \n                    `Token temporário #${tokenId} revogado manualmente`, \n                    req\n                );\n                \n                res.json({ success: true, message: 'Token revogado com sucesso' });\n            }\n        );\n    } catch (error) {\n        console.error('Erro ao revogar token:', error);\n        logEvent('error', req.session.username, 'temp_token_revoke_error', error.message, req);\n        res.status(500).json({ error: 'Erro ao revogar token' });\n    }\n});\n\napp.get('/api/dev/temp-tokens', requirePageLogin, (req, res) => {\n    if (!DEV_TEMP_ACCESS_ENABLED) {\n        return res.status(403).json({ error: 'Acesso temporário desabilitado' });\n    }\n    \n    db.all(\n        `SELECT id, role, expira_em, ip_origem, ip_restrito, revogado, criado_por, criado_em, usado_em, revogado_em, revogado_por \n         FROM temp_tokens \n         ORDER BY criado_em DESC \n         LIMIT 100`,\n        [],\n        (err, tokens) => {\n            if (err) {\n                console.error('Erro ao listar tokens:', err);\n                return res.status(500).json({ error: 'Erro ao listar tokens' });\n            }\n            \n            const tokensWithStatus = tokens.map(t => ({\n                ...t,\n                status: t.revogado ? 'revogado' : \n                       (new Date(t.expira_em) < new Date() ? 'expirado' : 'ativo')\n            }));\n            \n            res.json(tokensWithStatus);\n        }\n    );\n});\n\napp.get('/api/session-info', requirePageLogin, (req, res) => { \n    const permissions = getPermissions();\n    res.json({ \n        id: req.session.userId, \n        username: req.session.username,\n        permissions: permissions\n    });\n});\napp.get('/api/usuarios', requirePageLogin, (req, res) => { \n    db.all(\"SELECT id, username FROM usuarios ORDER BY username\", (err, users) => { \n        if (err) return res.status(500).json({ error: err.message }); \n        res.json(users || []); \n    }); \n});\napp.post('/api/usuarios', requirePageLogin, validateCsrf, async (req, res) => { \n    const { username, password } = req.body; \n    if (!username || !password) return res.status(400).json({ error: 'Username e senha são obrigatórios.' }); \n    \n    try {\n        const hashedPassword = await bcrypt.hash(password, 10);\n        \n        db.run('INSERT INTO usuarios (username, password, password_hashed) VALUES (?, ?, 1)', \n            [username, hashedPassword], \n            function (err) { \n                if (err) {\n                    logEvent('error', req.session.username, 'user_creation_failed', `Erro ao criar usuário ${username}: ${err.message}`, req);\n                    return res.status(500).json({ error: 'Erro ao criar usuário. O nome de usuário já pode existir.' }); \n                }\n                logEvent('admin', req.session.username, 'user_created', `Usuário ${username} criado`, req);\n                res.status(201).json({ success: true, id: this.lastID }); \n            }\n        );\n    } catch (error) {\n        logEvent('error', req.session.username, 'user_creation_error', `Erro ao hash senha: ${error.message}`, req);\n        res.status(500).json({ error: 'Erro ao processar senha.' });\n    }\n});\napp.put('/api/usuarios/:id', requirePageLogin, validateCsrf, async (req, res) => { \n    const { id } = req.params; \n    const { username, password } = req.body; \n    if (!username) return res.status(400).json({ error: 'Username é obrigatório.' }); \n    \n    try {\n        let sql, params;\n        \n        if (password) {\n            const hashedPassword = await bcrypt.hash(password, 10);\n            sql = 'UPDATE usuarios SET username = ?, password = ?, password_hashed = 1 WHERE id = ?';\n            params = [username, hashedPassword, id];\n        } else {\n            sql = 'UPDATE usuarios SET username = ? WHERE id = ?';\n            params = [username, id];\n        }\n        \n        db.run(sql, params, function (err) { \n            if (err) {\n                logEvent('error', req.session.username, 'user_update_failed', `Erro ao atualizar usuário ${username}: ${err.message}`, req);\n                return res.status(500).json({ error: 'Erro ao atualizar usuário.' }); \n            }\n            logEvent('admin', req.session.username, 'user_updated', `Usuário ${username} atualizado`, req);\n            res.json({ success: true }); \n        }); \n    } catch (error) {\n        logEvent('error', req.session.username, 'user_update_error', `Erro ao hash senha: ${error.message}`, req);\n        res.status(500).json({ error: 'Erro ao processar senha.' });\n    }\n});\napp.delete('/api/usuarios/:id', requirePageLogin, validateCsrf, (req, res) => { \n    const { id } = req.params; \n    if (id == req.session.userId) return res.status(403).json({ error: 'Não é permitido excluir o próprio usuário logado.' }); \n    db.run(\"DELETE FROM usuarios WHERE id = ?\", [id], function (err) { \n        if (err) return res.status(500).json({ error: 'Erro ao excluir usuário.' }); \n        if (this.changes === 0) return res.status(404).json({ error: \"Usuário não encontrado.\" }); \n        res.json({ success: true }); \n    }); \n});\n\n// APIs DE LOJAS \napp.get('/api/lojas', requirePageLogin, (req, res) => { \n    let whereClauses = []; \n    const params = []; \n    \n    // Aplicar filtro de lojas baseado no role\n    \n    if (req.query.status) { \n        whereClauses.push(\"status = ?\"); \n        params.push(req.query.status); \n    } \n    \n    const whereString = whereClauses.length > 0 ? \" WHERE \" + whereClauses.join(\" AND \") : \"\";\n    const query = \"SELECT * FROM lojas\" + whereString + \" ORDER BY nome\"; \n    console.log('SQL executado:', query);\n    console.log('Params:', params);\n    db.all(query, params, (err, lojas) => { \n        if (err) return res.status(500).json({ error: err.message }); \n        console.log('Lojas retornadas:', lojas.length);\n        if (lojas.length === 0 && params.length > 0) {\n            // Verificar lojas no banco\n            db.all('SELECT nome FROM lojas LIMIT 10', [], (err2, allLojas) => {\n                console.log('Primeiras 10 lojas no banco:', allLojas ? allLojas.map(l => l.nome) : []);\n            });\n        }\n        res.json(lojas || []); \n    }); \n});\napp.post('/api/lojas', requirePageLogin, (req, res) => { \n    const { nome, status, funcao_especial, tecnico_username, observacoes, cargo, cep, numero_contato, gerente } = req.body; \n    db.run('INSERT INTO lojas (nome, status, funcao_especial, tecnico_username, observacoes, cargo, cep, numero_contato, gerente) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)', \n        [nome, status, funcao_especial, tecnico_username, observacoes, cargo, cep, numero_contato, gerente], \n        function (err) { \n            if (err) return res.status(500).json({ error: 'Erro ao criar loja. O nome já pode existir.' }); \n            res.status(201).json({ success: true, id: this.lastID }); \n        }); \n});\napp.put('/api/lojas/:id', requirePageLogin, (req, res) => { \n    const { id } = req.params; \n    const { nome, status, funcao_especial, tecnico_username, observacoes, cargo, cep, numero_contato, gerente } = req.body; \n    db.run('UPDATE lojas SET nome = ?, status = ?, funcao_especial = ?, tecnico_username = ?, observacoes = ?, cargo = ?, cep = ?, numero_contato = ?, gerente = ? WHERE id = ?', \n        [nome, status, funcao_especial, tecnico_username, observacoes, cargo, cep, numero_contato, gerente, id], \n        function (err) { \n            if (err) return res.status(500).json({ error: 'Erro ao atualizar loja.' }); \n            res.json({ success: true }); \n        }); \n});\napp.delete('/api/lojas/:id', requirePageLogin, (req, res) => { db.run(\"DELETE FROM lojas WHERE id = ?\", [req.params.id], function (err) { if (err) return res.status(500).json({ error: 'Erro ao excluir loja.' }); if (this.changes === 0) return res.status(404).json({ error: \"Loja não encontrada.\" }); res.json({ success: true }); }); });\n\n// APIs DE VENDEDORES\napp.get('/api/vendedores', requirePageLogin, (req, res) => {\n    const { loja_id } = req.query;\n    \n    if (!loja_id) {\n        return res.status(400).json({ error: 'ID da loja é obrigatório.' });\n    }\n    \n    const query = `\n        SELECT v.*, l.nome as loja_nome \n        FROM vendedores v\n        INNER JOIN lojas l ON v.loja_id = l.id\n        WHERE v.loja_id = ?\n        ORDER BY v.ativo DESC, v.nome ASC\n    `;\n    \n    db.all(query, [loja_id], (err, vendedores) => {\n        if (err) {\n            console.error('Erro ao buscar vendedores:', err);\n            return res.status(500).json({ error: 'Erro ao buscar vendedores.' });\n        }\n        res.json(vendedores || []);\n    });\n});\n\napp.post('/api/vendedores', requirePageLogin, (req, res) => {\n    const { loja_id, nome, telefone, data_entrada, data_demissao, previsao_entrada, previsao_saida } = req.body;\n    \n    if (!loja_id || !nome || !telefone || !data_entrada) {\n        return res.status(400).json({ error: 'Campos obrigatórios: loja_id, nome, telefone, data_entrada' });\n    }\n    \n    const query = `\n        INSERT INTO vendedores (loja_id, nome, telefone, data_entrada, data_demissao, previsao_entrada, previsao_saida, ativo)\n        VALUES (?, ?, ?, ?, ?, ?, ?, 1)\n    `;\n    \n    db.run(query, [loja_id, nome, telefone, data_entrada, data_demissao || null, previsao_entrada || null, previsao_saida || null], function(err) {\n        if (err) {\n            console.error('Erro ao adicionar vendedor:', err);\n            return res.status(500).json({ error: 'Erro ao adicionar vendedor.' });\n        }\n        res.status(201).json({ success: true, id: this.lastID });\n    });\n});\n\napp.put('/api/vendedores/:id', requirePageLogin, (req, res) => {\n    const { id } = req.params;\n    const { nome, telefone, data_entrada, data_demissao, previsao_entrada, previsao_saida, ativo } = req.body;\n    \n    if (!nome || !telefone || !data_entrada) {\n        return res.status(400).json({ error: 'Campos obrigatórios: nome, telefone, data_entrada' });\n    }\n    \n    const query = `\n        UPDATE vendedores \n        SET nome = ?, telefone = ?, data_entrada = ?, data_demissao = ?, \n            previsao_entrada = ?, previsao_saida = ?, ativo = ?\n        WHERE id = ?\n    `;\n    \n    db.run(query, [nome, telefone, data_entrada, data_demissao || null, previsao_entrada || null, previsao_saida || null, ativo !== undefined ? ativo : 1, id], function(err) {\n        if (err) {\n            console.error('Erro ao atualizar vendedor:', err);\n            return res.status(500).json({ error: 'Erro ao atualizar vendedor.' });\n        }\n        if (this.changes === 0) {\n            return res.status(404).json({ error: 'Vendedor não encontrado.' });\n        }\n        res.json({ success: true });\n    });\n});\n\napp.delete('/api/vendedores/:id', requirePageLogin, (req, res) => {\n    const { id } = req.params;\n    \n    db.run(\"DELETE FROM vendedores WHERE id = ?\", [id], function(err) {\n        if (err) {\n            console.error('Erro ao excluir vendedor:', err);\n            return res.status(500).json({ error: 'Erro ao excluir vendedor.' });\n        }\n        if (this.changes === 0) {\n            return res.status(404).json({ error: 'Vendedor não encontrado.' });\n        }\n        res.json({ success: true });\n    });\n});\n\n// API de métricas agregadas para dashboard - suporta filtros independentes\napp.get('/api/dashboard/metrics', requirePageLogin, (req, res) => {\n    const { loja_monitoramento, loja_bluve } = req.query;\n    \n    // Query para Monitoramento\n    const queryMonit = loja_monitoramento ? `\n        SELECT \n            SUM(clientes_monitoramento) as total_clientes_monitoramento,\n            SUM(vendas_monitoramento) as total_vendas_monitoramento,\n            SUM(quantidade_omni) as total_omni\n        FROM relatorios\n        WHERE loja = ?\n    ` : `\n        SELECT \n            SUM(clientes_monitoramento) as total_clientes_monitoramento,\n            SUM(vendas_monitoramento) as total_vendas_monitoramento,\n            SUM(quantidade_omni) as total_omni\n        FROM relatorios\n    `;\n    const paramsMonit = loja_monitoramento ? [loja_monitoramento] : [];\n    \n    // Query para Bluve\n    const queryBluve = loja_bluve ? `\n        SELECT \n            SUM(clientes_loja) as total_clientes_loja,\n            SUM(vendas_loja) as total_vendas_loja\n        FROM relatorios\n        WHERE loja = ?\n    ` : `\n        SELECT \n            SUM(clientes_loja) as total_clientes_loja,\n            SUM(vendas_loja) as total_vendas_loja\n        FROM relatorios\n    `;\n    const paramsBluve = loja_bluve ? [loja_bluve] : [];\n    \n    // Executar ambas as queries\n    db.get(queryMonit, paramsMonit, (err1, rowMonit) => {\n        if (err1) {\n            console.error('Erro ao buscar métricas de Monitoramento:', err1);\n            return res.status(500).json({ error: err1.message });\n        }\n        \n        db.get(queryBluve, paramsBluve, (err2, rowBluve) => {\n            if (err2) {\n                console.error('Erro ao buscar métricas de Bluve:', err2);\n                return res.status(500).json({ error: err2.message });\n            }\n            \n            // Calcular métricas de Monitoramento\n            const clientesMonitoramento = parseInt(rowMonit.total_clientes_monitoramento) || 0;\n            const vendasMonitoramento = parseInt(rowMonit.total_vendas_monitoramento) || 0;\n            const omni = parseInt(rowMonit.total_omni) || 0;\n            const vendasMonitoramentoTotal = vendasMonitoramento + omni;\n            const txConversaoMonitoramento = clientesMonitoramento > 0 \n                ? ((vendasMonitoramentoTotal / clientesMonitoramento) * 100).toFixed(2)\n                : '0.00';\n            \n            // Calcular métricas de Bluve\n            const clientesLoja = parseInt(rowBluve.total_clientes_loja) || 0;\n            const vendasLoja = parseInt(rowBluve.total_vendas_loja) || 0;\n            const txConversaoLoja = clientesLoja > 0 \n                ? ((vendasLoja / clientesLoja) * 100).toFixed(2)\n                : '0.00';\n            \n            res.json({\n                monitoramento: {\n                    clientes: clientesMonitoramento,\n                    vendas: vendasMonitoramentoTotal,\n                    tx_conversao: txConversaoMonitoramento\n                },\n                bluve: {\n                    clientes: clientesLoja,\n                    vendas: vendasLoja,\n                    tx_conversao: txConversaoLoja\n                }\n            });\n        });\n    });\n});\n\n// APIs DE RELATÓRIOS\nconst processarRelatorio = (r) => { if (!r) return null; const vendas_monitoramento_total = (parseInt(r.vendas_monitoramento, 10) || 0) + (parseInt(r.quantidade_omni, 10) || 0); const tx_conversao_monitoramento = (parseInt(r.clientes_monitoramento, 10) || 0) > 0 ? (vendas_monitoramento_total / r.clientes_monitoramento) * 100 : 0; const tx_conversao_loja = (parseInt(r.clientes_loja, 10) || 0) > 0 ? ((parseInt(r.vendas_loja, 10) || 0) / r.clientes_loja) * 100 : 0; let vendedores_processados = []; try { const vendedores = JSON.parse(r.vendedores || '[]'); vendedores_processados = vendedores.map(v => ({ ...v, tx_conversao: (v.atendimentos > 0 ? ((v.vendas / v.atendimentos) * 100) : 0).toFixed(2) })); } catch (e) {} return { ...r, vendas_monitoramento_total, tx_conversao_monitoramento: tx_conversao_monitoramento.toFixed(2), tx_conversao_loja: tx_conversao_loja.toFixed(2), vendedores_processados }; };\napp.get('/api/relatorios', requirePageLogin, (req, res) => { \n    const whereClauses = []; \n    const params = []; \n    \n    // Aplicar filtro de lojas baseado no role\n    \n    if (req.query.loja) { \n        whereClauses.push(\"loja = ?\"); \n        params.push(req.query.loja); \n    } \n    if (req.query.data_inicio) { \n        whereClauses.push(\"data >= ?\"); \n        params.push(req.query.data_inicio); \n    } \n    if (req.query.data_fim) { \n        whereClauses.push(\"data <= ?\"); \n        params.push(req.query.data_fim); \n    } \n    const whereString = whereClauses.length > 0 ? \" WHERE \" + whereClauses.join(\" AND \") : \"\"; \n    const sortOrder = req.query.sortOrder === 'asc' ? 'ASC' : 'DESC'; \n    db.get(`SELECT COUNT(*) as total FROM relatorios` + whereString, params, (err, row) => { \n        if (err) return res.status(500).json({ error: err.message }); \n        const total = row ? row.total : 0; \n        const limit = parseInt(req.query.limit) || 20; \n        const offset = parseInt(req.query.offset) || 0; \n        const query = `SELECT id, loja, data, total_vendas_dinheiro FROM relatorios` + whereString + ` ORDER BY id ${sortOrder} LIMIT ? OFFSET ?`; \n        db.all(query, [...params, limit, offset], (err, relatorios) => { \n            if (err) return res.status(500).json({ error: err.message }); \n            res.json({ relatorios: relatorios || [], total }); \n        }); \n    }); \n});\napp.post('/api/relatorios', requirePageLogin, validateCsrf, (req, res) => { const d = req.body; const sql = `INSERT INTO relatorios (loja, data, hora_abertura, hora_fechamento, gerente_entrada, gerente_saida, clientes_monitoramento, vendas_monitoramento, clientes_loja, vendas_loja, total_vendas_dinheiro, ticket_medio, pa, quantidade_trocas, quantidade_omni, quantidade_funcao_especial, vendedores, enviado_por_usuario, vendas_cartao, vendas_pix, vendas_dinheiro) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)`; const params = [ d.loja, d.data, d.hora_abertura, d.hora_fechamento, d.gerente_entrada, d.gerente_saida, parseInt(d.clientes_monitoramento, 10) || 0, parseInt(d.vendas_monitoramento, 10) || 0, parseInt(d.clientes_loja, 10) || 0, parseInt(d.vendas_loja, 10) || 0, parseFloat(String(d.total_vendas_dinheiro).replace(/[R$\\s.]/g, '').replace(',', '.')) || 0, d.ticket_medio || 'R$ 0,00', d.pa || '0.00', parseInt(d.quantidade_trocas, 10) || 0, parseInt(d.quantidade_omni, 10) || 0, parseInt(d.quantidade_funcao_especial, 10) || 0, d.vendedores || '[]', req.session.username, parseInt(d.vendas_cartao, 10) || 0, parseInt(d.vendas_pix, 10) || 0, parseInt(d.vendas_dinheiro, 10) || 0 ]; db.run(sql, params, function (err) { if (err) { console.error(\"Erro ao inserir relatório:\", err.message); return res.status(500).json({ error: 'Falha ao salvar relatório.' }); } res.status(201).json({ success: true, id: this.lastID }); }); });\napp.get('/api/relatorios/:id', requirePageLogin, (req, res) => { db.get(\"SELECT * FROM relatorios WHERE id = ?\", [req.params.id], (err, relatorio) => { if (err) return res.status(500).json({ error: err.message }); if (!relatorio) return res.status(404).json({ error: \"Relatório não encontrado\" }); res.json({ relatorio }); }); });\napp.put('/api/relatorios/:id', requirePageLogin, validateCsrf, (req, res) => { const { id } = req.params; const d = req.body; const sql = `UPDATE relatorios SET loja=?, data=?, hora_abertura=?, hora_fechamento=?, gerente_entrada=?, gerente_saida=?, clientes_monitoramento=?, vendas_monitoramento=?, clientes_loja=?, vendas_loja=?, total_vendas_dinheiro=?, ticket_medio=?, pa=?, quantidade_trocas=?, quantidade_omni=?, quantidade_funcao_especial=?, vendedores=?, vendas_cartao=?, vendas_pix=?, vendas_dinheiro=? WHERE id=?`; const params = [ d.loja, d.data, d.hora_abertura, d.hora_fechamento, d.gerente_entrada, d.gerente_saida, parseInt(d.clientes_monitoramento, 10) || 0, parseInt(d.vendas_monitoramento, 10) || 0, parseInt(d.clientes_loja, 10) || 0, parseInt(d.vendas_loja, 10) || 0, parseFloat(String(d.total_vendas_dinheiro).replace(/[R$\\s.]/g, '').replace(',', '.')) || 0, d.ticket_medio || 'R$ 0,00', d.pa || '0.00', parseInt(d.quantidade_trocas, 10) || 0, parseInt(d.quantidade_omni, 10) || 0, parseInt(d.quantidade_funcao_especial, 10) || 0, d.vendedores || '[]', parseInt(d.vendas_cartao, 10) || 0, parseInt(d.vendas_pix, 10) || 0, parseInt(d.vendas_dinheiro, 10) || 0, id ]; db.run(sql, params, function (err) { if (err) { console.error(\"Erro ao atualizar relatório:\", err.message); return res.status(500).json({ error: 'Falha ao atualizar o relatório.' }); } if (this.changes === 0) return res.status(404).json({ error: \"Relatório não encontrado.\" }); res.json({ success: true, id: id }); }); });\napp.delete('/api/relatorios/:id', requirePageLogin, validateCsrf, (req, res) => { db.run(\"DELETE FROM relatorios WHERE id = ?\", [req.params.id], function (err) { if (err) return res.status(500).json({ error: err.message }); if (this.changes === 0) return res.status(404).json({ error: \"Relatório não encontrado\" }); res.json({ success: true, message: \"Relatório excluído.\" }); }); });\nconst formatCurrency = (value) => { const numberValue = Number(value) || 0; return new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(numberValue); };\n\n// Função para desenhar um gráfico de rosquinha (donut chart)\nfunction desenharGraficoRosquinha(doc, centerX, centerY, radius, dados, cores) {\n    const total = dados.reduce((sum, item) => sum + item.valor, 0);\n    if (total === 0) return;\n    \n    let startAngle = -Math.PI / 2;\n    const innerRadius = radius * 0.6;\n    \n    dados.forEach(item => {\n        const sliceAngle = (item.valor / total) * 2 * Math.PI;\n        const endAngle = startAngle + sliceAngle;\n        \n        doc.save();\n        doc.path('')\n           .moveTo(centerX, centerY)\n           .arc(centerX, centerY, radius, startAngle, endAngle, false)\n           .lineTo(centerX, centerY)\n           .fill(item.cor);\n        \n        doc.path('')\n           .moveTo(centerX, centerY)\n           .arc(centerX, centerY, innerRadius, startAngle, endAngle, false)\n           .lineTo(centerX, centerY)\n           .fill('#ffffff');\n        doc.restore();\n        \n        startAngle = endAngle;\n    });\n    \n    doc.fontSize(10).font('Helvetica-Bold').fillColor('#1f2937')\n       .text(`${total}`, centerX - 20, centerY - 5, { width: 40, align: 'center' });\n}\n\n// Função para gerar PDF do relatório com cores do sistema (laranja e cinza)\nfunction gerarRelatorioPDFProfissional(doc, r) {\n    const rp = processarRelatorio(r);\n    if (!rp) {\n        doc.fontSize(14).text('Erro ao processar relatório.');\n        return;\n    }\n    \n    const cores = {\n        laranja: '#ff9966',\n        cinza: '#6b7280',\n        cinzaClaro: '#f3f4f6',\n        cinzaEscuro: '#4b5563',\n        texto: '#1f2937',\n        branco: '#ffffff'\n    };\n    \n    const pageWidth = doc.page.width;\n    const pageHeight = doc.page.height;\n    const margin = 25;\n    const maxY = pageHeight - 25;\n    let y = 25;\n    \n    // === CABEÇALHO COM COR LARANJA ===\n    doc.rect(0, 0, pageWidth, 85).fill(cores.laranja);\n    doc.fontSize(24).font('Helvetica-Bold').fillColor(cores.branco)\n       .text(r.loja.toUpperCase(), margin, 22, { align: 'center', width: pageWidth - margin * 2 });\n    const dataFormatada = new Date(rp.data).toLocaleDateString('pt-BR', { timeZone: 'UTC' });\n    doc.fontSize(13).font('Helvetica').fillColor(cores.branco)\n       .text(`Relatório de ${dataFormatada}`, margin, 56, { align: 'center', width: pageWidth - margin * 2 });\n    \n    y = 100;\n    doc.fillColor(cores.texto);\n    \n    // === MÉTRICAS PRINCIPAIS (2 colunas maiores) + GRÁFICO ===\n    const colWidth = (pageWidth - margin * 2 - 12) / 3;\n    const metricHeight = 70;\n    \n    // TX. CONV. MONIT.\n    doc.roundedRect(margin, y, colWidth, metricHeight, 4).fillAndStroke(cores.cinzaClaro, cores.cinza);\n    doc.fontSize(11).font('Helvetica').fillColor(cores.cinza).text('TX. CONV. MONIT.', margin + 8, y + 10, { width: colWidth - 16 });\n    doc.fontSize(22).font('Helvetica-Bold').fillColor(cores.cinza).text(`${rp.tx_conversao_monitoramento}%`, margin + 8, y + 28);\n    doc.fontSize(9).font('Helvetica').fillColor(cores.cinzaEscuro).text(`${rp.clientes_monitoramento || 0} cli | ${rp.vendas_monitoramento_total || 0} vnd`, margin + 8, y + 55);\n    \n    // TX. CONV. LOJA\n    doc.roundedRect(margin + colWidth + 6, y, colWidth, metricHeight, 4).fillAndStroke(cores.cinzaClaro, cores.laranja);\n    doc.fontSize(11).font('Helvetica').fillColor(cores.cinza).text('TX. CONV. LOJA', margin + colWidth + 14, y + 10, { width: colWidth - 16 });\n    doc.fontSize(22).font('Helvetica-Bold').fillColor(cores.laranja).text(`${rp.tx_conversao_loja}%`, margin + colWidth + 14, y + 28);\n    doc.fontSize(9).font('Helvetica').fillColor(cores.cinzaEscuro).text(`${rp.clientes_loja || 0} cli | ${rp.vendas_loja || 0} vnd`, margin + colWidth + 14, y + 55);\n    \n    // GRÁFICO DE ROSQUINHA (Formas de Pagamento)\n    const graficoX = margin + colWidth * 2 + 12;\n    const graficoCenterX = graficoX + colWidth / 2;\n    const graficoCenterY = y + 28;\n    \n    const dadosGrafico = [\n        { valor: rp.vendas_cartao || 0, cor: cores.laranja, label: 'Cartão' },\n        { valor: rp.vendas_pix || 0, cor: '#60a5fa', label: 'Pix' },\n        { valor: rp.vendas_dinheiro || 0, cor: '#a78bfa', label: 'Dinheiro' }\n    ];\n    \n    // Título do gráfico\n    const totalVendasQtd = (rp.vendas_cartao || 0) + (rp.vendas_pix || 0) + (rp.vendas_dinheiro || 0);\n    doc.fontSize(9).font('Helvetica-Bold').fillColor(cores.cinza).text('PAGAMENTOS', graficoX, y + 4);\n    \n    // Desenhar gráfico maior e mais visível\n    desenharGraficoRosquinha(doc, graficoCenterX, graficoCenterY, 24, dadosGrafico, cores);\n    \n    // Legenda compacta abaixo do gráfico\n    let legendaY = y + 52;\n    dadosGrafico.forEach((item, idx) => {\n        doc.circle(graficoX + 8, legendaY + 3, 3).fill(item.cor);\n        doc.fontSize(7).font('Helvetica').fillColor(cores.texto)\n           .text(`${item.label}: ${item.valor}`, graficoX + 16, legendaY);\n        legendaY += 10;\n    });\n    \n    y += metricHeight + 12;\n    \n    // === TOTAL VENDAS (card maior e destacado) ===\n    doc.roundedRect(margin, y, (pageWidth - margin * 2) / 2 - 6, 65, 4).fillAndStroke(cores.cinzaClaro, cores.laranja);\n    doc.fontSize(11).font('Helvetica').fillColor(cores.cinza).text('TOTAL VENDAS', margin + 10, y + 10);\n    doc.fontSize(20).font('Helvetica-Bold').fillColor(cores.laranja).text(formatCurrency(rp.total_vendas_dinheiro), margin + 10, y + 30);\n    doc.fontSize(9).font('Helvetica').fillColor(cores.cinzaEscuro).text(`TM: ${rp.ticket_medio} | PA: ${rp.pa}`, margin + 10, y + 53);\n    \n    // === INFORMAÇÕES OPERACIONAIS ===\n    const infoX = margin + (pageWidth - margin * 2) / 2 + 6;\n    doc.fontSize(11).font('Helvetica-Bold').fillColor(cores.cinza).text('OPERACIONAL', infoX, y + 10);\n    y += 26;\n    \n    doc.fontSize(9).font('Helvetica').fillColor(cores.texto);\n    doc.text(`Abertura: ${rp.hora_abertura || '--:--'} - ${rp.hora_fechamento || '--:--'}`, infoX, y);\n    y += 13;\n    doc.text(`Gerente: ${rp.gerente_entrada || '--:--'} - ${rp.gerente_saida || '--:--'}`, infoX, y);\n    y += 13;\n    doc.text(`Trocas: ${rp.quantidade_trocas || 0} | Total: ${totalVendasQtd}`, infoX, y);\n    if (rp.funcao_especial === \"Omni\") {\n        y += 13;\n        doc.text(`Omni: ${rp.quantidade_omni || 0}`, infoX, y);\n    } else if (rp.funcao_especial === \"Busca por Assist. Tec.\") {\n        y += 13;\n        doc.text(`Assist. Tec.: ${rp.quantidade_funcao_especial || 0}`, infoX, y);\n    }\n    \n    y = 100 + metricHeight + 14 + 65 + 18;\n    \n    // === DESEMPENHO DA EQUIPE ===\n    doc.fontSize(13).font('Helvetica-Bold').fillColor(cores.laranja).text('DESEMPENHO DA EQUIPE', margin, y);\n    y += 20;\n    \n    if (rp.vendedores_processados && rp.vendedores_processados.length > 0) {\n        const colX = [margin, margin + 220, margin + 330, margin + 420, margin + 500];\n        const headerHeight = 24;\n        const rowHeight = 20;\n        \n        // Cabeçalho\n        doc.roundedRect(margin, y, pageWidth - margin * 2, headerHeight, 3).fill(cores.laranja);\n        doc.fontSize(11).font('Helvetica-Bold').fillColor(cores.branco);\n        doc.text('VENDEDOR', colX[0] + 6, y + 8, { width: 210 });\n        doc.text('ATEND.', colX[1] + 6, y + 8);\n        doc.text('VENDAS', colX[2] + 6, y + 8);\n        doc.text('TX. CONV.', colX[3] + 6, y + 8);\n        y += headerHeight;\n        \n        // Calcular quantos vendedores cabem\n        const spaceLeft = maxY - y - 18;\n        const maxRows = Math.floor(spaceLeft / rowHeight);\n        const numVendedores = Math.min(rp.vendedores_processados.length, maxRows);\n        \n        // Renderizar vendedores\n        for (let i = 0; i < numVendedores; i++) {\n            const v = rp.vendedores_processados[i];\n            const bgColor = i % 2 === 0 ? cores.branco : cores.cinzaClaro;\n            doc.rect(margin, y, pageWidth - margin * 2, rowHeight).fill(bgColor);\n            doc.fontSize(9).font('Helvetica').fillColor(cores.texto);\n            doc.text(v.nome || 'N/A', colX[0] + 6, y + 6, { width: 210 });\n            doc.text(String(v.atendimentos || 0), colX[1] + 6, y + 6);\n            doc.text(String(v.vendas || 0), colX[2] + 6, y + 6);\n            doc.fontSize(9).font('Helvetica-Bold').fillColor(parseFloat(v.tx_conversao) >= 50 ? '#10b981' : cores.laranja);\n            doc.text(`${v.tx_conversao}%`, colX[3] + 6, y + 6);\n            y += rowHeight;\n        }\n        \n        if (rp.vendedores_processados.length > numVendedores) {\n            doc.fontSize(8).font('Helvetica').fillColor(cores.cinza)\n               .text(`... e mais ${rp.vendedores_processados.length - numVendedores} vendedores`, margin, y + 5);\n        }\n    } else {\n        doc.fontSize(10).font('Helvetica').fillColor(cores.cinza)\n           .text('Nenhum vendedor registrado.', margin, y);\n    }\n    \n    // === RODAPÉ ===\n    doc.fontSize(9).font('Helvetica').fillColor(cores.cinza)\n       .text(`Gerado em ${new Date().toLocaleDateString('pt-BR')}`, margin, maxY, { align: 'left' });\n}\n\nconst formatarRelatorioTexto = (r) => { const rp = processarRelatorio(r); if (!rp) return \"Erro ao processar relatório.\"; let equipeInfo = 'Nenhum vendedor registrado.\\n'; if (rp.vendedores_processados && rp.vendedores_processados.length > 0) { equipeInfo = rp.vendedores_processados.map(v => { return `${v.nome}: ${v.atendimentos} Atendimentos / ${v.vendas} Vendas / ${v.tx_conversao}%`; }).join('\\n'); } let funcaoEspecialInfo = ''; if (rp.funcao_especial === \"Omni\") { funcaoEspecialInfo = `Omni: ${rp.quantidade_omni || 0}\\n`; } else if (rp.funcao_especial === \"Busca por Assist. Tec.\") { funcaoEspecialInfo = `Busca por assist tec: ${rp.quantidade_funcao_especial || 0}\\n`; } const totalVendasQuantidade = (rp.vendas_cartao || 0) + (rp.vendas_pix || 0) + (rp.vendas_dinheiro || 0); const content = ` DATA: ${new Date(rp.data).toLocaleDateString('pt-BR', { timeZone: 'UTC' })} \\n\\nClientes: ${rp.clientes_monitoramento || 0}\\nBluve: ${rp.clientes_loja || 0}\\nVendas / Monitoramento: ${rp.vendas_monitoramento_total || 0}\\nVendas / Loja: ${rp.vendas_loja || 0}\\nTaxa de conversão da loja: ${rp.tx_conversao_loja || '0.00'}%\\nTaxa de conversão do monitoramento: ${rp.tx_conversao_monitoramento || '0.00'}%\\n\\nAbertura: ${rp.hora_abertura || '--:--'} - ${rp.hora_fechamento || '--:--'}\\nGerente: ${rp.gerente_entrada || '--:--'} - ${rp.gerente_saida || '--:--'}\\nVendas em Cartão: ${rp.vendas_cartao || 0}\\nVendas em Pix: ${rp.vendas_pix || 0}\\nVendas em Dinheiro: ${rp.vendas_dinheiro || 0}\\n${funcaoEspecialInfo}Total vendas: ${totalVendasQuantidade}\\nTroca/Devolução: ${rp.quantidade_trocas || 0}\\n\\nDesempenho Equipe:\\n\\n${equipeInfo}\\n\\nTM: ${rp.ticket_medio || 'R$ 0,00'} / P.A: ${rp.pa || '0.00'} / Total: ${formatCurrency(rp.total_vendas_dinheiro)} / `; return content.trim(); };\napp.get('/api/relatorios/:id/txt', requirePageLogin, (req, res) => { const sql = ` SELECT r.*, l.funcao_especial FROM relatorios r LEFT JOIN lojas l ON r.loja = l.nome WHERE r.id = ? `; db.get(sql, [req.params.id], (err, r) => { if (err || !r) return res.status(404).send('Relatório não encontrado'); res.setHeader('Content-disposition', `attachment; filename=relatorio_${r.loja.replace(/ /g, '_')}_${r.data}.txt`); res.setHeader('Content-type', 'text/plain; charset=utf-8'); res.send(formatarRelatorioTexto(r)); }); });\napp.get('/api/relatorios/:id/pdf', requirePageLogin, (req, res) => { \n    const sql = ` SELECT r.*, l.funcao_especial FROM relatorios r LEFT JOIN lojas l ON r.loja = l.nome WHERE r.id = ? `; \n    db.get(sql, [req.params.id], (err, r) => { \n        if (err || !r) return res.status(404).send('Relatório não encontrado'); \n        const doc = new PDFDocument({ margin: 50, size: 'A4' }); \n        res.setHeader('Content-disposition', `inline; filename=\"relatorio_${r.loja.replace(/ /g, '_')}_${r.data}.pdf\"`); \n        res.setHeader('Content-type', 'application/pdf'); \n        doc.pipe(res); \n        gerarRelatorioPDFProfissional(doc, r);\n        doc.end(); \n    }); \n});\n\n// =================================================================\n// ROTAS DE PROCESSAMENTO DE PDF\n// =================================================================\n\n// Configuração do multer para upload de PDFs\nconst pdfStorage = multer.memoryStorage();\nconst pdfUpload = multer({\n    storage: pdfStorage,\n    limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit\n    fileFilter: (req, file, cb) => {\n        if (file.mimetype === 'application/pdf') {\n            cb(null, true);\n        } else {\n            cb(new Error('Apenas arquivos PDF são permitidos'));\n        }\n    }\n});\n\n// Função auxiliar para extrair dados do PDF de Ranking\nfunction extractRankingData(pdfText) {\n    const lines = pdfText.split('\\n').map(l => l.trim()).filter(l => l);\n    \n    // Extrair nome da loja (formato: \"103 - LOFT ITAGUAÇU STORE\")\n    let lojaMatch = null;\n    for (const line of lines) {\n        const match = line.match(/^\\d+\\s*-\\s*(.+?)(?:\\s+Emissão:|\\s+Ranking)/);\n        if (match) {\n            lojaMatch = match[1].trim();\n            break;\n        }\n    }\n    \n    // Extrair período/data (formato: \"Período de 04/11/2025 a 04/11/2025\")\n    let dataMatch = null;\n    for (const line of lines) {\n        const match = line.match(/Período de (\\d{2}\\/\\d{2}\\/\\d{4})/);\n        if (match) {\n            const [dia, mes, ano] = match[1].split('/');\n            dataMatch = `${ano}-${mes}-${dia}`; // Formato ISO\n            break;\n        }\n    }\n    \n    // Procurar linha de \"Totais:\" e extrair valores\n    // No PDF real, a linha é: \"     Totais:\\n1.109,00       0,00         0,00 %       3,33 %      1.109,00      10         4          2,50         110,90   277,25\"\n    let pa = null, precoMedio = null, atendimentoMedio = null;\n    \n    for (let i = 0; i < lines.length; i++) {\n        // Procurar linha que contém \"Totais:\"\n        if (lines[i].includes('Totais:')) {\n            // Verificar se os valores estão na mesma linha ou na linha seguinte\n            let dataLine = lines[i];\n            \n            // Se a linha só tem \"Totais:\", pegar a próxima linha\n            if (dataLine.trim() === 'Totais:') {\n                dataLine = lines[i + 1] || '';\n            }\n            \n            // Extrair todos os números no formato brasileiro\n            // Formato: \\d{1,3}(?:\\.\\d{3})*(?:,\\d+)? captura números como 1.109,00 ou 2,50 ou 10\n            // Ex: \"1.109,00 0,00 0,00 % 3,33 % 1.109,00 10 4 2,50 110,90 277,25\"\n            const numberPattern = /\\d{1,3}(?:\\.\\d{3})*(?:,\\d+)?/g;\n            const numbers = dataLine.match(numberPattern);\n            \n            if (numbers && numbers.length >= 3) {\n                // Os últimos 3 valores são: PA, Preço Médio, Atendimento Médio\n                // Converter formato brasileiro (1.000,50) para formato padrão (1000.50)\n                const convertBrazilianNumber = (num) => {\n                    return num.replace(/\\./g, '').replace(',', '.');\n                };\n                \n                pa = convertBrazilianNumber(numbers[numbers.length - 3]);\n                precoMedio = convertBrazilianNumber(numbers[numbers.length - 2]);\n                atendimentoMedio = convertBrazilianNumber(numbers[numbers.length - 1]);\n            }\n            break;\n        }\n    }\n    \n    return {\n        loja: lojaMatch,\n        data: dataMatch,\n        pa: pa,\n        preco_medio: precoMedio,\n        atendimento_medio: atendimentoMedio\n    };\n}\n\n// POST /api/pdf/ranking - Processa e salva PDF de ranking\napp.post('/api/pdf/ranking', requirePageLogin, pdfUpload.single('pdf'), async (req, res) => {\n    try {\n        if (!req.file) {\n            return res.status(400).json({ error: 'Nenhum arquivo PDF foi enviado' });\n        }\n        \n        const { loja, data } = req.body;\n        \n        if (!loja || !data) {\n            return res.status(400).json({ error: 'Loja e data são obrigatórios' });\n        }\n        \n        // Extrair texto do PDF\n        const pdfData = await pdf(req.file.buffer);\n        const pdfText = pdfData.text;\n        \n        // Extrair dados do PDF\n        const extractedData = extractRankingData(pdfText);\n        \n        // Validar se a loja corresponde\n        if (extractedData.loja && !loja.includes(extractedData.loja) && !extractedData.loja.includes(loja)) {\n            return res.status(400).json({\n                error: 'O PDF selecionado não corresponde à loja atual.',\n                pdfLoja: extractedData.loja,\n                lojaAtual: loja\n            });\n        }\n        \n        // Validar se a data corresponde\n        if (extractedData.data && extractedData.data !== data) {\n            return res.status(400).json({\n                error: 'O PDF selecionado não corresponde à data atual.',\n                pdfData: extractedData.data,\n                dataAtual: data\n            });\n        }\n        \n        // Verificar se conseguiu extrair os valores\n        if (!extractedData.pa || !extractedData.preco_medio || !extractedData.atendimento_medio) {\n            return res.status(400).json({\n                error: 'Não foi possível extrair os dados do PDF. Verifique se o arquivo está no formato correto.',\n                extracted: extractedData\n            });\n        }\n        \n        // Criar diretório se não existir\n        const rankingsDir = path.join(__dirname, 'data', 'pdfs', 'rankings');\n        if (!fs.existsSync(rankingsDir)) {\n            fs.mkdirSync(rankingsDir, { recursive: true });\n        }\n        \n        // Gerar nome do arquivo\n        const timestamp = Date.now();\n        const lojaSafe = loja.replace(/[^a-zA-Z0-9]/g, '_');\n        const filename = `ranking_${lojaSafe}_${data}_${timestamp}.pdf`;\n        const filepath = path.join(rankingsDir, filename);\n        \n        // Salvar arquivo\n        fs.writeFileSync(filepath, req.file.buffer);\n        \n        // Registrar no banco de dados\n        const sql = `INSERT INTO pdf_rankings (loja, data, filename, filepath, pa, preco_medio, atendimento_medio, uploaded_by, uploaded_at) \n                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, datetime('now'))`;\n        \n        db.run(sql, [loja, data, filename, filepath, extractedData.pa, extractedData.preco_medio, extractedData.atendimento_medio, req.session.username], function(err) {\n            if (err) {\n                console.error('Erro ao registrar PDF no banco:', err);\n                try {\n                    fs.unlinkSync(filepath);\n                } catch (e) {}\n                return res.status(500).json({ error: 'Erro ao salvar registro do PDF' });\n            }\n            \n            res.json({\n                success: true,\n                message: 'PDF de ranking salvo com sucesso',\n                data: {\n                    id: this.lastID,\n                    filename: filename,\n                    loja: loja,\n                    data: data,\n                    pa: extractedData.pa,\n                    preco_medio: extractedData.preco_medio,\n                    atendimento_medio: extractedData.atendimento_medio\n                }\n            });\n        });\n        \n    } catch (error) {\n        console.error('Erro ao processar PDF de ranking:', error);\n        res.status(500).json({ error: 'Erro ao processar o PDF: ' + error.message });\n    }\n});\n\n// POST /api/pdf/ticket - Armazena PDF de ticket\napp.post('/api/pdf/ticket', requirePageLogin, pdfUpload.single('pdf'), async (req, res) => {\n    try {\n        if (!req.file) {\n            return res.status(400).json({ error: 'Nenhum arquivo PDF foi enviado' });\n        }\n        \n        const { loja, data } = req.body;\n        \n        if (!loja || !data) {\n            return res.status(400).json({ error: 'Loja e data são obrigatórios' });\n        }\n        \n        // Criar diretório se não existir\n        const ticketsDir = path.join(__dirname, 'data', 'pdfs', 'tickets');\n        if (!fs.existsSync(ticketsDir)) {\n            fs.mkdirSync(ticketsDir, { recursive: true });\n        }\n        \n        // Gerar nome do arquivo\n        const timestamp = Date.now();\n        const lojaSafe = loja.replace(/[^a-zA-Z0-9]/g, '_');\n        const filename = `ticket_${lojaSafe}_${data}_${timestamp}.pdf`;\n        const filepath = path.join(ticketsDir, filename);\n        \n        // Salvar arquivo\n        fs.writeFileSync(filepath, req.file.buffer);\n        \n        // Registrar no banco de dados\n        const sql = `INSERT INTO pdf_tickets (loja, data, filename, filepath, uploaded_by, uploaded_at) \n                     VALUES (?, ?, ?, ?, ?, datetime('now'))`;\n        \n        db.run(sql, [loja, data, filename, filepath, req.session.username], function(err) {\n            if (err) {\n                console.error('Erro ao registrar PDF no banco:', err);\n                // Tentar remover o arquivo salvo\n                try {\n                    fs.unlinkSync(filepath);\n                } catch (e) {}\n                return res.status(500).json({ error: 'Erro ao salvar registro do PDF' });\n            }\n            \n            res.json({\n                success: true,\n                message: 'PDF salvo com sucesso',\n                data: {\n                    id: this.lastID,\n                    filename: filename,\n                    loja: loja,\n                    data: data\n                }\n            });\n        });\n        \n    } catch (error) {\n        console.error('Erro ao salvar PDF de ticket:', error);\n        res.status(500).json({ error: 'Erro ao salvar o PDF: ' + error.message });\n    }\n});\n\n// GET /api/pdf/tickets - Lista PDFs de ticket salvos\napp.get('/api/pdf/tickets', requirePageLogin, (req, res) => {\n    const { loja, data } = req.query;\n    \n    let sql = 'SELECT id, loja, data, filename, uploaded_by, uploaded_at FROM pdf_tickets';\n    const params = [];\n    const whereClauses = [];\n    \n    if (loja) {\n        whereClauses.push('loja = ?');\n        params.push(loja);\n    }\n    \n    if (data) {\n        whereClauses.push('data = ?');\n        params.push(data);\n    }\n    \n    if (whereClauses.length > 0) {\n        sql += ' WHERE ' + whereClauses.join(' AND ');\n    }\n    \n    sql += ' ORDER BY uploaded_at DESC';\n    \n    db.all(sql, params, (err, rows) => {\n        if (err) {\n            console.error('Erro ao listar PDFs:', err);\n            return res.status(500).json({ error: 'Erro ao listar PDFs' });\n        }\n        \n        res.json({ success: true, tickets: rows || [] });\n    });\n});\n\n// GET /api/pdf/tickets/:id/download - Download de PDF de ticket\napp.get('/api/pdf/tickets/:id/download', requirePageLogin, (req, res) => {\n    const sql = 'SELECT * FROM pdf_tickets WHERE id = ?';\n    \n    db.get(sql, [req.params.id], (err, row) => {\n        if (err || !row) {\n            return res.status(404).json({ error: 'PDF não encontrado' });\n        }\n        \n        if (!fs.existsSync(row.filepath)) {\n            return res.status(404).json({ error: 'Arquivo PDF não encontrado no servidor' });\n        }\n        \n        res.setHeader('Content-Type', 'application/pdf');\n        res.setHeader('Content-Disposition', `attachment; filename=\"${row.filename}\"`);\n        fs.createReadStream(row.filepath).pipe(res);\n    });\n});\n\n// GET /api/pdf/rankings - Lista PDFs de ranking salvos\napp.get('/api/pdf/rankings', requirePageLogin, (req, res) => {\n    const { loja, data } = req.query;\n    \n    let sql = 'SELECT id, loja, data, filename, pa, preco_medio, atendimento_medio, uploaded_by, uploaded_at FROM pdf_rankings';\n    const params = [];\n    const whereClauses = [];\n    \n    if (loja) {\n        whereClauses.push('loja = ?');\n        params.push(loja);\n    }\n    \n    if (data) {\n        whereClauses.push('data = ?');\n        params.push(data);\n    }\n    \n    if (whereClauses.length > 0) {\n        sql += ' WHERE ' + whereClauses.join(' AND ');\n    }\n    \n    sql += ' ORDER BY uploaded_at DESC';\n    \n    db.all(sql, params, (err, rows) => {\n        if (err) {\n            console.error('Erro ao listar PDFs de ranking:', err);\n            return res.status(500).json({ error: 'Erro ao listar PDFs de ranking' });\n        }\n        \n        res.json({ success: true, rankings: rows || [] });\n    });\n});\n\n// GET /api/pdf/rankings/:id/download - Download de PDF de ranking\napp.get('/api/pdf/rankings/:id/download', requirePageLogin, (req, res) => {\n    const sql = 'SELECT * FROM pdf_rankings WHERE id = ?';\n    \n    db.get(sql, [req.params.id], (err, row) => {\n        if (err || !row) {\n            return res.status(404).json({ error: 'PDF não encontrado' });\n        }\n        \n        if (!fs.existsSync(row.filepath)) {\n            return res.status(404).json({ error: 'Arquivo PDF não encontrado no servidor' });\n        }\n        \n        res.setHeader('Content-Type', 'application/pdf');\n        res.setHeader('Content-Disposition', `attachment; filename=\"${row.filename}\"`);\n        fs.createReadStream(row.filepath).pipe(res);\n    });\n});\n\n// =================================================================\n// FIM DAS ROTAS DE PROCESSAMENTO DE PDF\n// =================================================================\n\n// =================================================================\n// APIS DE DVR/NVR INTELBRAS\n// =================================================================\n\n// Configurar multer para upload de arquivos DVR\nconst dvrStorage = multer.diskStorage({\n    destination: (req, file, cb) => {\n        const dvrId = req.body.dvr_id || 'temp';\n        const dvrDir = path.join(dataDir, 'dvr_files', dvrId.toString());\n        if (!fs.existsSync(dvrDir)) {\n            fs.mkdirSync(dvrDir, { recursive: true });\n        }\n        cb(null, dvrDir);\n    },\n    filename: (req, file, cb) => {\n        const timestamp = Date.now();\n        const safeName = file.originalname.replace(/[^a-zA-Z0-9.-]/g, '_');\n        cb(null, `${timestamp}_${safeName}`);\n    }\n});\n\nconst dvrUpload = multer({\n    storage: dvrStorage,\n    limits: {\n        fileSize: 500 * 1024 * 1024\n    },\n    fileFilter: (req, file, cb) => {\n        const allowedTypes = ['.mp4', '.avi', '.mkv', '.jpg', '.jpeg', '.png', '.pdf', '.xml', '.json', '.txt'];\n        const ext = path.extname(file.originalname).toLowerCase();\n        if (allowedTypes.includes(ext)) {\n            cb(null, true);\n        } else {\n            cb(new Error('Tipo de arquivo não permitido. Permitidos: vídeos, imagens, PDF, XML, JSON, TXT'));\n        }\n    }\n});\n\n// GET /api/dvr/dispositivos - Listar dispositivos DVR/NVR\napp.get('/api/dvr/dispositivos', requirePageLogin, async (req, res) => {\n    try {\n        const filtros = {\n            loja_id: req.query.loja_id,\n            loja_nome: req.query.loja_nome,\n            status: req.query.status\n        };\n        \n        const dispositivos = await dvrService.listarDispositivos(filtros);\n        res.json({ success: true, data: dispositivos });\n    } catch (error) {\n        console.error('Erro ao listar dispositivos DVR:', error);\n        res.status(500).json({ error: 'Erro ao listar dispositivos DVR' });\n    }\n});\n\n// GET /api/dvr/dispositivos/:id - Obter dispositivo específico\napp.get('/api/dvr/dispositivos/:id', requirePageLogin, async (req, res) => {\n    try {\n        const dispositivo = await dvrService.obterDispositivo(req.params.id);\n        if (!dispositivo) {\n            return res.status(404).json({ error: 'Dispositivo não encontrado' });\n        }\n        res.json({ success: true, data: dispositivo });\n    } catch (error) {\n        console.error('Erro ao obter dispositivo DVR:', error);\n        res.status(500).json({ error: 'Erro ao obter dispositivo DVR' });\n    }\n});\n\n// POST /api/dvr/dispositivos - Criar novo dispositivo DVR/NVR\napp.post('/api/dvr/dispositivos', requirePageLogin, [\n    body('nome').notEmpty().withMessage('Nome é obrigatório'),\n    body('ip_address').notEmpty().withMessage('IP é obrigatório'),\n    body('ip_address').matches(/^(\\d{1,3}\\.){3}\\d{1,3}$/).withMessage('IP inválido')\n], async (req, res) => {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n        return res.status(400).json({ errors: errors.array() });\n    }\n    \n    try {\n        const resultado = await dvrService.criarDispositivo(req.body);\n        logEvent('admin', req.session.username, 'dvr_created', `Dispositivo DVR ${req.body.nome} criado`, req);\n        res.status(201).json({ success: true, data: resultado });\n    } catch (error) {\n        console.error('Erro ao criar dispositivo DVR:', error);\n        res.status(500).json({ error: 'Erro ao criar dispositivo DVR' });\n    }\n});\n\n// PUT /api/dvr/dispositivos/:id - Atualizar dispositivo DVR/NVR\napp.put('/api/dvr/dispositivos/:id', requirePageLogin, async (req, res) => {\n    try {\n        await dvrService.atualizarDispositivo(req.params.id, req.body);\n        logEvent('admin', req.session.username, 'dvr_updated', `Dispositivo DVR ${req.params.id} atualizado`, req);\n        res.json({ success: true });\n    } catch (error) {\n        console.error('Erro ao atualizar dispositivo DVR:', error);\n        if (error.message === 'Dispositivo não encontrado') {\n            return res.status(404).json({ error: error.message });\n        }\n        res.status(500).json({ error: 'Erro ao atualizar dispositivo DVR' });\n    }\n});\n\n// DELETE /api/dvr/dispositivos/:id - Excluir dispositivo DVR/NVR\napp.delete('/api/dvr/dispositivos/:id', requirePageLogin, async (req, res) => {\n    try {\n        await dvrService.excluirDispositivo(req.params.id);\n        logEvent('admin', req.session.username, 'dvr_deleted', `Dispositivo DVR ${req.params.id} excluído`, req);\n        res.json({ success: true });\n    } catch (error) {\n        console.error('Erro ao excluir dispositivo DVR:', error);\n        if (error.message === 'Dispositivo não encontrado') {\n            return res.status(404).json({ error: error.message });\n        }\n        res.status(500).json({ error: 'Erro ao excluir dispositivo DVR' });\n    }\n});\n\n// PATCH /api/dvr/dispositivos/:id/status - Atualizar status do dispositivo\napp.patch('/api/dvr/dispositivos/:id/status', requirePageLogin, async (req, res) => {\n    try {\n        const { status } = req.body;\n        if (!['online', 'offline'].includes(status)) {\n            return res.status(400).json({ error: 'Status inválido. Use: online ou offline' });\n        }\n        await dvrService.atualizarStatus(req.params.id, status);\n        res.json({ success: true });\n    } catch (error) {\n        console.error('Erro ao atualizar status:', error);\n        res.status(500).json({ error: 'Erro ao atualizar status' });\n    }\n});\n\n// GET /api/dvr/logs - Listar logs de DVR\napp.get('/api/dvr/logs', requirePageLogin, async (req, res) => {\n    try {\n        const filtros = {\n            dvr_id: req.query.dvr_id,\n            loja_nome: req.query.loja_nome,\n            tipo_evento: req.query.tipo_evento,\n            severidade: req.query.severidade,\n            data_inicio: req.query.data_inicio,\n            data_fim: req.query.data_fim\n        };\n        \n        const paginacao = {\n            limit: parseInt(req.query.limit) || 100,\n            offset: parseInt(req.query.offset) || 0\n        };\n        \n        const logs = await dvrService.listarLogs(filtros, paginacao);\n        res.json({ success: true, data: logs });\n    } catch (error) {\n        console.error('Erro ao listar logs DVR:', error);\n        res.status(500).json({ error: 'Erro ao listar logs DVR' });\n    }\n});\n\n// POST /api/dvr/logs - Registrar novo log de DVR\napp.post('/api/dvr/logs', requirePageLogin, [\n    body('dvr_id').notEmpty().withMessage('ID do DVR é obrigatório'),\n    body('tipo_evento').notEmpty().withMessage('Tipo de evento é obrigatório')\n], async (req, res) => {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n        return res.status(400).json({ errors: errors.array() });\n    }\n    \n    try {\n        const resultado = await dvrService.registrarLog(req.body);\n        res.status(201).json({ success: true, data: resultado });\n    } catch (error) {\n        console.error('Erro ao registrar log DVR:', error);\n        res.status(500).json({ error: 'Erro ao registrar log DVR' });\n    }\n});\n\n// DELETE /api/dvr/logs/:id - Excluir log\napp.delete('/api/dvr/logs/:id', requirePageLogin, async (req, res) => {\n    try {\n        await dvrService.excluirLog(req.params.id);\n        res.json({ success: true });\n    } catch (error) {\n        console.error('Erro ao excluir log:', error);\n        res.status(500).json({ error: 'Erro ao excluir log' });\n    }\n});\n\n// GET /api/dvr/arquivos - Listar arquivos de DVR\napp.get('/api/dvr/arquivos', requirePageLogin, async (req, res) => {\n    try {\n        const filtros = {\n            dvr_id: req.query.dvr_id,\n            loja_nome: req.query.loja_nome,\n            tipo_arquivo: req.query.tipo_arquivo,\n            data_inicio: req.query.data_inicio,\n            data_fim: req.query.data_fim\n        };\n        \n        const paginacao = {\n            limit: parseInt(req.query.limit) || 50,\n            offset: parseInt(req.query.offset) || 0\n        };\n        \n        const arquivos = await dvrService.listarArquivos(filtros, paginacao);\n        res.json({ success: true, data: arquivos });\n    } catch (error) {\n        console.error('Erro ao listar arquivos DVR:', error);\n        res.status(500).json({ error: 'Erro ao listar arquivos DVR' });\n    }\n});\n\n// POST /api/dvr/arquivos - Upload de arquivo DVR\napp.post('/api/dvr/arquivos', requirePageLogin, dvrUpload.single('arquivo'), async (req, res) => {\n    try {\n        if (!req.file) {\n            return res.status(400).json({ error: 'Nenhum arquivo foi enviado' });\n        }\n        \n        const dadosArquivo = {\n            dvr_id: req.body.dvr_id,\n            dvr_nome: req.body.dvr_nome,\n            loja_nome: req.body.loja_nome,\n            tipo_arquivo: req.body.tipo_arquivo || path.extname(req.file.originalname).substring(1),\n            nome_arquivo: req.file.originalname,\n            caminho_arquivo: req.file.path,\n            tamanho_bytes: req.file.size,\n            data_geracao: req.body.data_geracao || new Date().toISOString(),\n            canal: req.body.canal,\n            inicio_gravacao: req.body.inicio_gravacao,\n            fim_gravacao: req.body.fim_gravacao,\n            descricao: req.body.descricao,\n            uploaded_by: req.session.username\n        };\n        \n        const resultado = await dvrService.registrarArquivo(dadosArquivo);\n        logEvent('admin', req.session.username, 'dvr_file_uploaded', `Arquivo ${req.file.originalname} enviado para DVR ${req.body.dvr_id}`, req);\n        res.status(201).json({ \n            success: true, \n            data: resultado,\n            file: {\n                id: resultado.id,\n                nome: req.file.originalname,\n                tamanho: req.file.size\n            }\n        });\n    } catch (error) {\n        console.error('Erro ao fazer upload de arquivo DVR:', error);\n        if (req.file && fs.existsSync(req.file.path)) {\n            fs.unlinkSync(req.file.path);\n        }\n        res.status(500).json({ error: 'Erro ao fazer upload de arquivo DVR' });\n    }\n});\n\n// GET /api/dvr/arquivos/:id/download - Download de arquivo DVR\napp.get('/api/dvr/arquivos/:id/download', requirePageLogin, async (req, res) => {\n    try {\n        const arquivo = await dvrService.obterArquivo(req.params.id);\n        \n        if (!arquivo) {\n            return res.status(404).json({ error: 'Arquivo não encontrado' });\n        }\n        \n        if (!fs.existsSync(arquivo.caminho_arquivo)) {\n            return res.status(404).json({ error: 'Arquivo físico não encontrado no servidor' });\n        }\n        \n        const ext = path.extname(arquivo.nome_arquivo).toLowerCase();\n        let contentType = 'application/octet-stream';\n        \n        if (['.mp4', '.avi', '.mkv'].includes(ext)) {\n            contentType = 'video/' + ext.substring(1);\n        } else if (['.jpg', '.jpeg'].includes(ext)) {\n            contentType = 'image/jpeg';\n        } else if (ext === '.png') {\n            contentType = 'image/png';\n        } else if (ext === '.pdf') {\n            contentType = 'application/pdf';\n        } else if (ext === '.xml') {\n            contentType = 'application/xml';\n        } else if (ext === '.json') {\n            contentType = 'application/json';\n        }\n        \n        res.setHeader('Content-Type', contentType);\n        res.setHeader('Content-Disposition', `attachment; filename=\"${arquivo.nome_arquivo}\"`);\n        res.setHeader('Content-Length', arquivo.tamanho_bytes);\n        \n        fs.createReadStream(arquivo.caminho_arquivo).pipe(res);\n    } catch (error) {\n        console.error('Erro ao fazer download de arquivo DVR:', error);\n        res.status(500).json({ error: 'Erro ao fazer download de arquivo DVR' });\n    }\n});\n\n// DELETE /api/dvr/arquivos/:id - Excluir arquivo DVR\napp.delete('/api/dvr/arquivos/:id', requirePageLogin, async (req, res) => {\n    try {\n        const arquivo = await dvrService.obterArquivo(req.params.id);\n        \n        if (!arquivo) {\n            return res.status(404).json({ error: 'Arquivo não encontrado' });\n        }\n        \n        await dvrService.excluirArquivo(req.params.id);\n        \n        if (fs.existsSync(arquivo.caminho_arquivo)) {\n            fs.unlinkSync(arquivo.caminho_arquivo);\n        }\n        \n        logEvent('admin', req.session.username, 'dvr_file_deleted', `Arquivo ${arquivo.nome_arquivo} excluído`, req);\n        res.json({ success: true });\n    } catch (error) {\n        console.error('Erro ao excluir arquivo DVR:', error);\n        res.status(500).json({ error: 'Erro ao excluir arquivo DVR' });\n    }\n});\n\n// =================================================================\n// FIM DAS APIS DE DVR/NVR\n// =================================================================\n\n// ROTA DE EXPORTAÇÃO PARA EXCEL \napp.get('/api/export/excel', requirePageLogin, async (req, res) => { const { month, year } = req.query; if (!month || !year) { return res.status(400).json({ error: 'Mês e ano são obrigatórios.' }); } const monthFormatted = month.toString().padStart(2, '0'); const sql = ` SELECT r.*, l.funcao_especial FROM relatorios r LEFT JOIN lojas l ON r.loja = l.nome WHERE strftime('%Y-%m', r.data) = ? ORDER BY r.loja, r.data `; db.all(sql, [`${year}-${monthFormatted}`], async (err, rows) => { if (err) { console.error(\"Erro ao buscar relatórios para Excel:\", err); return res.status(500).json({ error: 'Erro ao buscar relatórios.' }); } if (rows.length === 0) { return res.status(404).json({ error: 'Nenhum relatório encontrado para o período.' }); } const workbook = new ExcelJS.Workbook(); const safeParseFloat = (value) => { if (typeof value === 'number') { return value; } if (typeof value === 'string') { const cleaned = value.replace(/[R$\\s]/g, '').replace(/\\./g, '').replace(',', '.'); const num = parseFloat(cleaned); return isNaN(num) ? 0 : num; } return 0; }; const relatoriosPorLoja = rows.reduce((acc, row) => { const loja = row.loja; if (!acc[loja]) { acc[loja] = { funcao_especial: row.funcao_especial || 'Não definido', relatorios: [] }; } acc[loja].relatorios.push(processarRelatorio(row)); return acc; }, {}); for (const lojaNome in relatoriosPorLoja) { const lojaData = relatoriosPorLoja[lojaNome]; const worksheet = workbook.addWorksheet(lojaNome.substring(0, 30)); worksheet.mergeCells('A1:M1'); const tituloCell = worksheet.getCell('A1'); tituloCell.value = lojaNome.toUpperCase(); tituloCell.font = { name: 'Arial Black', size: 16, bold: true, color: { argb: 'FF44546A' } }; tituloCell.alignment = { vertical: 'middle', horizontal: 'center' }; worksheet.getRow(1).height = 30; const headers = [ 'DATA', 'BLUVE', 'VENDAS (L)', 'TX DE CONVERSÃO (L)', 'CLIENTES (M)', 'VENDAS (M)', 'TX DE CONVERSÃO (M)', 'P.A', 'TM', 'VALOR TOTAL', 'TROCAS' ]; let funcaoEspecialHeader = 'FUNÇÃO ESPECIAL'; if (lojaData.funcao_especial === 'Omni') { funcaoEspecialHeader = 'OMNI'; } else if (lojaData.funcao_especial === 'Busca por Assist. Tec.') { funcaoEspecialHeader = 'BUSCA P/ ASSIST. TEC.'; } headers.push(funcaoEspecialHeader); headers.push('ENVIADO POR'); const headerRow = worksheet.getRow(3); headerRow.values = headers; headerRow.height = 35; headerRow.eachCell(cell => { cell.font = { bold: true, color: { argb: 'FFFFFFFF' }, size: 10 }; cell.alignment = { vertical: 'middle', horizontal: 'center', wrapText: true }; cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF4472C4' } }; cell.border = { top: { style: 'thin', color: { argb: 'FFBFBFBF' } }, left: { style: 'thin', color: { argb: 'FFBFBFBF' } }, bottom: { style: 'thin', color: { argb: 'FFBFBFBF' } }, right: { style: 'thin', color: { argb: 'FFBFBFBF' } } }; }); lojaData.relatorios.forEach(r => { const rowData = [ new Date(r.data + 'T00:00:00'), parseInt(r.clientes_loja, 10) || 0, parseInt(r.vendas_loja, 10) || 0, parseFloat(r.tx_conversao_loja) / 100, parseInt(r.clientes_monitoramento, 10) || 0, parseInt(r.vendas_monitoramento_total, 10) || 0, parseFloat(r.tx_conversao_monitoramento) / 100, parseFloat(String(r.pa).replace(',', '.')) || 0, safeParseFloat(r.ticket_medio), r.total_vendas_dinheiro, parseInt(r.quantidade_trocas, 10) || 0 ]; if (lojaData.funcao_especial === 'Omni') { rowData.push(parseInt(r.quantidade_omni, 10) || 0); } else if (lojaData.funcao_especial === 'Busca por Assist. Tec.') { rowData.push(parseInt(r.quantidade_funcao_especial, 10) || 0); } else { rowData.push(0); } rowData.push(r.enviado_por_usuario || '-'); const row = worksheet.addRow(rowData); row.getCell(1).numFmt = 'DD/MM/YYYY'; row.getCell(4).numFmt = '0.00%'; row.getCell(7).numFmt = '0.00%'; row.getCell(8).numFmt = '0.00'; row.getCell(9).numFmt = 'R$ #,##0.00'; row.getCell(10).numFmt = 'R$ #,##0.00'; row.eachCell(cell => { cell.alignment = { vertical: 'middle', horizontal: 'center' }; }); }); worksheet.columns.forEach(column => { let maxLength = 0; column.eachCell({ includeEmpty: true }, cell => { const length = cell.value ? cell.value.toString().length : 10; if (length > maxLength) { maxLength = length; } }); column.width = Math.max(12, maxLength + 3); }); worksheet.getColumn(4).width = 20; worksheet.getColumn(7).width = 20; worksheet.getColumn(12).width = 22; } res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'); res.setHeader('Content-Disposition', `attachment; filename=\"Relatorios_${year}-${monthFormatted}.xlsx\"`); await workbook.xlsx.write(res); res.end(); }); });\n\n// ROTA DE EXPORTAÇÃO PARA EXCEL - TODOS OS RELATÓRIOS\napp.get('/api/export/excel/all', requirePageLogin, async (req, res) => { \n    const sql = ` SELECT r.*, l.funcao_especial FROM relatorios r LEFT JOIN lojas l ON r.loja = l.nome ORDER BY r.loja, r.data `; \n    db.all(sql, [], async (err, rows) => { \n        if (err) { \n            console.error(\"Erro ao buscar relatórios para Excel:\", err); \n            return res.status(500).json({ error: 'Erro ao buscar relatórios.' }); \n        } \n        if (rows.length === 0) { \n            return res.status(404).json({ error: 'Nenhum relatório encontrado no sistema.' }); \n        } \n        const workbook = new ExcelJS.Workbook(); \n        const safeParseFloat = (value) => { \n            if (typeof value === 'number') { return value; } \n            if (typeof value === 'string') { \n                const cleaned = value.replace(/[R$\\s]/g, '').replace(/\\./g, '').replace(',', '.'); \n                const num = parseFloat(cleaned); \n                return isNaN(num) ? 0 : num; \n            } \n            return 0; \n        }; \n        const relatoriosPorLoja = rows.reduce((acc, row) => { \n            const loja = row.loja; \n            if (!acc[loja]) { \n                acc[loja] = { funcao_especial: row.funcao_especial || 'Não definido', relatorios: [] }; \n            } \n            acc[loja].relatorios.push(processarRelatorio(row)); \n            return acc; \n        }, {}); \n        for (const lojaNome in relatoriosPorLoja) { \n            const lojaData = relatoriosPorLoja[lojaNome]; \n            const worksheet = workbook.addWorksheet(lojaNome.substring(0, 30)); \n            worksheet.mergeCells('A1:M1'); \n            const tituloCell = worksheet.getCell('A1'); \n            tituloCell.value = lojaNome.toUpperCase(); \n            tituloCell.font = { name: 'Arial Black', size: 16, bold: true, color: { argb: 'FF44546A' } }; \n            tituloCell.alignment = { vertical: 'middle', horizontal: 'center' }; \n            worksheet.getRow(1).height = 30; \n            const headers = [ 'DATA', 'BLUVE', 'VENDAS (L)', 'TX DE CONVERSÃO (L)', 'CLIENTES (M)', 'VENDAS (M)', 'TX DE CONVERSÃO (M)', 'P.A', 'TM', 'VALOR TOTAL', 'TROCAS' ]; \n            let funcaoEspecialHeader = 'FUNÇÃO ESPECIAL'; \n            if (lojaData.funcao_especial === 'Omni') { \n                funcaoEspecialHeader = 'OMNI'; \n            } else if (lojaData.funcao_especial === 'Busca por Assist. Tec.') { \n                funcaoEspecialHeader = 'BUSCA P/ ASSIST. TEC.'; \n            } \n            headers.push(funcaoEspecialHeader); \n            headers.push('ENVIADO POR'); \n            const headerRow = worksheet.getRow(3); \n            headerRow.values = headers; \n            headerRow.height = 35; \n            headerRow.eachCell(cell => { \n                cell.font = { bold: true, color: { argb: 'FFFFFFFF' }, size: 10 }; \n                cell.alignment = { vertical: 'middle', horizontal: 'center', wrapText: true }; \n                cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF4472C4' } }; \n                cell.border = { top: { style: 'thin', color: { argb: 'FFBFBFBF' } }, left: { style: 'thin', color: { argb: 'FFBFBFBF' } }, bottom: { style: 'thin', color: { argb: 'FFBFBFBF' } }, right: { style: 'thin', color: { argb: 'FFBFBFBF' } } }; \n            }); \n            lojaData.relatorios.forEach(r => { \n                const rowData = [ \n                    new Date(r.data + 'T00:00:00'), \n                    parseInt(r.clientes_loja, 10) || 0, \n                    parseInt(r.vendas_loja, 10) || 0, \n                    parseFloat(r.tx_conversao_loja) / 100, \n                    parseInt(r.clientes_monitoramento, 10) || 0, \n                    parseInt(r.vendas_monitoramento_total, 10) || 0, \n                    parseFloat(r.tx_conversao_monitoramento) / 100, \n                    parseFloat(String(r.pa).replace(',', '.')) || 0, \n                    safeParseFloat(r.ticket_medio), \n                    r.total_vendas_dinheiro, \n                    parseInt(r.quantidade_trocas, 10) || 0 \n                ]; \n                if (lojaData.funcao_especial === 'Omni') { \n                    rowData.push(parseInt(r.quantidade_omni, 10) || 0); \n                } else if (lojaData.funcao_especial === 'Busca por Assist. Tec.') { \n                    rowData.push(parseInt(r.quantidade_funcao_especial, 10) || 0); \n                } else { \n                    rowData.push(0); \n                } \n                rowData.push(r.enviado_por_usuario || '-'); \n                const row = worksheet.addRow(rowData); \n                row.getCell(1).numFmt = 'DD/MM/YYYY'; \n                row.getCell(4).numFmt = '0.00%'; \n                row.getCell(7).numFmt = '0.00%'; \n                row.getCell(8).numFmt = '0.00'; \n                row.getCell(9).numFmt = 'R$ #,##0.00'; \n                row.getCell(10).numFmt = 'R$ #,##0.00'; \n                row.eachCell(cell => { \n                    cell.alignment = { vertical: 'middle', horizontal: 'center' }; \n                }); \n            }); \n            worksheet.columns.forEach(column => { \n                let maxLength = 0; \n                column.eachCell({ includeEmpty: true }, cell => { \n                    const length = cell.value ? cell.value.toString().length : 10; \n                    if (length > maxLength) { maxLength = length; } \n                }); \n                column.width = Math.max(12, maxLength + 3); \n            }); \n            worksheet.getColumn(4).width = 20; \n            worksheet.getColumn(7).width = 20; \n            worksheet.getColumn(12).width = 22; \n        } \n        const currentDate = new Date().toLocaleDateString('pt-BR').replace(/\\//g, '-');\n        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'); \n        res.setHeader('Content-Disposition', `attachment; filename=\"Todos_Relatorios_${currentDate}.xlsx\"`); \n        await workbook.xlsx.write(res); \n        res.end(); \n    }); \n});\n\n// APIs DE DASHBOARD, DEMANDAS, BACKUP E RESTORE \napp.get('/api/dashboard-data', requirePageLogin, (req, res) => { \n    let whereClauses = []; \n    let params = []; \n    \n    // Aplicar filtro de lojas baseado no role\n    \n    if (req.query.loja && req.query.loja !== 'todas') { \n        whereClauses.push('loja = ?'); \n        params.push(req.query.loja); \n    } \n    if (req.query.data_inicio) { \n        whereClauses.push('data >= ?'); \n        params.push(req.query.data_inicio); \n    } \n    if (req.query.data_fim) { \n        whereClauses.push('data <= ?'); \n        params.push(req.query.data_fim); \n    } \n    const whereString = whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : ''; \n    const sql = `SELECT COALESCE(SUM(clientes_monitoramento),0) as total_clientes_monitoramento, COALESCE(SUM(vendas_monitoramento),0) as total_vendas_monitoramento, COALESCE(SUM(clientes_loja),0) as total_clientes_loja, COALESCE(SUM(vendas_loja),0) as total_vendas_loja, COALESCE(SUM(quantidade_omni),0) as total_omni FROM relatorios ${whereString}`; \n    db.get(sql, params, (err, row) => { \n        if (err) return res.status(500).json({ error: err.message }); \n        \n        const allowedMonitoramentoRoles = ['admin', 'monitoramento', 'dev', 'consultor'];\n        const canViewMonitoramento = allowedMonitoramentoRoles.includes(req.session.role);\n        \n        const vendas_m_total = (row.total_vendas_monitoramento || 0) + (row.total_omni || 0); \n        const response = { \n            ...row, \n            tx_conversao_monitoramento: (row.total_clientes_monitoramento > 0 ? (vendas_m_total / row.total_clientes_monitoramento) * 100 : 0), \n            tx_conversao_loja: (row.total_clientes_loja > 0 ? (row.total_vendas_loja / row.total_clientes_loja) * 100 : 0),\n            canViewMonitoramento \n        };\n        \n        if (!canViewMonitoramento) {\n            delete response.total_clientes_monitoramento;\n            delete response.total_vendas_monitoramento;\n            delete response.total_omni;\n            delete response.tx_conversao_monitoramento;\n        }\n        \n        res.json(response); \n    }); \n});\n\napp.get('/api/dashboard-bluve', requirePageLogin, (req, res) => { \n    let whereClauses = []; \n    let params = []; \n    \n    \n    if (req.query.loja && req.query.loja !== 'todas') { \n        whereClauses.push('loja = ?'); \n        params.push(req.query.loja); \n    } \n    if (req.query.data_inicio) { \n        whereClauses.push('data >= ?'); \n        params.push(req.query.data_inicio); \n    } \n    if (req.query.data_fim) { \n        whereClauses.push('data <= ?'); \n        params.push(req.query.data_fim); \n    } \n    \n    const whereString = whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : ''; \n    const sql = `SELECT \n        COALESCE(SUM(clientes_loja), 0) as clientes_atendidos, \n        COALESCE(SUM(vendas_loja), 0) as vendas,\n        CASE \n            WHEN SUM(clientes_loja) > 0 THEN (CAST(SUM(vendas_loja) AS REAL) / SUM(clientes_loja)) * 100\n            ELSE 0\n        END as taxa_conversao\n    FROM relatorios ${whereString}`; \n    \n    db.get(sql, params, (err, row) => { \n        if (err) return res.status(500).json({ error: err.message }); \n        res.json({\n            clientes_atendidos: row.clientes_atendidos || 0,\n            vendas: row.vendas || 0,\n            taxa_conversao: row.taxa_conversao ? parseFloat(row.taxa_conversao.toFixed(2)) : 0\n        }); \n    }); \n});\napp.get('/api/ranking', requirePageLogin, (req, res) => { \n    let whereClauses = ['l.status = \\'ativa\\'']; \n    let params = []; \n    \n    // Aplicar filtro de lojas baseado no role (no LEFT JOIN)\n    \n    let joinConditions = [];\n    if (req.query.data_inicio) { \n        joinConditions.push('r.data >= ?'); \n        params.push(req.query.data_inicio); \n    } \n    if (req.query.data_fim) { \n        joinConditions.push('r.data <= ?'); \n        params.push(req.query.data_fim); \n    } \n    const joinCondition = joinConditions.length > 0 ? `AND ${joinConditions.join(' AND ')}` : ''; \n    const whereString = whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : '';\n    const sql = `SELECT l.nome as loja, COALESCE(SUM(r.clientes_loja), 0) as total_clientes_loja, COALESCE(SUM(r.vendas_loja), 0) as total_vendas_loja, COALESCE(SUM(r.clientes_monitoramento), 0) as total_clientes_monitoramento, COALESCE(SUM(r.vendas_monitoramento), 0) as total_vendas_monitoramento, COALESCE(SUM(r.quantidade_omni), 0) as total_omni FROM lojas l LEFT JOIN relatorios r ON l.nome = r.loja ${joinCondition} ${whereString} GROUP BY l.nome`; \n    db.all(sql, params, (err, rows) => { \n        if (err) return res.status(500).json({ error: err.message }); \n        \n        const ranking = rows.map(r => { \n            const vendas_m_total = (r.total_vendas_monitoramento || 0) + (r.total_omni || 0); \n            return { \n                ...r, \n                tx_loja: (r.total_clientes_loja > 0 ? (r.total_vendas_loja / r.total_clientes_loja) * 100 : 0), \n                tx_monitoramento: (r.total_clientes_monitoramento > 0 ? (vendas_m_total / r.total_clientes_monitoramento) * 100 : 0) \n            };\n        }); \n        res.json(ranking); \n    }); \n});\napp.get('/api/dashboard/chart-data', requirePageLogin, (req, res) => {\n    const { loja, data_inicio, data_fim } = req.query;\n    let whereClauses = [];\n    let params = [];\n    \n    // Aplicar filtro de lojas baseado no role\n    \n    // Filtro específico por loja (query param)\n    if (loja && loja !== 'todas' && !lojaFilter) {\n        whereClauses.push('TRIM(loja) = ?');\n        params.push(loja);\n    }\n    \n    // Filtros de data\n    if (data_inicio) {\n        whereClauses.push('data >= ?');\n        params.push(data_inicio);\n    }\n    if (data_fim) {\n        whereClauses.push('data <= ?');\n        params.push(data_fim);\n    }\n    \n    // Se não tem nenhum filtro de data, pegar últimos 30 dias\n    if (!data_inicio && !data_fim) {\n        const date = new Date();\n        date.setDate(date.getDate() - 30);\n        const startDate = date.toISOString().slice(0, 10);\n        whereClauses.push('data >= ?');\n        params.push(startDate);\n    }\n    \n    const whereString = whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : '';\n    const sql = `SELECT data, SUM(clientes_loja) as total_clientes_loja, SUM(vendas_loja) as total_vendas_loja, SUM(clientes_monitoramento) as total_clientes_monitoramento, SUM(vendas_monitoramento) as total_vendas_monitoramento, SUM(quantidade_omni) as total_omni FROM relatorios ${whereString} GROUP BY data ORDER BY data ASC`;\n    \n    db.all(sql, params, (err, rows) => {\n        if (err) return res.status(500).json({ error: 'Erro ao buscar dados para o gráfico.' });\n        \n        const labels = [];\n        const txConversaoLoja = [];\n        const txConversaoMonitoramento = [];\n        \n        rows.forEach(row => {\n            labels.push(new Date(row.data).toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', timeZone: 'UTC' }));\n            const tx_l = row.total_clientes_loja > 0 ? (row.total_vendas_loja / row.total_clientes_loja) * 100 : 0;\n            txConversaoLoja.push(tx_l.toFixed(2));\n            \n            const vendas_m_total = (row.total_vendas_monitoramento || 0) + (row.total_omni || 0);\n            const tx_m = row.total_clientes_monitoramento > 0 ? (vendas_m_total / row.total_clientes_monitoramento) * 100 : 0;\n            txConversaoMonitoramento.push(tx_m.toFixed(2));\n        });\n        \n        res.json({ labels, txConversaoLoja, txConversaoMonitoramento });\n    });\n});\n\napp.get('/api/dashboard/store-performance', requirePageLogin, (req, res) => {\n    const { data_inicio, data_fim } = req.query;\n    let whereClauses = [];\n    let params = [];\n    \n    if (data_inicio) {\n        whereClauses.push('data >= ?');\n        params.push(data_inicio);\n    }\n    if (data_fim) {\n        whereClauses.push('data <= ?');\n        params.push(data_fim);\n    }\n    \n    if (!data_inicio && !data_fim) {\n        const date = new Date();\n        date.setDate(date.getDate() - 30);\n        const startDate = date.toISOString().slice(0, 10);\n        whereClauses.push('data >= ?');\n        params.push(startDate);\n    }\n    \n    const whereString = whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : '';\n    \n    const sql = `\n        SELECT \n            loja,\n            SUM(vendas_loja) as total_vendas,\n            AVG(ticket_medio) as ticket_medio_avg,\n            AVG(pa) as pa_avg,\n            SUM(vendas_cartao) as total_vendas_cartao,\n            SUM(vendas_pix) as total_vendas_pix,\n            SUM(vendas_dinheiro) as total_vendas_dinheiro,\n            SUM(clientes_loja) as total_clientes,\n            COUNT(*) as dias_registrados\n        FROM relatorios \n        ${whereString}\n        GROUP BY loja\n        ORDER BY total_vendas DESC\n    `;\n    \n    db.all(sql, params, (err, rows) => {\n        if (err) {\n            console.error('Erro ao buscar métricas de desempenho:', err);\n            return res.status(500).json({ error: 'Erro ao buscar métricas de desempenho.' });\n        }\n        \n        const metrics = rows.map(row => {\n            const diasRegistrados = row.dias_registrados || 1;\n            const totalVendas = row.total_vendas || 0;\n            const vendasMediaDia = totalVendas / diasRegistrados;\n            \n            return {\n                loja: row.loja,\n                vendas_media_dia: parseFloat(vendasMediaDia.toFixed(2)),\n                total_vendas: totalVendas,\n                ticket_medio: parseFloat((row.ticket_medio_avg || 0).toFixed(2)),\n                pa: parseFloat((row.pa_avg || 0).toFixed(2)),\n                formas_pagamento: {\n                    cartao: row.total_vendas_cartao || 0,\n                    pix: row.total_vendas_pix || 0,\n                    dinheiro: row.total_vendas_dinheiro || 0\n                },\n                total_clientes: row.total_clientes || 0,\n                dias_registrados: diasRegistrados\n            };\n        }).sort((a, b) => b.vendas_media_dia - a.vendas_media_dia);\n        \n        res.json(metrics);\n    });\n});\n\napp.post('/api/demandas', requirePageLogin, (req, res) => { const { loja_nome, descricao, tag } = req.body; db.run('INSERT INTO demandas (loja_nome, descricao, tag, criado_por_usuario) VALUES (?, ?, ?, ?)', [loja_nome, descricao, tag, req.session.username], function (err) { if (err) return res.status(500).json({ error: 'Falha ao salvar demanda.' }); res.status(201).json({ success: true, id: this.lastID }); }); });\napp.get('/api/demandas/:status', requirePageLogin, (req, res) => { \n    const status = req.params.status === 'pendentes' ? 'pendente' : 'concluido'; \n    const whereClauses = ['status = ?'];\n    const params = [status];\n    \n    // Aplicar filtro de lojas baseado no role\n    \n    const whereString = whereClauses.join(' AND ');\n    const query = `SELECT * FROM demandas WHERE ${whereString} ORDER BY criado_em DESC`;\n    \n    db.all(query, params, (err, demandas) => { \n        if (err) return res.status(500).json({ error: err.message }); \n        res.json(demandas || []); \n    }); \n});\napp.put('/api/demandas/:id/concluir', requirePageLogin, (req, res) => { db.run(\"UPDATE demandas SET status = 'concluido', concluido_por_usuario = ?, concluido_em = CURRENT_TIMESTAMP WHERE id = ?\", [req.session.username, req.params.id], function (err) { if (err) return res.status(500).json({ error: 'Erro ao concluir demanda.' }); if (this.changes === 0) return res.status(404).json({ error: 'Demanda não encontrada.' }); res.json({ success: true }); }); });\napp.delete('/api/demandas/:id', requirePageLogin, (req, res) => { db.run(\"DELETE FROM demandas WHERE id = ?\", [req.params.id], function (err) { if (err) return res.status(500).json({ error: 'Erro ao excluir demanda.' }); if (this.changes === 0) return res.status(404).json({ error: \"Demanda não encontrada.\" }); res.json({ success: true }); }); });\napp.get('/api/backup/info', requirePageLogin, (req, res) => {\n    try {\n        const stats = fs.statSync(DB_PATH);\n        const sizeMB = (stats.size / (1024 * 1024)).toFixed(2);\n        res.json({ sizeMB });\n    } catch (error) {\n        console.error(\"Erro ao obter informações do backup:\", error);\n        res.status(500).json({ error: 'Não foi possível obter informações do banco de dados.' });\n    }\n});\n\n// API para limpar tabelas específicas do banco de dados\napp.delete('/api/backup/clear', requirePageLogin, (req, res) => {\n    db.serialize(() => {\n        db.run(\"DELETE FROM relatorios\", (err) => {\n            if (err) return res.status(500).json({ error: 'Erro ao limpar relatórios.' });\n        });\n        db.run(\"DELETE FROM demandas\", (err) => {\n            if (err) return res.status(500).json({ error: 'Erro ao limpar demandas.' });\n        });\n        res.json({ success: true, message: 'Relatórios e demandas foram limpos.' });\n    });\n});\napp.get('/api/backup/download', requirePageLogin, (req, res) => { const date = new Date().toISOString().slice(0, 10); const fileName = `backup_reports_${date}.db`; res.download(DB_PATH, fileName, (err) => { if (err && !res.headersSent) { res.status(500).send(\"Não foi possível baixar o arquivo de backup.\"); } }); });\napp.post('/api/backup/restore', requirePageLogin, upload.single('backupFile'), (req, res) => { if (!req.file) { return res.status(400).json({ error: \"Nenhum arquivo de backup foi enviado.\" }); } const backupBuffer = req.file.buffer; db.close((err) => { if (err) { console.error(\"Erro ao fechar o DB antes de restaurar:\", err.message); return res.status(500).json({ error: \"Não foi possível fechar a conexão com o banco de dados atual.\" }); } fs.writeFile(DB_PATH, backupBuffer, (err) => { if (err) { console.error(\"Falha ao escrever o arquivo de backup:\", err.message); db = new sqlite3.Database(DB_PATH); return res.status(500).json({ error: \"Falha ao substituir o arquivo de banco de dados.\" }); } db = new sqlite3.Database(DB_PATH, (err) => { if (err) { console.error(\"DB restaurado, mas falha ao reconectar:\", err.message); return res.status(500).json({ error: \"Banco de dados restaurado, mas falha ao reconectar. Reinicie o servidor.\" }); } console.log(\"Banco de dados restaurado e reconectado com sucesso.\"); res.json({ success: true, message: \"Banco de dados restaurado com sucesso. A página será recarregada.\" }); }); }); }); });\n\n// APIs DE LOGS (apenas para Dev)\napp.get('/api/logs', requirePageLogin, (req, res) => {\n    const { type, start, end, limit, offset } = req.query;\n    let whereClauses = [];\n    let params = [];\n    \n    if (type && type !== 'all') {\n        whereClauses.push('type = ?');\n        params.push(type);\n    }\n    if (start) {\n        whereClauses.push('timestamp >= ?');\n        params.push(start);\n    }\n    if (end) {\n        whereClauses.push('timestamp <= ?');\n        params.push(end + ' 23:59:59');\n    }\n    \n    const whereString = whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : '';\n    const limitNum = parseInt(limit) || 50;\n    const offsetNum = parseInt(offset) || 0;\n    \n    // Buscar total\n    db.get(`SELECT COUNT(*) as total FROM logs ${whereString}`, params, (err, countRow) => {\n        if (err) return res.status(500).json({ error: err.message });\n        \n        // Buscar logs\n        db.all(`SELECT * FROM logs ${whereString} ORDER BY timestamp DESC LIMIT ? OFFSET ?`, \n            [...params, limitNum, offsetNum], \n            (err, logs) => {\n                if (err) return res.status(500).json({ error: err.message });\n                \n                // Buscar estatísticas (últimas 24h)\n                const last24h = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();\n                db.all(`SELECT type, COUNT(*) as count FROM logs WHERE timestamp >= ? GROUP BY type`, [last24h], (err, statsRows) => {\n                    const stats = {\n                        errors: 0,\n                        warnings: 0,\n                        activeUsers: 0,\n                        uptime: Math.floor(process.uptime() / 60) + ' min'\n                    };\n                    \n                    if (!err && statsRows) {\n                        statsRows.forEach(row => {\n                            if (row.type === 'error') stats.errors = row.count;\n                            if (row.type === 'warning') stats.warnings = row.count;\n                        });\n                    }\n                    \n                    // Contar usuários ativos (última hora)\n                    const lastHour = new Date(Date.now() - 60 * 60 * 1000).toISOString();\n                    db.get(`SELECT COUNT(DISTINCT username) as count FROM logs WHERE timestamp >= ? AND type = 'access'`, [lastHour], (err, userRow) => {\n                        if (!err && userRow) stats.activeUsers = userRow.count;\n                        res.json({ logs, total: countRow.total, stats });\n                    });\n                });\n            }\n        );\n    });\n});\n\napp.delete('/api/logs', requirePageLogin, (req, res) => {\n    db.run('DELETE FROM logs', (err) => {\n        if (err) return res.status(500).json({ error: 'Erro ao limpar logs.' });\n        res.json({ success: true, message: 'Logs limpos com sucesso.' });\n    });\n});\n\n// Função auxiliar para obter IP real do cliente\nfunction getClientIp(req) {\n    return req.headers['x-forwarded-for']?.split(',')[0]?.trim() || \n           req.headers['x-real-ip'] || \n           req.connection?.remoteAddress || \n           req.socket?.remoteAddress ||\n           'unknown';\n}\n\n// Função auxiliar para criar hash de payload (sem expor dados sensíveis)\nfunction hashPayload(data) {\n    if (!data || typeof data !== 'object') return null;\n    const sanitized = JSON.stringify(data);\n    return crypto.createHash('sha256').update(sanitized).digest('hex').substring(0, 16);\n}\n\n// Função auxiliar para registrar logs com auditoria completa\nfunction logEvent(type, username, action, details, req = null) {\n    const ip_address = req ? getClientIp(req) : null;\n    const user_agent = req ? req.headers['user-agent'] : null;\n    const route = req ? req.path : null;\n    const event_type = type;\n    const payload_hash = req ? hashPayload(req.body) : null;\n    \n    db.run(\n        `INSERT INTO logs (type, username, action, details, ip_address, user_agent, event_type, route, payload_hash) \n         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`, \n        [type, username, action, details, ip_address, user_agent, event_type, route, payload_hash],\n        (err) => { \n            if (err && !err.message.includes('no column named')) {\n                console.error('Erro ao registrar log:', err.message); \n            }\n        }\n    );\n}\n\n// Exportar função de log para usar em outras rotas\nglobal.logEvent = logEvent;\n\n// =================================================================\n// ROTAS DE ASSISTÊNCIA TÉCNICA\n// =================================================================\n\n// Página principal de Assistência Técnica\napp.get('/assistencia', requirePageLogin, (req, res) => {\n    res.sendFile(path.join(__dirname, 'views', 'assistencia.html'));\n});\n\n// Página de Alertas para Técnicos (via SPA)\napp.get('/alertas-tecnico', requirePageLogin, (req, res) => {\n    res.sendFile(path.join(__dirname, 'views', 'index.html'));\n});\n\n// API - Listar Estoque Técnico\napp.get('/api/estoque-tecnico', requirePageLogin, (req, res) => {\n    const search = req.query.search || '';\n    const disponivel = req.query.disponivel;\n    const loja = req.query.loja;\n    \n    let whereClauses = [];\n    let params = [];\n    \n    if (search) {\n        whereClauses.push('(nome_peca LIKE ? OR codigo_interno LIKE ?)');\n        params.push(`%${search}%`, `%${search}%`);\n    }\n    \n    if (disponivel === 'true') {\n        whereClauses.push('quantidade > 0');\n    }\n    \n    if (loja) {\n        whereClauses.push('loja = ?');\n        params.push(loja);\n    }\n    \n    const whereString = whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : '';\n    \n    db.all(`SELECT * FROM estoque_tecnico ${whereString} ORDER BY nome_peca ASC`, params, (err, rows) => {\n        if (err) return res.status(500).json({ error: err.message });\n        res.json(rows || []);\n    });\n});\n\n// API - Adicionar Peça ao Estoque\napp.post('/api/estoque-tecnico', requirePageLogin, (req, res) => {\n    const { nome_peca, codigo_interno, quantidade, valor_custo, loja } = req.body;\n    \n    if (!nome_peca || !codigo_interno || !loja) {\n        return res.status(400).json({ error: 'Nome da peça, código interno e loja são obrigatórios.' });\n    }\n    \n    db.run(\n        'INSERT INTO estoque_tecnico (nome_peca, codigo_interno, quantidade, valor_custo, loja) VALUES (?, ?, ?, ?, ?)',\n        [nome_peca, codigo_interno, quantidade || 0, valor_custo || 0, loja],\n        function(err) {\n            if (err) {\n                if (err.message.includes('UNIQUE')) {\n                    return res.status(400).json({ error: 'Código interno já existe.' });\n                }\n                return res.status(500).json({ error: err.message });\n            }\n            logEvent('info', req.session.username, 'estoque_add', `Peça adicionada: ${nome_peca} (Loja: ${loja})`);\n            res.status(201).json({ success: true, id: this.lastID });\n        }\n    );\n});\n\n// API - Atualizar Estoque de Peça\napp.put('/api/estoque-tecnico/:id', requirePageLogin, (req, res) => {\n    const { id } = req.params;\n    const { nome_peca, codigo_interno, quantidade, valor_custo, loja } = req.body;\n    \n    db.run(\n        `UPDATE estoque_tecnico SET \n            nome_peca = ?, \n            codigo_interno = ?, \n            quantidade = ?, \n            valor_custo = ?,\n            loja = ?,\n            updated_at = CURRENT_TIMESTAMP\n        WHERE id = ?`,\n        [nome_peca, codigo_interno, quantidade, valor_custo, loja, id],\n        function(err) {\n            if (err) return res.status(500).json({ error: err.message });\n            if (this.changes === 0) return res.status(404).json({ error: 'Peça não encontrada.' });\n            logEvent('info', req.session.username, 'estoque_update', `Estoque atualizado: ID ${id} (Loja: ${loja})`);\n            res.json({ success: true });\n        }\n    );\n});\n\n// API - Deletar Peça do Estoque\napp.delete('/api/estoque-tecnico/:id', requirePageLogin, (req, res) => {\n    const { id } = req.params;\n    \n    db.run('DELETE FROM estoque_tecnico WHERE id = ?', [id], function(err) {\n        if (err) return res.status(500).json({ error: err.message });\n        if (this.changes === 0) return res.status(404).json({ error: 'Peça não encontrada.' });\n        logEvent('info', req.session.username, 'estoque_delete', `Peça removida: ID ${id}`);\n        res.json({ success: true });\n    });\n});\n\n// API - Listar Assistências\napp.get('/api/assistencias', requirePageLogin, (req, res) => {\n    const status = req.query.status;\n    const search = req.query.search || '';\n    const limit = req.query.limit ? parseInt(req.query.limit) : null;\n    const lojaFilter = req.query.loja || '';\n    \n    let whereClauses = [];\n    let params = [];\n    \n    // Filtro opcional por loja específica\n    if (lojaFilter) {\n        whereClauses.push('TRIM(loja) = ?');\n        params.push(lojaFilter.trim());\n    }\n    \n    if (status && status !== 'todos') {\n        // Suportar múltiplos status separados por vírgula\n        const statusList = status.split(',').map(s => s.trim());\n        if (statusList.length === 1) {\n            whereClauses.push('status = ?');\n            params.push(statusList[0]);\n        } else {\n            const placeholders = statusList.map(() => '?').join(',');\n            whereClauses.push(`status IN (${placeholders})`);\n            params.push(...statusList);\n        }\n    }\n    \n    if (search) {\n        whereClauses.push('(cliente_nome LIKE ? OR cliente_cpf LIKE ? OR numero_pedido LIKE ?)');\n        params.push(`%${search}%`, `%${search}%`, `%${search}%`);\n    }\n    \n    const whereString = whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : '';\n    const limitString = limit ? ` LIMIT ${limit}` : '';\n    \n    db.all(`SELECT * FROM assistencias ${whereString} ORDER BY created_at DESC${limitString}`, params, (err, rows) => {\n        if (err) return res.status(500).json({ error: err.message });\n        res.json(rows || []);\n    });\n});\n\n// API - Criar Assistência\napp.post('/api/assistencias', requirePageLogin, (req, res) => {\n    const {\n        cliente_nome,\n        cliente_cpf,\n        numero_pedido,\n        data_entrada,\n        valor_peca_loja,\n        valor_servico_cliente,\n        aparelho,\n        peca_id,\n        peca_nome,\n        observacoes,\n        loja\n    } = req.body;\n    \n    if (!cliente_nome || !cliente_cpf || !data_entrada || !aparelho) {\n        return res.status(400).json({ error: 'Campos obrigatórios: cliente, CPF, data de entrada e aparelho.' });\n    }\n    \n    db.run(\n        `INSERT INTO assistencias (\n            cliente_nome, cliente_cpf, numero_pedido, data_entrada,\n            valor_peca_loja, valor_servico_cliente, aparelho,\n            peca_id, peca_nome, observacoes, tecnico_responsavel, loja\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,\n        [\n            cliente_nome, cliente_cpf, numero_pedido, data_entrada,\n            valor_peca_loja || 0, valor_servico_cliente || 0, aparelho,\n            peca_id, peca_nome, observacoes, req.session.username, loja\n        ],\n        function(err) {\n            if (err) return res.status(500).json({ error: err.message });\n            logEvent('info', req.session.username, 'assistencia_create', `Assistência criada: ${cliente_nome}`);\n            res.status(201).json({ success: true, id: this.lastID });\n        }\n    );\n});\n\n// API - Atualizar Assistência\napp.put('/api/assistencias/:id', requirePageLogin, (req, res) => {\n    const { id } = req.params;\n    const {\n        cliente_nome,\n        cliente_cpf,\n        numero_pedido,\n        data_entrada,\n        data_conclusao,\n        valor_peca_loja,\n        valor_servico_cliente,\n        aparelho,\n        peca_id,\n        peca_nome,\n        observacoes,\n        status,\n        loja\n    } = req.body;\n    \n    db.run(\n        `UPDATE assistencias SET \n            cliente_nome = ?, cliente_cpf = ?, numero_pedido = ?,\n            data_entrada = ?, data_conclusao = ?,\n            valor_peca_loja = ?, valor_servico_cliente = ?,\n            aparelho = ?, peca_id = ?, peca_nome = ?,\n            observacoes = ?, status = ?, loja = ?,\n            updated_at = CURRENT_TIMESTAMP\n        WHERE id = ?`,\n        [\n            cliente_nome, cliente_cpf, numero_pedido, data_entrada, data_conclusao,\n            valor_peca_loja, valor_servico_cliente, aparelho, peca_id, peca_nome,\n            observacoes, status, loja, id\n        ],\n        function(err) {\n            if (err) return res.status(500).json({ error: err.message });\n            if (this.changes === 0) return res.status(404).json({ error: 'Assistência não encontrada.' });\n            logEvent('info', req.session.username, 'assistencia_update', `Assistência atualizada: ID ${id}`);\n            res.json({ success: true });\n        }\n    );\n});\n\n// API - Concluir Assistência (atualiza status e estoque)\napp.post('/api/assistencias/:id/concluir', requirePageLogin, (req, res) => {\n    const { id } = req.params;\n    \n    // Buscar assistência\n    db.get('SELECT * FROM assistencias WHERE id = ?', [id], (err, assistencia) => {\n        if (err) return res.status(500).json({ error: err.message });\n        if (!assistencia) return res.status(404).json({ error: 'Assistência não encontrada.' });\n        \n        // Atualizar assistência para concluída\n        db.run(\n            `UPDATE assistencias SET \n                status = 'Concluído',\n                data_conclusao = ?,\n                updated_at = CURRENT_TIMESTAMP\n            WHERE id = ?`,\n            [new Date().toISOString().split('T')[0], id],\n            function(err) {\n                if (err) return res.status(500).json({ error: err.message });\n                \n                // Se tem peça associada, atualizar estoque\n                if (assistencia.peca_id) {\n                    db.run(\n                        'UPDATE estoque_tecnico SET quantidade = quantidade - 1 WHERE id = ? AND quantidade > 0',\n                        [assistencia.peca_id],\n                        (err) => {\n                            if (err) console.error('Erro ao atualizar estoque:', err.message);\n                        }\n                    );\n                }\n                \n                logEvent('info', req.session.username, 'assistencia_complete', `Assistência concluída: ${assistencia.cliente_nome}`);\n                res.json({ success: true, message: 'Assistência concluída com sucesso!' });\n            }\n        );\n    });\n});\n\n// API - Histórico de Assistências (apenas concluídas)\napp.get('/api/assistencias/historico', requirePageLogin, (req, res) => {\n    const search = req.query.search || '';\n    const lojaFilter = req.query.loja || '';\n    \n    let whereClauses = [\"status = 'Concluído'\"];\n    let params = [];\n    \n    // Filtro opcional por loja específica\n    if (lojaFilter) {\n        whereClauses.push('TRIM(loja) = ?');\n        params.push(lojaFilter.trim());\n    }\n    \n    if (search) {\n        whereClauses.push('(cliente_nome LIKE ? OR cliente_cpf LIKE ? OR numero_pedido LIKE ?)');\n        params.push(`%${search}%`, `%${search}%`, `%${search}%`);\n    }\n    \n    const whereString = `WHERE ${whereClauses.join(' AND ')}`;\n    \n    db.all(`SELECT * FROM assistencias ${whereString} ORDER BY data_conclusao DESC, created_at DESC`, params, (err, rows) => {\n        if (err) return res.status(500).json({ error: err.message });\n        res.json(rows || []);\n    });\n});\n\n// API - Deletar Assistência (apenas concluídas)\napp.delete('/api/assistencias/:id', requirePageLogin, (req, res) => {\n    const { id } = req.params;\n    \n    // Primeiro, verificar se a assistência existe e se está concluída\n    db.get('SELECT id, status FROM assistencias WHERE id = ?', [id], (err, row) => {\n        if (err) return res.status(500).json({ error: err.message });\n        if (!row) return res.status(404).json({ error: 'Assistência não encontrada.' });\n        \n        // Verificar se está concluída\n        if (row.status !== 'Concluído') {\n            return res.status(403).json({ \n                error: 'Apenas assistências concluídas podem ser removidas.' \n            });\n        }\n        \n        // Se estiver concluída, deletar\n        db.run('DELETE FROM assistencias WHERE id = ?', [id], function(err) {\n            if (err) return res.status(500).json({ error: err.message });\n            logEvent('info', req.session.username, 'assistencia_delete', `Assistência concluída removida: ID ${id}`);\n            res.json({ success: true });\n        });\n    });\n});\n\n// API - Estatísticas de Assistência Técnica para Dashboard\napp.get('/api/assistencias/stats-tecnico', requirePageLogin, (req, res) => {\n    const hoje = new Date().toISOString().split('T')[0];\n    const mesAtual = hoje.substring(0, 7);\n    \n    // Em andamento\n    db.get(`\n        SELECT COUNT(*) as total \n        FROM assistencias \n        WHERE status = 'Em andamento'\n    `, [], (err, emAndamento) => {\n        if (err) return res.status(500).json({ error: err.message });\n        \n        // Concluídas hoje\n        db.get(`\n            SELECT COUNT(*) as total \n            FROM assistencias \n            WHERE status = 'Concluído' AND DATE(data_saida) = ?\n        `, [hoje], (err2, concluidasHoje) => {\n            if (err2) return res.status(500).json({ error: err2.message });\n            \n            // Total do mês\n            db.get(`\n                SELECT COUNT(*) as total \n                FROM assistencias \n                WHERE strftime('%Y-%m', data_entrada) = ?\n            `, [mesAtual], (err3, totalMes) => {\n                if (err3) return res.status(500).json({ error: err3.message });\n                \n                // Aguardando peças\n                db.get(`\n                    SELECT COUNT(*) as total \n                    FROM assistencias \n                    WHERE status = 'Aguardando peças'\n                `, [], (err4, aguardandoPecas) => {\n                    if (err4) return res.status(500).json({ error: err4.message });\n                    \n                    res.json({\n                        emAndamento: emAndamento?.total || 0,\n                        concluidasHoje: concluidasHoje?.total || 0,\n                        totalMes: totalMes?.total || 0,\n                        aguardandoPecas: aguardandoPecas?.total || 0\n                    });\n                });\n            });\n        });\n    });\n});\n\napp.get('/api/assistencias/stats', requirePageLogin, (req, res) => {\n    // Técnico com mais assistências\n    db.get(`\n        SELECT tecnico_responsavel, COUNT(*) as total \n        FROM assistencias \n        WHERE tecnico_responsavel IS NOT NULL \n        GROUP BY tecnico_responsavel \n        ORDER BY total DESC \n        LIMIT 1\n    `, (err, topTecnico) => {\n        if (err) return res.status(500).json({ error: err.message });\n        \n        // Loja com mais assistências\n        db.get(`\n            SELECT loja, COUNT(*) as total \n            FROM assistencias \n            WHERE loja IS NOT NULL \n            GROUP BY loja \n            ORDER BY total DESC \n            LIMIT 1\n        `, (err2, topLoja) => {\n            if (err2) return res.status(500).json({ error: err2.message });\n            \n            // Total de assistências e valores\n            db.get(`\n                SELECT \n                    COUNT(*) as total_assistencias,\n                    SUM(CASE WHEN status = 'Concluído' THEN 1 ELSE 0 END) as concluidas,\n                    SUM(CASE WHEN status = 'Em andamento' THEN 1 ELSE 0 END) as em_andamento,\n                    SUM(valor_peca_loja + valor_servico_cliente) as valor_total\n                FROM assistencias\n            `, (err3, totais) => {\n                if (err3) return res.status(500).json({ error: err3.message });\n                \n                res.json({\n                    topTecnico: topTecnico || { tecnico_responsavel: '-', total: 0 },\n                    topLoja: topLoja || { loja: '-', total: 0 },\n                    totais: totais || { total_assistencias: 0, concluidas: 0, em_andamento: 0, valor_total: 0 }\n                });\n            });\n        });\n    });\n});\n\n// API - Assistências por Loja (detalhamento)\napp.get('/api/assistencias/por-loja', requirePageLogin, (req, res) => {\n    db.all(`\n        SELECT \n            loja,\n            COUNT(*) as total,\n            SUM(CASE WHEN status = 'Concluído' THEN 1 ELSE 0 END) as concluidas,\n            SUM(CASE WHEN status = 'Em andamento' THEN 1 ELSE 0 END) as em_andamento,\n            SUM(valor_peca_loja + valor_servico_cliente) as valor_total\n        FROM assistencias\n        WHERE loja IS NOT NULL\n        GROUP BY loja\n        ORDER BY total DESC\n    `, (err, rows) => {\n        if (err) return res.status(500).json({ error: err.message });\n        res.json(rows || []);\n    });\n});\n\n// API - Estatísticas Diárias de Assistência com Filtro de Loja\napp.get('/api/assistencias/stats-daily', requirePageLogin, (req, res) => {\n    const { loja } = req.query;\n    const hoje = new Date().toISOString().split('T')[0];\n    \n    let whereClauses = [`DATE(data_saida) = ?`];\n    let params = [hoje];\n    \n    if (loja && loja !== 'todas') {\n        whereClauses.push('TRIM(loja) = ?');\n        params.push(loja.trim());\n    }\n    \n    const whereString = whereClauses.join(' AND ');\n    \n    db.get(`\n        SELECT \n            SUM(CASE WHEN status = 'Concluído' THEN 1 ELSE 0 END) as concluidas_hoje,\n            SUM(CASE WHEN status = 'Concluído' THEN (valor_peca_loja + valor_servico_cliente) ELSE 0 END) as faturamento_hoje\n        FROM assistencias\n        WHERE ${whereString}\n    `, params, (err, totais) => {\n        if (err) return res.status(500).json({ error: err.message });\n        \n        let whereClausesAndamento = ['status = ?'];\n        let paramsAndamento = ['Em andamento'];\n        \n        if (loja && loja !== 'todas') {\n            whereClausesAndamento.push('TRIM(loja) = ?');\n            paramsAndamento.push(loja.trim());\n        }\n        \n        const whereStringAndamento = whereClausesAndamento.join(' AND ');\n        \n        db.get(`\n            SELECT COUNT(*) as em_andamento\n            FROM assistencias\n            WHERE ${whereStringAndamento}\n        `, paramsAndamento, (err2, andamento) => {\n            if (err2) return res.status(500).json({ error: err2.message });\n            \n            res.json({\n                concluidas_hoje: totais?.concluidas_hoje || 0,\n                faturamento_hoje: totais?.faturamento_hoje || 0,\n                em_andamento: andamento?.em_andamento || 0\n            });\n        });\n    });\n});\n\n// API - Lista de Tickets de Assistência\napp.get('/api/assistencias/tickets', requirePageLogin, (req, res) => {\n    const { loja, limit } = req.query;\n    \n    let whereClauses = [\"status IN ('Em andamento', 'Aguardando peças')\"];\n    let params = [];\n    \n    if (loja && loja !== 'todas') {\n        whereClauses.push('TRIM(loja) = ?');\n        params.push(loja.trim());\n    }\n    \n    const whereString = whereClauses.join(' AND ');\n    const limitClause = limit ? `LIMIT ${parseInt(limit)}` : 'LIMIT 50';\n    \n    db.all(`\n        SELECT \n            id,\n            cliente_nome,\n            cliente_cpf,\n            numero_pedido,\n            aparelho,\n            status,\n            loja,\n            data_entrada,\n            data_saida,\n            tecnico_responsavel,\n            defeito_reclamado,\n            valor_peca_loja,\n            valor_servico_cliente\n        FROM assistencias\n        WHERE ${whereString}\n        ORDER BY data_entrada DESC\n        ${limitClause}\n    `, params, (err, rows) => {\n        if (err) return res.status(500).json({ error: err.message });\n        res.json(rows || []);\n    });\n});\n\n// =================================================================\n// INICIALIZAÇÃO DO SERVIDOR\n// =================================================================\nconst startTime = new Date();\nconsole.log(`Iniciando servidor em ${startTime.toLocaleString('pt-BR')}...`);\n\napp.listen(PORT, '0.0.0.0', () => {\n    console.log(`Servidor rodando em http://0.0.0.0:${PORT}`);\n    logEvent('info', 'system', 'server_start', `Servidor iniciado em http://0.0.0.0:${PORT}`);\n});\n\n","size_bytes":147409},"monitoramento-lojas-varejo-main/create-relatorio/public/js/pages/demandas.js":{"content":"import { showToast, showConfirmModal } from '../utils.js';\n\nexport function initDemandasPage() {\n    const containerPendentes = document.getElementById('demandas-pendentes-container');\n    const containerHistorico = document.getElementById('demandas-historico-container');\n    const abas = document.querySelectorAll('#demandasTab .nav-link');\n    const modalDemandaEl = document.getElementById('modal-add-demanda');\n    \n    // ===== A MUDANÇA ESTÁ AQUI =====\n    // Trocamos 'page-content' pelo nosso novo wrapper específico da página.\n    const demandasWrapper = document.getElementById('demandas-page-wrapper');\n    // ===============================\n\n    if (!modalDemandaEl || !demandasWrapper) return; // Adicionada verificação para o wrapper\n\n    const modalDemanda = new bootstrap.Modal(modalDemandaEl);\n    const formDemanda = document.getElementById('form-add-demanda');\n    const selectLojaModal = document.getElementById('demanda-loja');\n\n    async function carregarLojasNoModal() {\n        try {\n            const response = await fetch('/api/lojas?status=ativa');\n            const lojas = await response.json();\n            selectLojaModal.innerHTML = '<option value=\"\" selected disabled>Selecione uma loja</option>';\n            lojas.forEach(loja => {\n                selectLojaModal.add(new Option(loja.nome, loja.nome));\n            });\n        } catch (error) {\n            console.error(\"Falha ao carregar lojas:\", error);\n        }\n    }\n\n    async function carregarDemandas(tipo) {\n        const container = tipo === 'pendentes' ? containerPendentes : containerHistorico;\n        const url = `/api/demandas/${tipo}`;\n        if (!container) return;\n\n        container.innerHTML = '<p class=\"text-center\">Carregando...</p>';\n        try {\n            const response = await fetch(url);\n            const demandas = await response.json();\n            if (demandas.length === 0) {\n                container.innerHTML = '<p class=\"text-center text-muted\">Nenhuma demanda encontrada.</p>';\n                return;\n            }\n\n            container.innerHTML = demandas.map(d => {\n                const tagCores = { 'Urgente': 'bg-danger', 'Alta': 'bg-warning text-dark', 'Normal': 'bg-info text-dark', 'Baixa': 'bg-secondary' };\n                let acoesHtml = '';\n                // A lógica para tipo 'concluidas' estava errada, corrigido para 'historico'\n                if (tipo === 'pendentes') {\n                    acoesHtml = `<div class=\"d-flex justify-content-end mt-2\"><button class=\"btn btn-sm btn-success me-2\" data-action=\"concluir\" data-id=\"${d.id}\" title=\"Concluir\"><i class=\"bi bi-check-lg\"></i></button><button class=\"btn btn-sm btn-danger\" data-action=\"excluir\" data-id=\"${d.id}\" title=\"Excluir\"><i class=\"bi bi-trash\"></i></button></div>`;\n                } else if (tipo === 'historico') { // CORREÇÃO LÓGICA\n                    acoesHtml = `<div class=\"d-flex justify-content-end mt-2\"><button class=\"btn btn-sm btn-danger\" data-action=\"excluir\" data-id=\"${d.id}\" title=\"Excluir do Histórico\"><i class=\"bi bi-trash\"></i></button></div>`;\n                }\n                const footerHtml = tipo === 'pendentes' ? `Criado por <strong>${d.criado_por_usuario}</strong> em ${new Date(d.criado_em).toLocaleDateString('pt-BR')}` : `Concluído por <strong>${d.concluido_por_usuario || 'N/A'}</strong> em ${new Date(d.concluido_em).toLocaleDateString('pt-BR')}`;\n\n                return `<div class=\"card mb-3\"><div class=\"card-body\"><div class=\"d-flex justify-content-between align-items-start\"><div><h5 class=\"card-title mb-1\">${d.loja_nome}</h5><p class=\"card-text mb-0\">${d.descricao}</p></div><span class=\"badge ${tagCores[d.tag] || 'bg-light text-dark'}\">${d.tag}</span></div>${acoesHtml}</div><div class=\"card-footer text-muted small\">${footerHtml}</div></div>`;\n            }).join('');\n        } catch (e) {\n            container.innerHTML = '<p class=\"text-center text-danger\">Erro ao carregar demandas.</p>';\n        }\n    }\n\n    formDemanda.addEventListener('submit', async (e) => {\n        e.preventDefault();\n        const data = Object.fromEntries(new FormData(e.target).entries());\n        if (!data.loja_nome) {\n            showToast('Atenção', 'Selecione uma loja.', 'danger');\n            return;\n        }\n        try {\n            const response = await fetch('/api/demandas', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) });\n            if (!response.ok) throw new Error('Falha ao adicionar demanda.');\n            modalDemanda.hide();\n            e.target.reset();\n            showToast('Sucesso', 'Demanda adicionada.', 'success');\n            carregarDemandas('pendentes');\n        } catch (error) {\n            showToast('Erro', error.message, 'danger');\n        }\n    });\n\n    abas.forEach(aba => {\n        aba.addEventListener('shown.bs.tab', (event) => {\n            const targetId = event.target.getAttribute('data-bs-target');\n            // A lógica para carregar o histórico estava errada, corrigido para 'historico'\n            if (targetId === '#pendentes') carregarDemandas('pendentes');\n            else if (targetId === '#historico') carregarDemandas('historico'); // CORREÇÃO LÓGICA\n        });\n    });\n\n    // ===== A MUDANÇA ESTÁ AQUI =====\n    // O ouvinte agora está no nosso wrapper, isolado do resto do app.\n    demandasWrapper.addEventListener('click', async (e) => {\n        const button = e.target.closest('button[data-action]');\n        // A verificação de containeres ainda é uma boa prática\n        if (!button || !button.closest('#demandas-pendentes-container, #demandas-historico-container')) return;\n\n        const id = button.dataset.id;\n        const action = button.dataset.action;\n        const isPendente = !!button.closest('#demandas-pendentes-container');\n\n        if (action === 'concluir') {\n            const confirmed = await showConfirmModal('Marcar esta demanda como concluída?');\n            if (!confirmed) return;\n            try {\n                const response = await fetch(`/api/demandas/${id}/concluir`, { method: 'PUT' });\n                if (!response.ok) throw new Error('Falha ao concluir demanda.');\n                showToast('Sucesso', 'Demanda movida para o histórico.', 'info');\n                carregarDemandas('pendentes');\n            } catch (e) { showToast('Erro', 'Não foi possível concluir.', 'danger'); }\n        }\n\n        if (action === 'excluir') {\n            const confirmed = await showConfirmModal('EXCLUIR PERMANENTEMENTE esta demanda?');\n            if (!confirmed) return;\n            try {\n                const response = await fetch(`/api/demandas/${id}`, { method: 'DELETE' });\n                if (!response.ok) throw new Error('Falha ao excluir demanda.');\n                showToast('Sucesso', 'Demanda excluída.', 'success');\n                // A lógica para recarregar o histórico estava errada, corrigido.\n                if (isPendente) carregarDemandas('pendentes');\n                else carregarDemandas('historico'); // CORREÇÃO LÓGICA\n            } catch (e) { showToast('Erro', 'Não foi possível excluir.', 'danger'); }\n        }\n    });\n\n    carregarLojasNoModal();\n    carregarDemandas('pendentes');\n}","size_bytes":7240},"public/js/pages/assistencia.js":{"content":"import { getAuthHeaders } from '../utils.js';\n\nexport function initAssistenciaPage() {\n    if (!window.currentUser) {\n        setTimeout(initAssistenciaPage, 100);\n        return;\n    }\n    \n    init();\n}\n\nlet estoquePecas = [];\nlet assistencias = [];\nlet assistenciaEdit = null;\nlet lojaAtiva = null;\n\nlet modalPeca, modalDetalhes;\n\nasync function init() {\n    modalPeca = new bootstrap.Modal(document.getElementById('modal-peca'));\n    modalDetalhes = new bootstrap.Modal(document.getElementById('modal-detalhes'));\n    \n    await carregarLojas();\n    await renderCardsLojas();\n    await carregarFiltrosLoja();\n    \n    // Controlar visibilidade das abas baseado no cargo\n    controlarVisibilidadeAbas();\n    \n    // Carregar dados iniciais (todas as lojas para quem tem acesso múltiplo)\n    await carregarChamados();\n    await carregarHistorico();\n    \n    // Se já tiver loja ativa (Gerente/Técnico), carregar estoque também\n    if (lojaAtiva) {\n        await carregarEstoque();\n    }\n    \n    document.getElementById('filter-status').addEventListener('change', carregarChamados);\n    document.getElementById('filter-loja-chamados').addEventListener('change', carregarChamados);\n    document.getElementById('search-chamados').addEventListener('input', debounce(carregarChamados, 300));\n    document.getElementById('search-estoque').addEventListener('input', debounce(carregarEstoque, 300));\n    document.getElementById('filter-disponivel').addEventListener('change', carregarEstoque);\n    document.getElementById('filter-loja-historico').addEventListener('change', carregarHistorico);\n    document.getElementById('search-historico').addEventListener('input', debounce(carregarHistorico, 300));\n    \n    document.getElementById('btn-adicionar-peca').addEventListener('click', () => {\n        document.getElementById('modalPecaLabel').textContent = 'Adicionar Peça';\n        document.getElementById('form-peca').reset();\n        document.getElementById('peca-id').value = '';\n        modalPeca.show();\n    });\n    \n    document.getElementById('form-peca').addEventListener('submit', salvarPeca);\n    document.getElementById('form-assistencia').addEventListener('submit', salvarAssistencia);\n    \n    document.getElementById('btn-cancelar').addEventListener('click', () => {\n        assistenciaEdit = null;\n        document.getElementById('form-assistencia').reset();\n        document.getElementById('assistencia-id').value = '';\n        document.getElementById('data-entrada').value = new Date().toISOString().split('T')[0];\n    });\n    \n    document.getElementById('data-entrada').value = new Date().toISOString().split('T')[0];\n    \n    // Ocultar botão de adicionar peça apenas para técnicos\n    if (window.currentUser && window.currentUser.role === 'tecnico') {\n        const btnAdicionarPeca = document.getElementById('btn-adicionar-peca');\n        if (btnAdicionarPeca) {\n            btnAdicionarPeca.style.display = 'none';\n        }\n    }\n    \n    document.querySelectorAll('button[data-bs-toggle=\"tab\"]').forEach(tab => {\n        tab.addEventListener('shown.bs.tab', (e) => {\n            if (e.target.id === 'historico-tab') {\n                carregarHistorico();\n            }\n        });\n    });\n}\n\nasync function carregarLojas() {\n    try {\n        const response = await fetch('/api/lojas');\n        const lojas = await response.json();\n        \n        const lojaSelect = document.getElementById('loja-assist');\n        \n        // Se for técnico, mostrar apenas a loja dele\n        if (window.currentUser && window.currentUser.role === 'tecnico' && window.currentUser.loja_tecnico) {\n            lojaSelect.innerHTML = `<option value=\"${window.currentUser.loja_tecnico}\" selected>${window.currentUser.loja_tecnico}</option>`;\n            lojaSelect.disabled = true;\n            lojaSelect.title = 'Técnicos só podem criar assistências para sua loja cadastrada';\n        } else if (window.currentUser && window.currentUser.role === 'gerente' && window.currentUser.loja_gerente) {\n            // Gerente vê apenas sua loja\n            lojaSelect.innerHTML = `<option value=\"${window.currentUser.loja_gerente}\" selected>${window.currentUser.loja_gerente}</option>`;\n            lojaSelect.disabled = true;\n            lojaSelect.title = 'Gerentes só podem criar assistências para sua loja';\n        } else if (lojaAtiva) {\n            // Se houver loja ativa (selecionada via card), pré-selecionar e desabilitar\n            lojaSelect.innerHTML = `<option value=\"${lojaAtiva}\" selected>${lojaAtiva}</option>`;\n            lojaSelect.disabled = true;\n            lojaSelect.title = 'Loja pré-selecionada. Clique em Voltar para trocar de loja';\n        } else {\n            // Admin/Dev/Consultor/Monitoramento sem loja selecionada veem todas as lojas\n            lojaSelect.innerHTML = '<option value=\"\">Selecione uma loja...</option>' + \n                lojas.map(loja => `<option value=\"${loja.nome}\">${loja.nome}</option>`).join('');\n            lojaSelect.disabled = false;\n        }\n    } catch (error) {\n        console.error('Erro ao carregar lojas:', error);\n    }\n}\n\nasync function carregarFiltrosLoja() {\n    // Mostrar filtro de loja apenas para cargos que veem múltiplas lojas\n    const role = window.currentUser.role;\n    const showFilter = ['consultor', 'admin', 'dev', 'monitoramento'].includes(role);\n    \n    if (showFilter) {\n        try {\n            const response = await fetch('/api/lojas');\n            const lojas = await response.json();\n            \n            // Preencher filtro de chamados\n            const filterChamados = document.getElementById('filter-loja-chamados');\n            filterChamados.innerHTML = '<option value=\"\">Todas as Lojas</option>' + \n                lojas.map(loja => `<option value=\"${loja.nome}\">${loja.nome}</option>`).join('');\n            filterChamados.style.display = 'block';\n            \n            // Preencher filtro de histórico\n            const filterHistorico = document.getElementById('filter-loja-historico');\n            filterHistorico.innerHTML = '<option value=\"\">Todas as Lojas</option>' + \n                lojas.map(loja => `<option value=\"${loja.nome}\">${loja.nome}</option>`).join('');\n            filterHistorico.style.display = 'block';\n        } catch (error) {\n            console.error('Erro ao carregar filtros de loja:', error);\n        }\n    }\n}\n\nasync function renderCardsLojas() {\n    const role = window.currentUser.role;\n    \n    // Gerente e Técnico: auto-selecionar sua loja\n    if (role === 'gerente' && window.currentUser.loja_gerente) {\n        lojaAtiva = window.currentUser.loja_gerente;\n        return;\n    }\n    if (role === 'tecnico' && window.currentUser.loja_tecnico) {\n        lojaAtiva = window.currentUser.loja_tecnico;\n        return;\n    }\n    \n    // Consultor, Admin, Dev, Monitoramento: mostrar cards\n    if (['consultor', 'admin', 'dev', 'monitoramento'].includes(role)) {\n        try {\n            const response = await fetch('/api/lojas');\n            const lojas = await response.json();\n            \n            console.log('Total de lojas retornadas:', lojas.length);\n            console.log('Lojas:', lojas);\n            \n            // Filtrar apenas lojas com funcao_especial \"Busca por Assist. Tec.\" OU todas as lojas ativas\n            // Mudança: Agora mostra TODAS as lojas ativas para facilitar acesso à assistência técnica\n            const lojasFiltradas = lojas.filter(loja => loja.status === 'ativa' || loja.status === 'Ativa');\n            \n            console.log('Lojas filtradas (ativas):', lojasFiltradas.length);\n            console.log('Lojas filtradas:', lojasFiltradas);\n            \n            const seletorLojas = document.getElementById('seletor-lojas');\n            const cardsContainer = document.getElementById('cards-lojas');\n            \n            if (!seletorLojas || !cardsContainer) {\n                console.error('Elementos seletor-lojas ou cards-lojas não encontrados!');\n                return;\n            }\n            \n            seletorLojas.style.display = 'block';\n            \n            if (lojasFiltradas.length === 0) {\n                cardsContainer.innerHTML = '<div class=\"col-12\"><p class=\"text-muted text-center\">Nenhuma loja ativa encontrada.</p></div>';\n            } else {\n                cardsContainer.innerHTML = lojasFiltradas.map(loja => `\n                    <div class=\"col-md-3\">\n                        <div class=\"card loja-card h-100\" data-loja=\"${loja.nome}\" onclick=\"window.selecionarLoja('${loja.nome}')\" style=\"cursor: pointer; transition: all 0.2s;\">\n                            <div class=\"card-body text-center\">\n                                <h5 class=\"card-title\">${loja.nome}</h5>\n                                <p class=\"text-muted small mb-0\">${loja.status}</p>\n                            </div>\n                        </div>\n                    </div>\n                `).join('');\n            }\n        } catch (error) {\n            console.error('Erro ao renderizar cards de lojas:', error);\n        }\n    }\n}\n\nwindow.selecionarLoja = async function(nomeLoja) {\n    lojaAtiva = nomeLoja;\n    \n    // Esconder todos os cards\n    document.getElementById('seletor-lojas').style.display = 'none';\n    \n    // Mostrar título da loja selecionada\n    document.getElementById('titulo-loja-selecionada').style.display = 'block';\n    document.getElementById('texto-loja-selecionada').textContent = `Assistência ${nomeLoja}`;\n    \n    // Mostrar todas as abas\n    controlarVisibilidadeAbas();\n    \n    // Atualizar campo Loja no formulário\n    await carregarLojas();\n    \n    // Recarregar dados filtrados pela loja\n    await carregarEstoque();\n    await carregarChamados();\n    await carregarHistorico();\n    \n    showToast(`Loja selecionada: ${nomeLoja}`, 'success');\n};\n\nwindow.voltarParaTodasLojas = async function() {\n    lojaAtiva = null;\n    \n    // Esconder título da loja selecionada\n    document.getElementById('titulo-loja-selecionada').style.display = 'none';\n    \n    // Mostrar cards novamente\n    document.getElementById('seletor-lojas').style.display = 'block';\n    \n    // Limpar seleção visual dos cards\n    document.querySelectorAll('.loja-card').forEach(card => {\n        card.classList.remove('border-primary', 'bg-primary', 'bg-opacity-10');\n    });\n    \n    // Esconder abas de Nova Assistência e Estoque\n    controlarVisibilidadeAbas();\n    \n    // Atualizar campo Loja no formulário\n    await carregarLojas();\n    \n    // Voltar para aba de Chamados\n    document.getElementById('chamados-tab').click();\n    \n    // Recarregar dados de todas as lojas\n    await carregarChamados();\n    await carregarHistorico();\n    \n    showToast('Visualizando todas as lojas', 'info');\n};\n\nfunction controlarVisibilidadeAbas() {\n    const role = window.currentUser.role;\n    \n    // Para cargos com acesso a múltiplas lojas\n    if (['consultor', 'admin', 'dev', 'monitoramento'].includes(role)) {\n        const cadastroTab = document.querySelector('#cadastro-tab').parentElement;\n        const estoqueTab = document.querySelector('#estoque-tab').parentElement;\n        \n        if (lojaAtiva) {\n            // Com loja selecionada: mostrar todas as abas\n            cadastroTab.style.display = 'block';\n            estoqueTab.style.display = 'block';\n        } else {\n            // Sem loja selecionada: esconder Nova Assistência e Estoque\n            cadastroTab.style.display = 'none';\n            estoqueTab.style.display = 'none';\n        }\n    }\n    // Gerente e Técnico sempre veem todas as abas (loja já está definida)\n};\n\nasync function carregarEstoque() {\n    if (!lojaAtiva) {\n        document.getElementById('tabela-estoque').innerHTML = '<tr><td colspan=\"6\" class=\"text-center text-muted\">Selecione uma loja para ver o estoque</td></tr>';\n        return;\n    }\n    \n    const search = document.getElementById('search-estoque').value;\n    const disponivel = document.getElementById('filter-disponivel').checked;\n    \n    try {\n        const params = new URLSearchParams({ search, disponivel, loja: lojaAtiva });\n        const response = await fetch(`/api/estoque-tecnico?${params.toString()}`);\n        estoquePecas = await response.json();\n        \n        atualizarSelectPecas();\n        renderEstoque();\n    } catch (error) {\n        showToast('Erro ao carregar estoque', 'error');\n    }\n}\n\nfunction renderEstoque() {\n    const tbody = document.getElementById('tabela-estoque');\n    \n    if (estoquePecas.length === 0) {\n        tbody.innerHTML = '<tr><td colspan=\"6\" class=\"text-center\">Nenhuma peça encontrada</td></tr>';\n        return;\n    }\n    \n    const isReadOnly = window.currentUser && window.currentUser.role === 'tecnico';\n    \n    tbody.innerHTML = estoquePecas.map(peca => `\n        <tr>\n            <td>${peca.nome_peca}</td>\n            <td><code>${peca.codigo_interno}</code></td>\n            <td>\n                <span class=\"badge bg-${peca.quantidade > 5 ? 'success' : peca.quantidade > 0 ? 'warning' : 'danger'}\">\n                    ${peca.quantidade}\n                </span>\n            </td>\n            <td>R$ ${parseFloat(peca.valor_custo).toFixed(2)}</td>\n            <td>\n                ${peca.quantidade > 0 \n                    ? '<span class=\"badge bg-success\">Disponível</span>' \n                    : '<span class=\"badge bg-danger\">Esgotado</span>'}\n            </td>\n            <td class=\"text-end pe-3\">\n                ${!isReadOnly ? `\n                    <button class=\"btn btn-sm btn-outline-primary\" onclick=\"window.editarPeca(${peca.id})\">\n                        <i class=\"bi bi-pencil\"></i>\n                    </button>\n                    <button class=\"btn btn-sm btn-outline-danger\" onclick=\"window.deletarPeca(${peca.id})\">\n                        <i class=\"bi bi-trash\"></i>\n                    </button>\n                ` : '<span class=\"text-muted small\">Somente leitura</span>'}\n            </td>\n        </tr>\n    `).join('');\n}\n\nfunction atualizarSelectPecas() {\n    const select = document.getElementById('peca-select');\n    select.innerHTML = '<option value=\"\">Selecione uma peça...</option>' + \n        estoquePecas\n            .filter(p => p.quantidade > 0)\n            .map(p => `<option value=\"${p.id}\" data-nome=\"${p.nome_peca}\">${p.nome_peca} (${p.quantidade} disponíveis)</option>`)\n            .join('');\n}\n\nasync function salvarPeca(e) {\n    e.preventDefault();\n    \n    if (!lojaAtiva) {\n        showToast('Selecione uma loja antes de adicionar peças', 'error');\n        return;\n    }\n    \n    const id = document.getElementById('peca-id').value;\n    const data = {\n        nome_peca: document.getElementById('peca-nome').value,\n        codigo_interno: document.getElementById('peca-codigo').value,\n        quantidade: parseInt(document.getElementById('peca-quantidade').value),\n        valor_custo: parseFloat(document.getElementById('peca-valor').value),\n        loja: lojaAtiva\n    };\n    \n    try {\n        const url = id ? `/api/estoque-tecnico/${id}` : '/api/estoque-tecnico';\n        const method = id ? 'PUT' : 'POST';\n        \n        const response = await fetch(url, {\n            method,\n            headers: await getAuthHeaders(),\n            body: JSON.stringify(data)\n        });\n        \n        const result = await response.json();\n        \n        if (response.ok) {\n            showToast(id ? 'Peça atualizada!' : 'Peça adicionada!', 'success');\n            modalPeca.hide();\n            await carregarEstoque();\n        } else {\n            showToast(result.error || 'Erro ao salvar peça', 'error');\n        }\n    } catch (error) {\n        showToast('Erro ao salvar peça', 'error');\n    }\n}\n\nwindow.editarPeca = async function(id) {\n    const peca = estoquePecas.find(p => p.id === id);\n    if (!peca) return;\n    \n    document.getElementById('modalPecaLabel').textContent = 'Editar Peça';\n    document.getElementById('peca-id').value = peca.id;\n    document.getElementById('peca-nome').value = peca.nome_peca;\n    document.getElementById('peca-codigo').value = peca.codigo_interno;\n    document.getElementById('peca-quantidade').value = peca.quantidade;\n    document.getElementById('peca-valor').value = peca.valor_custo;\n    \n    modalPeca.show();\n};\n\nwindow.deletarPeca = async function(id) {\n    if (!confirm('Tem certeza que deseja remover esta peça do estoque?')) return;\n    \n    try {\n        const response = await fetch(`/api/estoque-tecnico/${id}`, { method: 'DELETE', headers: await getAuthHeaders() });\n        \n        if (response.ok) {\n            showToast('Peça removida do estoque', 'success');\n            await carregarEstoque();\n        } else {\n            showToast('Erro ao remover peça', 'error');\n        }\n    } catch (error) {\n        showToast('Erro ao remover peça', 'error');\n    }\n};\n\nasync function carregarChamados() {\n    const status = document.getElementById('filter-status').value;\n    const search = document.getElementById('search-chamados').value;\n    const loja = document.getElementById('filter-loja-chamados').value;\n    \n    try {\n        const params = new URLSearchParams({ status, search });\n        \n        // Se houver loja ativa, filtrar por ela (ignora filtro manual)\n        if (lojaAtiva) {\n            params.append('loja', lojaAtiva);\n        } else if (loja) {\n            // Se não houver loja ativa, usar filtro manual\n            params.append('loja', loja);\n        }\n        // Se não houver loja ativa nem filtro, carrega de todas as lojas\n        \n        const response = await fetch(`/api/assistencias?${params.toString()}`);\n        assistencias = await response.json();\n        \n        renderChamados();\n    } catch (error) {\n        showToast('Erro ao carregar chamados', 'error');\n    }\n}\n\nfunction renderChamados() {\n    const tbody = document.getElementById('tabela-chamados');\n    \n    if (assistencias.length === 0) {\n        tbody.innerHTML = '<tr><td colspan=\"7\" class=\"text-center\">Nenhum chamado encontrado</td></tr>';\n        return;\n    }\n    \n    const canDelete = window.currentUser && ['gerente', 'consultor', 'admin', 'dev'].includes(window.currentUser.role);\n    const canEdit = window.currentUser && ['tecnico', 'gerente', 'consultor', 'admin', 'dev'].includes(window.currentUser.role);\n    \n    tbody.innerHTML = assistencias.map(assist => `\n        <tr>\n            <td>${assist.cliente_nome}</td>\n            <td>${formatCPF(assist.cliente_cpf)}</td>\n            <td>${assist.numero_pedido || '-'}</td>\n            <td>${assist.aparelho}</td>\n            <td>\n                <span class=\"badge bg-${getStatusColor(assist.status)}\">\n                    ${assist.status}\n                </span>\n            </td>\n            <td>${formatDate(assist.data_entrada)}</td>\n            <td class=\"text-end pe-3\">\n                <button class=\"btn btn-sm btn-outline-info\" onclick=\"window.verDetalhes(${assist.id})\">\n                    <i class=\"bi bi-eye\"></i>\n                </button>\n                ${canEdit ? `\n                    <button class=\"btn btn-sm btn-outline-primary\" onclick=\"window.editarAssistencia(${assist.id})\">\n                        <i class=\"bi bi-pencil\"></i>\n                    </button>\n                    ${assist.status !== 'Concluído' ? `\n                        <button class=\"btn btn-sm btn-outline-success\" onclick=\"window.concluirAssistencia(${assist.id})\">\n                            <i class=\"bi bi-check-circle\"></i>\n                        </button>\n                    ` : ''}\n                ` : ''}\n                ${canDelete && assist.status === 'Concluído' ? `\n                    <button class=\"btn btn-sm btn-outline-danger\" onclick=\"window.deletarAssistencia(${assist.id})\">\n                        <i class=\"bi bi-trash\"></i>\n                    </button>\n                ` : ''}\n            </td>\n        </tr>\n    `).join('');\n}\n\nasync function salvarAssistencia(e) {\n    e.preventDefault();\n    \n    const pecaSelect = document.getElementById('peca-select');\n    const pecaOption = pecaSelect.selectedOptions[0];\n    \n    const id = document.getElementById('assistencia-id').value;\n    const data = {\n        cliente_nome: document.getElementById('cliente-nome').value,\n        cliente_cpf: document.getElementById('cliente-cpf').value.replace(/\\D/g, ''),\n        numero_pedido: document.getElementById('numero-pedido').value,\n        data_entrada: document.getElementById('data-entrada').value,\n        valor_peca_loja: parseFloat(document.getElementById('valor-peca').value) || 0,\n        valor_servico_cliente: parseFloat(document.getElementById('valor-servico').value) || 0,\n        aparelho: document.getElementById('aparelho').value,\n        peca_id: pecaSelect.value || null,\n        peca_nome: pecaOption ? pecaOption.dataset.nome : null,\n        observacoes: document.getElementById('observacoes').value,\n        status: document.getElementById('status-select').value,\n        loja: document.getElementById('loja-assist').value\n    };\n    \n    if (id) {\n        data.data_conclusao = assistenciaEdit?.data_conclusao || null;\n    }\n    \n    try {\n        const url = id ? `/api/assistencias/${id}` : '/api/assistencias';\n        const method = id ? 'PUT' : 'POST';\n        \n        const response = await fetch(url, {\n            method,\n            headers: await getAuthHeaders(),\n            body: JSON.stringify(data)\n        });\n        \n        const result = await response.json();\n        \n        if (response.ok) {\n            showToast(id ? 'Assistência atualizada!' : 'Assistência cadastrada!', 'success');\n            document.getElementById('form-assistencia').reset();\n            document.getElementById('assistencia-id').value = '';\n            document.getElementById('data-entrada').value = new Date().toISOString().split('T')[0];\n            assistenciaEdit = null;\n            \n            await carregarChamados();\n            \n            const tab = new bootstrap.Tab(document.getElementById('chamados-tab'));\n            tab.show();\n        } else {\n            showToast(result.error || 'Erro ao salvar assistência', 'error');\n        }\n    } catch (error) {\n        showToast('Erro ao salvar assistência', 'error');\n    }\n}\n\nwindow.editarAssistencia = async function(id) {\n    const assist = assistencias.find(a => a.id === id);\n    if (!assist) return;\n    \n    assistenciaEdit = assist;\n    \n    document.getElementById('assistencia-id').value = assist.id;\n    document.getElementById('cliente-nome').value = assist.cliente_nome;\n    document.getElementById('cliente-cpf').value = formatCPF(assist.cliente_cpf);\n    document.getElementById('numero-pedido').value = assist.numero_pedido || '';\n    document.getElementById('data-entrada').value = assist.data_entrada;\n    document.getElementById('valor-peca').value = assist.valor_peca_loja;\n    document.getElementById('valor-servico').value = assist.valor_servico_cliente;\n    document.getElementById('aparelho').value = assist.aparelho;\n    document.getElementById('peca-select').value = assist.peca_id || '';\n    document.getElementById('observacoes').value = assist.observacoes || '';\n    document.getElementById('status-select').value = assist.status;\n    document.getElementById('loja-assist').value = assist.loja || '';\n    \n    const tab = new bootstrap.Tab(document.getElementById('cadastro-tab'));\n    tab.show();\n};\n\nwindow.concluirAssistencia = async function(id) {\n    if (!confirm('Deseja marcar esta assistência como concluída?')) return;\n    \n    try {\n        const response = await fetch(`/api/assistencias/${id}/concluir`, { method: 'POST', headers: await getAuthHeaders() });\n        const result = await response.json();\n        \n        if (response.ok) {\n            showToast(result.message, 'success');\n            await carregarChamados();\n        } else {\n            showToast(result.error || 'Erro ao concluir assistência', 'error');\n        }\n    } catch (error) {\n        showToast('Erro ao concluir assistência', 'error');\n    }\n};\n\nwindow.deletarAssistencia = async function(id) {\n    if (!confirm('Tem certeza que deseja excluir esta assistência?')) return;\n    \n    try {\n        const response = await fetch(`/api/assistencias/${id}`, { method: 'DELETE', headers: await getAuthHeaders() });\n        const result = await response.json();\n        \n        if (response.ok) {\n            showToast('Assistência removida', 'success');\n            await carregarChamados();\n        } else {\n            showToast(result.error || 'Erro ao remover assistência', 'error');\n        }\n    } catch (error) {\n        showToast('Erro ao remover assistência', 'error');\n    }\n};\n\nwindow.verDetalhes = function(id) {\n    const assist = assistencias.find(a => a.id === id);\n    if (!assist) return;\n    \n    const valorTotal = (parseFloat(assist.valor_peca_loja) || 0) + (parseFloat(assist.valor_servico_cliente) || 0);\n    \n    document.getElementById('detalhes-content').innerHTML = `\n        <div class=\"row\">\n            <div class=\"col-md-6\">\n                <h6>Informações do Cliente</h6>\n                <p><strong>Nome:</strong> ${assist.cliente_nome}</p>\n                <p><strong>CPF:</strong> ${formatCPF(assist.cliente_cpf)}</p>\n                <p><strong>Nº Pedido:</strong> ${assist.numero_pedido || '-'}</p>\n            </div>\n            <div class=\"col-md-6\">\n                <h6>Informações da Assistência</h6>\n                <p><strong>Aparelho:</strong> ${assist.aparelho}</p>\n                <p><strong>Peça:</strong> ${assist.peca_nome || 'Nenhuma'}</p>\n                <p><strong>Loja:</strong> ${assist.loja || '-'}</p>\n            </div>\n        </div>\n        <div class=\"row mt-3\">\n            <div class=\"col-md-6\">\n                <h6>Datas</h6>\n                <p><strong>Entrada:</strong> ${formatDate(assist.data_entrada)}</p>\n                <p><strong>Conclusão:</strong> ${assist.data_conclusao ? formatDate(assist.data_conclusao) : '-'}</p>\n            </div>\n            <div class=\"col-md-6\">\n                <h6>Valores</h6>\n                <p><strong>Peça (Loja):</strong> R$ ${parseFloat(assist.valor_peca_loja).toFixed(2)}</p>\n                <p><strong>Serviço (Cliente):</strong> R$ ${parseFloat(assist.valor_servico_cliente).toFixed(2)}</p>\n                <p><strong>Total:</strong> <strong>R$ ${valorTotal.toFixed(2)}</strong></p>\n            </div>\n        </div>\n        <div class=\"row mt-3\">\n            <div class=\"col-12\">\n                <h6>Status</h6>\n                <p><span class=\"badge bg-${getStatusColor(assist.status)}\">${assist.status}</span></p>\n            </div>\n        </div>\n        ${assist.observacoes ? `\n            <div class=\"row mt-3\">\n                <div class=\"col-12\">\n                    <h6>Observações</h6>\n                    <p>${assist.observacoes}</p>\n                </div>\n            </div>\n        ` : ''}\n        <div class=\"row mt-3\">\n            <div class=\"col-12\">\n                <p class=\"text-muted small mb-0\">\n                    <strong>Técnico:</strong> ${assist.tecnico_responsavel || '-'}<br>\n                    <strong>Criado em:</strong> ${new Date(assist.created_at).toLocaleString('pt-BR')}\n                </p>\n            </div>\n        </div>\n    `;\n    \n    modalDetalhes.show();\n};\n\nasync function carregarHistorico() {\n    const search = document.getElementById('search-historico').value;\n    const loja = document.getElementById('filter-loja-historico').value;\n    \n    try {\n        const params = new URLSearchParams({ search });\n        \n        // Se houver loja ativa, filtrar por ela (ignora filtro manual)\n        if (lojaAtiva) {\n            params.append('loja', lojaAtiva);\n        } else if (loja) {\n            // Se não houver loja ativa, usar filtro manual\n            params.append('loja', loja);\n        }\n        // Se não houver loja ativa nem filtro, carrega de todas as lojas\n        \n        const response = await fetch(`/api/assistencias/historico?${params.toString()}`);\n        const historico = await response.json();\n        \n        renderHistorico(historico);\n    } catch (error) {\n        showToast('Erro ao carregar histórico', 'error');\n    }\n}\n\nfunction renderHistorico(historico) {\n    const tbody = document.getElementById('tabela-historico');\n    \n    if (historico.length === 0) {\n        tbody.innerHTML = '<tr><td colspan=\"9\" class=\"text-center\">Nenhuma assistência encontrada</td></tr>';\n        return;\n    }\n    \n    const canDelete = window.currentUser && ['gerente', 'consultor', 'admin', 'dev'].includes(window.currentUser.role);\n    \n    tbody.innerHTML = historico.map(assist => {\n        const dataAtualizacao = assist.data_saida || assist.data_conclusao || assist.created_at;\n        return `\n            <tr>\n                <td>${assist.cliente_nome}</td>\n                <td>${formatCPF(assist.cliente_cpf)}</td>\n                <td>${assist.numero_pedido || '-'}</td>\n                <td>${assist.loja || '-'}</td>\n                <td>${assist.tecnico_responsavel || '-'}</td>\n                <td>\n                    <span class=\"badge bg-${getStatusColor(assist.status)}\">\n                        ${assist.status}\n                    </span>\n                </td>\n                <td>${formatDate(assist.data_entrada)}</td>\n                <td>${formatDateTime(dataAtualizacao)}</td>\n                <td class=\"text-end pe-3\">\n                    <button class=\"btn btn-sm btn-outline-info\" onclick=\"window.verDetalhesHistorico(${assist.id})\" title=\"Ver Detalhes\">\n                        <i class=\"bi bi-eye\"></i>\n                    </button>\n                    ${canDelete && assist.status === 'Concluído' ? `\n                        <button class=\"btn btn-sm btn-outline-danger\" onclick=\"window.deletarAssistencia(${assist.id})\" title=\"Excluir\">\n                            <i class=\"bi bi-trash\"></i>\n                        </button>\n                    ` : ''}\n                </td>\n            </tr>\n        `;\n    }).join('');\n}\n\nwindow.verDetalhesHistorico = async function(id) {\n    try {\n        const response = await fetch(`/api/assistencias?status=Concluído`);\n        const historico = await response.json();\n        const assist = historico.find(a => a.id === id);\n        \n        if (assist) {\n            assistencias.push(assist);\n            window.verDetalhes(id);\n        }\n    } catch (error) {\n        showToast('Erro ao carregar detalhes', 'error');\n    }\n};\n\nfunction getStatusColor(status) {\n    const colors = {\n        'Em andamento': 'primary',\n        'Falta de peças': 'warning',\n        'Concluído': 'success'\n    };\n    return colors[status] || 'secondary';\n}\n\nfunction formatCPF(cpf) {\n    if (!cpf) return '';\n    const cleaned = cpf.replace(/\\D/g, '');\n    return cleaned.replace(/(\\d{3})(\\d{3})(\\d{3})(\\d{2})/, '$1.$2.$3-$4');\n}\n\nfunction formatDate(dateStr) {\n    if (!dateStr) return '-';\n    const [year, month, day] = dateStr.split('-');\n    return `${day}/${month}/${year}`;\n}\n\nfunction formatDateTime(dateTimeStr) {\n    if (!dateTimeStr) return '-';\n    try {\n        const date = new Date(dateTimeStr);\n        return date.toLocaleString('pt-BR', {\n            day: '2-digit',\n            month: '2-digit',\n            year: 'numeric',\n            hour: '2-digit',\n            minute: '2-digit'\n        });\n    } catch (e) {\n        return '-';\n    }\n}\n\nfunction debounce(func, wait) {\n    let timeout;\n    return function(...args) {\n        clearTimeout(timeout);\n        timeout = setTimeout(() => func.apply(this, args), wait);\n    };\n}\n\nfunction showToast(message, type = 'info') {\n    const toast = document.createElement('div');\n    toast.className = `toast align-items-center text-white bg-${type === 'error' ? 'danger' : type} border-0`;\n    toast.setAttribute('role', 'alert');\n    toast.innerHTML = `\n        <div class=\"d-flex\">\n            <div class=\"toast-body\">${message}</div>\n            <button type=\"button\" class=\"btn-close btn-close-white me-2 m-auto\" data-bs-dismiss=\"toast\"></button>\n        </div>\n    `;\n    \n    let container = document.querySelector('.toast-container');\n    if (!container) {\n        container = document.createElement('div');\n        container.className = 'toast-container position-fixed top-0 end-0 p-3';\n        document.body.appendChild(container);\n    }\n    \n    container.appendChild(toast);\n    const bsToast = new bootstrap.Toast(toast);\n    bsToast.show();\n    \n    toast.addEventListener('hidden.bs.toast', () => toast.remove());\n}\n","size_bytes":32475},"monitoramento-lojas-varejo-main/create-relatorio/public/js/utils.js":{"content":"/**\n * Exibe uma notificação toast no canto da tela.\n * @param {string} title Título do toast.\n * @param {string} message Mensagem do corpo do toast.\n * @param {'success'|'danger'|'info'} type O tipo de notificação (muda a cor).\n */\nexport function showToast(title, message, type = 'success') {\n    const toastEl = document.getElementById('notificationToast');\n    if (!toastEl) return;\n    const toastHeader = toastEl.querySelector('.toast-header');\n    const toastTitle = document.getElementById('toast-title');\n    const toastBody = document.getElementById('toast-body');\n\n    toastTitle.textContent = title;\n    toastBody.textContent = message;\n\n    toastHeader.classList.remove('bg-success', 'bg-danger', 'bg-info');\n    if (type === 'success') toastHeader.classList.add('bg-success');\n    else if (type === 'danger') toastHeader.classList.add('bg-danger');\n    else toastHeader.classList.add('bg-info');\n\n    const toast = new bootstrap.Toast(toastEl);\n    toast.show();\n}\n\n/**\n * Exibe um modal de confirmação e retorna uma Promise que resolve como true ou false.\n * @param {string} message A pergunta a ser exibida no modal.\n * @returns {Promise<boolean>} Retorna true se o usuário clicar \"Sim\", senão false.\n */\nexport function showConfirmModal(message) {\n    return new Promise((resolve) => {\n        const confirmModalEl = document.getElementById('confirmModal');\n        if (!confirmModalEl) {\n            resolve(window.confirm(message));\n            return;\n        }\n\n        const confirmModal = new bootstrap.Modal(confirmModalEl);\n        document.getElementById('confirmModalBody').textContent = message;\n\n        const btnYes = document.getElementById('confirm-btn-yes');\n        const btnNo = document.getElementById('confirm-btn-no');\n        const btnClose = confirmModalEl.querySelector('.btn-close');\n\n        const handleResolve = (value) => {\n            btnYes.removeEventListener('click', onYesClick);\n            btnNo.removeEventListener('click', onNoClick);\n            btnClose.removeEventListener('click', onNoClick);\n            confirmModalEl.removeEventListener('hidden.bs.modal', onHidden);\n\n            if (confirmModal._isShown) {\n                confirmModal.hide();\n            }\n            resolve(value);\n        };\n\n        const onYesClick = () => handleResolve(true);\n        const onNoClick = () => handleResolve(false);\n        const onHidden = () => handleResolve(false);\n\n        btnYes.addEventListener('click', onYesClick, { once: true });\n        btnNo.addEventListener('click', onNoClick, { once: true });\n        btnClose.addEventListener('click', onNoClick, { once: true });\n        confirmModalEl.addEventListener('hidden.bs.modal', onHidden, { once: true });\n\n        confirmModal.show();\n    });\n}","size_bytes":2767},"replit.md":{"content":"# Sistema de Monitoramento de Lojas de Varejo\n\n## Overview\nThis project is a web-based retail store monitoring and reporting system built with Node.js, Express, and SQLite. Its primary purpose is to provide functionalities for managing retail stores, generating various sales reports, handling PDF uploads, exporting data, and visualizing key performance indicators through a dashboard. The system aims to streamline retail operations by offering authentication, user management, and a comprehensive view of store performance, with future integration planned for external sales platforms like Bluve/Blu.\n\n## User Preferences\nI prefer simple language. I want iterative development. Ask before making major changes. I prefer detailed explanations.\n\n## System Architecture\n\n### UI/UX Decisions\nThe system features a modern, Apple-inspired design aesthetic with premium visual elements. Key UI/UX decisions include:\n- **Glassmorphism**: Utilizes frosted glass effects for cards, modals, and menus.\n- **Micro-animations**: Implements subtle animations for buttons, hover states, and active states.\n- **Responsive Design**: Comprehensive responsiveness across various devices.\n- **Theming**: Includes a floating dark mode toggle with smooth transitions.\n- **Login Page**: Features a hero-style login page with gradient backgrounds and sequenced fade-in animations.\n- **Component Styling**: Standardized buttons, cards with layered shadows, and forms with bold labels and enhanced focus states.\n- **Dashboard**: Enhanced with performance indicator cards, comparative bar charts, and a donut chart. Ranking visuals include medal icons.\n- **Navigation**: Sidebar navigation with sliding accent bars and animated icons, with a toggle for persistent state.\n- **Pastel Color Palette**: Soft, eye-friendly pastel colors throughout the interface to prevent visual fatigue:\n  - Buttons: #d0ebff (blue details), #e9ecef (grey edit), #ffe3e3 (red delete)\n  - Badges: #c3fae8 (green active), #ffe3e3 (red demitido), #f1f3f5 (grey inactive), #a5d8ff (blue counter)\n  - Three-state vendor status logic: Ativo (active), Demitido (dismissed with date), Inativo (inactive without dismissal date)\n\n### Technical Implementations\n- **Backend**: Node.js with Express.js framework.\n- **Database**: SQLite (`database.db`) with automatic table creation and configurable path (`DB_PATH`).\n- **Authentication**: User authentication with different access levels (admin, user, technician), supporting session management and temporary JWT tokens for development. Default admin credentials: `admin`/`admin`.\n- **File Uploads**: Utilizes `multer` for `multipart/form-data`.\n- **PDF Processing**: `pdf-parse` for reading and `pdfkit` for generating PDFs.\n- **Excel Export**: `exceljs` for generating Excel reports.\n- **Dashboard Features**: Dynamic graphs and statistics.\n- **Demand System**: Internal management of demands.\n- **Backup/Restore**: Database backup and restoration functionality.\n- **Assistência Técnica Module**: Manages technical assistance calls, stock control for repair parts, and logging assistance events. Includes \"Técnico\" role with restricted access.\n- **DVR/NVR Monitoring Module**: Manages Intelbras DVR/NVR devices with log collection and file management (recordings, screenshots, XML/JSON reports). Uses separate multer instance with diskStorage for persistent file storage in `data/dvr_files/<dvrId>/`. Does NOT include video streaming functionality.\n\n### Feature Specifications\n- User authentication and access control.\n- Store management (cadastro e gerenciamento de lojas) with fields for CEP, contact number, and manager.\n- Sales report generation and querying.\n- **PDF Processing & Import**: \n  - **Ranking Dia PDF**: Upload and automatic extraction of PA, Preço Médio, and Atendimento Médio metrics from totals line. Validates store name and date before processing. Uses regex pattern `\\d{1,3}(?:\\.\\d{3})*(?:,\\d+)?` to correctly capture Brazilian-formatted numbers.\n  - **Ticket Dia PDF**: Upload and storage of PDF files for future consultation with filtering by store and date.\n  - **Database table**: `pdf_tickets` stores uploaded PDFs metadata and file paths.\n  - **Endpoints**: POST `/api/pdf/ranking`, POST `/api/pdf/ticket`, GET `/api/pdf/tickets`, GET `/api/pdf/tickets/:id/download`.\n- Report export in TXT, PDF, and Excel formats.\n- Interactive dashboard with graphs and statistics.\n- Internal demand management system.\n- Database backup and restoration.\n- Technical assistance module with stock management and restricted technician views.\n- Temporary JWT token system for development with configurable validity, IP restriction, and revocation.\n- **DVR/NVR Monitoring Module**:\n  - **Device Management**: Register and manage Intelbras DVR/NVR devices with IP, port, credentials, and location details.\n  - **Log System**: Collect and filter device logs with timestamps, event types, and descriptions.\n  - **File Management**: Upload and download files (recordings, screenshots, XML/JSON reports) with metadata tracking.\n  - **Database tables**: `dvr_dispositivos` (devices), `dvr_logs` (event logs), `dvr_arquivos` (uploaded files with metadata).\n  - **Service Layer**: `services/dvrService.js` provides CRUD operations with parameterized SQL queries.\n  - **Storage**: Dedicated multer instance with diskStorage (not memoryStorage) saving files to `data/dvr_files/<dvrId>/`.\n  - **Security**: File size limit (500MB), MIME type filtering, authentication required for all endpoints.\n  - **Endpoints**: POST/GET/PUT/DELETE `/api/dvr/dispositivos`, POST/GET `/api/dvr/logs`, POST/GET/DELETE `/api/dvr/arquivos`, GET `/api/dvr/arquivos/:id/download`.\n  - **Frontend**: Three-tab interface (Dispositivos, Logs, Arquivos) with filters, pagination, and file upload/download capabilities.\n\n### System Design Choices\n- **Project Structure**: Clear separation of concerns with `server.js` as the main entry point, dedicated folders for views, static assets, and data.\n- **Environment**: Configured for Replit, running on port 5000 and binding to `0.0.0.0`.\n- **Modularity**: New features are structured with dedicated tables and APIs.\n- **Responsiveness**: Extensive CSS for adaptive layouts.\n- **Security**: CSP updates, CSRF token handling, bcrypt hashing for passwords, and rate limiting for login attempts.\n\n## External Dependencies\n- **express**: Web server framework.\n- **sqlite3**: SQLite database driver.\n- **express-session**: Middleware for session management.\n- **multer**: Middleware for handling `multipart/form-data`.\n- **pdf-parse**: Library for parsing PDF files.\n- **pdfkit**: Library for PDF generation.\n- **exceljs**: Library for creating and reading Excel XLSX files.\n- **jsonwebtoken**: For generating and verifying JWTs.\n- **bcrypt**: For password hashing.\n- **Bluve/Blu (Planned)**: Future integration for bidirectional store synchronization, automatic report import, and utilizing Bluve's APIs (Movement of Sales, Extract, Reconciliation).","size_bytes":6965},"ROLES_SYSTEM.md":{"content":"# Sistema de Controle de Acesso Baseado em Roles\n\n## Visão Geral\nO sistema implementa um controle de acesso granular baseado em 5 roles (cargos) diferentes, cada um com permissões e acessos específicos.\n\n## Roles Disponíveis\n\n### 1. Gerente\n- **Descrição**: Gerente de uma única loja\n- **Acesso**: Apenas aos dados da loja específica vinculada a ele\n- **Permissões**:\n  - ✅ Dashboard (dados filtrados pela sua loja)\n  - ✅ Consultar relatórios (apenas da sua loja)\n  - ✅ Demandas (visualizar todas, mas criar apenas para sua loja)\n  - ❌ Novo Relatório\n  - ❌ Gerenciar Lojas\n  - ❌ Gerenciar Usuários\n  - ❌ Logs do Sistema\n\n**Configuração**: No cadastro de usuário, seleciona-se o role \"Gerente\" e vincula-se UMA loja específica.\n\n### 2. Consultor\n- **Descrição**: Consultor que gerencia múltiplas lojas\n- **Acesso**: Aos dados de várias lojas vinculadas a ele\n- **Permissões**:\n  - ✅ Dashboard (dados filtrados pelas lojas vinculadas)\n  - ✅ Consultar relatórios (apenas das lojas vinculadas)\n  - ✅ Demandas (visualizar todas, criar para suas lojas)\n  - ❌ Novo Relatório\n  - ❌ Gerenciar Lojas\n  - ❌ Gerenciar Usuários\n  - ❌ Logs do Sistema\n\n**Configuração**: No cadastro de usuário, seleciona-se o role \"Consultor\" e vincula-se MÚLTIPLAS lojas (Ctrl+clique).\n\n### 3. Monitoramento\n- **Descrição**: Equipe de monitoramento com acesso completo aos dados\n- **Acesso**: Todos os dados de todas as lojas\n- **Permissões**:\n  - ✅ Dashboard (todas as lojas)\n  - ✅ Consultar relatórios (todas as lojas)\n  - ✅ Novo Relatório\n  - ✅ Gerenciar Lojas\n  - ✅ Demandas\n  - ❌ Gerenciar Usuários\n  - ❌ Logs do Sistema\n\n**Configuração**: Apenas seleciona-se o role \"Monitoramento\", sem vínculo de lojas.\n\n### 4. Administrador (Admin)\n- **Descrição**: Administrador do sistema\n- **Acesso**: Acesso total ao sistema\n- **Permissões**:\n  - ✅ Dashboard (todas as lojas)\n  - ✅ Consultar relatórios (todas as lojas)\n  - ✅ Novo Relatório\n  - ✅ Gerenciar Lojas\n  - ✅ Demandas\n  - ✅ Gerenciar Usuários\n  - ✅ Backup e Restauração\n  - ❌ Logs do Sistema (exclusivo de Dev)\n\n**Configuração**: Apenas seleciona-se o role \"Administrador\", sem vínculo de lojas.\n\n### 5. Desenvolvedor (Dev)\n- **Descrição**: Desenvolvedor com acesso total incluindo logs\n- **Acesso**: Acesso total ao sistema + logs\n- **Permissões**:\n  - ✅ Dashboard (todas as lojas)\n  - ✅ Consultar relatórios (todas as lojas)\n  - ✅ Novo Relatório\n  - ✅ Gerenciar Lojas\n  - ✅ Demandas\n  - ✅ Gerenciar Usuários\n  - ✅ Backup e Restauração\n  - ✅ **Logs do Sistema**\n\n**Configuração**: Apenas seleciona-se o role \"Desenvolvedor\", sem vínculo de lojas.\n\n## Arquitetura Técnica\n\n### Backend (server.js)\n1. **Middleware de Autorização** (`middleware/roleAuth.js`):\n   - `requireRole([roles])`: Restringe acesso a rotas baseado no role\n   - `requirePage([pages])`: Valida permissões para páginas específicas\n   - `getLojaFilter(role, loja_gerente, lojas_consultor)`: Retorna filtros SQL baseados no role\n   - `getPermissions(role)`: Retorna objeto com todas as permissões do role\n\n2. **Estrutura do Banco de Dados**:\n   - Tabela `usuarios`:\n     - `role`: gerente, consultor, monitoramento, admin, dev\n     - `loja_gerente`: nome da loja (para gerente)\n     - `lojas_consultor`: lista de lojas separadas por vírgula (para consultor)\n   - Tabela `logs`:\n     - Registra ações do sistema (login, erros, acessos)\n     - Visível apenas para role \"dev\"\n\n3. **Filtros de Dados**:\n   - APIs de dashboard, ranking, relatórios e lojas aplicam filtros automáticos\n   - Gerente vê apenas dados da sua loja\n   - Consultor vê apenas dados das lojas vinculadas\n   - Outros roles veem todos os dados\n\n### Frontend (app.js e páginas)\n1. **Controle de Menu**:\n   - Menu lateral mostra apenas itens permitidos para o role do usuário\n   - Baseado no objeto `permissions` retornado pela API `/api/session-info`\n\n2. **Interface de Gerenciamento de Usuários**:\n   - Campo de role com dropdown\n   - Campos condicionais para lojas:\n     - Gerente: select simples (uma loja)\n     - Consultor: select múltiplo (várias lojas)\n   - Exibição de lojas vinculadas na tabela de usuários\n\n3. **Página de Logs** (`views/logs.html`):\n   - Exclusiva para role \"dev\"\n   - Filtragem por tipo (error, warning, info, access)\n   - Filtragem por data\n   - Estatísticas de sistema (erros, warnings, usuários ativos, uptime)\n   - Função de limpar logs\n\n## Segurança\n\n1. **Validação de Permissões**:\n   - Todas as rotas validam permissões no backend\n   - Frontend esconde elementos, mas backend sempre valida\n\n2. **Isolamento de Dados**:\n   - Filtros SQL aplicados automaticamente\n   - Impossível acessar dados de outras lojas (para gerente/consultor)\n\n3. **Registro de Ações**:\n   - Sistema de logs registra acessos e ações importantes\n   - Logs incluem: timestamp, tipo, usuário, ação, detalhes\n\n## Fluxo de Uso\n\n### Criando um Usuário Gerente:\n1. Admin/Dev acessa \"Usuários\" → \"Adicionar Usuário\"\n2. Preenche username e senha\n3. Seleciona role \"Gerente\"\n4. Campo \"Loja do Gerente\" aparece\n5. Seleciona a loja específica\n6. Salva\n\n### Criando um Usuário Consultor:\n1. Admin/Dev acessa \"Usuários\" → \"Adicionar Usuário\"\n2. Preenche username e senha\n3. Seleciona role \"Consultor\"\n4. Campo \"Lojas do Consultor\" aparece\n5. Seleciona múltiplas lojas (Ctrl+clique)\n6. Salva\n\n### Acessando Logs (apenas Dev):\n1. Dev faz login\n2. Vê item \"Logs\" no menu lateral\n3. Acessa página de logs\n4. Pode filtrar por tipo, data\n5. Pode limpar logs se necessário\n\n## Arquivos Modificados/Criados\n\n### Novos Arquivos:\n- `middleware/roleAuth.js` - Middleware de autorização\n- `views/403.html` - Página de acesso negado\n- `views/logs.html` - Página de logs do sistema\n- `public/js/pages/logs.js` - JavaScript da página de logs\n- `ROLES_SYSTEM.md` - Esta documentação\n\n### Arquivos Modificados:\n- `server.js` - Integração do middleware, rotas de logs, filtros de dados\n- `views/index.html` - Menu com IDs e item de Logs\n- `views/gerenciar-usuarios.html` - Campos de roles e lojas\n- `public/js/app.js` - Controle de menu baseado em permissões\n- `public/js/pages/gerenciar-usuarios.js` - Lógica de gerenciamento de roles e lojas\n\n## Manutenção\n\n### Adicionando um Novo Role:\n1. Adicionar role em `middleware/roleAuth.js` no objeto `ROLES`\n2. Definir permissões no `getPermissions()`\n3. Atualizar dropdown em `views/gerenciar-usuarios.html`\n4. Atualizar mapeamento de nomes em `public/js/app.js` e `gerenciar-usuarios.js`\n\n### Modificando Permissões de um Role:\n1. Editar função `getPermissions()` em `middleware/roleAuth.js`\n2. Permissões são aplicadas automaticamente em todas as rotas\n\n## Credenciais Padrão\n- **Username**: admin\n- **Password**: admin\n- **Role**: admin\n","size_bytes":6829},"public/js/pages/logs.js":{"content":"import { showToast, getAuthHeaders } from '../utils.js';\n\nexport function initLogsPage() {\n    const tableBody = document.getElementById('logs-table-body');\n    const btnFilter = document.getElementById('btn-filter-logs');\n    const btnClear = document.getElementById('btn-clear-logs');\n    const btnLoadMore = document.getElementById('btn-load-more-logs');\n    const logTypeFilter = document.getElementById('log-type-filter');\n    const dateStart = document.getElementById('log-date-start');\n    const dateEnd = document.getElementById('log-date-end');\n\n    let currentOffset = 0;\n    const limit = 50;\n\n    async function loadLogs(reset = false) {\n        if (reset) {\n            currentOffset = 0;\n            tableBody.innerHTML = '<tr><td colspan=\"5\" class=\"text-center\">Carregando...</td></tr>';\n        }\n\n        const params = new URLSearchParams({\n            type: logTypeFilter.value,\n            start: dateStart.value || '',\n            end: dateEnd.value || '',\n            limit,\n            offset: currentOffset\n        });\n\n        try {\n            const response = await fetch(`/api/logs?${params}`);\n            const { logs, total, stats } = await response.json();\n\n            if (reset) {\n                tableBody.innerHTML = '';\n            }\n\n            if (logs.length === 0 && reset) {\n                tableBody.innerHTML = '<tr><td colspan=\"5\" class=\"text-center text-muted\">Nenhum log encontrado.</td></tr>';\n                btnLoadMore.classList.add('d-none');\n                return;\n            }\n\n            logs.forEach(log => {\n                const row = createLogRow(log);\n                tableBody.insertAdjacentHTML('beforeend', row);\n            });\n\n            currentOffset += logs.length;\n            btnLoadMore.classList.toggle('d-none', currentOffset >= total);\n\n            updateStats(stats);\n\n        } catch (err) {\n            showToast('Erro', 'Não foi possível carregar os logs.', 'danger');\n            tableBody.innerHTML = '<tr><td colspan=\"5\" class=\"text-center text-danger\">Erro ao carregar logs.</td></tr>';\n        }\n    }\n\n    function createLogRow(log) {\n        const typeColors = {\n            error: 'danger',\n            warning: 'warning',\n            info: 'info',\n            access: 'success'\n        };\n        const color = typeColors[log.type] || 'secondary';\n\n        return `\n            <tr>\n                <td><small>${new Date(log.timestamp).toLocaleString('pt-BR')}</small></td>\n                <td><span class=\"badge bg-${color}\">${log.type.toUpperCase()}</span></td>\n                <td>${log.username || '-'}</td>\n                <td>${log.action || '-'}</td>\n                <td><small>${log.details || '-'}</small></td>\n            </tr>\n        `;\n    }\n\n    function updateStats(stats) {\n        if (stats) {\n            document.getElementById('stat-errors').textContent = stats.errors || 0;\n            document.getElementById('stat-warnings').textContent = stats.warnings || 0;\n            document.getElementById('stat-users').textContent = stats.activeUsers || 0;\n            document.getElementById('stat-uptime').textContent = stats.uptime || '--';\n        }\n    }\n\n    async function clearLogs() {\n        if (!confirm('Tem certeza que deseja limpar todos os logs? Esta ação não pode ser desfeita.')) {\n            return;\n        }\n\n        try {\n            const response = await fetch('/api/logs', { method: 'DELETE', headers: await getAuthHeaders() });\n            if (response.ok) {\n                showToast('Sucesso', 'Logs limpos com sucesso.', 'success');\n                loadLogs(true);\n            } else {\n                throw new Error('Falha ao limpar logs');\n            }\n        } catch (err) {\n            showToast('Erro', 'Não foi possível limpar os logs.', 'danger');\n        }\n    }\n\n    btnFilter.addEventListener('click', () => loadLogs(true));\n    btnClear.addEventListener('click', clearLogs);\n    btnLoadMore.addEventListener('click', () => loadLogs(false));\n\n    loadLogs(true);\n}\n","size_bytes":4020},"public/js/app.js":{"content":"// =================================================================\n// IMPORTS E CONFIGURAÇÃO DE PÁGINAS\n// =================================================================\nimport { initAdminPage } from './pages/admin.js';\nimport { initConsultaPage } from './pages/consulta.js';\nimport { initGerenciarLojasPage } from './pages/gerenciar-lojas.js';\nimport { initDemandasPage } from './pages/demandas.js';\nimport { initNovoRelatorioPage } from './pages/novo-relatorio.js';\nimport { initGerenciarUsuariosPage } from './pages/gerenciar-usuarios.js';\nimport { initLogsPage } from './pages/logs.js';\nimport { initDVRMonitorPage } from './pages/dvr-monitor.js';\nimport { initPageAnimations, initScrollAnimations } from './utils.js';\n\nconst pageInitializers = {\n    'admin': initAdminPage,\n    'consulta': initConsultaPage,\n    'gerenciar-lojas': initGerenciarLojasPage,\n    'demandas': initDemandasPage,\n    'novo-relatorio': initNovoRelatorioPage,\n    'gerenciar-usuarios': initGerenciarUsuariosPage,\n    'logs': initLogsPage,\n    'dvr-monitor': initDVRMonitorPage\n};\n\nlet currentUser = null;\n\n// =================================================================\n// LÓGICA DE NAVEGAÇÃO E CARREGAMENTO DE PÁGINAS\n// =================================================================\nasync function loadPage(path) {\n    const pageContent = document.getElementById('page-content');\n    if (!pageContent) return;\n\n    // Página padrão\n    const defaultPage = 'admin';\n    \n    const pageName = (path.startsWith('/') ? path.substring(1) : path).split('?')[0] || defaultPage;\n    const activePage = (pageName === '' || pageName === 'index.html') ? defaultPage : pageName;\n\n    // Atualiza a classe 'active' nos menus (desktop e mobile)\n    document.querySelectorAll('.sidebar-nav .nav-item').forEach(item => {\n        const link = item.querySelector('.nav-link');\n        const linkHrefPage = link.getAttribute('href').substring(1);\n        item.classList.toggle('active', linkHrefPage === activePage);\n    });\n\n    pageContent.innerHTML = '<div class=\"d-flex justify-content-center p-5\"><div class=\"spinner-border\" role=\"status\"></div></div>';\n\n    try {\n        const response = await fetch(`/content/${activePage}`);\n        if (!response.ok) throw new Error(`Página /content/${activePage} não encontrada.`);\n\n        pageContent.innerHTML = await response.text();\n        \n        // Inicializar animações de scroll para os novos elementos\n        setTimeout(() => initScrollAnimations(), 50);\n        \n        // Garante que a função de inicialização da página seja chamada\n        const initFunc = pageInitializers[activePage];\n        if (typeof initFunc === 'function') {\n           \n            setTimeout(() => {\n                try {\n                    \n                    initFunc(currentUser);\n                } catch (err) {\n                    console.error(`Erro ao inicializar a página '${activePage}':`, err);\n                }\n            }, 0);\n        }\n    } catch (error) {\n        console.error(\"Erro ao carregar página:\", error);\n        pageContent.innerHTML = `<div class=\"p-3 text-center text-danger\"><h3>Oops!</h3><p>Erro ao carregar conteúdo da página.</p></div>`;\n    }\n}\n\nfunction navigateTo(path) {\n    if (location.pathname + location.search === path) return;\n    history.pushState(null, '', path);\n    loadPage(path);\n}\n\n// =================================================================\n// SESSÃO E INICIALIZAÇÃO PRINCIPAL\n// =================================================================\nasync function setupSessionAndUI() {\n    try {\n        const response = await fetch('/api/session-info');\n        if (!response.ok) { window.location.href = '/login'; return; }\n        currentUser = await response.json();\n        window.currentUser = currentUser; // Expor para outras páginas\n        // Todos os menus estão visíveis para todos os usuários\n        const menuIds = ['nav-dashboard', 'nav-consulta', 'nav-novo-relatorio', 'nav-lojas', 'nav-demandas', 'nav-dvr', 'nav-configuracoes', 'nav-logs'];\n        menuIds.forEach(menuId => {\n            document.querySelectorAll(`#${menuId}`).forEach(el => {\n                el?.classList.remove('d-none');\n            });\n        });\n        \n        const userInfoContainer = document.getElementById('user-info-container');\n        if (userInfoContainer) {\n            // Todos os usuários têm acesso a todos os botões\n            const actionButtons = `\n                <a href=\"/novo-relatorio\" id=\"live-mode-btn\" class=\"btn\" title=\"Novo Relatório\"><i class=\"bi bi-broadcast\"></i></a>\n                <a href=\"/gerenciar-usuarios\" class=\"btn\" title=\"Configurações\"><i class=\"bi bi-gear-fill\"></i></a>\n                <a href=\"/logs\" class=\"btn\" title=\"Logs do Sistema\"><i class=\"bi bi-file-earmark-text\"></i></a>\n            `;\n\n            userInfoContainer.innerHTML = `\n                <div class=\"user-info\">\n                    <span>Olá, <strong>${currentUser.username}</strong></span>\n                </div>\n                <div class=\"user-actions\">\n                    ${actionButtons}\n                    <button id=\"theme-toggle-desktop\" class=\"btn\" title=\"Alternar Tema\"><i class=\"bi bi-moon-fill\"></i></button>\n                    <a href=\"/logout\" class=\"btn\" title=\"Sair\"><i class=\"bi bi-box-arrow-right\"></i></a>\n                </div>`;\n            \n            // Reinicializar o theme manager para o botão injetado dinamicamente\n            if (window.themeManager) {\n                window.themeManager.setupToggleButton();\n            }\n        }\n    } catch (e) { console.error(\"Falha na sessão:\", e); window.location.href = '/login'; }\n}\n\n// =================================================================\n// CONTROLE DE SIDEBAR TOGGLE\n// =================================================================\nfunction initSidebarToggle() {\n    const sidebar = document.querySelector('.sidebar-desktop');\n    const mainContent = document.querySelector('.main-content');\n    const toggleBtn = document.getElementById('sidebar-toggle');\n    const showBtn = document.getElementById('sidebar-show-btn');\n    \n    if (!sidebar || !mainContent || !toggleBtn || !showBtn) return;\n    \n    // Carregar estado salvo do localStorage\n    const sidebarHidden = localStorage.getItem('sidebarHidden') === 'true';\n    \n    if (sidebarHidden) {\n        sidebar.classList.add('sidebar-hidden');\n        mainContent.classList.add('sidebar-hidden');\n        showBtn.classList.add('visible');\n    }\n    \n    // Toggle sidebar ao clicar no botão de ocultar\n    toggleBtn.addEventListener('click', () => {\n        const isHidden = sidebar.classList.toggle('sidebar-hidden');\n        mainContent.classList.toggle('sidebar-hidden');\n        \n        if (isHidden) {\n            showBtn.classList.add('visible');\n            localStorage.setItem('sidebarHidden', 'true');\n        } else {\n            showBtn.classList.remove('visible');\n            localStorage.setItem('sidebarHidden', 'false');\n        }\n    });\n    \n    // Mostrar sidebar ao clicar no botão flutuante\n    showBtn.addEventListener('click', () => {\n        sidebar.classList.remove('sidebar-hidden');\n        mainContent.classList.remove('sidebar-hidden');\n        showBtn.classList.remove('visible');\n        localStorage.setItem('sidebarHidden', 'false');\n    });\n}\n\nasync function main() {\n    await setupSessionAndUI();\n    \n    // Inicializar animações globais da página\n    initPageAnimations();\n    \n    // Inicializar controle de sidebar toggle\n    initSidebarToggle();\n    \n    const mobileMenuModalEl = document.getElementById('mobileMenuModal');\n    const mobileMenuModal = mobileMenuModalEl ? new bootstrap.Modal(mobileMenuModalEl) : null;\n\n    document.body.addEventListener('click', e => {\n        const navLink = e.target.closest('a.nav-link');\n        if (navLink && navLink.closest('.sidebar-nav')) {\n            e.preventDefault();\n            const destination = navLink.getAttribute('href');\n            \n            if (navLink.closest('#mobileMenuModal')) {\n                mobileMenuModalEl.addEventListener('hidden.bs.modal', () => {\n                    navigateTo(destination);\n                }, { once: true });\n                if (mobileMenuModal) mobileMenuModal.hide();\n            } else {\n                navigateTo(destination);\n            }\n        }\n    });\n\n    window.addEventListener('popstate', () => loadPage(location.pathname + location.search));\n    loadPage(location.pathname + location.search);\n}\n\ndocument.addEventListener('DOMContentLoaded', main);\n\n// =================================================================\n// FUNÇÕES DE UTILIDADE GLOBAIS\n// =================================================================\nexport function showToast(title, message, type = 'success') {\n    const toastEl = document.getElementById('notificationToast');\n    if (!toastEl) return;\n    const toast = bootstrap.Toast.getOrCreateInstance(toastEl);\n    \n    toastEl.querySelector('#toast-title').textContent = title;\n    toastEl.querySelector('#toast-body').textContent = message;\n    const toastHeader = toastEl.querySelector('.toast-header');\n    toastHeader.classList.remove('bg-success', 'bg-danger', 'bg-info');\n    if (type === 'success') toastHeader.classList.add('bg-success');\n    else if (type === 'danger') toastHeader.classList.add('bg-danger');\n    else toastHeader.classList.add('bg-info');\n    \n    toast.show();\n}\n\nexport function showConfirmModal(message) {\n    return new Promise((resolve) => {\n        const confirmModalEl = document.getElementById('confirmModal');\n        if (!confirmModalEl) { resolve(window.confirm(message)); return; }\n\n        const confirmModal = bootstrap.Modal.getOrCreateInstance(confirmModalEl);\n        confirmModalEl.querySelector('#confirmModalBody').textContent = message;\n\n        const btnYes = confirmModalEl.querySelector('#confirm-btn-yes');\n        const btnNo = confirmModalEl.querySelector('#confirm-btn-no');\n\n        const onYesClick = () => resolve(true);\n        const onNoClick = () => resolve(false);\n\n        btnYes.addEventListener('click', onYesClick, { once: true });\n        btnNo.addEventListener('click', onNoClick, { once: true });\n        \n        // Garante que se o modal for fechado de outra forma, ele resolve como 'false'\n        confirmModalEl.addEventListener('hidden.bs.modal', () => resolve(false), { once: true });\n\n        confirmModal.show();\n    });\n}","size_bytes":10465},"DASHBOARD_IMPROVEMENTS.md":{"content":"# Melhorias no Dashboard - Sistema de Relatórios de Lojas\n\n## 📊 Resumo das Melhorias Implementadas\n\nO dashboard foi completamente renovado com novos gráficos comparativos, melhor organização visual e cards informativos. Todas as melhorias mantêm o padrão visual do sistema.\n\n---\n\n## 🎨 Alterações Implementadas\n\n### 1. **Estrutura e Layout Aprimorados**\n\n#### ✅ Correções de Espaçamento\n- **Classes de Gap Consistentes**: Utilizado `g-3` (gap de 1rem) em todos os `.row` para espaçamento uniforme\n- **Margins Bottom**: Adicionado `mb-4` em sections para separação clara entre blocos\n- **Min-height em Comparações**: Adicionado `min-height: 20px` nos elementos de comparação para evitar saltos visuais\n- **Responsividade**: Grid Bootstrap otimizado (`col-12`, `col-sm-6`, `col-lg-3`, etc.)\n\n#### ✅ Alinhamento de Botões\n- **Botões de Período**: Agora usam `btn-outline-secondary` com estados de hover/active melhorados\n- **Botões de Formulário**: Classe `btn-sm` para tamanho consistente\n- **Selects**: Classe `form-select-sm` para alinhamento vertical perfeito\n\n#### ✅ Ícones Adicionados\nTodos os títulos e labels agora incluem ícones Bootstrap Icons:\n- `<i class=\"bi bi-shop\">` - Lojas\n- `<i class=\"bi bi-calendar3\">` - Calendário\n- `<i class=\"bi bi-speedometer2\">` - Visão Geral\n- `<i class=\"bi bi-bar-chart-line\">` - Métricas\n- `<i class=\"bi bi-graph-up\">` - Análise Comparativa\n- `<i class=\"bi bi-trophy\">` - Melhor Loja\n- E muitos outros...\n\n---\n\n### 2. **Novos Cards de Visão Geral** ⭐ NOVO\n\nSeção completamente nova no topo do dashboard com 4 cards informativos:\n\n```html\n<h4 class=\"mb-3\"><i class=\"bi bi-speedometer2\"></i> Visão Geral</h4>\n<div class=\"row g-3 mb-4\">\n    <!-- 4 cards com métricas -->\n</div>\n```\n\n#### Cards Implementados:\n\n1. **Total de Lojas Ativas**\n   - Ícone: `bi-building` (laranja)\n   - Mostra: Quantidade de lojas ativas no período\n   - Fonte de dados: `rankingData.length`\n\n2. **Melhor Loja (Conv.)**\n   - Ícone: `bi-trophy` (dourado)\n   - Mostra: Nome da loja com maior taxa de conversão\n   - Fonte de dados: Ranking ordenado por `tx_loja`\n\n3. **Média de Conversão**\n   - Ícone: `bi-graph-up-arrow` (verde)\n   - Mostra: Média da taxa de conversão de todas as lojas\n   - Cálculo: Soma de `tx_loja` / número de lojas\n\n4. **Total de Vendas**\n   - Ícone: `bi-cart-check` (laranja)\n   - Mostra: Total de vendas do período selecionado\n   - Fonte de dados: `currentData.total_vendas_loja`\n\n---\n\n### 3. **Gráfico de Barras Comparativo** ⭐ NOVO\n\nLocalização: Logo após os cards de métricas principais\n\n#### Características:\n- **Tipo**: Gráfico de barras vertical (Chart.js)\n- **Dimensões**: 8 colunas (col-lg-8) com 400px de altura\n- **Canvas ID**: `dashboard-bar-chart`\n\n#### Funcionalidades:\n- **Seletor de Métrica**: Dropdown para alternar entre:\n  - Vendas (padrão) - Cor laranja (`--accent-color`)\n  - Clientes - Cor verde (`--color-success`)\n  - Taxa de Conversão - Cor azul (`#4169E1`)\n  \n- **Top 10 Lojas**: Mostra as 10 melhores lojas na métrica selecionada\n- **Tooltips**: Formatação em português com separadores de milhar\n- **Responsivo**: Ajusta-se automaticamente ao tamanho da tela\n\n#### Código JavaScript:\n```javascript\nfunction renderBarChart(rankingData) {\n    // Ordena por métrica selecionada\n    // Pega top 10\n    // Renderiza com cores dinâmicas baseadas na métrica\n}\n```\n\n---\n\n### 4. **Gráfico Donut de Conversão** ⭐ NOVO\n\nLocalização: Ao lado do gráfico de barras (col-lg-4)\n\n#### Características:\n- **Tipo**: Gráfico Donut (Chart.js)\n- **Dimensões**: 4 colunas com 400px de altura\n- **Canvas ID**: `dashboard-donut-chart`\n\n#### Funcionalidades:\n- **Top 5 Lojas**: Mostra as 5 lojas com melhor taxa de conversão\n- **Cores Personalizadas**:\n  ```javascript\n  const colors = [\n      '#FF6384', // Rosa\n      '#36A2EB', // Azul\n      '#FFCE56', // Amarelo\n      '#4BC0C0', // Ciano\n      '#9966FF'  // Roxo\n  ];\n  ```\n- **Legenda**: Posicionada na parte inferior\n- **Tooltips**: Mostra taxa de conversão com 2 casas decimais\n\n#### Código JavaScript:\n```javascript\nfunction renderDonutChart(rankingData) {\n    // Ordena por tx_loja\n    // Pega top 5\n    // Renderiza donut com cores personalizadas\n}\n```\n\n---\n\n### 5. **Gráfico de Ranking Horizontal** ⭐ NOVO\n\nLocalização: Seção de Ranking, ao lado da tabela\n\n#### Características:\n- **Tipo**: Barra horizontal (Chart.js com `indexAxis: 'y'`)\n- **Dimensões**: 6 colunas com 450px de altura\n- **Canvas ID**: `dashboard-ranking-chart`\n\n#### Funcionalidades:\n- **Top 10 Lojas**: Ordenadas por taxa de conversão\n- **Cores Dinâmicas por Desempenho**:\n  ```javascript\n  backgroundColor: function(context) {\n      const value = context.parsed.x;\n      if (value >= 70) return '#2ea043';     // Verde (excelente)\n      if (value >= 50) return '--accent-color'; // Laranja (bom)\n      return '#dc3545';                       // Vermelho (precisa melhorar)\n  }\n  ```\n- **Escala**: 0% a 100% com labels formatados\n- **Ordem Invertida**: Do menor para o maior (top para bottom)\n\n#### Código JavaScript:\n```javascript\nfunction renderRankingChart(rankingData) {\n    // Ordena e inverte (.reverse())\n    // Aplica cores condicionais\n    // Renderiza horizontal\n}\n```\n\n---\n\n### 6. **Melhorias na Tabela de Ranking**\n\n#### Alterações:\n- **Medalhas**: Primeiros 3 lugares ganham emojis 🥇🥈🥉\n- **Sticky Header**: Cabeçalho fixo ao fazer scroll (`position: sticky`)\n- **Max-height**: 500px com scroll automático\n- **Hover Effects**: Destaque ao passar o mouse sobre linhas\n\n#### Código Atualizado:\n```javascript\nconst medal = index === 0 ? '🥇' : \n              index === 1 ? '🥈' : \n              index === 2 ? '🥉' : \n              `#${index + 1}`;\n```\n\n---\n\n## 📁 Arquivos Modificados\n\n### 1. `views/admin.html`\n**Tamanho**: ~220 linhas (antes: ~149)\n\n**Principais Mudanças**:\n- ✅ Adicionada seção \"Visão Geral\" com 4 cards\n- ✅ Reorganizada estrutura com headings `<h4>` separando seções\n- ✅ Adicionados 3 novos canvas para gráficos\n- ✅ Melhorado layout responsivo com `g-3` consistente\n- ✅ Ícones Bootstrap adicionados em todos os títulos\n- ✅ Min-height em elementos de comparação para evitar layout shift\n\n### 2. `public/js/pages/admin.js`\n**Tamanho**: ~520 linhas (antes: ~261)\n\n**Principais Mudanças**:\n- ✅ Adicionadas 3 novas variáveis globais de gráficos\n- ✅ Função `renderBarChart()` - Gráfico de barras comparativo\n- ✅ Função `renderDonutChart()` - Gráfico donut\n- ✅ Função `renderRankingChart()` - Gráfico horizontal\n- ✅ Função `updateOverviewCards()` - Atualiza cards de visão geral\n- ✅ Event listener para `bar-chart-metric-select`\n- ✅ Loading state estendido para todos os gráficos\n\n---\n\n## 🔧 Como Testar\n\n### 1. Fazer Login\n```\nUsuário: admin\nSenha: admin\n```\n\n### 2. Acessar o Dashboard\n- Clique em \"Dashboard\" no menu lateral\n- Ou acesse diretamente: `http://localhost:5000/admin`\n\n### 3. Testar Funcionalidades\n\n#### a) Filtros\n- Selecione diferentes lojas\n- Teste períodos rápidos (Hoje, 7 dias, Este Mês, Mês Passado)\n- Use o período manual com datas customizadas\n- Alterne entre \"Período Anterior\" e \"Ano Anterior\"\n\n#### b) Gráficos\n- **Gráfico de Barras**: Alterne entre Vendas, Clientes e Conversão\n- **Gráfico Donut**: Visualize a distribuição das top 5 lojas\n- **Gráfico Horizontal**: Veja o ranking visual com cores\n- **Gráfico de Linha**: Acompanhe a evolução temporal\n\n#### c) Ranking\n- **Tabela**: Use o select para ordenar por diferentes métricas\n- **Top 3**: Verifique os emojis de medalha\n- **Scroll**: Role a tabela se houver muitas lojas\n\n---\n\n## 🎨 Personalização de Ícones\n\nTodos os ícones foram adicionados como placeholders usando Bootstrap Icons. Para substituir por ícones personalizados:\n\n### Onde estão os ícones:\n\n1. **HTML** (`views/admin.html`):\n```html\n<!-- Exemplo -->\n<i class=\"bi bi-shop\"></i>\n<i class=\"bi bi-calendar3\"></i>\n<i class=\"bi bi-speedometer2\"></i>\n```\n\n2. **Como Substituir**:\n- **Opção 1**: Manter Bootstrap Icons e trocar apenas a classe\n  ```html\n  <i class=\"bi bi-shop\"></i>  →  <i class=\"bi bi-house-fill\"></i>\n  ```\n\n- **Opção 2**: Usar Font Awesome\n  ```html\n  <i class=\"bi bi-shop\"></i>  →  <i class=\"fas fa-store\"></i>\n  ```\n\n- **Opção 3**: Usar SVG customizado\n  ```html\n  <i class=\"bi bi-shop\"></i>  →  <img src=\"/icons/custom-shop.svg\" alt=\"Shop\" style=\"width: 20px;\">\n  ```\n\n### Lista de Ícones Usados:\n| Contexto | Ícone Atual | Classe |\n|----------|-------------|--------|\n| Lojas | 🏪 | `bi-shop` |\n| Calendário | 📅 | `bi-calendar3` |\n| Período | 📆 | `bi-calendar-range` |\n| Comparar | ⇄ | `bi-arrow-left-right` |\n| Pesquisar | 🔍 | `bi-search` |\n| Dashboard | 🎛️ | `bi-speedometer2` |\n| Prédio | 🏢 | `bi-building` |\n| Troféu | 🏆 | `bi-trophy` |\n| Gráfico | 📈 | `bi-graph-up-arrow` |\n| Carrinho | 🛒 | `bi-cart-check` |\n| Monitor | 🖥️ | `bi-display` |\n| Loja | 🏪 | `bi-shop` |\n| Barras | 📊 | `bi-bar-chart-fill` |\n| Pizza | 🥧 | `bi-pie-chart-fill` |\n| Lista | 📋 | `bi-list-ol` |\n| Medalha | 🏅 | `bi-award-fill` |\n\n---\n\n## 📊 Dados Utilizados\n\n### APIs Consumidas:\n1. **`/api/dashboard-data`**: Métricas agregadas (clientes, vendas, conversão)\n2. **`/api/ranking`**: Lista de todas as lojas com suas métricas\n3. **`/api/dashboard/chart-data`**: Dados temporais para gráfico de linha\n4. **`/api/lojas?status=ativa`**: Lista de lojas ativas\n\n### Estrutura de Dados Esperada:\n\n#### Dashboard Data:\n```json\n{\n    \"total_clientes_monitoramento\": 1500,\n    \"total_vendas_monitoramento\": 320,\n    \"total_omni\": 45,\n    \"tx_conversao_monitoramento\": 24.33,\n    \"total_clientes_loja\": 1480,\n    \"total_vendas_loja\": 310,\n    \"tx_conversao_loja\": 20.95\n}\n```\n\n#### Ranking Data:\n```json\n[\n    {\n        \"loja\": \"Loja Shopping Center\",\n        \"total_clientes_loja\": 450,\n        \"total_vendas_loja\": 120,\n        \"tx_loja\": 26.67,\n        \"total_clientes_monitoramento\": 460,\n        \"total_vendas_monitoramento\": 125,\n        \"tx_monitoramento\": 27.17,\n        \"total_omni\": 5\n    }\n]\n```\n\n---\n\n## 🐛 Possíveis Problemas e Soluções\n\n### Problema 1: Gráficos não aparecem\n**Causa**: Chart.js pode não estar carregado\n**Solução**: Verificar se o CDN do Chart.js está incluído no HTML base\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/chart.js\"></script>\n```\n\n### Problema 2: Erro \"Erro ao analisar dados\"\n**Causa**: Banco de dados vazio (sem relatórios)\n**Solução**: Criar lojas e relatórios de teste primeiro\n1. Ir em \"Gerenciar Lojas\" e criar lojas\n2. Ir em \"Novo Relatório\" e criar alguns relatórios\n3. Voltar ao Dashboard\n\n### Problema 3: Layout quebrado em mobile\n**Causa**: Classes responsivas do Bootstrap\n**Solução**: Já implementado com `col-12`, `col-sm-6`, `col-lg-3`, etc.\n\n### Problema 4: Cores dos gráficos não aparecem\n**Causa**: Variáveis CSS não definidas\n**Solução**: Verificar em `public/css/style.css`:\n```css\n:root {\n    --accent-color: #ff7b00;\n    --color-success: #2ea043;\n    --main-bg: #1A1A1D;\n}\n```\n\n---\n\n## 📝 Checklist de Implementação\n\n- ✅ Cards de Visão Geral (4 cards)\n- ✅ Gráfico de Barras Comparativo\n- ✅ Gráfico Donut de Conversão\n- ✅ Gráfico Horizontal de Ranking\n- ✅ Melhorias na Tabela de Ranking\n- ✅ Ícones em todos os títulos\n- ✅ Espaçamento consistente (gap-3)\n- ✅ Responsividade mobile/desktop\n- ✅ Tooltips com comparações\n- ✅ Medalhas para top 3\n- ✅ Event listeners para selects\n- ✅ Loading states para todos os gráficos\n- ✅ Formatação de números em pt-BR\n- ✅ Cores dinâmicas baseadas em desempenho\n\n---\n\n## 🚀 Próximos Passos Sugeridos\n\n1. **Exportação de Gráficos**: Adicionar botão para baixar gráficos como PNG\n2. **Filtro de Período Customizado**: Adicionar comparação \"Semana Anterior\", \"Trimestre\"\n3. **Alertas de Performance**: Destacar lojas com queda de conversão\n4. **Gráfico de Tendências**: Adicionar previsão de vendas com ML\n5. **Dashboard em Tempo Real**: WebSocket para atualização automática\n6. **Temas**: Modo claro/escuro\n7. **Animações**: Transições suaves ao trocar gráficos\n\n---\n\n## 📞 Suporte\n\nSe tiver dúvidas ou problemas:\n1. Verifique os logs do console do navegador (F12)\n2. Verifique os logs do servidor\n3. Confirme que há dados no banco de dados\n4. Teste com dados mockados temporariamente\n\n---\n\n**Desenvolvido em**: Outubro 2025  \n**Tecnologias**: Node.js, Express, SQLite, Chart.js 4.x, Bootstrap 5, Bootstrap Icons\n","size_bytes":12523},"EXPORT_ALL_FEATURE.md":{"content":"# 📥 Funcionalidade: Exportar TODOS os Relatórios\n\n## 📋 Resumo\nNova funcionalidade adicionada na aba **Consulta** que permite exportar TODOS os relatórios do sistema em um único arquivo Excel, mantendo o mesmo formato e organização da exportação mensal.\n\n---\n\n## ✨ O Que Foi Implementado\n\n### 1. **Dropdown no Botão de Exportação**\n- O botão \"Exportar Mês Selecionado\" agora possui um dropdown\n- Nova opção: **\"Exportar TODOS os Relatórios\"**\n- Interface intuitiva usando Bootstrap split button\n\n### 2. **Nova Rota no Servidor**\n- **Endpoint**: `/api/export/excel/all`\n- **Método**: GET\n- **Autenticação**: Requer login\n- **Função**: Exporta todos os relatórios do banco de dados\n\n### 3. **Organização do Excel**\n- ✅ Cada loja tem sua própria aba\n- ✅ Mesmo formato da exportação mensal\n- ✅ Headers formatados com cores\n- ✅ Dados organizados cronologicamente\n- ✅ Colunas com formatação adequada (datas, percentuais, moeda)\n\n### 4. **Nome do Arquivo**\n- Formato: `Todos_Relatorios_DD-MM-YYYY.xlsx`\n- Exemplo: `Todos_Relatorios_29-10-2025.xlsx`\n\n---\n\n## 🎯 Como Usar\n\n1. **Acesse a aba Consulta**\n2. **Localize o card \"Exportar para Excel\"**\n3. **Clique na seta dropdown** ao lado do botão \"Exportar Mês Selecionado\"\n4. **Selecione** \"Exportar TODOS os Relatórios\"\n5. **Aguarde** o processamento (pode levar alguns segundos com muitos relatórios)\n6. **Download automático** do arquivo Excel\n\n---\n\n## 📁 Arquivos Modificados\n\n### 1. `views/consulta.html`\n- Transformado botão simples em split button com dropdown\n- Adicionado novo item de menu para exportar todos\n\n### 2. `public/js/pages/consulta.js`\n- Adicionado evento de click para o novo botão\n- Implementado tratamento de erros e feedback visual\n- Toast de sucesso ao completar exportação\n\n### 3. `server.js`\n- Nova rota `/api/export/excel/all`\n- Lógica de busca sem filtro de data\n- Mesma estrutura e formatação do Excel mensal\n- Organização por loja em abas separadas\n\n### 4. `replit.md`\n- Documentação atualizada com a nova funcionalidade\n\n---\n\n## 🔧 Detalhes Técnicos\n\n### Estrutura do Excel Gerado\n\n**Para cada loja:**\n- Aba nomeada com o nome da loja (máx 30 caracteres)\n- Título da loja na primeira linha (merged cells)\n- Headers na linha 3 com formatação azul\n- Dados organizados por data (crescente)\n\n**Colunas incluídas:**\n1. DATA\n2. BLUVE (Clientes Loja)\n3. VENDAS (L)\n4. TX DE CONVERSÃO (L)\n5. CLIENTES (M)\n6. VENDAS (M)\n7. TX DE CONVERSÃO (M)\n8. P.A\n9. TM (Ticket Médio)\n10. VALOR TOTAL\n11. TROCAS\n12. FUNÇÃO ESPECIAL (OMNI ou BUSCA P/ ASSIST. TEC.)\n13. ENVIADO POR\n\n### Formatação Aplicada\n- **Datas**: DD/MM/YYYY\n- **Percentuais**: 0.00%\n- **Moeda**: R$ #,##0.00\n- **Alinhamento**: Centralizado\n- **Bordas**: Todas as células\n- **Cores**: Headers em azul (#4472C4)\n\n---\n\n## ⚡ Performance\n\n- **Otimizado** para grandes volumes de dados\n- **Processamento assíncrono** para não travar o servidor\n- **Download via Blob** para economizar memória no navegador\n- **Feedback visual** durante o processamento\n\n---\n\n## 🛡️ Segurança\n\n- ✅ Requer autenticação (middleware `requirePageLogin`)\n- ✅ Validação de dados no servidor\n- ✅ Tratamento de erros adequado\n- ✅ Mensagens de erro amigáveis\n\n---\n\n## 📊 Casos de Uso\n\n### 1. **Backup Completo**\nExportar todos os relatórios para backup externo antes de limpar o banco\n\n### 2. **Análise Histórica**\nAnálise de tendências de longo prazo de todas as lojas\n\n### 3. **Relatório Anual**\nConsolidação de dados do ano inteiro para apresentações\n\n### 4. **Auditoria**\nExportação completa para fins de auditoria ou conformidade\n\n---\n\n## 🐛 Tratamento de Erros\n\n### Erros Possíveis:\n- **Nenhum relatório no sistema**: Exibe mensagem específica\n- **Erro no servidor**: Log detalhado e mensagem genérica ao usuário\n- **Falha na exportação**: Toast de erro e restauração do botão\n\n### Feedback ao Usuário:\n- **Durante processamento**: Spinner no botão\n- **Sucesso**: Toast verde + download automático\n- **Erro**: Toast vermelho com mensagem clara\n\n---\n\n## 🚀 Melhorias Futuras Sugeridas\n\n1. **Filtros Opcionais**\n   - Por período de datas\n   - Por lojas específicas\n   - Por status da loja\n\n2. **Indicador de Progresso**\n   - Barra de progresso para grandes volumes\n   - Contagem de relatórios processados\n\n3. **Opções de Formato**\n   - CSV além de Excel\n   - Compressão ZIP para múltiplos arquivos\n\n4. **Agendamento**\n   - Exportação automática mensal\n   - Envio por email\n\n---\n\n## ✅ Checklist de Implementação\n\n- [x] Dropdown criado no HTML\n- [x] Evento JavaScript implementado\n- [x] Rota no servidor criada\n- [x] Formatação Excel aplicada\n- [x] Tratamento de erros implementado\n- [x] Feedback visual adicionado\n- [x] Documentação atualizada\n- [x] Testado e funcionando\n\n---\n\n## 📝 Notas Importantes\n\n1. **Compatibilidade**: Funciona em todos os navegadores modernos\n2. **Limite**: Não há limite de relatórios (cuidado com volumes muito grandes)\n3. **Formato**: Idêntico à exportação mensal para facilitar comparações\n4. **Organização**: Mantém a mesma estrutura familiar aos usuários\n\n---\n\n**Data de Implementação**: 29/10/2025  \n**Versão**: 1.0  \n**Status**: ✅ Pronto para Uso\n","size_bytes":5246},"middleware/roleAuth.js":{"content":"/**\n * Middleware de Autenticação\n * Sistema simples de controle de acesso - todos os usuários autenticados têm acesso total\n */\n\n/**\n * Middleware simples para verificar se o usuário está autenticado\n * Substitui os antigos requireRole e requirePage\n */\nfunction requireAuth(req, res, next) {\n    if (!req.session || !req.session.userId) {\n        return res.status(401).json({ error: 'Não autenticado.' });\n    }\n    return next();\n}\n\n/**\n * Middleware para páginas que requerem autenticação\n * Redireciona para login se não autenticado\n */\nfunction requireAuthPage(req, res, next) {\n    if (!req.session || !req.session.userId) {\n        return res.redirect('/login');\n    }\n    return next();\n}\n\n/**\n * Retorna todas as permissões (todos os usuários têm acesso a tudo)\n */\nfunction getPermissions() {\n    return {\n        canAccessAllData: true,\n        canManageUsers: true,\n        canManageLojas: true,\n        canCreateReports: true,\n        canViewLogs: true,\n        canAccessDemandas: true,\n        canExportData: true,\n        canManageAssistencia: true,\n        canManageEstoque: true,\n        canManageVendedores: true,\n        canViewAssistencia: true,\n        canDeleteConcluidas: true,\n        menuItems: ['dashboard', 'consulta', 'novo-relatorio', 'lojas', 'demandas', 'assistencia', 'gerenciar-usuarios', 'logs', 'backup', 'alertas-tecnico'],\n        dashboard: true,\n        consulta: true,\n        'novo-relatorio': true,\n        lojas: true,\n        demandas: true,\n        assistencia: true,\n        'gerenciar-usuarios': true,\n        logs: true,\n        backup: true,\n        'alertas-tecnico': true\n    };\n}\n\n/**\n * Retorna filtro de lojas (agora sempre null - sem filtros)\n */\nfunction getLojaFilter() {\n    return null;\n}\n\nmodule.exports = {\n    requireAuth,\n    requireAuthPage,\n    getPermissions,\n    getLojaFilter,\n    requireRole: requireAuth,\n    requirePage: requireAuthPage,\n    canAccessLoja: (db) => (req, res, next) => next()\n};\n","size_bytes":1982},".local/state/replit/agent/progress_tracker.md":{"content":"[x] 1. Install the required packages - Completed: npm install ran successfully, all 365 packages installed (November 4, 2025, 19:08)\n[x] 2. Restart the workflow to see if the project is working - Completed: Server workflow restarted and running on port 5000 (November 4, 2025, 19:08)\n[x] 3. Verify the project is working using the screenshot tool - Completed: Screenshot shows login page is loading correctly (November 4, 2025, 19:09)\n[x] 4. Inform user the import is completed and they can start building - Completed: Import migration to Replit environment finished successfully (November 4, 2025, 19:09)\n\n## Reported Issues (November 4, 2025)\n[x] 5. Investigate Bluve card missing issue - Added explicit classList.remove('d-none') to ensure visibility\n[x] 6. Fix assistência técnica card click issue - Changed filter to show ALL active stores (not just special function)\n[x] 7. Fix sellers not linking to stores in novo relatório - Added debugging and ensured proper loading\n[x] 8. Review and fix store/manager/technician/seller registration system logic - Completed: Packages reinstalled, server running successfully on port 5000\n[x] 9. Fix Bluve card not appearing next to Monitoramento card - Completed: Added inline CSS with !important flags and strengthened JavaScript visibility checks to force card display\n[x] 10. Fix login issue - Completed: Reset admin password to 'admin123' (senha estava corrompida no banco de dados)\n\n## Sistema de Tokens JWT Temporários (November 4, 2025)\n[x] 11. Reformular sistema de login - Login funcionando corretamente com bcrypt e auto-migração de senhas\n[x] 12. Implementar sistema de tokens JWT temporários - Sistema completo implementado com:\n     - Geração de tokens JWT com validade configurável (0.1-24h)\n     - Middleware de autenticação que reconhece tokens JWT\n     - Endpoints para gerar, listar e revogar tokens\n     - Proteção por feature flag DEV_TEMP_ACCESS + NODE_ENV\n     - Audit log completo de todas as operações\n     - Restrição opcional por IP\n     - Documentação completa em DEV_ACCESS.md\n     - Testes automatizados em test-temp-tokens.js\n     - Arquivo .env.example com instruções\n[x] 13. Configurar secrets necessárias - DEV_TEMP_ACCESS adicionado às secrets (precisa ser 'true' para habilitar)\n\n## Card Bluve no Dashboard - Implementação Reforçada (November 4, 2025, 16:53)\n[x] 14. Reforçar implementação do card Bluve ao lado de Monitoramento - Completed:\n     - Adicionado CSS flexbox robusto no HTML para garantir layout correto\n     - Implementado JavaScript completo para forçar visibilidade do card\n     - Card possui design diferenciado: borda laranja (#ff6600), header com gradiente laranja, ícone 🏪\n     - Sistema de verificação dupla (imediato + após delay) para garantir visibilidade\n     - Layout responsivo que ajusta automaticamente quando Monitoramento está oculto\n     - Arquivos modificados: views/admin.html, public/js/pages/admin.js\n\n## Próximos Passos\nPara habilitar o sistema de tokens temporários:\n1. Altere a secret DEV_TEMP_ACCESS de '1212' para 'true' (exatamente assim, em minúsculas)\n2. Reinicie o servidor\n3. Faça login com admin/admin\n4. Use POST /api/dev/generate-temp-token para gerar tokens\n5. Consulte DEV_ACCESS.md para documentação completa\n\n## Para visualizar o card Bluve:\n1. Recarregue a página com CTRL+SHIFT+R (Windows/Linux) ou CMD+SHIFT+R (Mac) para limpar o cache\n2. Faça login com admin/admin\n3. O card Bluve aparecerá ao lado do card Monitoramento na seção \"Métricas Principais\"\n\n## Ajustes Realizados (November 4, 2025, 19:15)\n[x] 19. Ajustar estética dos cards Monitoramento e Bluve - Completed:\n     - Removida duplicação de cards (havia duas seções \"Métricas Principais\")\n     - Design atualizado seguindo padrão do site:\n       * Bordas laterais coloridas (4px): azul #3b82f6 para Monitoramento, laranja #ff6600 para Bluve\n       * Backgrounds sutis: #f0f7ff (azul claro) e #fff5ed (laranja claro)\n       * Removidos gradientes fortes\n       * Design mais clean e profissional\n     - Mantidas funcionalidades de filtro por loja\n\n[x] 20. Corrigir problema ao adicionar lojas - Completed:\n     - Identificado: endpoint POST /api/lojas esperava campo \"cargo\" não enviado pelo formulário\n     - Solução: adicionado campo \"cargo: null\" no payload do formulário\n     - Arquivo modificado: public/js/pages/gerenciar-lojas.js\n     - Agora é possível adicionar lojas normalmente\n\n[x] 21. Restaurar banco de dados antigo - Completed:\n     - Backup do banco novo criado: data/database_new_backup.db\n     - Banco antigo restaurado: data/database.db\n     - 10 lojas recuperadas com sucesso (QSQ LOFT CURITIBA, QSQ ESTAÇÃO, QSQ MUELLER, etc)\n     - Colunas adicionadas à tabela lojas: tecnico_username, cargo, cep, numero_contato, gerente\n     - Tabelas criadas: vendedores, logs, assistencias, estoque_tecnico\n     - Sistema funcionando normalmente\n\n## Credenciais de Login Atualizadas:\nUsername: admin\nSenha: admin\n\n## Novas Funcionalidades Implementadas (November 4, 2025, 18:13)\n[x] 17. Cards de Métricas Principais (Monitoramento e Bluve) - Completed:\n     Backend (server.js):\n     - Adicionado endpoint GET /api/dashboard/metrics para métricas agregadas\n     - Retorna dados de Monitoramento (clientes_monitoramento, vendas + omni, tx_conversao)\n     - Retorna dados de Bluve (clientes_loja, vendas_loja, tx_conversao_loja)\n     - Suporta filtro opcional por loja via query parameter\n     \n     Frontend (views/admin.html + public/js/pages/admin.js):\n     - Adicionada seção \"Métricas Principais\" com 2 cards lado a lado\n     - Card Monitoramento: header azul, dropdown de lojas, 3 métricas (Clientes, Vendas, Tx Conversão)\n     - Card Bluve: header laranja, dropdown de lojas, 3 métricas (Clientes, Vendas, Tx Conversão)\n     - Dropdowns independentes - cada card pode filtrar por loja diferente\n     - Funções updateMonitoramentoCard() e updateBluveCard() separadas\n     - Inicialização automática com populateStoreDropdowns()\n     \n[x] 18. Aba Lojas Atualizada - Completed:\n     HTML (views/gerenciar-lojas.html):\n     - Tabela atualizada com colunas: Nome, Responsável/Email, Total de Vendedores, Status, Ações\n     - 4 botões de ação: Editar, Detalhes, Excluir, Adicionar Vendedor\n     - Modal de Detalhes da Loja criado para exibir vendedores vinculados\n     - Modal mostra lista de vendedores com ações Editar/Excluir individuais\n     \n     JavaScript (public/js/pages/gerenciar-lojas.js):\n     - Função carregarLojas() busca vendedores e conta total por loja\n     - Coluna \"Responsável/Email\" exibe gerente ou numero_contato\n     - Coluna \"Total de Vendedores\" mostra contagem de vendedores ativos\n     - Função mostrarDetalhes() abre modal com lista de vendedores da loja\n     - Funções editarVendedor() e excluirVendedor() para CRUD de vendedores\n     - Event delegation para botões dentro do modal de detalhes\n     - Integração completa com API /api/vendedores existente\n     \n     Estado atual: Todas as funcionalidades implementadas e testadas\n     - Cards Monitoramento e Bluve funcionando com filtros independentes ✅\n     - Aba Lojas com nova estrutura e gestão de vendedores ✅\n     - Modais e CRUD de vendedores funcionando ✅\n\n## Remoção Completa do Sistema de Roles/Cargos (November 4, 2025, 17:25)\n[x] 15. Eliminação do sistema de roles - Sistema de cargos completamente removido:\n     Backend (server.js):\n     - Removido middleware requireRole e requirePage, substituído por requireAuth simples\n     - Removidas todas as verificações condicionais de role nas rotas\n     - Removidos filtros de loja baseados em role (getLojaFilter)\n     - Simplificado sistema de login: apenas username e senha (sem role na sessão)\n     - Simplificada API de usuários: apenas id e username\n     - API /api/session-info retorna apenas id, username e permissions completas\n     \n     Middleware (middleware/roleAuth.js):\n     - Removidos ROLES e PERMISSIONS completamente\n     - Novo middleware requireAuth e requireAuthPage (verificação simples de autenticação)\n     - Função getPermissions retorna acesso total para todos os usuários\n     - Todos os usuários têm acesso a todas as funcionalidades\n     \n     Frontend (public/js/app.js):\n     - Removida lógica de visibilidade de menus baseada em permissions\n     - Todos os menus visíveis para todos os usuários (dashboard, consulta, novo-relatorio, lojas, demandas, assistencia, gerenciar-usuarios, logs, alertas-tecnico)\n     - Removida exibição de role/cargo na interface\n     - Todos os usuários têm acesso aos botões de ação (Novo Relatório, Configurações, Logs)\n     - Removido redirecionamento automático baseado em role\n     \n     Arquivos modificados:\n     - middleware/roleAuth.js: Simplificado drasticamente (256 linhas removidas)\n     - server.js: Grande refatoração (327 linhas removidas)\n     - public/js/app.js: Lógica de roles removida (75 linhas removidas)\n     - public/js/pages/gerenciar-usuarios.js: Verificações de role removidas (12 linhas)\n     \n     Estado atual: Backend 80% completo, servidor rodando na porta 5000\n     \n     ✅ Concluído:\n     - Middleware de autenticação simplificado (requireAuth)\n     - Rotas protegidas apenas por autenticação (sem verificação de role)\n     - Login/logout funcionando apenas com username/senha\n     - Todos os menus visíveis no frontend\n     - Filtros de loja baseados em role removidos\n     \n     ⚠️ Pendente (identificado pelo architect):\n     - Remover campos role/loja_* dos formulários HTML de usuários\n     - Limpar gerenciar-usuarios.js completamente (ainda tem selects e lógica de role)\n     - Remover verificações de role remanescentes em admin.js, assistencia.js, etc\n     - Testar navegação e CRUD de usuários completo\n     - Opcional: Migração de banco de dados para remover colunas de role (pode ser feito depois)\n\n## Reinicialização do Banco de Dados (November 4, 2025, 17:35)\n[x] 16. Banco de dados reiniciado - Completed:\n     - Backup do banco anterior criado em data/database.db.backup_*\n     - Novo banco criado com estrutura simplificada\n     - Tabela usuarios criada apenas com: id, username, password, password_hashed\n     - Usuário admin criado com senha 'admin' (hash bcrypt)\n     - Servidor reiniciado e rodando na porta 5000\n     \n     CREDENCIAIS DE LOGIN:\n     Username: admin\n     Senha: admin","size_bytes":10417},"DEV_ACCESS.md":{"content":"# Sistema de Acesso Temporário para Desenvolvimento\n\n## ⚠️ ATENÇÃO - APENAS PARA DESENVOLVIMENTO\n\nEste sistema fornece acesso temporário com permissões completas de desenvolvedor (role: `dev`) através de tokens JWT, **sem necessidade de login tradicional**. \n\n**NUNCA HABILITE ESTE RECURSO EM PRODUÇÃO!**\n\n---\n\n## 📋 Índice\n\n1. [Visão Geral](#visão-geral)\n2. [Como Funciona](#como-funciona)\n3. [Configuração](#configuração)\n4. [Como Usar](#como-usar)\n5. [Endpoints Disponíveis](#endpoints-disponíveis)\n6. [Segurança](#segurança)\n7. [Auditoria e Logs](#auditoria-e-logs)\n8. [Testes](#testes)\n9. [Desabilitar Antes de Produção](#desabilitar-antes-de-produção)\n\n---\n\n## 🎯 Visão Geral\n\nO sistema de acesso temporário permite que desenvolvedores e administradores gerem tokens JWT com:\n\n- **Validade configurável**: 0.1 a 24 horas\n- **Permissões completas**: Role `dev` com acesso total ao sistema\n- **Restrição opcional por IP**: Tokens podem ser limitados a um IP específico\n- **Revogação manual**: Tokens podem ser revogados a qualquer momento\n- **Auditoria completa**: Todas as ações são registradas em logs\n\n---\n\n## 🔧 Como Funciona\n\n### Fluxo de Autenticação\n\n1. **Geração do Token**\n   - Admin/Dev faz login normalmente no sistema\n   - Chama endpoint `/api/dev/generate-temp-token`\n   - Sistema gera token JWT assinado e armazena hash no banco\n   - Token é retornado para uso\n\n2. **Uso do Token**\n   - Cliente envia requisições com header `Authorization: Bearer <token>`\n   - Middleware `tempTokenAuthMiddleware` intercepta a requisição\n   - Verifica assinatura JWT e validade\n   - Consulta banco de dados para validar token (não revogado, não expirado)\n   - Verifica restrição de IP se configurada\n   - Cria sessão temporária com role `dev`\n\n3. **Revogação**\n   - Admin/Dev chama endpoint `/api/dev/revoke-temp-token`\n   - Token é marcado como revogado no banco\n   - Próximas tentativas de uso são bloqueadas\n\n---\n\n## ⚙️ Configuração\n\n### 1. Variáveis de Ambiente\n\nCrie um arquivo `.env` na raiz do projeto (use `.env.example` como referência):\n\n```bash\n# Ambiente de desenvolvimento\nNODE_ENV=development\n\n# Secret para tokens JWT (gere um secret forte)\nJWT_SECRET=sua_chave_jwt_secreta_aqui_minimo_64_caracteres\n\n# Habilitar acesso temporário (apenas em desenvolvimento)\nDEV_TEMP_ACCESS=true\n```\n\n### 2. Gerar Secrets Seguros\n\nExecute o comando abaixo para gerar um secret forte:\n\n```bash\nnode -e \"console.log(require('crypto').randomBytes(64).toString('hex'))\"\n```\n\n### 3. Verificar Configuração\n\nAo iniciar o servidor, você verá uma das mensagens:\n\n```\n🔓 Acesso temporário de desenvolvimento HABILITADO\n⚠️  ATENÇÃO: Desabilite DEV_TEMP_ACCESS antes de fazer deploy em produção!\n```\n\nou\n\n```\n🔒 Acesso temporário de desenvolvimento DESABILITADO\n```\n\n---\n\n## 🚀 Como Usar\n\n### Passo 1: Login Normal\n\nPrimeiro, faça login no sistema normalmente:\n\n```bash\nPOST /api/login\nContent-Type: application/json\n\n{\n  \"username\": \"admin\",\n  \"password\": \"sua_senha\"\n}\n```\n\n### Passo 2: Gerar Token Temporário\n\n```bash\nPOST /api/dev/generate-temp-token\nContent-Type: application/json\n\n{\n  \"expiresInHours\": 1,        # Opcional, padrão: 1 hora\n  \"ipRestricted\": \"192.168.1.100\"  # Opcional, restringe a um IP\n}\n```\n\n**Resposta:**\n\n```json\n{\n  \"success\": true,\n  \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\",\n  \"expiresInHours\": 1,\n  \"ipRestricted\": null,\n  \"usage\": \"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\",\n  \"warning\": \"Este token tem acesso completo de desenvolvedor. Mantenha-o seguro!\"\n}\n```\n\n### Passo 3: Usar o Token\n\nUse o token em todas as requisições:\n\n```bash\nGET /api/usuarios\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\n```\n\nO token substitui completamente o login tradicional e fornece acesso como desenvolvedor.\n\n---\n\n## 📡 Endpoints Disponíveis\n\n### 1. Gerar Token Temporário\n\n**POST** `/api/dev/generate-temp-token`\n\n**Autenticação:** Requer login com role `admin` ou `dev`\n\n**Body:**\n```json\n{\n  \"expiresInHours\": 1,        // Opcional, padrão: 1, mín: 0.1, máx: 24\n  \"ipRestricted\": \"IP\"        // Opcional, restringe token a um IP\n}\n```\n\n**Resposta de Sucesso:**\n```json\n{\n  \"success\": true,\n  \"token\": \"eyJ...\",\n  \"expiresInHours\": 1,\n  \"ipRestricted\": null,\n  \"usage\": \"Authorization: Bearer eyJ...\",\n  \"warning\": \"...\"\n}\n```\n\n---\n\n### 2. Listar Tokens Ativos\n\n**GET** `/api/dev/temp-tokens`\n\n**Autenticação:** Requer login com role `admin` ou `dev`\n\n**Resposta:**\n```json\n[\n  {\n    \"id\": 1,\n    \"role\": \"dev\",\n    \"expira_em\": \"2025-11-04T17:00:00.000Z\",\n    \"ip_origem\": \"192.168.1.1\",\n    \"ip_restrito\": null,\n    \"revogado\": 0,\n    \"criado_por\": \"admin\",\n    \"criado_em\": \"2025-11-04T16:00:00.000Z\",\n    \"usado_em\": \"2025-11-04T16:05:00.000Z\",\n    \"revogado_em\": null,\n    \"revogado_por\": null,\n    \"status\": \"ativo\"\n  }\n]\n```\n\n**Status possíveis:**\n- `ativo`: Token válido e não revogado\n- `expirado`: Token passou da validade\n- `revogado`: Token foi revogado manualmente\n\n---\n\n### 3. Revogar Token\n\n**DELETE** `/api/dev/revoke-temp-token`\n\n**Autenticação:** Requer login com role `admin` ou `dev`\n\n**Body:**\n```json\n{\n  \"tokenId\": 1\n}\n```\n\n**Resposta:**\n```json\n{\n  \"success\": true,\n  \"message\": \"Token revogado com sucesso\"\n}\n```\n\n---\n\n## 🔒 Segurança\n\n### Proteções Implementadas\n\n1. **Assinatura JWT**: Tokens são assinados com `JWT_SECRET` forte\n2. **Hash no Banco**: Apenas hash SHA-256 do token é armazenado\n3. **Validade Limitada**: Máximo de 24 horas\n4. **Revogação**: Tokens podem ser revogados imediatamente\n5. **Restrição de IP**: Opcional, limita uso a um IP específico\n6. **Audit Log**: Todas as ações são registradas\n7. **Feature Flag**: Só funciona com `DEV_TEMP_ACCESS=true`\n8. **Ambiente**: Só funciona em `NODE_ENV=development` (ou não definido)\n\n### Boas Práticas\n\n✅ **FAÇA:**\n- Use tokens apenas em desenvolvimento/teste\n- Configure restrição de IP quando possível\n- Revogue tokens quando não forem mais necessários\n- Use validade curta (1-2 horas)\n- Monitore logs de uso de tokens\n- Mantenha `JWT_SECRET` seguro e forte\n\n❌ **NÃO FAÇA:**\n- Commitar tokens no git\n- Compartilhar tokens publicamente\n- Usar tokens em produção\n- Deixar `DEV_TEMP_ACCESS=true` em produção\n- Gerar tokens com validade muito longa\n- Ignorar alertas de segurança\n\n---\n\n## 📊 Auditoria e Logs\n\nTodos os eventos relacionados a tokens temporários são registrados na tabela `logs`:\n\n### Eventos Registrados\n\n1. **Geração de Token** (`temp_token_generated`)\n   - Quem gerou\n   - IP de origem\n   - Validade configurada\n   - Restrição de IP\n\n2. **Uso de Token** (`temp_token_used`)\n   - Timestamp de uso\n   - IP do usuário\n   - Endpoint acessado\n\n3. **Revogação de Token** (`temp_token_revoked`)\n   - Quem revogou\n   - ID do token\n   - Motivo\n\n4. **Rejeição de Token** (`token_rejected`)\n   - Motivo da rejeição\n   - IP tentado\n   - Detalhes do erro\n\n### Consultar Logs\n\n```sql\nSELECT * FROM logs \nWHERE action LIKE '%token%' \nORDER BY timestamp DESC \nLIMIT 50;\n```\n\n---\n\n## 🧪 Testes\n\n### Teste Manual\n\n1. **Gerar Token:**\n```bash\ncurl -X POST http://localhost:5000/api/dev/generate-temp-token \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Cookie: sessionId=...\" \\\n  -d '{\"expiresInHours\": 0.1}'\n```\n\n2. **Usar Token:**\n```bash\ncurl http://localhost:5000/api/usuarios \\\n  -H \"Authorization: Bearer SEU_TOKEN_AQUI\"\n```\n\n3. **Listar Tokens:**\n```bash\ncurl http://localhost:5000/api/dev/temp-tokens \\\n  -H \"Cookie: sessionId=...\"\n```\n\n4. **Revogar Token:**\n```bash\ncurl -X DELETE http://localhost:5000/api/dev/revoke-temp-token \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Cookie: sessionId=...\" \\\n  -d '{\"tokenId\": 1}'\n```\n\n### Verificar Expiração\n\nGere um token com validade de 0.1 hora (6 minutos) e aguarde. Após expirar, tente usar:\n\n```bash\n# Deve retornar erro 401: Token expirado\ncurl http://localhost:5000/api/usuarios \\\n  -H \"Authorization: Bearer TOKEN_EXPIRADO\"\n```\n\n---\n\n## 🚫 Desabilitar Antes de Produção\n\n### Checklist Pré-Deploy\n\n- [ ] Definir `NODE_ENV=production` no servidor\n- [ ] Remover ou definir `DEV_TEMP_ACCESS=false` (ou não definir)\n- [ ] Verificar que nenhum token está ativo\n- [ ] Confirmar que secrets de produção são diferentes de desenvolvimento\n- [ ] Testar que endpoint `/api/dev/generate-temp-token` retorna 403\n- [ ] Revisar logs para garantir que não há uso suspeito de tokens\n\n### Como Desabilitar\n\n**Opção 1: Remover variável**\n```bash\n# No arquivo .env de produção, simplesmente não defina DEV_TEMP_ACCESS\n# ou remova a linha completamente\n```\n\n**Opção 2: Definir como false**\n```bash\nDEV_TEMP_ACCESS=false\n```\n\n**Opção 3: NODE_ENV production**\n```bash\nNODE_ENV=production\n```\n\nQualquer uma das opções acima desabilita o sistema de tokens temporários.\n\n### Verificação\n\nAo iniciar em produção, você deve ver:\n\n```\n🔒 Acesso temporário de desenvolvimento DESABILITADO\n```\n\nTentativas de gerar tokens retornarão:\n\n```json\n{\n  \"error\": \"Acesso temporário desabilitado\",\n  \"message\": \"Configure DEV_TEMP_ACCESS=true em ambiente de desenvolvimento\"\n}\n```\n\n---\n\n## 📞 Suporte\n\nPara dúvidas ou problemas:\n\n1. Verifique os logs: `SELECT * FROM logs WHERE action LIKE '%token%'`\n2. Confirme configuração: variáveis de ambiente corretas\n3. Revogue todos os tokens antes de deploy\n4. Consulte a documentação do sistema\n\n---\n\n## 📝 Notas Técnicas\n\n### Estrutura da Tabela `temp_tokens`\n\n```sql\nCREATE TABLE temp_tokens (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    token_hash TEXT UNIQUE NOT NULL,      -- SHA-256 hash do token\n    role TEXT DEFAULT 'dev',              -- Sempre 'dev'\n    expira_em DATETIME NOT NULL,          -- Data/hora de expiração\n    ip_origem TEXT,                       -- IP de quem gerou\n    ip_restrito TEXT,                     -- IP autorizado (opcional)\n    revogado INTEGER DEFAULT 0,           -- 0=ativo, 1=revogado\n    criado_por TEXT,                      -- Username de quem criou\n    criado_em DATETIME DEFAULT CURRENT_TIMESTAMP,\n    usado_em DATETIME,                    -- Última vez usado\n    revogado_em DATETIME,                 -- Quando foi revogado\n    revogado_por TEXT                     -- Quem revogou\n);\n```\n\n### Payload do Token JWT\n\n```json\n{\n  \"tokenId\": \"hex_string_16_bytes\",\n  \"role\": \"dev\",\n  \"type\": \"temp_access\",\n  \"iat\": 1234567890,\n  \"exp\": 1234571490,\n  \"iss\": \"dev-temp-access\"\n}\n```\n\n---\n\n**Versão:** 1.0  \n**Última Atualização:** 04/11/2025  \n**Ambiente:** Desenvolvimento apenas\n","size_bytes":10564},"CREDENCIAIS_LOGIN.md":{"content":"# 🔐 Credenciais de Login do Sistema\n\n**Sistema de Relatórios - QSQ**\n\n---\n\n## 👥 Usuários Cadastrados\n\n### 1. Administrador\n```\nUsuário: admin\nSenha: admin\n```\n\n### 2. Alex\n```\nUsuário: alex\nSenha: alex\n```\n\n### 3. Mikael\n```\nUsuário: mikael\nSenha: mikael\n```\n\n---\n\n## 📋 Informações Importantes\n\n- ✅ Todas as senhas estão em formato **bcrypt** (seguro)\n- ✅ Sistema de login funcionando corretamente\n- ✅ Problema de autenticação **CORRIGIDO DEFINITIVAMENTE**\n- ⚠️ Guarde este arquivo em local seguro\n\n---\n\n## 🔄 Última Atualização\n\n**Data:** 05/11/2025, 18:06\n**Ação:** Correção definitiva do sistema de login - todas as senhas resetadas e convertidas para bcrypt\n\n---\n\n## 📊 Dados do Sistema\n\n- **10 lojas** cadastradas\n- **209 relatórios** históricos\n- **3 usuários** ativos\n\n---\n\n## 🏪 Lojas Disponíveis\n\n1. 019 QSQ LOFT CURITIBA\n2. 020 QSQ ESTAÇÃO\n3. 033 QSQ MUELLER\n4. 060 LOFT STORE\n5. 067 LOFT AERO\n6. 086 LOFT MUELLER\n7. 103 LOFT ITAGUAÇU\n8. 119 QSQ AERO RJ\n9. IMG MUELLER\n10. IMG PALLADIUM\n","size_bytes":1046},"SOLUCAO_ANEXOS_RELATORIO_212.md":{"content":"# ✅ Solução: Anexos do Relatório #212\n\n## 🔍 O Que Aconteceu\n\nVocê mencionou que o **Relatório #212** tinha anexos, mas eles não apareciam. Investiguei e descobri que:\n\n1. ✅ **O sistema de anexos está 100% funcional**\n2. ❌ **Não havia PDFs salvos no banco de dados** para esse relatório\n3. ✅ **Criei PDFs de demonstração** para você testar agora\n\n## 📋 Situação do Relatório #212\n\n**Dados do relatório:**\n- ID: 212\n- Loja: \"119 QSQ AERO RJ\"\n- Data: 04/11/2025\n\n**PDFs criados agora:**\n- ✓ 1 PDF de Ticket\n- ✓ 1 PDF de Ranking\n\n## 🎯 Como Visualizar os Anexos AGORA\n\n1. **Faça login** com: admin / admin\n2. **Vá para a aba \"Consulta\"**\n3. **Busque** pelos relatórios de novembro/2025 ou procure pelo relatório #212\n4. **Clique em \"Visualizar\"** no relatório da loja \"119 QSQ AERO RJ\" de 04/11/2025\n5. **Olhe na sidebar \"ANEXOS\"** - agora você verá:\n   - 📄 PDF de Ranking\n   - 🧾 PDF de Ticket\n6. **Clique nos anexos** para abrir em abas separadas\n7. **Navegue** entre as abas: Relatório / Ranking / Ticket\n\n## ⚠️ Por Que os Anexos Não Apareciam Antes?\n\nOs PDFs anteriores que você pensou ter anexado **não foram salvos no sistema**. Isso pode ter acontecido porque:\n\n1. O upload falhou silenciosamente (erro de rede/servidor)\n2. Os PDFs foram anexados de outra forma que não registrou no banco de dados\n3. Houve algum erro durante o processo que não foi notificado\n\n## 📤 Como Adicionar Anexos no Futuro\n\nPara garantir que os PDFs sejam salvos corretamente:\n\n### Método 1: PDF de Ranking (com importação automática)\n1. Vá em **\"Novo Relatório\"**\n2. Selecione **loja e data** ANTES de tudo\n3. Clique no botão **\"Importar PDF\"** 📊\n4. Selecione o PDF de ranking\n5. O sistema vai:\n   - Extrair os dados automaticamente\n   - Validar se corresponde à loja/data\n   - Salvar o arquivo no servidor\n   - **Marcar o botão em laranja** se salvou com sucesso\n\n### Método 2: PDF de Ticket\n1. Vá em **\"Novo Relatório\"**\n2. Selecione **loja e data** ANTES de tudo\n3. Clique no botão do **\"Ticket\"** 🧾\n4. Selecione o PDF do ticket\n5. O sistema vai salvar e **marcar o botão em laranja**\n\n### ⚠️ IMPORTANTE:\n- **Sempre selecione loja e data ANTES** de fazer upload dos PDFs\n- **Aguarde** o botão ficar laranja para confirmar que salvou\n- Se aparecer algum erro, tente novamente ou me avise\n\n## 🧪 Teste Agora!\n\nSiga os passos acima para visualizar os PDFs que criei para o relatório #212. Depois disso, você pode adicionar seus próprios PDFs reais seguindo o método descrito.\n\n## 📊 Status Atual do Sistema\n\n**Total de PDFs no banco:**\n- 2 PDFs de Ticket\n- 2 PDFs de Ranking\n\n**Relatórios com anexos:**\n- Relatório #212: 119 QSQ AERO RJ (04/11/2025) ✓\n- Relatório: 020 QSQ ESTAÇÃO (06/08/2025) ✓\n\n---\n\n**Qualquer dúvida ou problema, me avise!** 🚀\n","size_bytes":2832},"GUIA_ANEXOS_PDF.md":{"content":"# Guia de Uso: Sistema de Anexos PDF\n\n## Como Funciona\n\nO sistema permite anexar PDFs (Ranking e Ticket do Dia) aos relatórios. Esses anexos ficam associados à **loja** e **data** do relatório, e podem ser visualizados na aba **Consulta**.\n\n## Como Adicionar Anexos a um Relatório\n\n### 1. Acesse a página \"Novo Relatório\"\n\nNa página de novo relatório, você verá dois botões no topo:\n- 📊 **Importar PDF** - Para fazer upload do PDF de Ranking\n- 🧾 **Ticket do Dia** - Para fazer upload do PDF de Ticket\n\n### 2. Selecione Loja e Data PRIMEIRO\n\n**IMPORTANTE:** Antes de fazer upload de qualquer PDF, você precisa:\n1. Selecionar a loja no dropdown\n2. Selecionar a data no campo de data\n\nOs PDFs serão associados a essa loja e data.\n\n### 3. Faça Upload dos PDFs\n\n#### Para PDF de Ranking:\n1. Clique no botão **\"Importar PDF\"** (ícone 📊)\n2. Selecione o arquivo PDF de ranking\n3. O sistema irá:\n   - Extrair automaticamente os dados (PA, Preço Médio, Atendimento Médio)\n   - Validar se a loja e data do PDF correspondem\n   - Salvar o arquivo no servidor\n   - Registrar no banco de dados\n\n#### Para PDF de Ticket:\n1. Clique no botão do ticket (ícone 🧾)\n2. Selecione o arquivo PDF do ticket do dia\n3. O sistema irá salvar e associar à loja e data selecionadas\n\n### 4. Visualizar Anexos na Aba Consulta\n\n1. Vá para a aba **Consulta**\n2. Busque o relatório que deseja visualizar\n3. Clique no botão **\"Visualizar\"** (ícone de olho)\n4. O modal será aberto com:\n   - **Aba \"Relatório\"**: PDF do relatório principal\n   - **Sidebar \"ANEXOS\"**: Lista todos os PDFs anexados (Rankings e Tickets)\n   - **Abas dinâmicas**: Cada anexo cria uma aba para navegação\n\n### 5. Navegar entre PDFs\n\n- Clique em qualquer anexo na sidebar para abrir sua aba\n- As abas aparecem no topo do modal:\n  - 📄 Relatório (sempre visível)\n  - ⚠️ Ranking (se houver PDF de ranking)\n  - 🧾 Ticket (se houver PDF de ticket)\n- Navegue entre as abas clicando nelas\n\n## Exemplos Práticos\n\nForam criados PDFs de exemplo para você testar:\n\n### Exemplo 1 - Relatório #212\n**Seu relatório mais recente:**\n- Loja: \"119 QSQ AERO RJ\"\n- Data: 04/11/2025\n- Anexos: 1 PDF de Ranking + 1 PDF de Ticket\n\n**Como visualizar:**\n1. Faça login (admin/admin)\n2. Vá para \"Consulta\"\n3. Busque pelo relatório #212 ou filtre por novembro/2025\n4. Clique em \"Visualizar\" no relatório da loja \"119 QSQ AERO RJ\" de 04/11/2025\n5. Na sidebar \"ANEXOS\", você verá os 2 PDFs\n6. Clique neles para abrir em abas separadas\n\n### Exemplo 2 - Relatório Antigo\n- Loja: \"020 QSQ ESTAÇÃO\"\n- Data: 06/08/2025  \n- Anexos: 1 PDF de Ranking + 1 PDF de Ticket\n\n**Como visualizar:** (mesmo processo do exemplo 1)\n\n## Observações Importantes\n\n- **Os anexos são associados por loja e data**: Todos os PDFs com a mesma loja e data aparecem juntos\n- **Múltiplos PDFs permitidos**: Você pode ter vários PDFs de ranking ou ticket para a mesma loja/data\n- **Validação automática**: O sistema valida se o PDF de ranking corresponde à loja e data selecionadas\n- **Carregamento sob demanda**: Os PDFs só são carregados quando você clica na aba (mais rápido)\n\n## Estrutura de Arquivos\n\nOs PDFs são salvos em:\n- Tickets: `data/pdfs/tickets/`\n- Rankings: `data/pdfs/rankings/`\n\nOs registros são salvos nas tabelas:\n- `pdf_tickets` (loja, data, filename, filepath, uploaded_by, uploaded_at)\n- `pdf_rankings` (loja, data, filename, filepath, pa, preco_medio, atendimento_medio, uploaded_by, uploaded_at)\n","size_bytes":3480},"bin/Demo/MfcDemo/11.Attendance/AttendanceManagerImpl.cpp":{"content":"#include \"stdafx.h\"\n#include \"AttendanceManagerImpl.h\"\n\nCAttendanceManagerImpl::CAttendanceManagerImpl()\n{\n\tm_lDeviceHandle = 0;\n\tm_lRealLoadHandle = 0;\n}\n\n\nCAttendanceManagerImpl::~CAttendanceManagerImpl()\n{\n\t\n}","size_bytes":212},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/TimingRecord.cpp":{"content":"// TimingRecord.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"TimingRecord.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CTimingRecord dialog\n\n\nCTimingRecord::CTimingRecord(CWnd* pParent /*=NULL*/)\n\t: CDialog(CTimingRecord::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CTimingRecord)\n\tm_bAllDayRecord = FALSE;\n\tm_hour1 = 0;\n\tm_hour2 = 0;\n\tm_hour3 = 0;\n\tm_hour4 = 0;\n\tm_minute1 = 0;\n\tm_minute2 = 0;\n\tm_minute3 = 0;\n\tm_minute4 = 0;\n\tm_shour1 = 0;\n\tm_shour2 = 0;\n\tm_shour3 = 0;\n\tm_shour4 = 0;\n\tm_sminute1 = 0;\n\tm_sminute2 = 0;\n\tm_sminute3 = 0;\n\tm_sminute4 = 0;\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CTimingRecord::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CTimingRecord)\n\tDDX_Control(pDX, IDC_RECORDTYPESEL, m_alldaytypesel);\n\tDDX_Control(pDX, IDC_RECORDTYPESEL4, m_recordtype4sel);\n\tDDX_Control(pDX, IDC_RECORDTYPESEL3, m_recordtype3sel);\n\tDDX_Control(pDX, IDC_RECORDTYPESEL2, m_recordtype2sel);\n\tDDX_Control(pDX, IDC_RECORDTYPESEL1, m_recordtype1sel);\n\tDDX_Control(pDX, IDC_RECORDDAYSEL, m_recorddaysel);\n\tDDX_Control(pDX, IDC_COPYDAYSEL, m_copydaysel);\n\tDDX_Check(pDX, IDC_ALLDAY_CHECK, m_bAllDayRecord);\n\tDDX_Text(pDX, IDC_HOUR1, m_hour1);\n\tDDX_Text(pDX, IDC_HOUR2, m_hour2);\n\tDDX_Text(pDX, IDC_HOUR3, m_hour3);\n\tDDX_Text(pDX, IDC_HOUR4, m_hour4);\n\tDDX_Text(pDX, IDC_MINUTE1, m_minute1);\n\tDDX_Text(pDX, IDC_MINUTE2, m_minute2);\n\tDDX_Text(pDX, IDC_MINUTE3, m_minute3);\n\tDDX_Text(pDX, IDC_MINUTE4, m_minute4);\n\tDDX_Text(pDX, IDC_SHOUR1, m_shour1);\n\tDDX_Text(pDX, IDC_SHOUR2, m_shour2);\n\tDDX_Text(pDX, IDC_SHOUR3, m_shour3);\n\tDDX_Text(pDX, IDC_SHOUR4, m_shour4);\n\tDDX_Text(pDX, IDC_SMINUTE1, m_sminute1);\n\tDDX_Text(pDX, IDC_SMINUTE2, m_sminute2);\n\tDDX_Text(pDX, IDC_SMINUTE3, m_sminute3);\n\tDDX_Text(pDX, IDC_SMINUTE4, m_sminute4);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CTimingRecord, CDialog)\n\t//{{AFX_MSG_MAP(CTimingRecord)\n\tON_CBN_SELCHANGE(IDC_RECORDDAYSEL, OnSelchangeRecorddaysel)\n\tON_BN_CLICKED(IDC_ALLDAY_CHECK, OnAlldayCheck)\n\tON_BN_CLICKED(IDC_BTNOK, OnBtnok)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CTimingRecord message handlers\n\n\n\n\nCTimingRecord::SetRecordInfo(NET_DEV_RECORD *recinfo)\n{\n\tm_recordinfo = recinfo;\n}\n\nBOOL CTimingRecord::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\tm_nDate = 0;\n\tm_recorddaysel.SetCurSel(m_nDate);\n\tm_nCopyDate = 0;\n\tm_copydaysel.SetCurSel(m_nCopyDate);\n\tm_bAllDayRecord = m_recordinfo->struRecAllDay[m_nDate].wAllDayRecord;\n\tm_alldaytypesel.SetCurSel(m_recordinfo->struRecAllDay[m_nDate].byRecordType);\t\t\n\tm_recordtype1sel.SetCurSel(m_recordinfo->struRecordSched[m_nDate][0].byRecordType);\n\tm_recordtype2sel.SetCurSel(m_recordinfo->struRecordSched[m_nDate][1].byRecordType);\n\tm_recordtype3sel.SetCurSel(m_recordinfo->struRecordSched[m_nDate][2].byRecordType);\n\tm_recordtype4sel.SetCurSel(m_recordinfo->struRecordSched[m_nDate][3].byRecordType);\n\tm_hour1 = m_recordinfo->struRecordSched[m_nDate][0].struRecordTime.byStartHour;\n\tm_shour1 = m_recordinfo->struRecordSched[m_nDate][0].struRecordTime.byStopHour;\n\tm_hour2 = m_recordinfo->struRecordSched[m_nDate][1].struRecordTime.byStartHour;\n\tm_shour2 = m_recordinfo->struRecordSched[m_nDate][1].struRecordTime.byStopHour;\n\tm_hour3 = m_recordinfo->struRecordSched[m_nDate][2].struRecordTime.byStartHour;\n\tm_shour3 = m_recordinfo->struRecordSched[m_nDate][2].struRecordTime.byStopHour;\n\tm_hour4 = m_recordinfo->struRecordSched[m_nDate][3].struRecordTime.byStartHour;\n\tm_shour4 = m_recordinfo->struRecordSched[m_nDate][3].struRecordTime.byStopHour;\n\tm_minute1 = m_recordinfo->struRecordSched[m_nDate][0].struRecordTime.byStartMin;\n\tm_sminute1 = m_recordinfo->struRecordSched[m_nDate][0].struRecordTime.byStopMin;\n\tm_minute2 = m_recordinfo->struRecordSched[m_nDate][1].struRecordTime.byStartMin;\n\tm_sminute2 = m_recordinfo->struRecordSched[m_nDate][1].struRecordTime.byStopMin;\n\tm_minute3 = m_recordinfo->struRecordSched[m_nDate][2].struRecordTime.byStartMin;\n\tm_sminute3 = m_recordinfo->struRecordSched[m_nDate][2].struRecordTime.byStopMin;\n\tm_minute4 = m_recordinfo->struRecordSched[m_nDate][3].struRecordTime.byStartMin;\n\tm_sminute4 = m_recordinfo->struRecordSched[m_nDate][3].struRecordTime.byStopMin;\n\tEnableControl(!m_bAllDayRecord);\n\tUpdateData(FALSE);\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\n\nvoid CTimingRecord::EnableControl(BOOL bEnable)\n{\n\tGetDlgItem(IDC_HOUR1)->EnableWindow(bEnable);\n\tGetDlgItem(IDC_HOUR2)->EnableWindow(bEnable);\n\tGetDlgItem(IDC_HOUR3)->EnableWindow(bEnable);\n\tGetDlgItem(IDC_HOUR4)->EnableWindow(bEnable);\n\t\n\tGetDlgItem(IDC_MINUTE1)->EnableWindow(bEnable);\n\tGetDlgItem(IDC_MINUTE2)->EnableWindow(bEnable);\n\tGetDlgItem(IDC_MINUTE3)->EnableWindow(bEnable);\n\tGetDlgItem(IDC_MINUTE4)->EnableWindow(bEnable);\n\t\n\tGetDlgItem(IDC_SHOUR1)->EnableWindow(bEnable);\n\tGetDlgItem(IDC_SHOUR2)->EnableWindow(bEnable);\n\tGetDlgItem(IDC_SHOUR3)->EnableWindow(bEnable);\n\tGetDlgItem(IDC_SHOUR4)->EnableWindow(bEnable);\n\t\n\tGetDlgItem(IDC_SMINUTE1)->EnableWindow(bEnable);\n\tGetDlgItem(IDC_SMINUTE2)->EnableWindow(bEnable);\n\tGetDlgItem(IDC_SMINUTE3)->EnableWindow(bEnable);\n\tGetDlgItem(IDC_SMINUTE4)->EnableWindow(bEnable);\n\t\n\tGetDlgItem(IDC_RECORDTYPESEL1)->EnableWindow(bEnable);\n\tGetDlgItem(IDC_RECORDTYPESEL2)->EnableWindow(bEnable);\n\tGetDlgItem(IDC_RECORDTYPESEL3)->EnableWindow(bEnable);\n\tGetDlgItem(IDC_RECORDTYPESEL4)->EnableWindow(bEnable);\n\t\n\tGetDlgItem(IDC_RECORDTYPESEL)->EnableWindow(!bEnable);\n}\n\nvoid CTimingRecord::OnSelchangeRecorddaysel() \n{\n\tm_nDate = m_recorddaysel.GetCurSel();\t\n\tm_bAllDayRecord = m_recordinfo->struRecAllDay[m_nDate].wAllDayRecord;\n\tm_alldaytypesel.SetCurSel(m_recordinfo->struRecAllDay[m_nDate].byRecordType);\n\tm_recordtype1sel.SetCurSel(m_recordinfo->struRecordSched[m_nDate][0].byRecordType);\n\tm_recordtype2sel.SetCurSel(m_recordinfo->struRecordSched[m_nDate][1].byRecordType);\n\tm_recordtype3sel.SetCurSel(m_recordinfo->struRecordSched[m_nDate][2].byRecordType);\n\tm_recordtype4sel.SetCurSel(m_recordinfo->struRecordSched[m_nDate][3].byRecordType);\n\tm_hour1 = m_recordinfo->struRecordSched[m_nDate][0].struRecordTime.byStartHour;\n\tm_shour1 = m_recordinfo->struRecordSched[m_nDate][0].struRecordTime.byStopHour;\n\tm_hour2 = m_recordinfo->struRecordSched[m_nDate][1].struRecordTime.byStartHour;\n\tm_shour2 = m_recordinfo->struRecordSched[m_nDate][1].struRecordTime.byStopHour;\n\tm_hour3 = m_recordinfo->struRecordSched[m_nDate][2].struRecordTime.byStartHour;\n\tm_shour3 = m_recordinfo->struRecordSched[m_nDate][2].struRecordTime.byStopHour;\n\tm_hour4 = m_recordinfo->struRecordSched[m_nDate][3].struRecordTime.byStartHour;\n\tm_shour4 = m_recordinfo->struRecordSched[m_nDate][3].struRecordTime.byStopHour;\n\tm_minute1 = m_recordinfo->struRecordSched[m_nDate][0].struRecordTime.byStartMin;\n\tm_sminute1 = m_recordinfo->struRecordSched[m_nDate][0].struRecordTime.byStopMin;\n\tm_minute2 = m_recordinfo->struRecordSched[m_nDate][1].struRecordTime.byStartMin;\n\tm_sminute2 = m_recordinfo->struRecordSched[m_nDate][1].struRecordTime.byStopMin;\n\tm_minute3 = m_recordinfo->struRecordSched[m_nDate][2].struRecordTime.byStartMin;\n\tm_sminute3 = m_recordinfo->struRecordSched[m_nDate][2].struRecordTime.byStopMin;\n\tm_minute4 = m_recordinfo->struRecordSched[m_nDate][3].struRecordTime.byStartMin;\n\tm_sminute4 = m_recordinfo->struRecordSched[m_nDate][3].struRecordTime.byStopMin;\n\tEnableControl(!m_bAllDayRecord);\n\tGetDlgItem(IDC_BTNCOPY)->EnableWindow(FALSE);\n\tUpdateData(FALSE);\t\n}\n\nvoid CTimingRecord::OnAlldayCheck() \n{\n\tUpdateData(TRUE);\n\tEnableControl(!m_bAllDayRecord);\n\t\n}\n\nBOOL CTimingRecord::TimeTest()\n{\n\tint i,j;\n\tCString sTemp;\n\tCString sTime[4][2];\n\tsTime[0][0].Format(\"%02d%02d\",m_hour1,m_minute1);\n\tsTime[0][1].Format(\"%02d%02d\",m_shour1,m_sminute1);\n\tsTime[1][0].Format(\"%02d%02d\",m_hour2,m_minute2);\n\tsTime[1][1].Format(\"%02d%02d\",m_shour2,m_sminute2);\n\tsTime[2][0].Format(\"%02d%02d\",m_hour3,m_minute3);\n\tsTime[2][1].Format(\"%02d%02d\",m_shour3,m_sminute3);\n\tsTime[3][0].Format(\"%02d%02d\",m_hour4,m_minute4);\n\tsTime[3][1].Format(\"%02d%02d\",m_shour4,m_sminute4);\n\tfor(i=0;i<4;i++)\n\t{\n\t\tif ((sTime[i][0].Left(2)>\"24\")||(sTime[i][0].Left(2)>\"24\")||(sTime[i][0].Left(2)<\"00\")||(sTime[i][0].Left(2)<\"00\"))\n\t\t{\n\t\t\tsTemp.Format(\"%d\",(i+1));\n\t\t\tsTemp = MSG_TIMINGREC_STARTTIMEERROR + sTemp;\n\t\t\tAfxMessageBox(sTemp);\n\t\t\treturn FALSE;\n\t\t}\n\t\tif ((sTime[i][0]>\"2400\")||(sTime[i][1]>\"2400\")||(sTime[i][0]<\"0000\")||(sTime[i][1]<\"0000\"))\n\t\t{\n\t\t\tsTemp.Format(\"%d\",(i+1));\n\t\t\tsTemp = MSG_TIMINGREC_STARTTIMEERROR + sTemp;\n\t\t\tAfxMessageBox(sTemp);\n\t\t\treturn FALSE;\n\t\t}\n\t\tif ((sTime[i][0].Right(2)>\"59\")||(sTime[i][0].Right(2)>\"59\")||(sTime[i][0].Right(2)<\"00\")||(sTime[i][0].Right(2)<\"00\"))\n\t\t{\n\t\t\tsTemp.Format(\"%d\",(i+1));\n\t\t\tsTemp = MSG_TIMINGREC_STARTTIMEERROR + sTemp;\n\t\t\tAfxMessageBox(sTemp);\n\t\t\treturn FALSE;\n\t\t}\n\t\tif ((sTime[i][1].Left(2)>\"24\")||(sTime[i][1].Left(2)>\"24\")||(sTime[i][1].Left(2)<\"00\")||(sTime[i][1].Left(2)<\"00\"))\n\t\t{\n\t\t\tsTemp.Format(\"%d\",(i+1));\n\t\t\tsTemp = MSG_TIMINGREC_STOPTIMEERROR + sTemp;\n\t\t\tAfxMessageBox(sTemp);\n\t\t\treturn FALSE;\n\t\t}\n\t\tif ((sTime[i][1].Right(2)>\"59\")||(sTime[i][1].Right(2)>\"59\")||(sTime[i][1].Right(2)<\"00\")||(sTime[i][1].Right(2)<\"00\"))\n\t\t{\n\t\t\tsTemp.Format(\"%d\",(i+1));\n\t\t\tsTemp = MSG_TIMINGREC_STOPTIMEERROR + sTemp;\n\t\t\tAfxMessageBox(sTemp);\n\t\t\treturn FALSE;\n\t\t}\n\t\tif(sTime[i][0]>=sTime[i][1])\n\t\t{\n\t\t\tif((sTime[i][0]!=\"0000\") || (sTime[i][1]!=\"0000\"))\n\t\t\t{\n\t\t\t\tsTemp.Format(\"%d\",(i+1));\n\t\t\t\tsTemp = MSG_TIMINGREC_STOPTIMEERROR + sTemp;\n\t\t\t\tAfxMessageBox(sTemp);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t\tfor (j=i+1;j<4;j++)\n\t\t{\n\t\t\tif((sTime[j][0]>sTime[i][0]) && (sTime[j][0]<sTime[i][1]))\n\t\t\t{\n\t\t\t\tsTemp.Format(\"%d,%d\",(i+1),(j+1));\n\t\t\t\tsTemp = MSG_TIMINGREC_TIMEOVERLAY + sTemp;\n\t\t\t\tAfxMessageBox(sTemp);\n\t\t\t\treturn FALSE;\n\t\t\t}else if((sTime[j][1]>sTime[i][0]) && (sTime[j][1]<sTime[i][1]))\n\t\t\t{\n\t\t\t\tsTemp.Format(\"%d,%d\",(i+1),(j+1));\n\t\t\t\tsTemp = MSG_TIMINGREC_TIMEOVERLAY + sTemp;\n\t\t\t\tAfxMessageBox(sTemp);\n\t\t\t\treturn FALSE;\n\t\t\t}else if((sTime[j][0]<=sTime[i][0]) && (sTime[j][1]>=sTime[i][1]))\n\t\t\t{\n\t\t\t\tif((sTime[j][0]!=\"0000\") && (sTime[j][1]!=\"0000\"))\n\t\t\t\t{\n\t\t\t\t\tsTemp.Format(\"%d,%d\",(i+1),(j+1));\n\t\t\t\t\tsTemp = MSG_TIMINGREC_TIMEOVERLAY + sTemp;\n\t\t\t\t\tAfxMessageBox(sTemp);\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}\n\nvoid CTimingRecord::OnBtnok() \n{\n\tif (!UpdateData(TRUE))\n\t{\n\t\treturn;\n\t}\n\tif(!TimeTest())\n\t{\n\t\treturn;\n\t}\n\t\n\tm_recordinfo->struRecAllDay[m_nDate].wAllDayRecord = m_bAllDayRecord;\n\tif(m_bAllDayRecord)\n\t{\t\t\n\t\tm_recordinfo->struRecAllDay[m_nDate].byRecordType = m_alldaytypesel.GetCurSel();\n\t}\n\telse\n\t{\n\t\tm_recordinfo->struRecordSched[m_nDate][0].byRecordType = m_recordtype1sel.GetCurSel();\n\t\tm_recordinfo->struRecordSched[m_nDate][1].byRecordType = m_recordtype2sel.GetCurSel();\n\t\tm_recordinfo->struRecordSched[m_nDate][2].byRecordType = m_recordtype3sel.GetCurSel();\n\t\tm_recordinfo->struRecordSched[m_nDate][3].byRecordType = m_recordtype4sel.GetCurSel();\t\t\t\n\t\tm_recordinfo->struRecordSched[m_nDate][0].struRecordTime.byStartHour = m_hour1;\n\t\tm_recordinfo->struRecordSched[m_nDate][0].struRecordTime.byStopHour = m_shour1;\n\t\tm_recordinfo->struRecordSched[m_nDate][1].struRecordTime.byStartHour = m_hour2;\n\t\tm_recordinfo->struRecordSched[m_nDate][1].struRecordTime.byStopHour = m_shour2;\n\t\tm_recordinfo->struRecordSched[m_nDate][2].struRecordTime.byStartHour = m_hour3;\n\t\tm_recordinfo->struRecordSched[m_nDate][2].struRecordTime.byStopHour = m_shour3;\n\t\tm_recordinfo->struRecordSched[m_nDate][3].struRecordTime.byStartHour = m_hour4;\n\t\tm_recordinfo->struRecordSched[m_nDate][3].struRecordTime.byStopHour = m_shour4;\n\t\t\n\t\tm_recordinfo->struRecordSched[m_nDate][0].struRecordTime.byStartMin = m_minute1;\n\t\tm_recordinfo->struRecordSched[m_nDate][0].struRecordTime.byStopMin = m_sminute1;\n\t\tm_recordinfo->struRecordSched[m_nDate][1].struRecordTime.byStartMin = m_minute2;\n\t\tm_recordinfo->struRecordSched[m_nDate][1].struRecordTime.byStopMin = m_sminute2;\n\t\tm_recordinfo->struRecordSched[m_nDate][2].struRecordTime.byStartMin = m_minute3;\n\t\tm_recordinfo->struRecordSched[m_nDate][2].struRecordTime.byStopMin = m_sminute3;\n\t\tm_recordinfo->struRecordSched[m_nDate][3].struRecordTime.byStartMin = m_minute4;\n\t\tm_recordinfo->struRecordSched[m_nDate][3].struRecordTime.byStopMin = m_sminute4;\n\t}\n\tGetDlgItem(IDC_BTNCOPY)->EnableWindow(TRUE);\t// TODO: Add your control notification handler code here\n\tCDialog::OnOK();\n}\n","size_bytes":12566},"bin/Demo/MfcDemo/23.VehicleGPS/Utils.cpp":{"content":"#include \"StdAfx.h\"\n#include \"Utils.h\"\n\nTCHAR* g_GetIniPath(void)\n{\n\tstatic char pszIniPath[512] = {0};\n\tif( strlen(pszIniPath) == 0 )\n\t{\n\t\tchar szDirBuf[512] = {0};\n\t\tGetCurrentDirectory(512, szDirBuf);\n\t\t_snprintf(pszIniPath, sizeof(pszIniPath), \"%s\\\\langchn.ini\", szDirBuf);\n\t}\n\treturn pszIniPath;\n}\n\nCString ConvertString(CString strText)\n{\n\tchar *val = new char[200];\n\tCString strIniPath,strRet;\n\n\tmemset(val,0,200);\n\tGetPrivateProfileString(\"String\",strText,\"\",\n\t\tval,200,g_GetIniPath());\n\tstrRet = val;\n\tif(strRet.GetLength()==0)\n\t{\n\t\t//If there is no corresponding string in ini file ,then set it to be default value.\n\t\tstrRet=strText;\n\t}\n\tdelete val;\n\treturn strRet;\n}\n\nvoid g_SetWndStaticText(CWnd * pWnd)\n{\n\tCString strCaption,strText;\n\n\t//Set main widnow title \n\tpWnd->GetWindowText(strCaption);\n\tif(strCaption.GetLength()>0)\n\t{\n\t\tstrText=ConvertString(strCaption);\n\t\tpWnd->SetWindowText(strText);\n\t}\n\n\t//Set small window title \n\tCWnd * pChild=pWnd->GetWindow(GW_CHILD);\n\tCString strClassName;\n\twhile(pChild)\n\t{\n\t\t//////////////////////////////////////////////////////////////////////////\t\t\n\t\t//Added by Jackbin 2005-03-11\n\t\tstrClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n\t\tif(strClassName == \"CEdit\")\n\t\t{\n\t\t\t//The next small window \n\t\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t\t\tcontinue;\n\t\t}\n\n\t\t//////////////////////////////////////////////////////////////////////////\t\n\n\t\t//Set current language text in small window\n\t\tpChild->GetWindowText(strCaption);\n\t\tstrText=ConvertString(strCaption);\n\t\tpChild->SetWindowText(strText);\n\n\t\t//The next small window \n\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t}\n}\n\nvoid FillCWndWithDefaultColor(CWnd* cwnd) \n{\n\tif (NULL == cwnd)\n\t{\n\t\treturn;\n\t}\n\n\tCDC* cdc = cwnd->GetDC();\n\tif (NULL == cdc)\n\t{\n\t\treturn;\n\t}\n\n\tRECT rect;\n\tcwnd->GetClientRect(&rect);\n\tCBrush brush(RGB(105,105,105));\n\tcdc->FillRect(&rect, &brush);\n\tcwnd->ReleaseDC(cdc);\n}","size_bytes":1916},"bin/Demo/MfcDemo/09.AccessControl/DlgQueryLog.cpp":{"content":"// DlgQueryLog.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AccessControl.h\"\n#include \"DlgQueryLog.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgQueryLog dialog\n\n\nCDlgQueryLog::CDlgQueryLog(CWnd* pParent /* = NULL */, LLONG lLoginId /* = 0 */, NET_DEVICE_TYPE emDevType /* = NET_PRODUCT_NONE */, int nMaxPageSize /* = 10 */)\n\t: CDialog(CDlgQueryLog::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgQueryLog)\n\tm_nPageLines\t= 10;\n\tm_timeEnd\t\t= 0;\n\tm_timeBegin\t\t= 0;\n\tm_dataEnd\t\t= COleDateTime::GetCurrentTime();\n\tm_dataBegin\t\t= COleDateTime::GetCurrentTime();\n\t//}}AFX_DATA_INIT\n\tm_lLoginId\t\t= lLoginId;\n    m_lLogID        = 0;\n\tm_nStartNo\t\t= 0;\n\tm_nMaxPageSize\t= nMaxPageSize;\n\tm_emDevType\t\t= emDevType;\n}\n\nvoid CDlgQueryLog::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgQueryLog)\n\tDDX_Control(pDX, IDC_QUERYLOG_LIST_LOGLIST, m_logList);\n\tDDX_Control(pDX, IDC_QUERYLOG_COMBO_TYPE, m_cmbQueryType);\n\tDDX_Text(pDX, IDC_QUERYLOG_EDIT_PAGELINES, m_nPageLines);\n//\tDDV_MinMaxInt(pDX, m_nPageLines, 1, 1024);\n\tDDX_DateTimeCtrl(pDX, IDC_QUERYLOG_DATETIMEPICKER_ENDTIME, m_timeEnd);\n\tDDX_DateTimeCtrl(pDX, IDC_QUERYLOG_DATETIMEPICKER_STARTTIME, m_timeBegin);\n\tDDX_DateTimeCtrl(pDX, IDC_QUERYLOG_DATETIMEPICKER_ENDDAY, m_dataEnd);\n\tDDX_DateTimeCtrl(pDX, IDC_QUERYLOG_DATETIMEPICKER_STARTDAY, m_dataBegin);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgQueryLog, CDialog)\n\t//{{AFX_MSG_MAP(CDlgQueryLog)\n\tON_BN_CLICKED(IDC_QUERYLOG_BTN_QUERYSTOP, OnBtnQueryStop)\n\tON_BN_CLICKED(IDC_QUERYLOG_BTN_QUERYSTART, OnBtnQueryStart)\n\tON_BN_CLICKED(IDC_QUERYLOG_BTN_QUERYNEXT, OnBtnQueryNext)\n\tON_WM_DESTROY()\n\tON_BN_CLICKED(IDC_QUERYLOG_BTN_TOTALCOUNT, OnQuerylogBtnTotalCount)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n//////////////////////////////////////////////////////////////////////////\n// private method\n\nvoid CDlgQueryLog::InitDlg()\n{\n\tm_logList.SetExtendedStyle(m_logList.GetExtendedStyle() | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);\n\tm_logList.InsertColumn(0, ConvertString(\"seq\", DLG_QUERYLOG), LVCFMT_LEFT,30,-1);\n\tm_logList.InsertColumn(1, ConvertString(\"type\", DLG_QUERYLOG), LVCFMT_LEFT,150,-1);\n\tm_logList.InsertColumn(2, ConvertString(\"date\", DLG_QUERYLOG),LVCFMT_LEFT,180,-1);\n\tm_logList.InsertColumn(3, ConvertString(\"content\", DLG_QUERYLOG),LVCFMT_LEFT,420,-1);\n\n    GetDlgItem(IDC_QUERYLOG_BTN_QUERYNEXT)->EnableWindow(FALSE);\n    GetDlgItem(IDC_QUERYLOG_BTN_QUERYSTART)->EnableWindow(TRUE);\n    GetDlgItem(IDC_QUERYLOG_BTN_QUERYSTOP)->EnableWindow(FALSE);\n}\n\nvoid CDlgQueryLog::InsertListViewItem(int nStartNo, const CString& strLogType, const CString& strLogTime, const CString& strLogContext)\n{\n\tint nIndex = m_logList.GetItemCount();\n\t\n\tCString strIndex;\n\tstrIndex.Format(\"%d\", nStartNo + 1);\n\tm_logList.InsertItem(nIndex, \"\");\n\t\n\tm_logList.SetItemText(nIndex, 0, strIndex);\n\tm_logList.SetItemText(nIndex, 1, strLogType);\n\tm_logList.SetItemText(nIndex, 2, strLogTime);\n\tm_logList.SetItemText(nIndex, 3, strLogContext);\n}\n\nBOOL CDlgQueryLog::QueryStart()\n{\n    NET_IN_START_QUERYLOG stuIn = {sizeof(stuIn)};\n    NET_OUT_START_QUERYLOG stuOut = {sizeof(stuOut)};\n    LLONG lLogID = CLIENT_StartQueryLog(m_lLoginId, &stuIn, &stuOut, SDK_API_WAITTIME);\n    if (lLogID != NULL)\n    {\n        m_logList.DeleteAllItems();\n        m_nStartNo = 0;\n        m_lLogID = lLogID;\n        return TRUE;\n    }\n    CString csInfo;\n    csInfo.Format(\"%s0x%08x\", ConvertString(\"Start query failed:\", DLG_QUERYLOG), CLIENT_GetLastError());\n    MessageBox(csInfo, ConvertString(\"Prompt\"));\n    return FALSE;\n}\n\nint CDlgQueryLog::QueryNext()\n{\n    NET_IN_QUERYNEXTLOG stuIn = {sizeof(stuIn)};\n    stuIn.nGetCount = m_nMaxPageSize;\n\n    NET_OUT_QUERYNEXTLOG stuOut = {sizeof(stuOut)};\n    stuOut.nMaxCount = m_nMaxPageSize;\n    stuOut.pstuLogInfo = new NET_LOG_INFO[m_nMaxPageSize];\n    if (NULL == stuOut.pstuLogInfo)\n    {\n        return -1;\n    }\n    memset(stuOut.pstuLogInfo, 0, sizeof(NET_LOG_INFO) * m_nMaxPageSize);\n    int i = 0;\n    for (i = 0; i < m_nMaxPageSize; i++)\n    {\n        stuOut.pstuLogInfo[i].dwSize = sizeof(NET_LOG_INFO);\n        stuOut.pstuLogInfo[i].stuLogMsg.dwSize = sizeof(NET_LOG_MESSAGE);\n    }\n    if (CLIENT_QueryNextLog(m_lLogID, &stuIn, &stuOut, SDK_API_WAITTIME))\n    {\n        if (stuOut.nRetCount > 0)\n        {\n            m_logList.DeleteAllItems();\n        }\n\n        for (i = 0; i < __min(stuOut.nMaxCount, stuOut.nRetCount); i++)\n        {\n            NET_TIME& stuTime = stuOut.pstuLogInfo[i].stuTime;\n\n            char szTime[64] = {0};\n            _snprintf(szTime, sizeof(szTime) - 1, \"%04d-%02d-%02d %02d:%02d:%02d\",\n                stuTime.dwYear, stuTime.dwMonth, stuTime.dwDay,\n                stuTime.dwHour, stuTime.dwMinute, stuTime.dwSecond);\n\n            InsertListViewItem(m_nStartNo++, \n                stuOut.pstuLogInfo[i].szLogType,\n                szTime,\n                stuOut.pstuLogInfo[i].stuLogMsg.szLogMessage);\n        }\n        delete []stuOut.pstuLogInfo;\n        stuOut.pstuLogInfo = NULL;\n        return stuOut.nRetCount;\n    }\n    delete []stuOut.pstuLogInfo;\n    stuOut.pstuLogInfo = NULL;\n    return 0;\n}\n\nBOOL CDlgQueryLog::QueryStop()\n{\n    return CLIENT_StopQueryLog(m_lLogID);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgQueryLog message handlers\n\nBOOL CDlgQueryLog::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\t// TODO: Add extra initialization here\n\tg_SetWndStaticText(this, DLG_QUERYLOG);\n\n\tInitDlg();\n\tOnQuerylogBtnTotalCount();\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n//////////////////////////////////////////////////////////////////////////\n//\n// start query\n//\n//////////////////////////////////////////////////////////////////////////\nvoid CDlgQueryLog::OnBtnQueryStart() \n{\n\t// TODO: Add your control notification handler code here\n    if (QueryStart())\n    {\n        GetDlgItem(IDC_QUERYLOG_BTN_QUERYSTART)->EnableWindow(FALSE);\n        GetDlgItem(IDC_QUERYLOG_BTN_QUERYNEXT)->EnableWindow();\n        GetDlgItem(IDC_QUERYLOG_BTN_QUERYSTOP)->EnableWindow();\n    }\n}\n//////////////////////////////////////////////////////////////////////////\n//\n// query next\n//\n//////////////////////////////////////////////////////////////////////////\nvoid CDlgQueryLog::OnBtnQueryNext() \n{\n\t// TODO: Add your control notification handler code here\n    int nRet = QueryNext();\n    if (nRet < m_nMaxPageSize)\n    {\n        // we got the last page\n        GetDlgItem(IDC_QUERYLOG_BTN_QUERYNEXT)->EnableWindow(FALSE);\n    }\n}\n//////////////////////////////////////////////////////////////////////////\n//\n// stop query\n//\n//////////////////////////////////////////////////////////////////////////\nvoid CDlgQueryLog::OnBtnQueryStop() \n{\n    // TODO: Add your control notification handler code here\n    if (QueryStop())\n    {\n        GetDlgItem(IDC_QUERYLOG_BTN_QUERYSTART)->EnableWindow();\n        GetDlgItem(IDC_QUERYLOG_BTN_QUERYNEXT)->EnableWindow(FALSE);\n        GetDlgItem(IDC_QUERYLOG_BTN_QUERYSTOP)->EnableWindow(FALSE);\n    }\n}\n\nvoid CDlgQueryLog::OnDestroy() \n{\n\tCDialog::OnDestroy();\n\t\n\t// TODO: Add your message handler code here\n\tif (m_lLogID != 0)\n\t{\n        CLIENT_StopQueryLog(m_lLogID);\n\t}\n}\n\nvoid CDlgQueryLog::OnQuerylogBtnTotalCount() \n{\n\t// TODO: Add your control notification handler code here\n\tNET_IN_GETCOUNT_LOG_PARAM stuIn = {sizeof(stuIn)};\n\tNET_OUT_GETCOUNT_LOG_PARAM stuOut = {sizeof(stuOut)};\n\tif (CLIENT_QueryDevLogCount(m_lLoginId, &stuIn, &stuOut, SDK_API_WAITTIME))\n\t{\n\t\tSetDlgItemInt(IDC_QUERYLOG_EDT_TOTALCOUNT, stuOut.nLogCount);\n\t}\n\telse\n\t{\n\t\tCString csOut;\n\t\tcsOut.Format(\"%s:0x%08x\", ConvertString(\"Query log total count failed\", DLG_QUERYLOG), CLIENT_GetLastError());\n\t\tMessageBox(csOut, ConvertString(\"Prompt\"));\n\t}\n}\n","size_bytes":7942},"bin/Demo/MfcDemo/10.AlarmDevice/DlgUserInfo.cpp":{"content":"// DlgUserInfo.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgUserInfo.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgUserInfo dialog\n\n\nCDlgUserInfo::CDlgUserInfo(CWnd* pParent /* = NULL */, LLONG hLoginId /* = 0 */)\n\t: CDialog(CDlgUserInfo::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgUserInfo)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\tm_hLoginId = hLoginId;\n\tm_bGetUserInfo = TRUE;\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CDlgUserInfo::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgUserInfo)\n\tDDX_Control(pDX, IDC_USERINFO_LIST_INFO, m_lsUserInfo);\n\tDDX_Control(pDX, IDC_USERINFO_CMB_TYPE, m_cmbType);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgUserInfo, CDialog)\n\t//{{AFX_MSG_MAP(CDlgUserInfo)\n\tON_WM_DESTROY()\n\tON_BN_CLICKED(IDC_USERINFO_BTN_GET, OnUserinfoGet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// Private method\n\nvoid CDlgUserInfo::InitDlg(BOOL bGetUserInfo /* = TRUE */)\n{\n\tint i = 0;\n\n\tm_lsUserInfo.DeleteAllItems();\n\tint nColumnCount = m_lsUserInfo.GetHeaderCtrl()->GetItemCount();\n\tfor (i = 0; i < nColumnCount; i++)\n\t{\n\t\tm_lsUserInfo.DeleteColumn(0);\n\t}\n\n\tm_cmbType.ResetContent();\n\tfor (i = 0; i < sizeof(stuDemoUserInfoType) / sizeof(stuDemoUserInfoType[0]); i++)\n\t{\n\t\tm_cmbType.InsertString(-1, ConvertString(stuDemoUserInfoType[i].pszName, DLG_USERINFO));\n\t}\n\n\tif (bGetUserInfo)\n\t{\n\t\tm_lsUserInfo.InsertColumn(0, ConvertString(\"Seq\", DLG_USERINFO), LVCFMT_LEFT, 40);\n\t\tm_lsUserInfo.InsertColumn(1, ConvertString(\"Name\", DLG_USERINFO), LVCFMT_LEFT, 100);\n\t\tm_lsUserInfo.InsertColumn(2, ConvertString(\"Modify time at last\", DLG_USERINFO), LVCFMT_LEFT, 150);\n\n\t\tm_cmbType.SetCurSel((int)emUserInfoType_All);\n\t} \n\telse\n\t{\n\t\tm_lsUserInfo.InsertColumn(0, ConvertString(\"Seq\", DLG_USERINFO), LVCFMT_LEFT, 40);\n\t\tm_lsUserInfo.InsertColumn(1, ConvertString(\"Name\", DLG_USERINFO), LVCFMT_LEFT, 50);\n\t\tm_lsUserInfo.InsertColumn(2, ConvertString(\"Type\", DLG_USERINFO), LVCFMT_LEFT, 100);\n\t\tm_lsUserInfo.InsertColumn(3, ConvertString(\"Address\", DLG_USERINFO), LVCFMT_LEFT, 100);\n\t\tm_lsUserInfo.InsertColumn(4, ConvertString(\"Login time\", DLG_USERINFO), LVCFMT_LEFT, 150);\n\t\tm_lsUserInfo.InsertColumn(5, ConvertString(\"Group\", DLG_USERINFO), LVCFMT_LEFT, 60);\n\n\t\tm_cmbType.SetCurSel((int)emUserInfoType_Active);\n\t}\n}\n\nvoid CDlgUserInfo::GetInfo(BOOL bGetUserInfo /* = TRUE */)\n{\t\n\tm_lsUserInfo.DeleteAllItems();\n\t\n\tif (m_bGetUserInfo)\n\t{\n\t\t// Get all users\n\t\tUSER_MANAGE_INFO_NEW* pstuParam = new USER_MANAGE_INFO_NEW;\n\t\tif (!pstuParam)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tmemset(pstuParam, 0, sizeof(USER_MANAGE_INFO_NEW));\n\t\tpstuParam->dwSize = sizeof(*pstuParam);\n\t\t{\n\t\t\tfor (int x = 0; x < sizeof(pstuParam->groupListEx)/sizeof(pstuParam->groupListEx[0]); x++)\n\t\t\t{\n                pstuParam->groupList[x].dwSize = sizeof(USER_GROUP_INFO_NEW);\n\t\t\t\tpstuParam->groupListEx[x].dwSize = sizeof(USER_GROUP_INFO_EX2);\n\t\t\t}\n            for (int x =0; x< DH_NEW_MAX_RIGHT_NUM; x++)\n            {\n                pstuParam->rightList[x].dwSize = sizeof(OPR_RIGHT_NEW);\n            }\n            for (int x= 0; x< DH_MAX_USER_NUM; x++)\n            {\n                pstuParam->userList[x].dwSize = sizeof(USER_INFO_NEW);\n            }\n\t\t}\n\t\tBOOL bRet = CLIENT_QueryUserInfoNew(m_hLoginId, pstuParam, NULL, SDK_API_WAIT);\n\t\tif (bRet)\n\t\t{\n\t\t\tint nCount = __min(pstuParam->dwUserNum, DH_MAX_USER_NUM);\n\t\t\tfor (int i = 0; i < nCount; i++)\n\t\t\t{\n\t\t\t\tInsertUserInfo(pstuParam->userList[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCString csOut;\n\t\t\tcsOut.Format(\"%s %08x\", ConvertString(\"Query user info failed:\", DLG_USERINFO), CLIENT_GetLastError());\n\t\t\tMessageBox(csOut, ConvertString(\"Prompt\"));\n\t\t}\n\n\t\tif (pstuParam)\n\t\t{\n\t\t\tdelete pstuParam;\n\t\t\tpstuParam = NULL;\n\t\t}\n\t} \n\telse\n\t{\n\t\tchar szJson[1024] = {0};\n\t\tCFG_ACTIVEALLUSER_INFO stuParam = {sizeof(stuParam)};\n\t\tint i = 0;\n\t\tfor (i = 0; i < MAX_ACTIVEUSER_NUM; i++)\n\t\t{\n\t\t\tstuParam.stuActiveUserInfo[i].nStructSize = sizeof(CFG_ACTIVEUSER_INFO);\n\t\t\tstuParam.stuActiveUserInfo[i].stuLoginTime.nStructSize = sizeof(CFG_NET_TIME);\n\t\t}\n\t\tint nErr = 0;\n\t\tBOOL bRet = CLIENT_QueryNewSystemInfo(m_hLoginId, CFG_USERMANAGER_ACTIVEUSER, -1,\n\t\t\tszJson, sizeof(szJson), &nErr, SDK_API_WAIT);\n\t\tif (bRet)\n\t\t{\n\t\t\tint nRet = 0;\n\t\t\tbRet = CLIENT_ParseData(CFG_USERMANAGER_ACTIVEUSER, szJson, &stuParam, sizeof(stuParam), &nRet);\n\t\t\tif (bRet && nRet == sizeof(stuParam))\n\t\t\t{\n\t\t\t\tfor (i = 0; i < stuParam.nCount; i++)\n\t\t\t\t{\n\t\t\t\t\tInsertActiveUserInfo(stuParam.stuActiveUserInfo[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCString csOut;\n\t\t\t\tcsOut.Format(\"%s\", ConvertString(\"Parse active user info failed!\", DLG_USERINFO));\n\t\t\t\tMessageBox(csOut, ConvertString(\"Prompt\"));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCString csOut;\n\t\t\tcsOut.Format(\"%s %08x\", ConvertString(\"Query active user info failed:\", DLG_USERINFO), CLIENT_GetLastError());\n\t\t\tMessageBox(csOut, ConvertString(\"Prompt\"));\n\t\t}\n\t}\n}\n\nvoid CDlgUserInfo::InsertUserInfo(const USER_INFO_NEW& stuInfo)\n{\n\tint nCount = m_lsUserInfo.GetItemCount();\n\tm_lsUserInfo.InsertItem(nCount, \"\");\n\t\n\tchar szSeq[8] = {0};\n\t_itoa(nCount, szSeq, 10);\n\tm_lsUserInfo.SetItemText(nCount, 0, szSeq);\n\t\n\tm_lsUserInfo.SetItemText(nCount, 1, stuInfo.name);\n\n\tCString csTime;\n\tcsTime.Format(\"%04d-%02d-%02d %02d:%02d:%02d\",\n\t\tstuInfo.stuTime.dwYear, stuInfo.stuTime.dwMonth, stuInfo.stuTime.dwDay,\n\t\tstuInfo.stuTime.dwHour, stuInfo.stuTime.dwMinute, stuInfo.stuTime.dwSecond);\n\tm_lsUserInfo.SetItemText(nCount, 2, csTime);\n}\n\nvoid CDlgUserInfo::InsertActiveUserInfo(const CFG_ACTIVEUSER_INFO& stuInfo)\n{\n\tint nCount = m_lsUserInfo.GetItemCount();\n\tm_lsUserInfo.InsertItem(nCount, \"\");\n\t\n\tchar szSeq[8] = {0};\n\t_itoa(nCount, szSeq, 10);\n\tm_lsUserInfo.SetItemText(nCount, 0, szSeq);\n\t\n\tm_lsUserInfo.SetItemText(nCount, 1, stuInfo.szUser);\n\t\n\tm_lsUserInfo.SetItemText(nCount, 2, stuInfo.szClientType);\n\t\n\tm_lsUserInfo.SetItemText(nCount, 3, stuInfo.szClientAddr);\n\t\n\tCString csTime;\n\tcsTime.Format(\"%04d-%02d-%02d %02d:%02d:%02d\",\n\t\tstuInfo.stuLoginTime.dwYear, stuInfo.stuLoginTime.dwMonth, stuInfo.stuLoginTime.dwDay,\n\t\tstuInfo.stuLoginTime.dwHour, stuInfo.stuLoginTime.dwMinute, stuInfo.stuLoginTime.dwSecond);\n\tm_lsUserInfo.SetItemText(nCount, 4, csTime);\n\n\tm_lsUserInfo.SetItemText(nCount, 5, stuInfo.szGroupName);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgUserInfo message handlers\n\nBOOL CDlgUserInfo::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_USERINFO);\n\t\n\t// TODO: Add extra initialization here\n\tInitDlg(m_bGetUserInfo);\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgUserInfo::OnUserinfoGet() \n{\n\t// TODO: Add your control notification handler code here\n\tm_bGetUserInfo = emUserInfoType_All == m_cmbType.GetCurSel() ? TRUE : FALSE;\n\tInitDlg(m_bGetUserInfo);\n\n\tGetInfo(m_bGetUserInfo);\n}\n\n","size_bytes":7092},"bin/DemoSrc/WaterCheck_demo/LanguageConvertor.cpp":{"content":"// LanguageConvertor.cpp: implementation of the CLanguageConvertor class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"LanguageConvertor.h\"\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\n//////////////////////////////////////////////////////////////////////\n// Construction/Destruction\n//////////////////////////////////////////////////////////////////////\nTCHAR CLanguageConvertor::m_szIniFile[MAX_PATH] = {0};\n\n\nint CLanguageConvertor::Init()\n{\n\t_stprintf(m_szIniFile, _T(\"%s%s\"), GetMoudlePath(), \"lang.ini\");\n\treturn 1;\n}\n\nCString CLanguageConvertor::ConvertString(CString strText)\n{\n\tif(strText.GetLength())\n\t{\n\t\tTCHAR val[300];\n\t\tGetPrivateProfileString(_T(\"String\"), strText, strText, val, sizeof(val), m_szIniFile);\n\t\treturn val;\n\t}\n\n\treturn strText;\n}\n\nvoid CLanguageConvertor::SetWndStaticText(CWnd * pWnd)\n{\n\tCString strCaption,strText;\n\n\tpWnd->GetWindowText(strCaption);\n\tif(strCaption.GetLength()>0)\n\t{\n\t\tstrText=ConvertString(strCaption);\n\t\tpWnd->SetWindowText(strText);\n\t}\n\n\tCWnd * pChild=pWnd->GetWindow(GW_CHILD);\n\tCString strClassName;\n\twhile(pChild)\n\t{\n\t\tstrClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n\t\tif(strClassName == \"CEdit\")\n\t\t{\n\t\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t\t\tcontinue;\n\t\t}\n\t\t//////////////////////////////////////////////////////////////////////////\n\t\tpChild->GetWindowText(strCaption);\n\t\tstrText=ConvertString(strCaption);\n\t\tpChild->SetWindowText(strText);\n\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t}\n}\n\nvoid CLanguageConvertor::SetMenuStaticText(CMenu* pMenu)\n{\n\tCString strCaption,strText;\n\t\n\tint MenuItemNum = pMenu->GetMenuItemCount() ;\n\t\n\tfor (int i = 0 ; i < MenuItemNum ; i++)\n\t{\t\t\n\t\tMENUITEMINFO info;\n\t\tmemset(&info, 0 , sizeof(MENUITEMINFO)) ;\n\t\tinfo.cbSize = sizeof (MENUITEMINFO); // must fill up this field\n\t\tinfo.fMask = MIIM_STATE;             // get the state of the menu item\n\t\t\n\t\tpMenu->GetMenuString(i, strCaption, MF_BYPOSITION);\n\t\t\n\t\tstrText=ConvertString(strCaption);\n\t\t\n\t\tUINT ID = pMenu->GetMenuItemID(i) ;\n\t\t\n\t\tif (ID != -1)\n\t\t{\n\t\t\tpMenu->GetMenuItemInfo(ID, &info) ;\n\t\t\tpMenu->ModifyMenu(ID, MF_BYCOMMAND|MF_STRING, ID, strText);\n\t\t\tSetMenuItemInfo(pMenu->m_hMenu, ID, FALSE, &info) ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpMenu->ModifyMenu(i, MF_BYPOSITION| MF_STRING, 0, strText);\n\t\t}\n\t\t\n\t\tCMenu* subMenu = pMenu->GetSubMenu(i) ;\n\t\t\n\t\tif (subMenu != NULL)\n\t\t{\t\t\t\n\t\t\tSetMenuStaticText(subMenu) ;\n\t\t}\n\t}\n}","size_bytes":2491},"bin/Demo/MfcDemo/22.ThermalCamera/AlarmConfigDlg.cpp":{"content":"// AlarmConfigDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"ThermalCamera.h\"\n#include \"AlarmConfigDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CAlarmConfigDlg dialog\n\n\nCAlarmConfigDlg::CAlarmConfigDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CAlarmConfigDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CAlarmConfigDlg)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CAlarmConfigDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CAlarmConfigDlg)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CAlarmConfigDlg, CDialog)\n\t//{{AFX_MSG_MAP(CAlarmConfigDlg)\n\t\t// NOTE: the ClassWizard will add message map macros here\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CAlarmConfigDlg message handlers\n","size_bytes":1045},"bin/Demo/MfcDemo/00.DevInit/StdAfx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n//\tDevInit.pch will be the pre-compiled header\n//\tstdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n\n\n\n","size_bytes":201},"bin/Demo/MfcDemo/22.ThermalCamera/Control.cpp":{"content":"// Control.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"ThermalCamera.h\"\n#include \"Control.h\"\n#include \"ThermalCameraDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CControl dialog\n\n\nCControl::CControl(CWnd* pParent /*=NULL*/, LLONG lLoginId)\n\t: CDialog(CControl::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CControl)\n\tm_Channel = 0;\n\tm_PresetID = 0;\n\tm_PresetName = _T(\"Unknown\");\n\tm_RuleID = 0;\n\t//}}AFX_DATA_INIT\n    m_lLoginId = lLoginId;\n}\n\n\nvoid CControl::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CControl)\n\tDDX_Control(pDX, IDC_COMBO_METERTYPE, m_ComboMeterType);\n\tDDX_Text(pDX, IDC_EDIT_CHANNEL, m_Channel);\n\tDDX_Text(pDX, IDC_EDIT_PRESETID, m_PresetID);\n\tDDX_Text(pDX, IDC_EDIT_PRESETNAME, m_PresetName);\n\tDDX_Text(pDX, IDC_EDIT_RULEID, m_RuleID);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CControl, CDialog)\n\t//{{AFX_MSG_MAP(CControl)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CControl message handlers\n\nvoid CControl::OnOK() \n{\n    UpdateData(TRUE);\n    BOOL ret = FALSE;\n    NET_IN_RADIOMETRY_SETOSDMARK stuOSDIn = {sizeof(stuOSDIn)};\n    stuOSDIn.dwSize = sizeof(stuOSDIn);\n    stuOSDIn.stCondition.nPresetId = m_PresetID;\n    stuOSDIn.stCondition.nRuleId = m_RuleID;\n    stuOSDIn.stCondition.nChannel = 1;\n    int i = m_ComboMeterType.GetCurSel();\n    if (0 == i)\n    {\n        stuOSDIn.stCondition.nMeterType = NET_RADIOMETRY_METERTYPE_SPOT;\n    }\n    else if (1 == i)\n    {\n        stuOSDIn.stCondition.nMeterType = NET_RADIOMETRY_METERTYPE_LINE;\n    }\n    else if (2 == i)\n    {\n        stuOSDIn.stCondition.nMeterType = NET_RADIOMETRY_METERTYPE_AREA;\n    }\n    strncpy(stuOSDIn.stCondition.szName,m_PresetName, sizeof(stuOSDIn.stCondition.szName) - 1);\n    NET_OUT_RADIOMETRY_SETOSDMARK stuOSDOut = {sizeof(stuOSDOut)};\n    ret = CLIENT_ControlDeviceEx(m_lLoginId, DH_CTRL_RADIOMETRY_SETOSDMARK, &stuOSDIn, &stuOSDOut,3000);\n\tCDialog::OnOK();\n}\n\nBOOL CControl::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n    InitDlg();\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CControl::InitDlg()\n{\n    g_SetWndStaticText(this);\n    int nIndex = 0;\n    CString strMeterType[3] = {ConvertString(\"Spot\"),ConvertString(\"Line\"),ConvertString(\"Area\")};\n    m_ComboMeterType.ResetContent();\n    nIndex = m_ComboMeterType.AddString(strMeterType[0]);\n    m_ComboMeterType.SetItemData(nIndex,SPOT);\n    nIndex = m_ComboMeterType.AddString(strMeterType[1]);\n    m_ComboMeterType.SetItemData(nIndex,LINE);\n    nIndex = m_ComboMeterType.AddString(strMeterType[2]);\n    m_ComboMeterType.SetItemData(nIndex,AREA);\n    m_ComboMeterType.SetCurSel(0);\n}\n","size_bytes":2904},"bin/Demo/MfcDemo/17.IntelligentTraffic/IntelligentTraffic.cpp":{"content":"// IntelligentTraffic.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"IntelligentTraffic.h\"\n#include \"IntelligentTrafficDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\n\n// CIntelligentTrafficApp\n\nBEGIN_MESSAGE_MAP(CIntelligentTrafficApp, CWinApp)\n\tON_COMMAND(ID_HELP, &CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n\n// CIntelligentTrafficApp construction\n\nCIntelligentTrafficApp::CIntelligentTrafficApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n\n// The one and only CIntelligentTrafficApp object\n\nCIntelligentTrafficApp theApp;\n\n\n// CIntelligentTrafficApp initialization\n\nBOOL CIntelligentTrafficApp::InitInstance()\n{\n\t// InitCommonControlsEx() is required on Windows XP if an application\n\t// manifest specifies use of ComCtl32.dll version 6 or later to enable\n\t// visual styles.  Otherwise, any window creation will fail.\n\tINITCOMMONCONTROLSEX InitCtrls;\n\tInitCtrls.dwSize = sizeof(InitCtrls);\n\t// Set this to include all the common control classes you want to use\n\t// in your application.\n\tInitCtrls.dwICC = ICC_WIN95_CLASSES;\n\tInitCommonControlsEx(&InitCtrls);\n\n\tCWinApp::InitInstance();\n\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t// of your final executable, you should remove from the following\n\t// the specific initialization routines you do not need\n\t// Change the registry key under which our settings are stored\n\t// TODO: You should modify this string to be something appropriate\n\t// such as the name of your company or organization\n\tSetRegistryKey(_T(\"Local AppWizard-Generated Applications\"));\n\n\tCIntelligentTrafficDlg dlg;\n\tm_pMainWnd = &dlg;\n\tINT_PTR nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n\nTCHAR* g_GetIniPath(void)\n{\n    static char pszIniPath[512] = {0};\n    if( strlen(pszIniPath) == 0 )\n    {\n        char szDirBuf[512] = {0};\n        GetCurrentDirectory(512, szDirBuf);\n        _snprintf_s(pszIniPath, 512, \"%s\\\\langchn.ini\", szDirBuf);\n    }\n    return pszIniPath;\n}\n\nCString ConvertString(CString strText)\n{\n    char val[200] = {0};\n    CString strIniPath,strRet;\n    GetPrivateProfileString(\"String\",strText,\"\", val,200,g_GetIniPath());\n    strRet = val;\n    if(strRet.GetLength()==0)\n    {\n        //If there is no corresponding string in ini file ,then set it to be default value.\n        strRet=strText;\n    }\n    return strRet;\n}\n//Set static text in dialogue box (English->current language)\nvoid g_SetWndStaticText(CWnd * pWnd)\n{\n    CString strCaption,strText;\n\n    //Set main window title\n    pWnd->GetWindowText(strCaption);\n    if(strCaption.GetLength()>0)\n    {\n        strText=ConvertString(strCaption);\n        pWnd->SetWindowText(strText);\n    }\n\n    //Set small window title \n    CWnd * pChild=pWnd->GetWindow(GW_CHILD);\n    CString strClassName;\n    while(pChild)\n    {\n        //////////////////////////////////////////////////////////////////////////\t\t\n        //Added by Jackbin 2005-03-11\n        strClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n        if(strClassName == \"CEdit\")\n        {\n            //Next small window \n            pChild=pChild->GetWindow(GW_HWNDNEXT);\n            continue;\n        }\n\n        //////////////////////////////////////////////////////////////////////////\t\n\n        //Set small window current language text \n        pChild->GetWindowText(strCaption);\n        strText=ConvertString(strCaption);\n        pChild->SetWindowText(strText);\n\n        //Next small window \n        pChild=pChild->GetWindow(GW_HWNDNEXT);\n    }\n}\n\n","size_bytes":3984},"bin/Demo/MfcDemo/19.MasterSlaveSensor/StdAfx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n//\tMasterSlaver_watcher.pch will be the pre-compiled header\n//\tstdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n\n\n\n","size_bytes":214},"bin/Demo/MfcDemo/22.ThermalCamera/Info.cpp":{"content":"// Info.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"ThermalCamera.h\"\n#include \"ThermalCameraDlg.h\"\n#include \"Info.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CInfo dialog\n\n\nCInfo::CInfo(CWnd* pParent /*=NULL*/, LLONG lLoginId,int nChannel)\n\t: CDialog(CInfo::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CInfo)\n\tm_iBrightness = 0;\n\tm_iSharpness = 0;\n\tm_iEZoom = 0;\n\tm_iThermographyGamma = 0;\n\tm_Colorization = _T(\"\");\n\tm_iSmartOptimizer = 0;\n\tm_iAgc = 0;\n\tm_iAgcMaxGain = 0;\n\tm_iAgcPlateau = 0;\n\tm_szSerialNum = _T(\"\");\n\tm_szSoftVersion = _T(\"\");\n\tm_szFirmVersion = _T(\"\");\n\tm_szLibraryVersion = _T(\"\");\n\tm_szOptRegion = _T(\"\");\n\tm_szRoiType = _T(\"\");\n\tm_Amout = 0;\n\tm_left = 0;\n\tm_top = 0;\n\tm_right = 0;\n\tm_bottom = 0;\n\t//}}AFX_DATA_INIT\n    m_lLoginID = lLoginId;\n    m_nChannel = nChannel;\n}\n\n\nvoid CInfo::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CInfo)\n\tDDX_Control(pDX, IDC_COMBO_REGIONNUM, m_ComboRegionNum);\n\tDDX_Text(pDX, IDC_EDIT_BRIGHTNESS, m_iBrightness);\n\tDDX_Text(pDX, IDC_EDIT_SHARPNESS, m_iSharpness);\n\tDDX_Text(pDX, IDC_EDIT_ZOOM, m_iEZoom);\n\tDDX_Text(pDX, IDC_EDIT_GAMMA, m_iThermographyGamma);\n\tDDX_Text(pDX, IDC_EDIT_COLOR, m_Colorization);\n\tDDX_Text(pDX, IDC_EDIT_OPTINDICATOR, m_iSmartOptimizer);\n\tDDX_Text(pDX, IDC_EDIT_GAINCTL, m_iAgc);\n\tDDX_Text(pDX, IDC_EDIT_MAXGAIN, m_iAgcMaxGain);\n\tDDX_Text(pDX, IDC_EDIT_GAINBALANCE, m_iAgcPlateau);\n\tDDX_Text(pDX, IDC_EDIT_SERIALNUM, m_szSerialNum);\n\tDDX_Text(pDX, IDC_SOFTVER, m_szSoftVersion);\n\tDDX_Text(pDX, IDC_EDIT_FIRMVER, m_szFirmVersion);\n\tDDX_Text(pDX, IDC_EDIT_LIBVER, m_szLibraryVersion);\n\tDDX_Text(pDX, IDC_EDIT_OPTREGION, m_szOptRegion);\n\tDDX_Text(pDX, IDC_EDIT_ROITYPE, m_szRoiType);\n\tDDX_Text(pDX, IDC_EDIT_AMOUNT, m_Amout);\n\tDDX_Text(pDX, IDC_EDIT_LEFT, m_left);\n\tDDX_Text(pDX, IDC_EDIT_TOP, m_top);\n\tDDX_Text(pDX, IDC_EDIT_RIGHT, m_right);\n\tDDX_Text(pDX, IDC_EDIT_BOTTOM, m_bottom);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CInfo, CDialog)\n\t//{{AFX_MSG_MAP(CInfo)\n\tON_CBN_SELCHANGE(IDC_COMBO_REGIONNUM, OnSelchangeComboRegionnum)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CInfo message handlers\n\nBOOL CInfo::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n    g_SetWndStaticText(this);\n\tOnGetPresetInfo();\n    OnGetExternalSystemInfo();\n    OnGetROIInfo();\n    UpdateData(FALSE);\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CInfo::OnGetPresetInfo()\n{\n    NET_IN_THERMO_GET_PRESETINFO stuInGetPresetInfo = {sizeof(stuInGetPresetInfo)};\n    stuInGetPresetInfo.dwSize = sizeof(stuInGetPresetInfo);\n    stuInGetPresetInfo.nChannel = m_nChannel;\n    stuInGetPresetInfo.emMode = NET_THERMO_MODE_DEFAULT;\n    NET_OUT_THERMO_GET_PRESETINFO stuOutGetPresetInfo = {sizeof(stuOutGetPresetInfo)}; \n    BOOL ret = CLIENT_QueryDevInfo(m_lLoginID, NET_QUERY_DEV_THERMO_GRAPHY_PRESET, &stuInGetPresetInfo,&stuOutGetPresetInfo,NULL,1000);\n    if (0 != ret)\n    {\n        m_iBrightness = stuOutGetPresetInfo.stInfo.nBrightness;\n        m_iSharpness = stuOutGetPresetInfo.stInfo.nSharpness;\n        m_iEZoom = stuOutGetPresetInfo.stInfo.nEZoom;\n        m_iThermographyGamma = stuOutGetPresetInfo.stInfo.nThermographyGamma;\n        if (stuOutGetPresetInfo.stInfo.nColorization == NET_THERMO_COLORIZATION_UNKNOWN)\n        {\n            m_Colorization = ConvertString(\"Unknown\");\n        }\n        else if (stuOutGetPresetInfo.stInfo.nColorization == NET_THERMO_COLORIZATION_WHITE_HOT)\n        {\n            m_Colorization = ConvertString(\"WhiteHot\");\n        }\n        else if (stuOutGetPresetInfo.stInfo.nColorization == NET_THERMO_COLORIZATION_BLACK_HOT)\n        {\n            m_Colorization = ConvertString(\"BlackHot\");\n        }\n        else if (stuOutGetPresetInfo.stInfo.nColorization == NET_THERMO_COLORIZATION_IRONBOW2)\n        {\n            m_Colorization = ConvertString(\"IronBow\");\n        }\n        else if (stuOutGetPresetInfo.stInfo.nColorization == NET_THERMO_COLORIZATION_ICEFIRE)\n        {\n            m_Colorization = ConvertString(\"Icefire\");\n        }\n        m_iSmartOptimizer = stuOutGetPresetInfo.stInfo.nSmartOptimizer;\n        m_iAgc = stuOutGetPresetInfo.stInfo.nAgc;\n        m_iAgcMaxGain = stuOutGetPresetInfo.stInfo.nAgcMaxGain;\n        m_iAgcPlateau = stuOutGetPresetInfo.stInfo.nAgcPlateau;\n    }\n    else\n    {\n        MessageBox(ConvertString(\"get info error\"), ConvertString(\"Prompt\"));\n    }\n}\nvoid CInfo::OnGetROIInfo()\n{\n    NET_IN_THERMO_GET_OPTREGION stuInGetOptRegion = {sizeof(stuInGetOptRegion)};\n    NET_OUT_THERMO_GET_OPTREGION stuOutGetOptRegion = {sizeof(stuOutGetOptRegion)};\n    stuInGetOptRegion.nChannel = m_nChannel;\n    BOOL ret = CLIENT_QueryDevInfo(m_lLoginID,NET_QUERY_DEV_THERMO_GRAPHY_OPTREGION,&stuInGetOptRegion,&stuOutGetOptRegion,NULL,1000);\n    if (0 != ret)\n    {\n        if (0 == stuOutGetOptRegion.stInfo.bOptimizedRegion)\n        {\n            m_szOptRegion = ConvertString(\"Disable\");\n        }\n        else\n        {\n            m_szOptRegion = ConvertString(\"Enable\");\n        }\n        if (NET_THERMO_ROI_UNKNOWN == stuOutGetOptRegion.stInfo.nOptimizedROIType)\n        {\n            m_szRoiType = ConvertString(\"Unknown\");\n        }\n        else if (NET_THERMO_ROI_FULL_SCREEN == stuOutGetOptRegion.stInfo.nOptimizedROIType)\n        {\n            m_szRoiType = ConvertString(\"Full-screen\");\n        }\n        else if (NET_THERMO_ROI_SKY == stuOutGetOptRegion.stInfo.nOptimizedROIType)\n        {\n            m_szRoiType = ConvertString(\"Top\");\n        }\n        else if (NET_THERMO_ROI_HORIZONTAL == stuOutGetOptRegion.stInfo.nOptimizedROIType)\n        {\n            m_szRoiType = ConvertString(\"Middle\");\n        }\n        else if (NET_THERMO_ROI_GROUND == stuOutGetOptRegion.stInfo.nOptimizedROIType)\n        {\n            m_szRoiType = ConvertString(\"Bottom\");\n        }\n        else if (NET_THERMO_ROI_CENTER_75 == stuOutGetOptRegion.stInfo.nOptimizedROIType)\n        {\n            m_szRoiType = ConvertString(\"Centerpoint 75%\");\n        }\n        else if (NET_THERMO_ROI_CENTER_50 == stuOutGetOptRegion.stInfo.nOptimizedROIType)\n        {\n            m_szRoiType = ConvertString(\"Centerpoint 50%\");\n        }\n        else if (NET_THERMO_ROI_CENTER_25 == stuOutGetOptRegion.stInfo.nOptimizedROIType)\n        {\n            m_szRoiType = ConvertString(\"Centerpoint 25%\");\n        }\n        else if (NET_THERMO_ROI_CUSTOM == stuOutGetOptRegion.stInfo.nOptimizedROIType)\n        {\n            m_szRoiType = ConvertString(\"Customized\");\n            m_Amout = stuOutGetOptRegion.stInfo.nCustomRegion;\n            int index = 0;\n            for (int i=1;i<=m_Amout;i++)\n            {\n                CString str;\n                str.Format(\"%d\",i);\n                index = m_ComboRegionNum.AddString(str);\n                m_ComboRegionNum.SetItemData(index,i);\n            }\n            m_ComboRegionNum.SetCurSel(0);\n            m_left = stuOutGetOptRegion.stInfo.stCustomRegions[0].nLeft;\n            m_right = stuOutGetOptRegion.stInfo.stCustomRegions[0].nRight;\n            m_top = stuOutGetOptRegion.stInfo.stCustomRegions[0].nTop;\n            m_bottom = stuOutGetOptRegion.stInfo.stCustomRegions[0].nBottom;\n        }\n    }\n}\nvoid CInfo::OnGetExternalSystemInfo()\n{\n    NET_IN_THERMO_GET_EXTSYSINFO stuInGetExtsysInfo = {sizeof(stuInGetExtsysInfo)};\n    NET_OUT_THERMO_GET_EXTSYSINFO stuOutGetExtsysInfo = {sizeof(stuOutGetExtsysInfo)};\n    stuInGetExtsysInfo.nChannel = m_nChannel;\n    BOOL ret = CLIENT_QueryDevInfo(m_lLoginID,NET_QUERY_DEV_THERMO_GRAPHY_EXTSYSINFO,&stuInGetExtsysInfo,&stuOutGetExtsysInfo,NULL,1000);\n    if (0 != ret)\n    {\n        m_szSerialNum = stuOutGetExtsysInfo.stInfo.szSerialNumber;\n        m_szFirmVersion = stuOutGetExtsysInfo.stInfo.szFirmwareVersion;\n        m_szSoftVersion = stuOutGetExtsysInfo.stInfo.szSoftwareVersion;\n        m_szLibraryVersion = stuOutGetExtsysInfo.stInfo.szLibVersion;\n    }\n}\n\nvoid CInfo::OnSelchangeComboRegionnum() \n{\n    NET_IN_THERMO_GET_OPTREGION stuInGetOptRegion = {sizeof(stuInGetOptRegion)};\n    NET_OUT_THERMO_GET_OPTREGION stuOutGetOptRegion = {sizeof(stuOutGetOptRegion)};\n    stuInGetOptRegion.nChannel = m_nChannel;\n    BOOL ret = CLIENT_QueryDevInfo(m_lLoginID,NET_QUERY_DEV_THERMO_GRAPHY_OPTREGION,&stuInGetOptRegion,&stuOutGetOptRegion,NULL,1000);\n    if (0 != ret)\n    {\n        int i = m_ComboRegionNum.GetCurSel();\n        m_left = stuOutGetOptRegion.stInfo.stCustomRegions[i].nLeft;\n        m_right = stuOutGetOptRegion.stInfo.stCustomRegions[i].nRight;\n        m_top = stuOutGetOptRegion.stInfo.stCustomRegions[i].nTop;\n        m_bottom = stuOutGetOptRegion.stInfo.stCustomRegions[i].nBottom;\n    }\n}\n\n","size_bytes":8871},"bin/Demo/MfcDemo/23.VehicleGPS/stdafx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n// VehicleGPS.pch will be the pre-compiled header\n// stdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n\n\n","size_bytes":203},"bin/Demo/MfcDemo/09.AccessControl/DlgVersion.cpp":{"content":"// DlgVersion.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AccessControl.h\"\n#include \"DlgVersion.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgVersion dialog\n\n\nCDlgVersion::CDlgVersion(CWnd* pParent /* = NULL */, LLONG hLoginId /* = 0 */)\n\t: CDialog(CDlgVersion::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgVersion)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\tm_hLoginId = hLoginId;\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CDlgVersion::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgVersion)\n\tDDX_Control(pDX, IDC_VERSION_STATIC_INFO, m_staVersion);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgVersion, CDialog)\n\t//{{AFX_MSG_MAP(CDlgVersion)\n\tON_BN_CLICKED(IDC_VERSION_BTN_UPDATE, OnVersionUpdate)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgVersion message handlers\n\nBOOL CDlgVersion::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_VERSION);\n\t\n\t// TODO: Add extra initialization here\n\tOnVersionUpdate();\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgVersion::OnVersionUpdate() \n{\n\t// TODO: Add your control notification handler code here\n\tif (!m_hLoginId)\n\t{\n\t\tMessageBox(ConvertString(CString(\"we haven't login a device yet!\"), DLG_VERSION), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tint nRet = 0;\n\tDHDEV_VERSION_INFO stuInfo = {0};\n\tBOOL bRet = CLIENT_QueryDevState(m_hLoginId, DH_DEVSTATE_SOFTWARE, (char*)&stuInfo, sizeof(stuInfo), &nRet, SDK_API_WAIT);\n\tif (bRet)\n\t{\n\t\tCString csVer;\n\t\tcsVer.Format(\"%s: %s\\r\\n\\\n%s: %s\\r\\n\\\n%s: %04d-%02d-%02d\\r\\n\",\nConvertString(\"Serial\", DLG_VERSION),\n\t\t\tstuInfo.szDevSerialNo,\n\t\t\tConvertString(\"SoftwareVersion\", DLG_VERSION),\n\t\t\tstuInfo.szSoftWareVersion,\n\t\t\tConvertString(\"ReleaseTime\", DLG_VERSION),\n\t\t\t((stuInfo.dwSoftwareBuildDate>>16) & 0xffff),\n\t\t\t((stuInfo.dwSoftwareBuildDate>>8) & 0xff),\n\t\t\t(stuInfo.dwSoftwareBuildDate & 0xff));\n\t\tm_staVersion.SetWindowText(csVer);\n\t} \n\telse\n\t{\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x...\", ConvertString(\"get Version failed with code :\", DLG_VERSION), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t}\n}\n","size_bytes":2422},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/ExSliderCtrl.cpp":{"content":"// ExSliderCtrl.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"ExSliderCtrl.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CExSliderCtrl\n\nCExSliderCtrl::CExSliderCtrl()\n{\n\tm_bLButtonDown = FALSE;\n}\n\nCExSliderCtrl::~CExSliderCtrl()\n{\n}\n\n\nBEGIN_MESSAGE_MAP(CExSliderCtrl, CSliderCtrl)\n\t//{{AFX_MSG_MAP(CExSliderCtrl)\n\tON_WM_LBUTTONDOWN()\n\tON_WM_LBUTTONUP()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CExSliderCtrl message handlers\n\nvoid CExSliderCtrl::OnLButtonDown(UINT nFlags, CPoint point) \n{\n\t// TODO: Add your message handler code here and/or call default\n\tm_bLButtonDown = TRUE;\n\t\n\tCSliderCtrl::OnLButtonDown(nFlags, point);\n}\n\nvoid CExSliderCtrl::OnLButtonUp(UINT nFlags, CPoint point) \n{\n\t// TODO: Add your message handler code here and/or call default\n\tm_bLButtonDown = FALSE;\n\n\tCSliderCtrl::OnLButtonUp(nFlags, point);\n}\n","size_bytes":1075},"bin/DemoSrc/DecCB_demo/DlgDisplay.cpp":{"content":"// DlgDisplay.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"DecCB_demo.h\"\n#include \"DlgDisplay.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgDisplay dialog\n\n\nCDlgDisplay::CDlgDisplay(CWnd* pParent /*=NULL*/)\n\t: CDialog(CDlgDisplay::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgDisplay)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CDlgDisplay::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgDisplay)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgDisplay, CDialog)\n\t//{{AFX_MSG_MAP(CDlgDisplay)\n\t\t// NOTE: the ClassWizard will add message map macros here\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgDisplay message handlers\n","size_bytes":994},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgAlarmSubSystem.cpp":{"content":"// DlgCfgAlarmSubSystem.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgCfgAlarmSubSystem.h\"\n#include \"SubDlgCfgTimeSection.h\"\n#include \"SubDlgSensorInfoDescription.h\"\n#include <VECTOR>\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgAlarmSubSystem dialog\n\n\nCDlgCfgAlarmSubSystem::CDlgCfgAlarmSubSystem(CWnd* pParent /* = NULL */, LLONG lLoginID /* = 0 */)\n\t: CDialog(CDlgCfgAlarmSubSystem::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgAlarmSubSystem)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_lLoginID = lLoginID;\n\tmemset(&m_stuInfo, 0, sizeof(m_stuInfo));\n}\n\n\nvoid CDlgCfgAlarmSubSystem::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgAlarmSubSystem)\n\tDDX_Control(pDX, IDC_ALARMSUBSYSTEMCFG_CHK_ISPUBLIC, m_chkIsPublic);\n\tDDX_Control(pDX, IDC_ALARMSUBSYSTEMCFG_CMB_SEQ, m_cmbSeq);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgAlarmSubSystem, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgAlarmSubSystem)\n\tON_BN_CLICKED(IDC_ALARMSUBSYSTEMCFG_BTN_GET, OnAlarmsubsystemBtnGet)\n\tON_BN_CLICKED(IDC_ALARMSUBSYSTEMCFG_BTN_SET, OnAlarmsubsystemBtnSet)\n\tON_BN_CLICKED(IDC_ALARMSUBSYSTEMCFG_BTN_ZONE, OnAlarmsubsystemBtnZone)\n\tON_BN_CLICKED(IDC_ALARMSUBSYSTEMCFG_BTN_EXZONE, OnAlarmsubsystemBtnExZone)\n\tON_BN_CLICKED(IDC_ALARMSUBSYSTEMCFG_BTN_PUBSUBSYSTEM, OnAlarmsubsystemBtnPubsubsystem)\n\tON_CBN_SELCHANGE(IDC_ALARMSUBSYSTEMCFG_CMB_SEQ, OnSelchangeAlarmsubsystemCmbSeq)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgAlarmSubSystem private method\n\nvoid CDlgCfgAlarmSubSystem::InitDlg()\n{\n\t// seq\n\tm_cmbSeq.ResetContent();\n\tconst int nSeq = 8;\n\tfor (int i = 0; i < nSeq; i++)\n\t{\n\t\tCString csSeq;\n\t\tcsSeq.Format(\"%d\", i + 1);\n\t\tm_cmbSeq.InsertString(-1, csSeq);\n\t}\n\tm_cmbSeq.SetCurSel(0);\n\n\t// name\n\tSetDlgItemText(IDC_ALARMSUBSYSTEMCFG_EDT_NAME, NULL);\n\n\t// zone\n\n\t// ex-zone\n\n\t// time section\n\n\t// disable delay\n\tSetDlgItemInt(IDC_ALARMSUBSYSTEMCFG_EDT_DISDELAY, 0);\n\n\t// enable delay\n\tSetDlgItemInt(IDC_ALARMSUBSYSTEMCFG_EDT_ENDELAY, 0);\n\n\t// is public\n\tm_chkIsPublic.SetCheck(BST_UNCHECKED);\n\n\t// public alarm subsystem\n}\n\nvoid CDlgCfgAlarmSubSystem::StuToDlg()\n{\n\t// name\n\tSetDlgItemText(IDC_ALARMSUBSYSTEMCFG_EDT_NAME, m_stuInfo.szName);\n\t\n\t// zone\n\t\n\t// ex-zone\n\t\n\t// time section\n\t\n\t// disable delay\n\tSetDlgItemInt(IDC_ALARMSUBSYSTEMCFG_EDT_DISDELAY, m_stuInfo.nDisableDelay);\n\t\n\t// enable delay\n\tSetDlgItemInt(IDC_ALARMSUBSYSTEMCFG_EDT_ENDELAY, m_stuInfo.nEnableDelay);\n\t\n\t// is public\n\tif (m_stuInfo.bIsPublic)\n\t{\n\t\tm_chkIsPublic.SetCheck(BST_CHECKED);\n\t}\n\telse\n\t{\n\t\tm_chkIsPublic.SetCheck(BST_UNCHECKED);\n\t}\n\n\t// public alarm subsystem\n}\n\nvoid CDlgCfgAlarmSubSystem::DlgToStu()\n{\n\t// name\n\tGetDlgItemText(IDC_ALARMSUBSYSTEMCFG_EDT_NAME, m_stuInfo.szName, sizeof(m_stuInfo.szName) - 1);\n\t\n\t// zone\n\t\n\t// ex-zone\n\t\n\t// time section\n\t\n\t// disable delay\n\tm_stuInfo.nDisableDelay = GetDlgItemInt(IDC_ALARMSUBSYSTEMCFG_EDT_DISDELAY, NULL, TRUE);\n\t\n\t// enable delay\n\tm_stuInfo.nEnableDelay = GetDlgItemInt(IDC_ALARMSUBSYSTEMCFG_EDT_ENDELAY, NULL, TRUE);\n\t\n\t// is public\n\tm_stuInfo.bIsPublic = m_chkIsPublic.GetCheck() ? TRUE : FALSE;\n\t\n\t// public alarm subsystem\n}\n\nBOOL CDlgCfgAlarmSubSystem::GetConfig()\n{\n\tint nChn = m_cmbSeq.GetCurSel();\n\tif (-1 == nChn)\n\t{\n\t\treturn FALSE;\n\t}\n\tchar szBuf[1024*10] = {0};\n\tint nErr = 0;\n\tBOOL bRet = CLIENT_GetNewDevConfig(m_lLoginID, CFG_CMD_ALARM_SUBSYSTEM, nChn, szBuf, sizeof(szBuf), &nErr, SDK_API_WAIT);\n\tif (!bRet)\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%s:%08x\", ConvertString(\"Get config of AlarmSubSystem error\", DLG_CFG_ALARM_SUBSYSTEM), CLIENT_GetLastError());\n\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\t\n\tint nRetLen = 0;\n\tbRet = CLIENT_ParseData(CFG_CMD_ALARM_SUBSYSTEM, szBuf, &m_stuInfo, sizeof(m_stuInfo), &nRetLen);\n\tif (!bRet || nRetLen != sizeof(m_stuInfo))\n\t{\n\t\tMessageBox(ConvertString(\"Parse config of AlarmSubSystem error\", DLG_CFG_ALARM_SUBSYSTEM), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nBOOL CDlgCfgAlarmSubSystem::SetConfig()\n{\n\tint nChn = m_cmbSeq.GetCurSel();\n\tif (-1 == nChn)\n\t{\n\t\treturn FALSE;\n\t}\n\tchar szBuf[1024*10] = {0};\n\tint nErr = 0;\n\tint nRestart = 0;\n\tBOOL bRet = CLIENT_PacketData(CFG_CMD_ALARM_SUBSYSTEM, &m_stuInfo, sizeof(m_stuInfo), szBuf, sizeof(szBuf));\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Packet config of AlarmSubSystem error\", DLG_CFG_ALARM_SUBSYSTEM), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\tbRet = CLIENT_SetNewDevConfig(m_lLoginID, CFG_CMD_ALARM_SUBSYSTEM, nChn, szBuf, strlen(szBuf), &nErr, &nRestart, SDK_API_WAIT);\n\tif (!bRet)\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%s:%08x\", ConvertString(\"Set config of AlarmSubSystem error\", DLG_CFG_ALARM_SUBSYSTEM), CLIENT_GetLastError());\n\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\telse\n\t{\n\t\tMessageBox(ConvertString(\"Set config of AlarmSubSystem ok\", DLG_CFG_ALARM_SUBSYSTEM), ConvertString(\"Prompt\"));\n\t}\n\treturn TRUE;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgAlarmSubSystem message handlers\n\nBOOL CDlgCfgAlarmSubSystem::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_ALARM_SUBSYSTEM);\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\tif (GetConfig())\n\t{\n\t\tStuToDlg();\n\t}\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgAlarmSubSystem::OnAlarmsubsystemBtnGet() \n{\n\t// TODO: Add your control notification handler code here\n\tif (GetConfig())\n\t{\n\t\tStuToDlg();\n\t}\t\n}\n\nvoid CDlgCfgAlarmSubSystem::OnAlarmsubsystemBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\tSetConfig();\n}\n\nvoid CDlgCfgAlarmSubSystem::OnAlarmsubsystemBtnZone() \n{\n\t// TODO: Add your control notification handler code here\n\tstd::vector<int> vecChn;\n\tint i = 0;\n\tfor (; i < m_stuInfo.nZoneNum; i++)\n\t{\n\t\tvecChn.push_back(m_stuInfo.anZone[i]);\n\t}\n\t\n\tCSubDlgSensorInfoDescription dlg(this, 256);\n\tdlg.SetID(vecChn);\n\tif (IDOK == dlg.DoModal())\n\t{\n\t\tvecChn.clear();\n\t\tvecChn = dlg.GetID();\n\t\tstd::vector<int>::iterator it = vecChn.begin();\n\t\tfor (i = 0; i < __min(vecChn.size(), DH_MAX_ZONE_NUM) && it != vecChn.end(); i++, it++)\n\t\t{\n\t\t\tm_stuInfo.anZone[i] = *it;\n\t\t}\n\t\tm_stuInfo.nZoneNum = __min(vecChn.size(), DH_MAX_ZONE_NUM);\n\t}\t\n}\n\nvoid CDlgCfgAlarmSubSystem::OnAlarmsubsystemBtnExZone() \n{\n\t// TODO: Add your control notification handler code here\n\tstd::vector<int> vecChn;\n\tint i = 0;\n\tfor (; i < m_stuInfo.nExZoneNum; i++)\n\t{\n\t\tvecChn.push_back(m_stuInfo.anExZone[i]);\n\t}\n\t\n\tCSubDlgSensorInfoDescription dlg(this, 32);\n\tdlg.SetID(vecChn);\n\tif (IDOK == dlg.DoModal())\n\t{\n\t\tvecChn.clear();\n\t\tvecChn = dlg.GetID();\n\t\tstd::vector<int>::iterator it = vecChn.begin();\n\t\tfor (i = 0; i < __min(vecChn.size(), DH_MAX_ZONE_NUM) && it != vecChn.end(); i++, it++)\n\t\t{\n\t\t\tm_stuInfo.anExZone[i] = *it;\n\t\t}\n\t\tm_stuInfo.nExZoneNum = __min(vecChn.size(), DH_MAX_ZONE_NUM);\n\t}\t\t\n}\n\nvoid CDlgCfgAlarmSubSystem::OnAlarmsubsystemBtnPubsubsystem() \n{\n\t// TODO: Add your control notification handler code here\n\tstd::vector<int> vecChn;\n\tint i = 0;\n\tfor (; i < m_stuInfo.nPublicSubSystem; i++)\n\t{\n\t\tvecChn.push_back(m_stuInfo.anPublicSubSystem[i]);\n\t}\n\t\n\tCSubDlgSensorInfoDescription dlg(this, DH_MAX_PUBLIC_SUBSYSTEM_NUM);\n\tdlg.SetID(vecChn);\n\tif (IDOK == dlg.DoModal())\n\t{\n\t\tvecChn.clear();\n\t\tvecChn = dlg.GetID();\n\t\tstd::vector<int>::iterator it = vecChn.begin();\n\t\tfor (i = 0; i < __min(vecChn.size(), DH_MAX_PUBLIC_SUBSYSTEM_NUM) && it != vecChn.end(); i++, it++)\n\t\t{\n\t\t\tm_stuInfo.anPublicSubSystem[i] = *it;\n\t\t}\n\t\tm_stuInfo.nPublicSubSystem = __min(vecChn.size(), DH_MAX_PUBLIC_SUBSYSTEM_NUM);\n\t}\t\t\t\n}\n\nvoid CDlgCfgAlarmSubSystem::OnSelchangeAlarmsubsystemCmbSeq() \n{\n\t// TODO: Add your control notification handler code here\n\tint nSel = m_cmbSeq.GetCurSel();\n\tif (-1 == nSel)\n\t{\n\t\treturn;\n\t}\n\tif (GetConfig())\n\t{\n\t\tStuToDlg();\n\t}\n}\n","size_bytes":8148},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/PlayWnd.cpp":{"content":"// PlayWnd.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"PlayWnd.h\"\n#include \"netsdkdemodlg.h\"\n#include \"ScreenPannel.h\"\n#include \"NetSDKDemo.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CPlayWnd dialog\n\n\nCPlayWnd::CPlayWnd()\n\t:m_nWndID(0)\n{\n\tInitializeCriticalSection(&m_cs);\n\tmemset(&m_splitInfo, 0, sizeof(m_splitInfo));\n\tm_nPreSplit = 0;\n\tm_bFullScreen = FALSE;\n\t\n\t//{{AFX_DATA_INIT(CPlayWnd)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\nBEGIN_MESSAGE_MAP(CPlayWnd, CWnd)\n\t//{{AFX_MSG_MAP(CPlayWnd)\n\tON_WM_ERASEBKGND()\n\tON_WM_CREATE()\n\tON_WM_CONTEXTMENU()\n\t//}}AFX_MSG_MAP\n\tON_COMMAND_RANGE(VIDEO_MENU_BASE, VIDEO_MENU_END, OnVideoMenu)\n\tON_MESSAGE(VIDEO_REPAINT, OnRepaintWnd)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CPlayWnd message handlers\nBOOL CPlayWnd::OnEraseBkgnd(CDC* pDC) \n{\n\t// TODO: Add your message handler code here and/or call default\n\tCRect rt;\n\tGetClientRect(&rt);\n\tCBrush br;\n\tbr.CreateSolidBrush(VIDEO_BACK_COLOR);\n\tpDC->FillRect(&rt,&br);\n\n\treturn TRUE;\n}\n\n\n\nLRESULT CPlayWnd::DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam) \n{\n\t// TODO: Add your specialized code here and/or call the base class\n\tCScreenPannel *pContainer = (CScreenPannel *)GetParent();\n\tif(pContainer)\n\t{\n\t\tswitch(message)\n\t\t{\n\t\tcase WM_LBUTTONDOWN:\n\t\tcase WM_RBUTTONDOWN:\n\t\t\tpContainer->SetActivePage(this);\n\t\t\t{\n\t\t\t\tCNetSDKDemoDlg * pMainWnd = (CNetSDKDemoDlg *)(AfxGetMainWnd());\n\t\t\t\tif (pMainWnd)\n\t\t\t\t{\n\t\t\t\t\tpMainWnd->SetCurWindId(m_nWndID);\n\t\t\t\t\tpMainWnd->UpdateCurScreenInfo();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WM_LBUTTONDBLCLK:\n\t\t\t{\n\t\t\t\tCNetSDKDemoDlg * pMainWnd = (CNetSDKDemoDlg *)(AfxGetMainWnd());\n\t\t\t\tBOOL bMulti = pContainer->GetMultiScreen();\n\t\t\t\tpContainer->SetMultiScreen(!bMulti);\n\n\t\t\t\tif (TRUE == bMulti)\n\t\t\t\t{\n\t\t\t\t\tm_nPreSplit = pMainWnd->GetSplit();\n\t\t\t\t\tpMainWnd->SetSplit(SPLIT1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpMainWnd->SetSplit(m_nPreSplit);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn CWnd::DefWindowProc(message, wParam, lParam);\n}\n\nvoid CPlayWnd::OnContextMenu(CWnd* pWnd, CPoint point) \n{\n\t// TODO: Add your message handler code here\n\tCScreenPannel *pContainer = (CScreenPannel *)GetParent();\n\tpContainer->SetActivePage(this);\n\n\tCMenu menu;\n\tmenu.CreatePopupMenu();\n\tmenu.AppendMenu(MF_STRING | pContainer->GetFullScreen()    ? MF_CHECKED : MF_UNCHECKED, VIDEO_MENU_FULLSCREEN, ConvertString(NAME_MENU_FULLSCREEN));\n\tmenu.AppendMenu(MF_STRING | pContainer->GetMultiScreen()    ? MF_CHECKED : MF_UNCHECKED, \tVIDEO_MENU_MULTISCREEN, ConvertString(NAME_MENU_MULTISCREEN));\n\tmenu.AppendMenu(MF_STRING | pContainer->GetAutoAdjustPos() ? MF_CHECKED : MF_UNCHECKED, VIDEO_MENU_AUTOADJUST, ConvertString(NAME_MENU_AUTOADJUST));\n\n\tTrackPopupMenu( \n\t\tmenu.m_hMenu, \n\t\tTPM_LEFTALIGN, \n\t\tpoint.x, \n\t\tpoint.y,\n\t\t0,\n\t\tm_hWnd,\n\t\tNULL);\n}\n\nvoid CPlayWnd::OnVideoMenu(UINT nID)\n{\n\tCScreenPannel *pContainer = (CScreenPannel *)GetParent();\n\tswitch(nID)\n\t{\n\tcase VIDEO_MENU_FULLSCREEN:\n\t\tpContainer->SetFullScreen(!pContainer->GetFullScreen());\n\t\tbreak;\n\tcase VIDEO_MENU_MULTISCREEN:\n\t\t{\n\t\t\tCNetSDKDemoDlg * pMainWnd = (CNetSDKDemoDlg *)(AfxGetMainWnd());\n\t\t\tBOOL bMulti = pContainer->GetMultiScreen();\n\t\t\t//\tint nCnt = pContainer->GetCount();\n\t\t\tpContainer->SetMultiScreen(!bMulti);\n\t\t\t\n\t\t\tif (TRUE == bMulti)\n\t\t\t{\n\t\t\t\tm_nPreSplit = pMainWnd->GetSplit();\n\t\t\t\tpMainWnd->SetSplit(SPLIT1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpMainWnd->SetSplit(m_nPreSplit);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t\n\tcase VIDEO_MENU_AUTOADJUST:\n\t\tpContainer->SetAutoAdjustPos(!pContainer->GetAutoAdjustPos());\n\t\tbreak;\n\tcase VIDEO_MENU_PRINTSCREEN:\n\t\tbreak;\n\tcase VIDEO_MENU_RECORDVIDEO:\n\t\tbreak;\n\tcase VIDEO_MENU_EXITDECODE:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nBOOL CPlayWnd::GetSplitInfo(SplitInfoNode* info)\n{\n\tif (!info)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tEnterCriticalSection(&m_cs);\n\tmemcpy(info, &m_splitInfo, sizeof(SplitInfoNode));\n\tLeaveCriticalSection(&m_cs);\n\n\treturn TRUE;\n}\n\nBOOL CPlayWnd::SetSplitInfo(SplitInfoNode* info)\n{\n\tif (!info)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tEnterCriticalSection(&m_cs);\n\tmemcpy(&m_splitInfo, info, sizeof(SplitInfoNode));\n\tLeaveCriticalSection(&m_cs);\n\n\treturn TRUE;\n}\n\nvoid CPlayWnd::SetSplitType(SplitType type)\n{\n\tEnterCriticalSection(&m_cs);\n\tm_splitInfo.Type = type;\n\tLeaveCriticalSection(&m_cs);\n}\n\nvoid CPlayWnd::SetSplitHandle(LLONG dwHandle)\n{\n\tEnterCriticalSection(&m_cs);\n\tm_splitInfo.iHandle = dwHandle;\n\tLeaveCriticalSection(&m_cs);\n}\n\nvoid CPlayWnd::SetSplitParam(void *Param)\n{\n\tEnterCriticalSection(&m_cs);\n\tm_splitInfo.Param = Param;\n\tLeaveCriticalSection(&m_cs);\n}\n\nvoid CPlayWnd::SetSplitCBFlag_Real(int nFlag)\n{\n\tEnterCriticalSection(&m_cs);\n\tm_splitInfo.isSaveData = nFlag;\n\tLeaveCriticalSection(&m_cs);\n}\n\nvoid CPlayWnd::SetSplitCBFile_Raw(FILE *file)\n{\n\tEnterCriticalSection(&m_cs);\n\tm_splitInfo.SavecbFileRaw = file;\n\tLeaveCriticalSection(&m_cs);\n}\n\nvoid CPlayWnd::SetSplitCBFile_Std(FILE *file)\n{\n\tEnterCriticalSection(&m_cs);\n\tm_splitInfo.SavecbFileStd = file;\n\tLeaveCriticalSection(&m_cs);\n}\n\nvoid CPlayWnd::SetSplitCBFile_Pcm(FILE *file)\n{\n\tEnterCriticalSection(&m_cs);\n\tm_splitInfo.SavecbFilePcm = file;\n\tLeaveCriticalSection(&m_cs);\n}\n\nvoid CPlayWnd::SetSplitCBFile_Yuv(FILE *file)\n{\n\tEnterCriticalSection(&m_cs);\n\tm_splitInfo.SavecbFileYUV = file;\n\tLeaveCriticalSection(&m_cs);\n}\n\nLRESULT CPlayWnd::OnRepaintWnd(WPARAM wParam, LPARAM lParam)\n{\n\tInvalidate();\n\t\n\treturn 0;\n}\n\nBOOL CPlayWnd::DestroyWindow() \n{\n\tDeleteCriticalSection(&m_cs);\n\treturn CWnd::DestroyWindow();\n}\n","size_bytes":5683},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgPhoneNotify.cpp":{"content":"// DlgCfgPhoneNotify.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgCfgPhoneNotify.h\"\n#include <list>\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgPhoneNotify dialog\n\n\nCDlgCfgPhoneNotify::CDlgCfgPhoneNotify(CWnd* pParent /* = NULL */, LLONG lLoginId /* = 0 */)\n\t: CDialog(CDlgCfgPhoneNotify::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgPhoneNotify)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\tm_lLoginId = lLoginId;\n\t//}}AFX_DATA_INIT\n\tmemset(&m_stuInfo, 0, sizeof(m_stuInfo));\n}\n\n\nvoid CDlgCfgPhoneNotify::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgPhoneNotify)\n\tDDX_Control(pDX, IDC_PHONENOTIFY_LIST_RECEIVENUMBER, m_lsNumberList);\n\tDDX_Control(pDX, IDC_PHONENOTIFY_CHK_ENABLE, m_chkEnable);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgPhoneNotify, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgPhoneNotify)\n\tON_BN_CLICKED(IDC_PHONENOTIFY_BTN_ADDNUMBER, OnPhonenotifyBtnAddnumber)\n\tON_BN_CLICKED(IDC_PHONENOTIFY_BTN_DELNUMBER, OnPhonenotifyBtnDelnumber)\n\tON_BN_CLICKED(IDC_PHONENOTIFY_BTN_GET, OnPhonenotifyBtnGet)\n\tON_BN_CLICKED(IDC_PHONENOTIFY_BTN_SET, OnPhonenotifyBtnSet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// Private methods\n\nvoid CDlgCfgPhoneNotify::InitDlg(BOOL bShow /* = TRUE */)\n{\n\tm_chkEnable.SetCheck(BST_UNCHECKED);\n\n\tm_lsNumberList.SetExtendedStyle(m_lsNumberList.GetExtendedStyle()\n\t\t| LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);\n\tm_lsNumberList.DeleteAllItems();\n\tm_lsNumberList.InsertColumn(0, ConvertString(\"Seq\", DLG_CFG_PHONENOTIFY), LVCFMT_LEFT, 60);\n\tm_lsNumberList.InsertColumn(1, ConvertString(\"Number\", DLG_CFG_PHONENOTIFY), LVCFMT_LEFT, 160);\n}\n\nBOOL CDlgCfgPhoneNotify::SetConfigToDevice()\n{\n\tchar szJsonBuf[1024 * 10] = {0};\n\tBOOL bRet = CLIENT_PacketData(CFG_CMD_PHONEEVENTNOTIFY, &m_stuInfo, sizeof(m_stuInfo), szJsonBuf, sizeof(szJsonBuf));\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(CString(\"packet PhoneEventNotify error...\"), DLG_CFG_PHONENOTIFY), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t} \n\telse\n\t{\n#if 0\n\t\tWriteLog(szJsonBuf);\n#endif\t\n\t\tint nErr = 0, nRestart = 0;\n\t\tBOOL bRetSetupCfg = CLIENT_SetNewDevConfig(m_lLoginId, CFG_CMD_PHONEEVENTNOTIFY,\n\t\t\t-1, szJsonBuf, strlen(szJsonBuf), &nErr, &nRestart, SDK_API_WAIT);\n\t\tif (!bRetSetupCfg)\n\t\t{\n\t\t\tCString csErr;\n\t\t\tcsErr.Format(\"%s %08x\", ConvertString(\"SetupConfig PhoneEventNotify failed:\", DLG_CFG_PHONENOTIFY), CLIENT_GetLastError());\n\t\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"SetConfig PhoenEventNotify ok!\"), DLG_CFG_PHONENOTIFY), ConvertString(\"Prompt\"));\n\t\t}\n\t}\n\treturn TRUE;\n}\n\nBOOL CDlgCfgPhoneNotify::GetConfigFromDevice()\n{\n\tchar szJsonBuf[1024 * 10] = {0};\n\tint nErr = 0, nRestart = 0;\n\tBOOL bRet = CLIENT_GetNewDevConfig(m_lLoginId, CFG_CMD_PHONEEVENTNOTIFY,\n\t\t-1, szJsonBuf, sizeof(szJsonBuf), &nErr, SDK_API_WAIT);\n\tif (bRet)\n\t{\n\t\tCFG_PHONEEVENTNOTIFY_INFO stuInfo = {0};\n\t\tDWORD dwRetLen = 0;\n\t\tbRet = CLIENT_ParseData(CFG_CMD_PHONEEVENTNOTIFY, szJsonBuf, (void*)&stuInfo, sizeof(stuInfo), &dwRetLen);\n\t\tif (!bRet)\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"parse PhoneEventNotify error...\"), DLG_CFG_PHONENOTIFY), ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(&m_stuInfo, &stuInfo, sizeof(CFG_PHONEEVENTNOTIFY_INFO));\n\t\t}\n\t}\n\telse\n\t{\t\t\t\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\",ConvertString(\"GetDevConfig PhoneEventNotify error:\", DLG_CFG_PHONENOTIFY), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nvoid CDlgCfgPhoneNotify::StuToDlg()\n{\n\t// enable\n\tm_chkEnable.SetCheck(m_stuInfo.bEnable ? BST_CHECKED : BST_UNCHECKED);\n\n\t// number list\n\tm_lsNumberList.DeleteAllItems();\n\tint nCount = __min(m_stuInfo.dwContactCount, MAX_CONTACT_NUM);\n\tfor (int i = 0; i < nCount; i++)\n\t{\n\t\tm_lsNumberList.InsertItem(i, \"\");\n\n\t\tchar szSeq[8] = {0};\n\t\t_itoa(i, szSeq, 10);\n\t\tm_lsNumberList.SetItemText(i, 0, szSeq);\n\t\tm_lsNumberList.SetItemText(i, 1, m_stuInfo.szContactNumbersList[i]);\n\t}\n}\n\nvoid CDlgCfgPhoneNotify::DlgToStu()\n{\n\t// enable\n\tm_stuInfo.bEnable = m_chkEnable.GetCheck() ? TRUE : FALSE;\n\t\n\t// number list\n\tint nCount = m_lsNumberList.GetItemCount();\n\tm_stuInfo.dwContactCount = nCount;\n\tmemset(m_stuInfo.szContactNumbersList, 0, sizeof(m_stuInfo.szContactNumbersList));\n\tfor (int i = 0; i < nCount; i++)\n\t{\n\t\tCString strNumber = m_lsNumberList.GetItemText(i, 1);\n\t\tstrncpy(m_stuInfo.szContactNumbersList[i], strNumber,\n\t\t\t    _countof(m_stuInfo.szContactNumbersList[i])-1);\n\t}\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgPhoneNotify message handlers\n\nBOOL CDlgCfgPhoneNotify::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_PHONENOTIFY);\n\t\n\t// TODO: Add extra initialization here\t\n\tif (0 == m_lLoginId)\n\t{\n\t\tMessageBox(ConvertString(\"We haven't login yet!\", DLG_CFG_PHONENOTIFY), ConvertString(\"Prompt\"));\n\t\t//EndDialog(0);\n\t}\n\t\n\tInitDlg();\n\tOnPhonenotifyBtnGet();\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgPhoneNotify::OnPhonenotifyBtnAddnumber() \n{\n\t// TODO: Add your control notification handler code here\t\n\tCString csNumber;\n\tGetDlgItemText(IDC_PHONENOTIFY_EDT_NUMBER, csNumber);\n\tif (!csNumber.GetLength())\n\t{\n\t\treturn;\n\t}\n\t\n\tint nCount = m_lsNumberList.GetItemCount();\n\tm_lsNumberList.InsertItem(nCount, _T(\"\"));\n\t\n\tchar szSeq[10] = {0};\n\t_itoa(nCount + 1, szSeq, 10);\n\tm_lsNumberList.SetItemText(nCount, 0, szSeq);\n\tm_lsNumberList.SetItemText(nCount, 1, csNumber);\t\n}\n\nvoid CDlgCfgPhoneNotify::OnPhonenotifyBtnDelnumber() \n{\n\t// TODO: Add your control notification handler code here\n\tPOSITION pItem = m_lsNumberList.GetFirstSelectedItemPosition();\n\tif (pItem)\n\t{\n\t\tint nSel = m_lsNumberList.GetNextSelectedItem(pItem);\n\t\tCString csSelNum = m_lsNumberList.GetItemText(nSel, 1);\n\t\t\n\t\t{\n\t\t\ttypedef std::list<CString> lsItem;\n\t\t\tlsItem lsNumberItem;\n\t\t\tint nCount = m_lsNumberList.GetItemCount();\n\t\t\tfor (int i = 0; i < nCount; i++)\n\t\t\t{\n\t\t\t\tCString csItem = m_lsNumberList.GetItemText(i, 1);\n\t\t\t\tlsNumberItem.push_back(csItem);\n\t\t\t}\n\t\t\t\n\t\t\tlsItem::iterator it = lsNumberItem.begin();\n\t\t\twhile (it != lsNumberItem.end())\n\t\t\t{\n\t\t\t\tCString csNum = *it;\n\t\t\t\tif (csNum == csSelNum)\n\t\t\t\t{\n\t\t\t\t\tlsNumberItem.erase(it++);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tit++;\n\t\t\t}\n\t\t\t\n\t\t\tm_lsNumberList.DeleteAllItems();\n\t\t\tit = lsNumberItem.begin();\n\t\t\t\n\t\t\tfor (int j = 0; j < lsNumberItem.size(); j++)\n\t\t\t{\n\t\t\t\tCString csItem = *it++;\n\t\t\t\t\n\t\t\t\tm_lsNumberList.InsertItem(j, \"\");\n\t\t\t\t\n\t\t\t\tchar szSeq[8] = {0};\n\t\t\t\t_itoa(j + 1, szSeq, 10);\n\t\t\t\tm_lsNumberList.SetItemText(j, 0, szSeq);\n\t\t\t\tm_lsNumberList.SetItemText(j, 1, csItem);\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\nvoid CDlgCfgPhoneNotify::OnPhonenotifyBtnGet() \n{\n\t// TODO: Add your control notification handler code here\n\tif (GetConfigFromDevice())\n\t{\n\t\tStuToDlg();\n\t}\t\n}\n\nvoid CDlgCfgPhoneNotify::OnPhonenotifyBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\tSetConfigToDevice();\n}\n","size_bytes":7291},"bin/Demo/MfcDemo/02.PlayBack/PlayApi.cpp":{"content":"\n#include \"StdAfx.h\"\n#include \"PlayApi.h\"\n\n//////////////////////////////////////////////////////////////////////////\n//\n\nCPlayAPI::CPlayAPI():\nm_hModule(NULL),\nm_APIOpenStream(NULL),\nm_APISetDisplayCallBack(NULL),\nm_APIRigisterDrawFun(NULL),\nm_APIPlay(NULL),\nm_APIInputData(NULL),\nm_APIQueryInfo(NULL),\nm_APIStop(NULL),\nm_APICloseStream(NULL),\nm_APIGetPicBMPEx(NULL),\nm_APIRenderPrivateData(NULL),\nm_APISetStreamOpenMode(NULL),\nm_APICatchPicEx(NULL),\nm_APIResetBuffer(NULL),\nm_APIGetBufferValue(NULL),\nm_APIGetSourceBufferRemain(NULL),\nm_APIPause(NULL),\nm_APISetPlayDirection(NULL),\nm_APISetPlaySpeed(NULL),\nm_APIOneByOne(NULL)\n{\n}\n\nCPlayAPI::~CPlayAPI()\n{\n\tif (m_hModule)\n\t{\n\t\tFreeLibrary(m_hModule);\n\t\tm_hModule = NULL;\n\n\t\tOutputDebugString(_T(\"Unload PlaySDK!\\n\"));\n\t}\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//\n\nvoid CPlayAPI::LoadPlayDll()\n{\n\tHMODULE hLib = ::LoadLibraryEx(_T(\"dhplay.dll\"), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n\tif (hLib)\n\t{\n\t\tm_APIOpenStream = (PLAY_API_OPENSTREAM)GetProcAddress(hLib, \"PLAY_OpenStream\");;\n\t\tm_APISetDisplayCallBack = (PLAY_API_SETIVSCALLBACK)GetProcAddress(hLib, \"PLAY_SetIVSCallBack\");\n\t\tm_APIRigisterDrawFun = (PLAY_API_RIGISTERDRAWFUN)GetProcAddress(hLib, \"PLAY_RigisterDrawFun\");\n\t\tm_APIPlay = (PLAY_API_PLAY)GetProcAddress(hLib, \"PLAY_Play\");\n\t\tm_APIInputData = (PLAY_API_INPUTDATA)GetProcAddress(hLib, \"PLAY_InputData\");\n\t\tm_APIQueryInfo = (PLAY_API_QUERYINFO)GetProcAddress(hLib, \"PLAY_QueryInfo\");\n\t\tm_APIStop = (PLAY_API_STOP)GetProcAddress(hLib, \"PLAY_Stop\");\n\t\tm_APICloseStream = (PLAY_API_CLOSESTREAM)GetProcAddress(hLib, \"PLAY_CloseStream\");\n\t\tm_APIRenderPrivateData = (PLAY_API_RenderPrivateData)GetProcAddress(hLib,\"PLAY_RenderPrivateData\");\n\t\tm_APIGetPicBMPEx = (PLAY_API_GetPicBMPEx)GetProcAddress(hLib,\"PLAY_GetPicBMPEx\");\n\t\tm_APISetStreamOpenMode = (PLAY_API_SetStreamOpenMode)GetProcAddress(hLib,\"PLAY_SetStreamOpenMode\");\n\t\tm_APICatchPicEx = (PLAY_API_CatchPicEx)GetProcAddress(hLib,\"PLAY_CatchPicEx\");\n\t\tm_APIResetBuffer = (PLAY_API_ResetBuffer)GetProcAddress(hLib,\"PLAY_ResetBuffer\");\n\t\tm_APIGetBufferValue = (PLAY_API_GetBufferValue)GetProcAddress(hLib,\"PLAY_GetBufferValue\");\n\t\tm_APIGetSourceBufferRemain = (PLAY_API_GetSourceBufferRemain)GetProcAddress(hLib,\"PLAY_GetSourceBufferRemain\");\n\t\tm_APIPause = (PLAY_API_Pause)GetProcAddress(hLib,\"PLAY_Pause\");\n\t\tm_APISetPlayDirection = (PLAY_API_SetPlayDirection)GetProcAddress(hLib,\"PLAY_SetPlayDirection\");\n\t\tm_APISetPlaySpeed = (PLAY_API_SetPlaySpeed)GetProcAddress(hLib,\"PLAY_SetPlaySpeed\");\n\t\tm_APIOneByOne = (PLAY_API_OneByOne)GetProcAddress(hLib, \"PLAY_OneByOne\");\n\t\tm_hModule = hLib;\n\t\tOutputDebugString(_T(\"Load PlaySDK Successfully!\\n\"));\n\t}\n\telse\n\t{\n\t\tOutputDebugString(_T(\"Load PlaySDK Failed!\\n\"));\n\t}\n}\n\nBOOL CPlayAPI::PLAY_OpenStream(LONG nPort,PBYTE pFileHeadBuf,DWORD nSize,DWORD nBufPoolSize)\n{\n\tif (m_APIOpenStream)\n\t{\n\t\treturn m_APIOpenStream(nPort, pFileHeadBuf, nSize, nBufPoolSize);\n\t}\n\n\treturn FALSE;\n}\n\nBOOL CPlayAPI::PLAY_SetIVSCallBack(LONG nPort, GetIVSInfoCallbackFunc pFunc, void* pUserData)\n{\n\tif (m_APISetDisplayCallBack)\n\t{\n\t\treturn m_APISetDisplayCallBack(nPort, pFunc, pUserData);\n\t}\n\n\treturn FALSE;\n}\n\nBOOL CPlayAPI::PLAY_RigisterDrawFun(LONG nPort, DrawFun DrawFuncb, void* pUserData)\n{\n\tif (m_APIRigisterDrawFun)\n\t{\n\t\treturn m_APIRigisterDrawFun(nPort, DrawFuncb, pUserData);\n\t}\n\n\treturn FALSE;\n}\n\nBOOL CPlayAPI::PLAY_Play(LONG nPort, HWND hWnd)\n{\n\tif (m_APIPlay)\n\t{\n\t\treturn m_APIPlay(nPort, hWnd);\n\t}\n\n\treturn FALSE;\n}\n\nBOOL CPlayAPI::PLAY_RenderPrivateData(LONG nPort, BOOL bTrue, LONG nReserve)\n{\n\tif (m_APIRenderPrivateData)\n\t{\n\t\treturn m_APIRenderPrivateData(nPort, bTrue, nReserve);\n\t}\n\n\treturn FALSE;\n\n}\n\nBOOL CPlayAPI::PLAY_InputData(LONG nPort, PBYTE pBuf, DWORD nSize)\n{\n\tif (m_APIInputData)\n\t{\n\t\treturn m_APIInputData(nPort, pBuf, nSize);\n\t}\n\n\treturn FALSE;\n}\n\nBOOL CPlayAPI::PLAY_QueryInfo(LONG nPort , int cmdType, char* buf, int buflen, int* returnlen)\n{\n\tif (m_APIQueryInfo)\n\t{\n\t\treturn m_APIQueryInfo(nPort, cmdType, buf, buflen, returnlen);\n\t}\n\n\treturn FALSE;\n}\n\nBOOL CPlayAPI::PLAY_Stop(LONG nPort)\n{\n\tif (m_APIStop)\n\t{\n\t\treturn m_APIStop(nPort);\n\t}\n\n\treturn FALSE;\n}\n\nBOOL CPlayAPI::PLAY_CloseStream(LONG nPort)\n{\n\tif (m_APICloseStream)\n\t{\n\t\treturn m_APICloseStream(nPort);\n\t}\n\n\treturn FALSE;\n}\n\n\nBOOL CPlayAPI::PLAY_GetPicBMPEx(LONG nPort, PBYTE pBmpBuf, DWORD dwBufSize, DWORD* pBmpSize, LONG nWidth, LONG nHeight, int nRgbType)\n{\n\tif (m_APIGetPicBMPEx)\n\t{\n\t\treturn m_APIGetPicBMPEx(nPort, pBmpBuf, dwBufSize,  pBmpSize,  nWidth, nHeight, nRgbType);\n\t}\n\treturn FALSE;\n}\n\n\nBOOL CPlayAPI::PLAY_SetStreamOpenMode(LONG nPort,DWORD nMode)\n{\n\tif (m_APISetStreamOpenMode)\n\t{\n\t\treturn m_APISetStreamOpenMode(nPort, nMode);\n\t}\n\treturn FALSE;\n}\n\nBOOL CPlayAPI::PLAY_CatchPicEx(LONG nPort,char* sFileName,tPicFormats ePicfomat)\n{\n\tif (m_APICatchPicEx)\n\t{\n\t\treturn m_APICatchPicEx(nPort, sFileName, ePicfomat);\n\t}\n\n\treturn FALSE;\n}\nBOOL CPlayAPI::PLAY_ResetBuffer(LONG nPort,DWORD nBufType)\n{\n\tif (m_APIResetBuffer)\n\t{\n\t\treturn m_APIResetBuffer(nPort, nBufType);\n\t}\n\treturn FALSE;\n}\n\nDWORD\tCPlayAPI::PLAY_GetBufferValue(LONG nPort,DWORD nBufType)\n{\n\tif (m_APIGetBufferValue)\n\t{\n\t\treturn m_APIGetBufferValue(nPort, nBufType);\n\t}\n\treturn 0;\n}\nDWORD\tCPlayAPI::PLAY_GetSourceBufferRemain(LONG nPort)\n{\n\tif (m_APIGetSourceBufferRemain)\n\t{\n\t\treturn m_APIGetSourceBufferRemain(nPort);\n\t}\n\treturn 0;\n}\nBOOL\tCPlayAPI::PLAY_Pause(LONG nPort,DWORD nPause)\n{\n\tif (m_APIPause)\n\t{\n\t\treturn m_APIPause(nPort, nPause);\n\t}\n\treturn FALSE;\n}\nBOOL\tCPlayAPI::PLAY_SetPlayDirection(LONG nPort, DWORD emDirection)\n{\n\tif (m_APISetPlayDirection)\n\t{\n\t\treturn m_APISetPlayDirection(nPort, emDirection);\n\t}\n\treturn FALSE;\n}\n\nBOOL CPlayAPI::PLAY_SetPlaySpeed(LONG nPort, float fCoff)\n{\n\tif (m_APISetPlaySpeed)\n\t{\n\t\treturn m_APISetPlaySpeed(nPort, fCoff);\n\t}\n\treturn FALSE;\n}\n\nBOOL CPlayAPI::PLAY_OneByOne(LONG nPort)\n{\n\tif (m_APIOneByOne)\n\t{\n\t\treturn m_APIOneByOne(nPort);\n\t}\n\treturn FALSE;\n}","size_bytes":5965},"bin/Demo/MfcDemo/07.ImageTest/AudioSource.cpp":{"content":"// AudioSource.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"imagetest.h\"\n#include \"AudioSource.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CAudioSource dialog\n\n\nCAudioSource::CAudioSource(CWnd* pParent /*=NULL*/,int nChannel,LLONG lLoginID)\n\t: CDialog(CAudioSource::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CAudioSource)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n    m_nChannel = nChannel;\n    m_LoginID = lLoginID;\n    memset(&m_stuAudioSource, 0, sizeof(m_stuAudioSource));\n    m_stuAudioSource.dwSize = sizeof(m_stuAudioSource);\n}\n\n\nvoid CAudioSource::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CAudioSource)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CAudioSource, CDialog)\n\t//{{AFX_MSG_MAP(CAudioSource)\n\tON_BN_CLICKED(IDC_SET, OnSet)\n\tON_BN_CLICKED(IDC_GET, OnGet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CAudioSource message handlers\n\nBOOL CAudioSource::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\t\n\tif (GetVideoIn())\n\t{\n        StuToDlg();\n\t}\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\nBOOL CAudioSource::GetVideoIn()\n{\n    BOOL bRet = CLIENT_GetConfig(m_LoginID,NET_EM_CFG_AUDIOIN_SOURCE,m_nChannel,&m_stuAudioSource,sizeof(m_stuAudioSource),TIMEOUT);\n    if (!bRet)\n    {\n        MessageBox(ConvertString(\"Get audio input type failed!\"), ConvertString(\"Prompt\"));\n    }\n    return bRet;\n}\nBOOL CAudioSource::SetVideoIn()\n{\n    BOOL bRet = CLIENT_SetConfig(m_LoginID,NET_EM_CFG_AUDIOIN_SOURCE,m_nChannel,&m_stuAudioSource,sizeof(m_stuAudioSource),TIMEOUT);\n    if (!bRet)\n    {\n        MessageBox(ConvertString(\"Set audio input type failed!\"), ConvertString(\"Prompt\"));\n    }\n    return bRet;\n}\nvoid CAudioSource::StuToDlg()\n{\n    int nNum = 0;\n    BOOL bCheck[16]; \n\tint i = 0;\n    for (i = 0;i <16 ;i++)\n    {\n        bCheck[i] = FALSE;\n    }\n    for(int j =0 ;j<m_stuAudioSource.nRetAudioInSource;j++)\n    {\n        bCheck[m_stuAudioSource.emAudioInSource[j]-1] = TRUE;\n    }\n    for (i= 0; i<16; i++)\n    {\n        ((CButton*)GetDlgItem(IDC_RADIO_COAXIAL+ i))->SetCheck(bCheck[i]);\n       \n    }\n    UpdateData(FALSE);\n}\nvoid CAudioSource::DlgToStu()\n{\n    UpdateData();\n    int nCount = 0;\n    for (int i= 0; i<16 ;i++)\n    {\n        if (((CButton*)GetDlgItem(IDC_RADIO_COAXIAL+i))->GetCheck())\n        {\n            m_stuAudioSource.emAudioInSource[nCount] = NET_EM_AUDIOIN_SOURCE_TYPE(i+1);\n            nCount++;\n        }\n    }\n    m_stuAudioSource.nMaxAudioInSource = nCount;\n}\n\nvoid CAudioSource::OnSet() \n{\n\tDlgToStu();\n    SetVideoIn();\n}\n\nvoid CAudioSource::OnGet() \n{\n    if (GetVideoIn())\n    {\n        StuToDlg();\n\t}\n}\n","size_bytes":3032},"bin/Demo/MfcDemo/18.IntelligentDevice/Utils.cpp":{"content":"#include \"StdAfx.h\"\n#include \"Utils.h\"\n\nTCHAR* g_GetIniPath(void)\n{\n\tstatic char pszIniPath[512] = {0};\n\tif( strlen(pszIniPath) == 0 )\n\t{\n\t\tchar szDirBuf[512] = {0};\n\t\tGetCurrentDirectory(512, szDirBuf);\n\t\t_snprintf(pszIniPath, sizeof(pszIniPath), \"%s\\\\langchn.ini\", szDirBuf);\n\t}\n\treturn pszIniPath;\n}\n\nCString ConvertString(CString strText)\n{\n\tchar *val = new char[200];\n\tCString strIniPath,strRet;\n\n\tmemset(val,0,200);\n\tGetPrivateProfileString(\"String\",strText,\"\",\n\t\tval,200,g_GetIniPath());\n\tstrRet = val;\n\tif(strRet.GetLength()==0)\n\t{\n\t\t//If there is no corresponding string in ini file ,then set it to be default value.\n\t\tstrRet=strText;\n\t}\n\tdelete val;\n\treturn strRet;\n}\n\nvoid g_SetWndStaticText(CWnd * pWnd)\n{\n\tCString strCaption,strText;\n\n\t//Set main widnow title \n\tpWnd->GetWindowText(strCaption);\n\tif(strCaption.GetLength()>0)\n\t{\n\t\tstrText=ConvertString(strCaption);\n\t\tpWnd->SetWindowText(strText);\n\t}\n\n\t//Set small window title \n\tCWnd * pChild=pWnd->GetWindow(GW_CHILD);\n\tCString strClassName;\n\twhile(pChild)\n\t{\n\t\t//////////////////////////////////////////////////////////////////////////\t\t\n\t\t//Added by Jackbin 2005-03-11\n\t\tstrClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n\t\tif(strClassName == \"CEdit\")\n\t\t{\n\t\t\t//The next small window \n\t\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t\t\tcontinue;\n\t\t}\n\n\t\t//////////////////////////////////////////////////////////////////////////\t\n\n\t\t//Set current language text in small window\n\t\tpChild->GetWindowText(strCaption);\n\t\tstrText=ConvertString(strCaption);\n\t\tpChild->SetWindowText(strText);\n\n\t\t//The next small window \n\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t}\n}\n\nvoid FillCWndWithDefaultColor(CWnd* cwnd) \n{\n\tif (NULL == cwnd)\n\t{\n\t\treturn;\n\t}\n\n\tCDC* cdc = cwnd->GetDC();\n\tif (NULL == cdc)\n\t{\n\t\treturn;\n\t}\n\n\tRECT rect;\n\tcwnd->GetClientRect(&rect);\n\tCBrush brush(RGB(105,105,105));\n\tcdc->FillRect(&rect, &brush);\n\tcwnd->ReleaseDC(cdc);\n}","size_bytes":1916},"bin/Demo/MfcDemo/07.ImageTest/StdAfx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n//\tImageTest.pch will be the pre-compiled header\n//\tstdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n\n\n\n","size_bytes":203},"bin/Demo/MfcDemo/11.Attendance/AttendanceManager.cpp":{"content":"#include \"stdafx.h\"\n#include \"AttendanceManager.h\"\n#include \"CAttendanceObserver.h\"\n#include \"AttendanceManagerImpl.h\"\n\n#if defined(_WIN64)\n#pragma comment(lib, \"./lib/win64/dhnetsdk.lib\")\n#else\n#pragma comment(lib, \"./lib/win32/dhnetsdk.lib\")\n#endif\n\nCAttendanceManager::CAttendanceManager()\n{\n\tm_pImpl = new CAttendanceManagerImpl;\n\tif (m_pImpl)\n\t{\n\t\tCLIENT_Init(NULL, NULL);\n\t}\n}\n\nCAttendanceManager::~CAttendanceManager()\n{\n\tif (m_pImpl)\n\t{\n\t\tLogoutDevice();\n\n\t\tCLIENT_Cleanup();\n\n\t\tdelete m_pImpl;\n\t\tm_pImpl = NULL;\n\t}\n}\n\n// get last error\nDWORD CAttendanceManager::GetLastError()\n{\n\tDWORD dwError = CLIENT_GetLastError();\n\treturn dwError;\n}\n\n// true:success false:failed \nbool CAttendanceManager::LoginDevice(const char *szIP, unsigned short nPort, const char *szUser, const char *szPasswd, int *pError)\n{\n\tif (NULL == m_pImpl)\n\t{\n\t\treturn false;\n\t}\n\n\tif (m_pImpl->m_lDeviceHandle)\n\t{\n\t\treturn false;\n\t}\n\n\tNET_DEVICEINFO_Ex  stuDevice = {0};\n\tLLONG lLoginHandle = CLIENT_LoginEx2(szIP, nPort, szUser, szPasswd, EM_LOGIN_SPEC_CAP_TCP, NULL, &stuDevice, pError);\n\tif (lLoginHandle)\n\t{\n\t\tm_pImpl->m_lDeviceHandle = lLoginHandle;\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\n// true:success false:failed\nbool CAttendanceManager::LogoutDevice()\n{\n\tif (NULL == m_pImpl)\n\t{\n\t\treturn false;\n\t}\n\n\tif (0 == m_pImpl->m_lDeviceHandle)\n\t{\n\t\treturn false;\t\n\t}\n\t\n\tif (m_pImpl->m_lRealLoadHandle)\n\t{\n\t\tCLIENT_StopLoadPic(m_pImpl->m_lRealLoadHandle);\n\t\tm_pImpl->m_lRealLoadHandle = 0;\n\t}\n\tBOOL bRet = CLIENT_Logout(m_pImpl->m_lDeviceHandle);\n\tm_pImpl->m_lDeviceHandle = 0;\n\treturn bRet==TRUE ? true:false;\n}\n\nint  CALLBACK funcAnalyzerDataCallBack(LLONG lAnalyzerHandle, DWORD dwAlarmType, void* pAlarmInfo, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser, int nSequence, void *reserved)\n{\n\tCAttendanceObserver *pObserver = (CAttendanceObserver *)dwUser;\n\tif (NULL == pObserver)\n\t{\n\t\treturn -1;\n\t}\n\n\tswitch(dwAlarmType)\n\t{\n\tcase EVENT_IVS_ACCESS_CTL:\n\t\t{\n\t\t\tpObserver->updateAttendanceInfo(ATTENDANCE_MSG_TYPE_IVS_ACCESS_CTL, pAlarmInfo, pBuffer, dwBufSize);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n// true:success false:failed \nbool CAttendanceManager::RealLoadPicture(int nChannel, DWORD dwAlarmType, CAttendanceObserver *pUser)\n{\n\tif (NULL == m_pImpl)\n\t{\n\t\treturn false;\n\t}\n\n\tif (0 == m_pImpl->m_lDeviceHandle)\n\t{\n\t\treturn false;\n\t}\n\n\tif (m_pImpl->m_lRealLoadHandle)\n\t{\n\t\treturn false;\n\t}\n\n\tLLONG lRealLoadPic = CLIENT_RealLoadPictureEx(m_pImpl->m_lDeviceHandle, nChannel, dwAlarmType, TRUE, funcAnalyzerDataCallBack, (LDWORD)pUser, NULL);\n\tif (lRealLoadPic)\n\t{\n\t\tm_pImpl->m_lRealLoadHandle = lRealLoadPic;\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\n//true:success false:failed\nbool CAttendanceManager::StopLoadPicture()\n{\n\tif (NULL == m_pImpl)\n\t{\n\t\treturn false;\n\t}\n\n\tif (0 == m_pImpl->m_lDeviceHandle || 0 == m_pImpl->m_lRealLoadHandle)\n\t{\n\t\treturn false;\n\t}\n\n\tBOOL bRet = CLIENT_StopLoadPic(m_pImpl->m_lRealLoadHandle);\n\tm_pImpl->m_lRealLoadHandle = 0;\n\treturn bRet==TRUE ? true: false;\n}\n\n// add attendance user\nbool CAttendanceManager::AddAttendanceUser(NET_IN_ATTENDANCE_ADDUSER *pstuInAddUser)\n{\n\tif (NULL == m_pImpl)\n\t{\n\t\treturn false;\n\t}\n\tif (0 == m_pImpl->m_lDeviceHandle)\n\t{\n\t\treturn false;\n\t}\n\n\tNET_OUT_ATTENDANCE_ADDUSER stuOutAddUser = {sizeof(stuOutAddUser)};\n\tBOOL bRet = CLIENT_Attendance_AddUser(m_pImpl->m_lDeviceHandle, pstuInAddUser, &stuOutAddUser, 5000);\n\treturn bRet == TRUE ? true:false;\n}\n\n// modify attendance user\nbool CAttendanceManager::ModifyAttendanceUser(NET_IN_ATTENDANCE_ModifyUSER *pstuInModifyUser)\n{\n\tif (NULL == m_pImpl)\n\t{\n\t\treturn false;\n\t}\n\tif (0 == m_pImpl->m_lDeviceHandle)\n\t{\n\t\treturn false;\n\t}\n\n\tNET_OUT_ATTENDANCE_ModifyUSER ModifyUser = {sizeof(ModifyUser)};\n\tBOOL bRet = CLIENT_Attendance_ModifyUser(m_pImpl->m_lDeviceHandle, pstuInModifyUser, &ModifyUser, 5000);\n\treturn bRet == TRUE ? true:false;\n}\n\n// delete attendance user\nbool CAttendanceManager::DelAttendanceUser(NET_IN_ATTENDANCE_DELUSER *pstuInDelUser)\n{\n\tif (NULL == m_pImpl)\n\t{\n\t\treturn false;\n\t}\n\tif (0 == m_pImpl->m_lDeviceHandle)\n\t{\n\t\treturn false;\n\t}\n\n\tNET_OUT_ATTENDANCE_DELUSER stuDelUser = {sizeof(stuDelUser)};\n\tBOOL bRet = CLIENT_Attendance_DelUser(m_pImpl->m_lDeviceHandle, pstuInDelUser, &stuDelUser, 5000);\n\treturn bRet == TRUE ? true:false;\n}\n\n// get attendance user\nbool CAttendanceManager::GetAttendanceUser(NET_IN_ATTENDANCE_GetUSER *pstuInGetUser, NET_OUT_ATTENDANCE_GetUSER *pstuOutGetUser)\n{\n\tif (NULL == m_pImpl)\n\t{\n\t\treturn false;\n\t}\n\tif (0 == m_pImpl->m_lDeviceHandle)\n\t{\n\t\treturn false;\n\t}\n\n\tBOOL bRet = CLIENT_Attendance_GetUser(m_pImpl->m_lDeviceHandle, pstuInGetUser, pstuOutGetUser, 5000);\n\treturn bRet == TRUE ? true:false;\n}\n\n// find attendance user\nbool CAttendanceManager::FindAttendanceUser(NET_IN_ATTENDANCE_FINDUSER *pstuInFindUser, NET_OUT_ATTENDANCE_FINDUSER *psutOutFindUser)\n{\n\tif (NULL == m_pImpl)\n\t{\n\t\treturn false;\n\t}\n\tif (0 == m_pImpl->m_lDeviceHandle)\n\t{\n\t\treturn false;\n\t}\n\n\tBOOL bRet = CLIENT_Attendance_FindUser(m_pImpl->m_lDeviceHandle, pstuInFindUser, psutOutFindUser, 5000);\n\treturn bRet == TRUE ? true:false;\t\n}\n\n// start listenEx\nbool CAttendanceManager::StartListenEx()\n{\n\tif (NULL == m_pImpl)\n\t{\n\t\treturn false;\n\t}\n\tif (0 == m_pImpl->m_lDeviceHandle)\n\t{\n\t\treturn false;\n\t}\n\n\tBOOL bRet = CLIENT_StartListenEx(m_pImpl->m_lDeviceHandle);\n\n\treturn bRet == TRUE ? true:false;\n}\n\n// stop listen\nbool CAttendanceManager::StopListen()\n{\n\tif (NULL == m_pImpl)\n\t{\n\t\treturn false;\n\t}\n\tif (0 == m_pImpl->m_lDeviceHandle)\n\t{\n\t\treturn false;\n\t}\n\n\tBOOL bRet = CLIENT_StopListen(m_pImpl->m_lDeviceHandle);\n\n\treturn bRet == TRUE ? true:false;\n}\n\n// attendance get finger by userid\nbool CAttendanceManager::GetFingerByUserID(NET_IN_FINGERPRINT_GETBYUSER *pstuIn, NET_OUT_FINGERPRINT_GETBYUSER *pstuOut)\n{\n\tif (NULL == m_pImpl)\n\t{\n\t\treturn false;\n\t}\n\tif (0 == m_pImpl->m_lDeviceHandle)\n\t{\n\t\treturn false;\n\t}\n\n\tBOOL bRet = CLIENT_Attendance_GetFingerByUserID(m_pImpl->m_lDeviceHandle,pstuIn, pstuOut, 10000);\n\n\treturn bRet == TRUE ? true:false;\n}\n\n// attendance insert finger by userid\nbool CAttendanceManager::InsertFingerByUserID(NET_IN_FINGERPRINT_INSERT_BY_USERID* pstuInInsert, NET_OUT_FINGERPRINT_INSERT_BY_USERID* pstuOutInsert)\n{\n\tif (NULL == m_pImpl)\n\t{\n\t\treturn false;\n\t}\n\tif (0 == m_pImpl->m_lDeviceHandle)\n\t{\n\t\treturn false;\n\t}\n\n\tBOOL bRet = CLIENT_Attendance_InsertFingerByUserID(m_pImpl->m_lDeviceHandle, pstuInInsert,pstuOutInsert, 5000);\n\n\treturn bRet == TRUE ? true:false;\n}\n\n// attendance remove finger by userid\nbool CAttendanceManager::RemoveFingerByUserID(NET_CTRL_IN_FINGERPRINT_REMOVE_BY_USERID* pstuInRemove, NET_CTRL_OUT_FINGERPRINT_REMOVE_BY_USERID* pstuOutRemove)\n{\n\tif (NULL == m_pImpl)\n\t{\n\t\treturn false;\n\t}\n\tif (0 == m_pImpl->m_lDeviceHandle)\n\t{\n\t\treturn false;\n\t}\n\t\n\tBOOL bRet = CLIENT_Attendance_RemoveFingerByUserID(m_pImpl->m_lDeviceHandle,pstuInRemove,pstuOutRemove, 5000);\n\n\treturn bRet == TRUE ? true:false;\n}\n\n// capture finger print\nbool CAttendanceManager::CaptureFingerprint()\n{\n\tif (NULL == m_pImpl)\n\t{\n\t\treturn false;\n\t}\n\tif (0 == m_pImpl->m_lDeviceHandle)\n\t{\n\t\treturn false;\n\t}\n\n\tNET_CTRL_CAPTURE_FINGER_PRINT stuCapParam = {sizeof(stuCapParam)};\n\tstuCapParam.nChannelID = 0;\n\tstrncpy(stuCapParam.szReaderID, \"1\", sizeof(stuCapParam.szReaderID)-1);\n\tBOOL bRet = CLIENT_ControlDevice(m_pImpl->m_lDeviceHandle, DH_CTRL_CAPTURE_FINGER_PRINT, &stuCapParam, 5000);\n\treturn bRet == TRUE ? true:false;\n}\n\n// get finger record by fingerid\nbool CAttendanceManager::GetFingerRecord(NET_CTRL_IN_FINGERPRINT_GET*pstuInGet, NET_CTRL_OUT_FINGERPRINT_GET* pstuOutGet)\n{\n\tif (NULL == m_pImpl)\n\t{\n\t\treturn false;\n\t}\n\tif (0 == m_pImpl->m_lDeviceHandle)\n\t{\n\t\treturn false;\n\t}\n\n\tBOOL bRet = CLIENT_Attendance_GetFingerRecord(m_pImpl->m_lDeviceHandle,pstuInGet, pstuOutGet, 5000);\n\treturn bRet == TRUE ? true:false;\n}\n\n// remove finger record by fingerid\nbool CAttendanceManager::RemoveFingerRecord(NET_CTRL_IN_FINGERPRINT_REMOVE*  pstuInRemove, NET_CTRL_OUT_FINGERPRINT_REMOVE* pstuOutRemove)\n{\n\tif (NULL == m_pImpl)\n\t{\n\t\treturn false;\n\t}\n\tif (0 == m_pImpl->m_lDeviceHandle)\n\t{\n\t\treturn false;\n\t}\n\n\tBOOL bRet = CLIENT_Attendance_RemoveFingerRecord(m_pImpl->m_lDeviceHandle,pstuInRemove,pstuOutRemove, 5000);\n\n\treturn bRet == TRUE ? true:false;\n}\n\nvoid CAttendanceManager::SetDVRMessCallBack(fMessCallBack cbMessage,LDWORD dwUser)\n{\n\tif (NULL == m_pImpl)\n\t{\n\t\treturn ;\n\t}\n\tif (0 == m_pImpl->m_lDeviceHandle)\n\t{\n\t\treturn ;\n\t}\n\n\tCLIENT_SetDVRMessCallBack(cbMessage, dwUser);\n\n\treturn ;\n}\n\n","size_bytes":8464},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgBatteryLowPower.cpp":{"content":"// DlgCfgBatteryLowPower.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgCfgBatteryLowPower.h\"\n#include \"SubDlgCfgEventHandler.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgBatteryLowPower dialog\n\n\nCDlgCfgBatteryLowPower::CDlgCfgBatteryLowPower(CWnd* pParent /* = NULL */, LLONG lLoginID /* = 0 */)\n\t: CDialog(CDlgCfgBatteryLowPower::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgBatteryLowPower)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_lLoginId = lLoginID;\n\tmemset(&m_stuInfo, 0, sizeof(m_stuInfo));\n}\n\n\nvoid CDlgCfgBatteryLowPower::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgBatteryLowPower)\n\tDDX_Control(pDX, IDC_BATTERYLOWPOWER_CHK_ENABLE, m_chkEnable);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgBatteryLowPower, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgBatteryLowPower)\n\tON_BN_CLICKED(IDC_BATTERYLOWPOWER_BTN_HANDLER, OnBatterylowpowerBtnHandler)\n\tON_BN_CLICKED(IDC_BATTERYLOWPOWER_BTN_GET, OnBatterylowpowerBtnGet)\n\tON_BN_CLICKED(IDC_BATTERYLOWPOWER_BTN_SET, OnBatterylowpowerBtnSet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgBatteryLowPower private method\n\nBOOL CDlgCfgBatteryLowPower::getInfo()\n{\n\t// enable\n\tm_stuInfo.bEnable = m_chkEnable.GetCheck() ? TRUE : FALSE;\n\n\t// event handler\n\n\treturn TRUE;\n}\n\nBOOL CDlgCfgBatteryLowPower::showInfo()\n{\n\t// enable\n\tm_chkEnable.SetCheck(m_stuInfo.bEnable ? BST_CHECKED : BST_UNCHECKED);\n\t\n\t// event handler\n\n\treturn TRUE;\n}\n\nBOOL CDlgCfgBatteryLowPower::GetConfigFromDevice()\n{\n\tchar szJsonBuf[1024 * 40] = {0};\n\tint nerror = 0;\n\tint nSelChn = -1;\n\tBOOL bRet = CLIENT_GetNewDevConfig(m_lLoginId, CFG_CMD_BATTERY_LOW_POWER, nSelChn, \n\t\tszJsonBuf, sizeof(szJsonBuf), &nerror, SDK_API_WAIT);\n\t\n\tif (bRet)\n\t{\n\t\tDWORD dwRetLen = 0;\n\t\tbRet = CLIENT_ParseData(CFG_CMD_BATTERY_LOW_POWER, szJsonBuf, (void*)&m_stuInfo, sizeof(CFG_BATTERY_LOW_POWER_INFO), &dwRetLen);\n\t\tif (!bRet)\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"parse BatterLowPower error...\"), DLG_ALARM_POWERFAULT), ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\t\t\t\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"QueryConfig BatterLowPower error:\", DLG_ALARM_POWERFAULT), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nBOOL CDlgCfgBatteryLowPower::SetConfigToDevice()\n{\n\tchar szJsonBuf[1024 * 40] = {0};\n\t\n\tBOOL bRet = CLIENT_PacketData(CFG_CMD_BATTERY_LOW_POWER, (void*)&m_stuInfo, \n\t\tsizeof(CFG_BATTERY_LOW_POWER_INFO), szJsonBuf, sizeof(szJsonBuf));\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(CString(\"packet BatterLowPower error...\"), DLG_ALARM_POWERFAULT), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t} \n\telse\n\t{\n\t\tint nerror = 0;\n\t\tint nrestart = 0;\n\t\tbRet = CLIENT_SetNewDevConfig(m_lLoginId, CFG_CMD_BATTERY_LOW_POWER, -1, szJsonBuf, \n\t\t\tstrlen(szJsonBuf), &nerror, &nrestart, SDK_API_WAIT);\n\t\tif (!bRet)\n\t\t{\n\t\t\tCString csErr;\n\t\t\tcsErr.Format(\"%s %08x\", ConvertString(\"SetupConfig BatterLowPower failed:\", DLG_ALARM_POWERFAULT), CLIENT_GetLastError());\n\t\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"SetConfig BatterLowPower ok!\"), DLG_ALARM_POWERFAULT), ConvertString(\"Prompt\"));\n\t\t}\n\t}\n\treturn TRUE;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgBatteryLowPower message handlers\n\nBOOL CDlgCfgBatteryLowPower::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_ALARM_POWERFAULT);\n\t// TODO: Add extra initialization here\n\tif (GetConfigFromDevice())\n\t{\n\t\tshowInfo();\n\t}\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgBatteryLowPower::OnBatterylowpowerBtnHandler() \n{\n\t// TODO: Add your control notification handler code here\t\n    CSubDlgCfgEventHandler* dlgEventHandler = new CSubDlgCfgEventHandler;\n    if (dlgEventHandler != NULL)\n    {\n        dlgEventHandler->SetEventHandler(m_stuInfo.stuEventHandler);\n        \n        if (IDOK == dlgEventHandler->DoModal())\n        {\n            const CFG_ALARM_MSG_HANDLE& stuEventHandler = dlgEventHandler->GetEventHandler();\n            memcpy(&m_stuInfo.stuEventHandler, &stuEventHandler, sizeof(CFG_ALARM_MSG_HANDLE));\n        }\n\t}\n}\n\nvoid CDlgCfgBatteryLowPower::OnBatterylowpowerBtnGet() \n{\n\t// TODO: Add your control notification handler code here\n\tif (GetConfigFromDevice())\n\t{\n\t\tshowInfo();\n\t}\t\n}\n\nvoid CDlgCfgBatteryLowPower::OnBatterylowpowerBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n\tgetInfo();\n\tSetConfigToDevice();\t\n}\n","size_bytes":4886},"bin/Demo/MfcDemo/09.AccessControl/AccessControl.cpp":{"content":"// AccessControl.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"AccessControl.h\"\n#include \"AccessControlDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CAccessControlApp\n\nBEGIN_MESSAGE_MAP(CAccessControlApp, CWinApp)\n\t//{{AFX_MSG_MAP(CAccessControlApp)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t\t//    DO NOT EDIT what you see in these blocks of generated code!\n\t//}}AFX_MSG\n\tON_COMMAND(ID_HELP, CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CAccessControlApp construction\n\nCAccessControlApp::CAccessControlApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n\ttheCrashDumper.Enable(_T(\"AccessControlDemo\"), true, _T(\"C:\\\\\"));\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The one and only CAccessControlApp object\n\nCAccessControlApp theApp;\n\n/////////////////////////////////////////////////////////////////////////////\n// CAccessControlApp initialization\n\nBOOL CAccessControlApp::InitInstance()\n{\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t//  of your final executable, you should remove from the following\n\t//  the specific initialization routines you do not need.\n\n#ifdef _AFXDLL\n\tEnable3dControls();\t\t\t// Call this when using MFC in a shared DLL\n#else\n\tEnable3dControlsStatic();\t// Call this when linking to MFC statically\n#endif\n\n\tCAccessControlDlg dlg;\n\tm_pMainWnd = &dlg;\n\tint nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n\nCString ConvertString(CString strText, const char* pszSeg /* = NULL */)\n{\n\tCString strIniPath, strRet;\n\tchar szVal[256] = {0};\n\t\n\tif (!pszSeg)\n\t{\n\t\tpszSeg = DLG_MAIN;\n\t}\n\t\n\tGetPrivateProfileString(pszSeg, strText, \"\", szVal, sizeof(szVal), \"./langchn.ini\");\n\tstrRet = szVal;\n\tif(strRet.GetLength()==0)\n\t{\n\t\t//If there is no corresponding string in ini file then set it to be default value(English).\n\t\tstrRet=strText;\n\t}\n\t\n\treturn strRet;\n}\n\n//Set static text in the dialogue box(English->current language) \nvoid g_SetWndStaticText(CWnd * pWnd, const char* pszSeg /* = NULL */)\n{\n\tCString strCaption,strText;\n\t\n\t//Set main window title \n\tpWnd->GetWindowText(strCaption);\n\tif(strCaption.GetLength()>0)\n\t{\n\t\tstrText=ConvertString(strCaption, pszSeg);\n\t\tpWnd->SetWindowText(strText);\n\t\t\n\t}\n\t\n\t//Set sub-window title \n\tCWnd * pChild=pWnd->GetWindow(GW_CHILD);\n\tCString strClassName;\n\twhile(pChild)\n\t{\n\t\t//////////////////////////////////////////////////////////////////////////\t\t\n\t\t//Added by Jackbin 2005-03-11\n\t\tstrClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n\t\tif(strClassName == \"CEdit\")\n\t\t{\n\t\t\t//The next sub-window \n\t\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t//////////////////////////////////////////////////////////////////////////\t\n\t\t\n\t\t//Set current language text in the sub-window \n\t\tpChild->GetWindowText(strCaption);\n\t\tstrText=ConvertString(strCaption, pszSeg);\n\t\tpChild->SetWindowText(strText);\n\t\t\n\t\t//The next sub-window \n\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t}\n}\n\nvoid SenseTypeToStr(NET_SENSE_METHOD nSenseType, CString& szStr)\n{\n\tif (NET_SENSE_DOOR == nSenseType)\n\t{\n\t\tszStr = \"DoorMagnetism\";\n\t}\n\telse if (NET_SENSE_PASSIVEINFRA == nSenseType)\n\t{\n\t\tszStr = \"PassiveInfrared\";\n\t}\n\telse if (NET_SENSE_GAS == nSenseType)\n\t{\n\t\tszStr = \"GasSensor\";\n\t}\n\telse if (NET_SENSE_SMOKING == nSenseType)\n\t{\n\t\tszStr = \"SmokingSensor\";\n\t}\n\telse if (NET_SENSE_WATER == nSenseType)\n\t{\n\t\tszStr = \"WaterSensor\";\n\t}\n\telse if (NET_SENSE_ACTIVEFRA == nSenseType)\n\t{\n\t\tszStr = \"ActiveInfrared\";\n\t}\n\telse if (NET_SENSE_GLASS == nSenseType)\n\t{\n\t\tszStr = \"GlassSensor\";\n\t}\n\telse if (NET_SENSE_EMERGENCYSWITCH == nSenseType)\n\t{\n\t\tszStr = \"EmergencySwitch\";\n\t}\n\telse if (NET_SENSE_SHOCK == nSenseType)\n\t{\n\t\tszStr = \"ShockSensor\";\n\t}\n\telse if (NET_SENSE_DOUBLEMETHOD == nSenseType)\n\t{\n\t\tszStr = \"DoubleMethod\";\n\t}\n\telse if (NET_SENSE_THREEMETHOD == nSenseType)\n\t{\n\t\tszStr = \"ThreeMethod\";\n\t}\n\telse if (NET_SENSE_TEMP == nSenseType)\n\t{\n\t\tszStr = \"TempSensor\";\n\t}\n\telse if (NET_SENSE_HUMIDITY == nSenseType)\n\t{\n\t\tszStr = \"HumiditySensor\";\n\t}\n\telse if (NET_SENSE_CALLBUTTON == nSenseType)\n\t{\n\t\tszStr = \"CallButton\";\n\t}\n\telse if (NET_SENSE_OTHER == nSenseType)\n\t{\n\t\tszStr = \"OtherSensor\";\n\t}\n\telse\n\t{\n\t\tszStr = \"UnknownSensor\";\n\t}\n}","size_bytes":4921},"bin/Demo/MfcDemo/17.IntelligentTraffic/IntelligentTrafficDlg.cpp":{"content":"// IntelligentTrafficDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"IntelligentTraffic.h\"\n#include \"IntelligentTrafficDlg.h\"\n\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\n// Device ip\n#define DEVICE_IP           \"172.23.19.62\"     \n// Connect port  \n#define CONNECT_PORT        37777            \n// Connect user name  \n#define CONNECT_USERNAME    \"admin\"          \n// Connect password\n#define CONNECT_PASSWORD    \"admin123\"     \n\n\n// Device disconnect Callback\nvoid CALLBACK DisConnect(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser)\n{\n    if(0 != dwUser)\n    {\n        PostMessage(((CIntelligentTrafficDlg *)dwUser)->GetSafeHwnd(), WM_DEVICE_DISCONNECT, 0, 0);\n    }\n}\n\n// Device reconnect Callback\nvoid CALLBACK ReConnect(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser)\n{\n    if(0 != dwUser)\n    {\n        PostMessage(((CIntelligentTrafficDlg *)dwUser)->GetSafeHwnd(), WM_REDEVICE_RECONNECT, 0, 0);\n    }\n}\n\n// Handle message : WM_DEVICE_DISCONNECT\nLRESULT CIntelligentTrafficDlg::OnDeviceDisConnect(WPARAM wParam, LPARAM lParam)\n{\n    SetWindowText(ConvertString(\"Network disconnected!\"));\n    return 0;\n}\n\n// Handle message : WM_REDEVICE_RECONNECT\nLRESULT CIntelligentTrafficDlg::OnDeviceReconnect(WPARAM wParam, LPARAM lParam)\n{\n    SetWindowText(ConvertString(\"IntelligentTraffic\"));\n    return 0;\n}\n\n// CAboutDlg dialog used for App About\n\nclass CAboutDlg : public CDialog\n{\npublic:\n\tCAboutDlg();\n\n// Dialog Data\n\tenum { IDD = IDD_ABOUTBOX };\n\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n\n// Implementation\nprotected:\n\tDECLARE_MESSAGE_MAP()\n};\n\nCAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)\n{\n}\n\nvoid CAboutDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n}\n\nBEGIN_MESSAGE_MAP(CAboutDlg, CDialog)\nEND_MESSAGE_MAP()\n\n\n// CIntelligentTrafficDlg dialog\n\n\nCIntelligentTrafficDlg::CIntelligentTrafficDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CIntelligentTrafficDlg::IDD, pParent)\n{\n\tm_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);\n    m_lLoginHandle = 0;\n\n}\n\nvoid CIntelligentTrafficDlg::DoDataExchange(CDataExchange* pDX)\n{\n    CDialog::DoDataExchange(pDX);\n    DDX_Control(pDX, IDC_TAB1, m_ctrTab);\n}\n\nBEGIN_MESSAGE_MAP(CIntelligentTrafficDlg, CDialog)\n\tON_WM_SYSCOMMAND()\n\tON_WM_PAINT()\n\tON_WM_QUERYDRAGICON()\n\t//}}AFX_MSG_MAP\n    ON_NOTIFY(TCN_SELCHANGE, IDC_TAB1, &CIntelligentTrafficDlg::OnTcnSelchangeTab)\n    ON_BN_CLICKED(IDC_BTN_LOGIN_AND_LOGOUT, &CIntelligentTrafficDlg::OnBnClickedBtnLoginAndLogout)\n    ON_MESSAGE(WM_DEVICE_DISCONNECT,&CIntelligentTrafficDlg::OnDeviceDisConnect)\n    ON_MESSAGE(WM_REDEVICE_RECONNECT,&CIntelligentTrafficDlg::OnDeviceReconnect)\n    ON_WM_DESTROY()\nEND_MESSAGE_MAP()\n\n\n// CIntelligentTrafficDlg message handlers\n\nBOOL CIntelligentTrafficDlg::PreTranslateMessage(MSG* pMsg)\n{\n    // Enter key\n    if(pMsg->message == WM_KEYDOWN &&\n        pMsg->wParam == VK_RETURN)\n    {\n        return TRUE;\n    }\n\n    // Escape key\n    if(pMsg->message == WM_KEYDOWN &&\n        pMsg->wParam == VK_ESCAPE)\n    {\n        return TRUE;\n    }\n    return CDialog::PreTranslateMessage(pMsg);\n}\n\nBOOL CIntelligentTrafficDlg::OnInitDialog()\n{\n\tCDialog::OnInitDialog();\n\n\t// Add \"About...\" menu item to system menu.\n\n\t// IDM_ABOUTBOX must be in the system command range.\n\tASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);\n\tASSERT(IDM_ABOUTBOX < 0xF000);\n\n\tCMenu* pSysMenu = GetSystemMenu(FALSE);\n\tif (pSysMenu != NULL)\n\t{\n\t\tCString strAboutMenu;\n\t\tstrAboutMenu.LoadString(IDS_ABOUTBOX);\n\t\tif (!strAboutMenu.IsEmpty())\n\t\t{\n\t\t\tpSysMenu->AppendMenu(MF_SEPARATOR);\n\t\t\tpSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);\n\t\t}\n\t}\n\n\t// Set the icon for this dialog.  The framework does this automatically\n\t//  when the application's main window is not a dialog\n\tSetIcon(m_hIcon, TRUE);\t\t\t// Set big icon\n\tSetIcon(m_hIcon, FALSE);\t\t// Set small icon\n    \n    g_SetWndStaticText(this);\n\tInitDialogContorl();\n    InitNetSdk();\n   \n\treturn TRUE;  // return TRUE  unless you set the focus to a control\n}\n\nvoid CIntelligentTrafficDlg::InitDialogContorl(void)\n{\n  \n    SetDlgItemText(IDC_IPADDRESS1, DEVICE_IP);\n    SetDlgItemInt(IDC_EDIT_PORT, CONNECT_PORT);\n    SetDlgItemText(IDC_EDIT_USER, CONNECT_USERNAME);\n    SetDlgItemText(IDC_EDIT_PWD, CONNECT_PASSWORD);\n\n    m_dlgBWList.Create(IDD_BW_LITS_DIALOG, &m_ctrTab);\n    m_dlgTrafficFlow.Create(IDD_TRAFIC_FLOW_DIALOG, &m_ctrTab);\n    m_dlgIntelligentEvent.Create(IDD_INTELLIGENT_EVENT_DIALOG, &m_ctrTab);\n    m_dlgQueryPictureAndRecord.Create(IDD_QUERY_TRAFFIC_PICTURE_DIALOG, &m_ctrTab);\n\n    m_ctrTab.InsertItem(0, ConvertString(\"Intelligent Event\"));\n    m_ctrTab.InsertItem(1, ConvertString(\"BW List\"));\n    m_ctrTab.InsertItem(2, ConvertString(\"Traffic Flow\"));\n    m_ctrTab.InsertItem(3, ConvertString(\"Query Traffic Picture\"));\n\n    m_ctrTab.SetMinTabWidth(-1);\n    m_ctrTab.SetPadding(CSize(25, 5));\n    m_ctrTab.SetCurSel(0);\n    DoTab(0);\n}\n\n\n\nvoid CIntelligentTrafficDlg::DoTab(int nTab)\n{\n    //Confirm nTab value is within the threshold.\n    if (nTab < 0 || nTab > 4)\n    {\n        nTab = 0;\n    }\n\n    BOOL bTab[4];\n    for (int i = 0; i < 4; ++i)\n    {\n        if (i == nTab)\n        {\n            bTab[i]=TRUE;\n        }\n        else\n        {\n            bTab[i]=FALSE;\n        }\n    }\n\n    //Display or hide dialog\n    SetDlgState(&m_dlgIntelligentEvent, bTab[0]);\n    SetDlgState(&m_dlgBWList, bTab[1]);\n    SetDlgState(&m_dlgTrafficFlow, bTab[2]);\n    SetDlgState(&m_dlgQueryPictureAndRecord, bTab[3]);\n}\n\nvoid CIntelligentTrafficDlg::SetDlgState(CWnd *pWnd, BOOL bShow)\n{\n    if(bShow)\n    {\n        CRect rc;\n        pWnd->GetWindowRect(rc);\n        pWnd->MoveWindow(10, 40, rc.Width(), rc.Height());\n        pWnd->ShowWindow(SW_SHOW);\n    }\n    else\n    {\n        pWnd->ShowWindow(SW_HIDE);\n    }\n}\n\n\n\nvoid CIntelligentTrafficDlg::InitNetSdk(void)\n{\n    CLIENT_Init(DisConnect, (LDWORD)this);\n    CLIENT_SetAutoReconnect(ReConnect, (LDWORD)this);\n}\n\n\n\nvoid CIntelligentTrafficDlg::OnSysCommand(UINT nID, LPARAM lParam)\n{\n\tif ((nID & 0xFFF0) == IDM_ABOUTBOX)\n\t{\n\t\tCAboutDlg dlgAbout;\n\t\tdlgAbout.DoModal();\n\t}\n\telse\n\t{\n\t\tCDialog::OnSysCommand(nID, lParam);\n\t}\n}\n\n// If you add a minimize button to your dialog, you will need the code below\n//  to draw the icon.  For MFC applications using the document/view model,\n//  this is automatically done for you by the framework.\n\nvoid CIntelligentTrafficDlg::OnPaint()\n{\n\tif (IsIconic())\n\t{\n\t\tCPaintDC dc(this); // device context for painting\n\n\t\tSendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);\n\n\t\t// Center icon in client rectangle\n\t\tint cxIcon = GetSystemMetrics(SM_CXICON);\n\t\tint cyIcon = GetSystemMetrics(SM_CYICON);\n\t\tCRect rect;\n\t\tGetClientRect(&rect);\n\t\tint x = (rect.Width() - cxIcon + 1) / 2;\n\t\tint y = (rect.Height() - cyIcon + 1) / 2;\n\n\t\t// Draw the icon\n\t\tdc.DrawIcon(x, y, m_hIcon);\n\t}\n\telse\n\t{\n\t\tCDialog::OnPaint();\n\t}\n}\n\n// The system calls this function to obtain the cursor to display while the user drags\n//  the minimized window.\nHCURSOR CIntelligentTrafficDlg::OnQueryDragIcon()\n{\n\treturn static_cast<HCURSOR>(m_hIcon);\n}\n\n\nvoid CIntelligentTrafficDlg::OnTcnSelchangeTab(NMHDR *pNMHDR, LRESULT *pResult)\n{\n    int nSelect = m_ctrTab.GetCurSel();\n    if(nSelect>=0)\n    {\n        DoTab(nSelect);\n    }\n    *pResult = 0;\n}\n\nvoid CIntelligentTrafficDlg::OnBnClickedBtnLoginAndLogout()\n{\n    CButton* pBtnLoginAndLogout =  (CButton*)GetDlgItem(IDC_BTN_LOGIN_AND_LOGOUT);\n\n    if (0 != m_lLoginHandle )\n    {\n        CleanUpChildDlgOfTab();\n        CLIENT_Logout(m_lLoginHandle);\n        m_lLoginHandle = 0;\n        pBtnLoginAndLogout->SetWindowText(ConvertString(\"Login\"));\n        SetWindowText(ConvertString(\"IntelligentTraffic\"));\n    }\n    else\n    {\n        CString csIP = \"\";\n        CString csUserName = \"\";\n        CString csPwd = \"\";\n        int nPort = 0; \n        GetDlgItemText(IDC_IPADDRESS1, csIP);\n        GetDlgItemText(IDC_EDIT_USER, csUserName);\n        GetDlgItemText(IDC_EDIT_PWD, csPwd);\n        nPort = GetDlgItemInt(IDC_EDIT_PORT);\n\n        NET_DEVICEINFO_Ex stDevInfo = {0};\n        m_lLoginHandle = CLIENT_LoginEx2(csIP.GetBuffer(), nPort, csUserName.GetBuffer(), csPwd.GetBuffer(), EM_LOGIN_SPEC_CAP_TCP, NULL, &stDevInfo, NULL);   \n        if (0 == m_lLoginHandle)\n        {\n            MessageBox(ConvertString(\"Login failed!\"), ConvertString(\"Prompt\")); \n            m_lLoginHandle = 0;\n            return;\n        }\n        InitChildDlgOfTab(stDevInfo.nChanNum, m_lLoginHandle);\n        pBtnLoginAndLogout->SetWindowText(ConvertString(\"Logout\"));\n    }\n}\n\nvoid CIntelligentTrafficDlg::OnDestroy()\n{\n    if (0 != m_lLoginHandle)\n    {\n        // Logout device \n        OnBnClickedBtnLoginAndLogout();\n    }\n    CLIENT_Cleanup();\n    CDialog::OnDestroy();\n}\n\n\nvoid CIntelligentTrafficDlg::InitChildDlgOfTab(int nChannel, LLONG lLoginIHandle)\n{\n    m_dlgIntelligentEvent.Init(nChannel, lLoginIHandle);\n    m_dlgBWList.Init(nChannel, lLoginIHandle);\n    m_dlgTrafficFlow.Init(nChannel, lLoginIHandle);\n    m_dlgQueryPictureAndRecord.Init(nChannel, lLoginIHandle);\n}\n\n\nvoid CIntelligentTrafficDlg::CleanUpChildDlgOfTab()\n{\n    m_dlgIntelligentEvent.CleanUp();\n    m_dlgBWList.CleanUp();\n    m_dlgTrafficFlow.CleanUp();\n    m_dlgQueryPictureAndRecord.CleanUp();\n}","size_bytes":9276},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/ConfigAlarmMotionAreaBlock.cpp":{"content":"// ConfigAlarmMotionAreaBlock.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"ConfigAlarmMotionAreaBlock.h\"\n#include \"ConfigAlarmMotionArea.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CConfigAlarmMotionAreaBlock dialog\n\n\nCConfigAlarmMotionAreaBlock::CConfigAlarmMotionAreaBlock()\n{\n\t//{{AFX_DATA_INIT(CConfigAlarmMotionAreaBlock)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_whiteBrush.CreateSolidBrush(RGB(255,255,255));\n\tm_blueBrush.CreateSolidBrush(RGB(125,125,200));\n\tm_brush = &m_whiteBrush;\n\tm_bSelected = FALSE;\n\tm_byX = 0;\n\tm_byY = 0;\n\tZeroMemory(m_rect, sizeof(CRect));\n\tm_thisDC = 0;\n}\n\n\nBEGIN_MESSAGE_MAP(CConfigAlarmMotionAreaBlock, CWnd)\n\t\t//{{AFX_MSG_MAP(CPlayWnd)\n\tON_WM_ERASEBKGND()\n\tON_WM_CREATE()\n\t//}}AFX_MSG_MAP\n\tON_MESSAGE(MSG_SELETED, OnSeleted)\n\tON_MESSAGE(MSG_SHOW, OnShow)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CConfigAlarmMotionAreaBlock message handlers\n\nBOOL CConfigAlarmMotionAreaBlock::DestroyWindow()\n{\n\treturn CWnd::DestroyWindow();\n}\n\n\nLRESULT CConfigAlarmMotionAreaBlock::DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam) \n{ \n\t// TODO: Add your specialized code here and/or call the base class\n\tCConfigAlarmMotionArea *pMap = (CConfigAlarmMotionArea *)GetParent();\n\tif(pMap)\n\t{\n\t\tswitch(message)\n\t\t{\n\t\tcase WM_LBUTTONDOWN:\n\t\t\tpMap->RecordPoint(m_byX, m_byY);\n\t\t\tbreak;\n\t\tcase WM_LBUTTONUP:\n\t\t\tpMap->ReleasePoint();\n\t\t\tbreak;\n\t\tcase WM_MOUSEMOVE:\n\t\t\tpMap->MovePoint(wParam, m_byX, m_byY);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn CWnd::DefWindowProc(message, wParam, lParam);\n}\n\nBOOL CConfigAlarmMotionAreaBlock::OnEraseBkgnd(CDC* pDC)\n{\n\tCRect rt;\n\tGetClientRect(&rt);\n\tpDC->FillRect(&rt, m_brush);\n\treturn TRUE;\n}\n\nLRESULT CConfigAlarmMotionAreaBlock::OnSeleted(WPARAM wParam, LPARAM lParam)\n{\n\tm_bSelected = !m_bSelected;\n\tif (m_bSelected)\n\t{\n\t\tm_brush = &m_blueBrush;\n\t}\n\telse\n\t{\n\t\tm_brush = &m_whiteBrush;\n\t}\n\t\n\tif (m_thisDC)\n\t{\n\t\tm_thisDC->FillRect(&m_rect, m_brush);\n\t}\n\n\treturn 0;\n}\n\nvoid CConfigAlarmMotionAreaBlock::SetPos(BYTE x, BYTE y)\n{\n\tm_byX = x;\n\tm_byY = y;\n\tGetClientRect(&m_rect);\n\tm_thisDC = GetDC();\n}\n\nLRESULT CConfigAlarmMotionAreaBlock::OnShow(WPARAM wParam, LPARAM lParam)\n{\n\tif (m_bSelected)\n\t{\n\t\tm_brush = &m_blueBrush;\n\t}\n\telse\n\t{\n\t\tm_brush = &m_whiteBrush;\n\t}\n\n\tif (m_thisDC)\n\t{\n\t\tm_thisDC->FillRect(&m_rect, m_brush);\n\t}\n\n\treturn 0;\n}\n","size_bytes":2594},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgNetCollection.cpp":{"content":"// DlgCfgNetCollection.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"alarmdevice.h\"\n#include \"DlgCfgNetCollection.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgNetCollection dialog\n\n\nCDlgCfgNetCollection::CDlgCfgNetCollection(CWnd* pParent /* = NULL */, LLONG lLoginID /* = NULL */)\n\t: CDialog(CDlgCfgNetCollection::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgNetCollection)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_lLoginID = lLoginID;\n\tmemset(&m_stuInfo, 0, sizeof(m_stuInfo));\n}\n\n\nvoid CDlgCfgNetCollection::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgNetCollection)\n\tDDX_Control(pDX, IDC_NETCOLLECTION_IPADDR, m_ctrlIP);\n\tDDX_Control(pDX, IDC_NETCOLLECTION_CMB_CHN, m_cmbChannel);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgNetCollection, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgNetCollection)\n\tON_CBN_SELCHANGE(IDC_NETCOLLECTION_CMB_CHN, OnSelchangeNetcollectionCmbChn)\n\tON_BN_CLICKED(IDC_NETCOLLECTION_BTN_GET, OnNetcollectionBtnGet)\n\tON_BN_CLICKED(IDC_NETCOLLECTION_BTN_SET, OnNetcollectionBtnSet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgNetCollection private method\n\nvoid CDlgCfgNetCollection::InitDlg()\n{\n\tm_cmbChannel.ResetContent();\n\tfor (int i = 0; i < 256; i++)\n\t{\n\t\tCString csItem;\n\t\tcsItem.Format(\"%s %03d\", ConvertString(\"Channel\", DLG_CFG_ALARM), i + 1);\n\t\tm_cmbChannel.InsertString(-1, csItem);\n\t}\n\tm_cmbChannel.SetCurSel(0);\n}\n\nBOOL CDlgCfgNetCollection::GetConfigFromDevice()\n{\n    char szJsonBuf[1024 * 40] = {0};\n    int nerror = 0;\n    int nSelChn = m_cmbChannel.GetCurSel() == -1 ? 0 : m_cmbChannel.GetCurSel();\n    BOOL bRet = CLIENT_GetNewDevConfig(m_lLoginID, CFG_CMD_NET_COLLECTION, nSelChn, szJsonBuf, sizeof(szJsonBuf), &nerror, SDK_API_WAIT);\n    \n    if (bRet)\n    {\n        DWORD dwRetLen = 0;\n        bRet = CLIENT_ParseData(CFG_CMD_NET_COLLECTION, szJsonBuf, (void*)&m_stuInfo, sizeof(m_stuInfo), &dwRetLen);\n        if (!bRet)\n        {\n            MessageBox(ConvertString(CString(\"parse NetCollection error...\"), DLG_CFG_NETCOLLECTION), ConvertString(\"Prompt\"));\n            return FALSE;\n        }\n    }\n    else\n    {\t\t\t\n        CString csErr;\n        csErr.Format(\"%s 0x%08x\",ConvertString(\"QueryConfig NetCollection error:\", DLG_CFG_NETCOLLECTION), CLIENT_GetLastError());\n        MessageBox(csErr, ConvertString(\"Prompt\"));\n        return FALSE;\n    }\n    return TRUE;\n}\n\nBOOL CDlgCfgNetCollection::SetConfigToDevice()\n{\n    char szJsonBuf[1024 * 40] = {0};    \n    BOOL bRet = CLIENT_PacketData(CFG_CMD_NET_COLLECTION, &m_stuInfo, sizeof(m_stuInfo), szJsonBuf, sizeof(szJsonBuf));\n    if (!bRet)\n    {\n        MessageBox(ConvertString(CString(\"packet NetCollection error...\"), DLG_CFG_NETCOLLECTION), ConvertString(\"Prompt\"));\n        return FALSE;\n    } \n    else\n    {\n\t\tint nSelChn = m_cmbChannel.GetCurSel() == -1 ? 0 : m_cmbChannel.GetCurSel();\n        int nerror = 0;\n        int nrestart = 0;\n        bRet = CLIENT_SetNewDevConfig(m_lLoginID, CFG_CMD_NET_COLLECTION, nSelChn, szJsonBuf, sizeof(szJsonBuf), &nerror, &nrestart, SDK_API_WAIT);\n        if (!bRet)\n        {\n            CString csErr;\n            csErr.Format(\"%s 0x%08x\", ConvertString(\"SetupConfig NetCollection failed:\", DLG_CFG_NETCOLLECTION), CLIENT_GetLastError());\n            MessageBox(csErr, ConvertString(\"Prompt\"));\n            return FALSE;\n        }\n        else\n        {\n            MessageBox(ConvertString(CString(\"SetConfig NetCollection ok!\"), DLG_CFG_NETCOLLECTION), ConvertString(\"Prompt\"));\n        }\n    }\n    return TRUE;\n}\n\nBOOL CDlgCfgNetCollection::showInfo()\n{\n\t// ip\n\tm_ctrlIP.SetWindowText(m_stuInfo.szIp);\n\n\t// port\n\tSetDlgItemInt(IDC_NETCOLLECTION_EDT_PORT, m_stuInfo.nPort, TRUE);\n\n    return TRUE;\n}\n\nBOOL CDlgCfgNetCollection::getInfo()\n{\n\t// ip\n\tm_ctrlIP.GetWindowText(m_stuInfo.szIp, sizeof(m_stuInfo.szIp) - 1);\n\n\t// port\n\tm_stuInfo.nPort = GetDlgItemInt(IDC_NETCOLLECTION_EDT_PORT);\n\n    return TRUE;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgNetCollection message handlers\n\nBOOL CDlgCfgNetCollection::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_NETCOLLECTION);\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\tif (GetConfigFromDevice())\n\t{\n\t\tshowInfo();\n\t}\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgNetCollection::OnSelchangeNetcollectionCmbChn() \n{\n\t// TODO: Add your control notification handler code here\n\tif (GetConfigFromDevice())\n    {\n        showInfo();\n\t}\n}\n\nvoid CDlgCfgNetCollection::OnNetcollectionBtnGet() \n{\n\t// TODO: Add your control notification handler code here\n    if (GetConfigFromDevice())\n    {\n        showInfo();\n\t}\n}\n\nvoid CDlgCfgNetCollection::OnNetcollectionBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n\tgetInfo();\n    SetConfigToDevice();\n}\n","size_bytes":5175},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/ConfigAlarmMotion.cpp":{"content":"// ConfigAlarmMotion.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"ConfigAlarmMotion.h\"\n#include \"ConfigAlarmMotionArea.h\"\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CConfigAlarmMotion dialog\n\n\nCConfigAlarmMotion::CConfigAlarmMotion(CWnd* pParent /*=NULL*/)\n\t: CDialog(CConfigAlarmMotion::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CConfigAlarmMotion)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_pDev = 0;\n\tmemset(m_motionCFG, 0, DH_MAX_VIDEO_IN_NUM*sizeof(DH_MOTION_DETECT_CFG));\n\tm_bReady = FALSE;\n\tm_chlIdx = -1;\n\tm_weekIdx = -1;\n\tm_ptzchlIdx = -1;\n\n\tm_dontsave = 0;\n}\n\nvoid CConfigAlarmMotion::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CConfigAlarmMotion)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CConfigAlarmMotion, CDialog)\n\t//{{AFX_MSG_MAP(CConfigAlarmMotion)\n\tON_CBN_SELCHANGE(IDC_COMBO_VIDEOCHL, OnSelchangeComboVideochl)\n\tON_WM_SHOWWINDOW()\n\tON_CBN_SELCHANGE(IDC_COMBO_ALARMWEEK, OnSelchangeComboAlarmweek)\n\tON_CBN_SELCHANGE(IDC_COMBO_ALARMPTZCHL, OnSelchangeComboAlarmptzchl)\n\tON_BN_CLICKED(IDC_BTN_AREA, OnBtnArea)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CConfigAlarmMotion message handlers\n\nvoid CConfigAlarmMotion::SetDevice(DeviceNode *pDev)\n{\n\tm_pDev = pDev;\n}\n\nvoid CConfigAlarmMotion::SetMotionCFG(DH_MOTION_DETECT_CFG *cfg)\n{\n\tif (!cfg)\n\t{\n\t\treturn;\n\t}\n\n\tmemcpy(m_motionCFG, cfg, DH_MAX_VIDEO_IN_NUM*sizeof(DH_MOTION_DETECT_CFG));\n\n\tDWORD dwActMask = m_motionCFG[0].struHandle.dwActionMask;\n\t//sentence if some functions enabled\n\tGetDlgItem(IDC_CHECK_UPLOAD)->EnableWindow((dwActMask & DH_ALARM_UPLOAD)?TRUE:FALSE);\n\tGetDlgItem(IDC_CHECK_LOCALTIP)->EnableWindow((dwActMask & DH_ALARM_TIP)?TRUE:FALSE);\n\tGetDlgItem(IDC_CHECK_LOCALTOUR)->EnableWindow((dwActMask & DH_ALARM_TOUR)?TRUE:FALSE);\n\tGetDlgItem(IDC_CHECK_SENDMAIL)->EnableWindow((dwActMask & DH_ALARM_MAIL)?TRUE:FALSE);\n\t\n\t//sentence if ptz enabled\n\tBOOL bPTZEn = (dwActMask & DH_ALARM_PTZ)?TRUE:FALSE;\n\tGetDlgItem(IDC_CHECK_PTZ)->EnableWindow(bPTZEn);\n\tGetDlgItem(IDC_COMBO_ALARMPTZCHL)->EnableWindow(bPTZEn);\n\tGetDlgItem(IDC_COMBO_ALARMPTZ)->EnableWindow(bPTZEn);\n\tGetDlgItem(IDC_EDIT_PTZNO)->EnableWindow(bPTZEn);\n\t\n\t//sentence if record enabled\n\tBOOL bRecEn = (dwActMask & DH_ALARM_RECORD)?TRUE:FALSE;\n\tGetDlgItem(IDC_CHECK_RECORD)->EnableWindow(bRecEn);\n\tfor (int i = 0; i < 16; i++)\n\t{\n\t\tGetDlgItem(IDC_CHECK_RECCH1+i)->EnableWindow(bRecEn);\n\t}\n\t\n\t//sentence if alarm output enabled\n\tBOOL bOutEn = (dwActMask & DH_ALARM_OUT)?TRUE:FALSE;\n\tGetDlgItem(IDC_CHECK_OUTPUT)->EnableWindow(bOutEn);\n\tfor (int j = 0; j < 16; j++)\n\t{\n\t\tGetDlgItem(IDC_CHECK_ALMOP1+j)->EnableWindow(bOutEn);\n\t}\n\t\n\tm_bReady = TRUE;\n}\n\nvoid CConfigAlarmMotion::ShowConfig()\n{\n\tif (!m_bReady)\n\t{\n\t\treturn;\n\t}\n\n\tif (((CComboBox*)GetDlgItem(IDC_COMBO_VIDEOCHL))->GetCount() < 0)\n\t{\n\t\treturn;\n\t}\n\n\t//show\n\t((CComboBox*)GetDlgItem(IDC_COMBO_VIDEOCHL))->SetCurSel(0);\n\tOnSelchangeComboVideochl();\n}\n\nvoid CConfigAlarmMotion::OnSelchangeComboVideochl() \n{\n\tif (!m_bReady)\n\t{\n\t\treturn;\n\t}\n\tint i,j,k;\n\n\t//save current config\n\tif (m_chlIdx < 0)\n\t{\n\t\tgoto skipsave;\n\t}\n\tm_motionCFG[m_chlIdx].byMotionEn = ((CButton*)GetDlgItem(IDC_CHECK_MOTIONENABLE))->GetCheck();\n\tm_motionCFG[m_chlIdx].wSenseLevel = GetDlgItemInt(IDC_EDIT_SENSELVL);\n\t\n\tif (m_weekIdx >= 0)\n\t{\n\t\tint secIdx = 0;\n\t\tfor (i = 0; i < 6; i++)\n\t\t{\n\t\t\tm_motionCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_motionCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_motionCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\t\n\t\t\tm_motionCFG[m_chlIdx].stSect[m_weekIdx][i].iEndHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_motionCFG[m_chlIdx].stSect[m_weekIdx][i].iEndMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_motionCFG[m_chlIdx].stSect[m_weekIdx][i].iEndSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t}\n\t}\n\t\n\tm_motionCFG[m_chlIdx].struHandle.dwActionFlag = 0;\n\tm_motionCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_UPLOAD))->GetCheck()?DH_ALARM_UPLOAD:0;\n\tm_motionCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_LOCALTIP))->GetCheck()?DH_ALARM_TIP:0;\n\tm_motionCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_LOCALTOUR))->GetCheck()?DH_ALARM_TOUR:0;\n\tm_motionCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_SENDMAIL))->GetCheck()?DH_ALARM_MAIL:0;\n\tm_motionCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_PTZ))->GetCheck()?DH_ALARM_PTZ:0;\n\tm_motionCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_RECORD))->GetCheck()?DH_ALARM_RECORD:0;\n\tm_motionCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_OUTPUT))->GetCheck()?DH_ALARM_OUT:0;\n\n\tfor (j = 0; j < m_pDev->Info.byAlarmOutPortNum; j++)\n\t{\n\t\tm_motionCFG[m_chlIdx].struHandle.byRelAlarmOut[j] = ((CButton*)GetDlgItem(IDC_CHECK_ALMOP1+j))->GetCheck();\n\t}\n\n\tfor (k = 0; k < m_pDev->Info.byChanNum; k++)\n\t{\n\t\tm_motionCFG[m_chlIdx].struHandle.byRecordChannel[k] = ((CButton*)GetDlgItem(IDC_CHECK_RECCH1+k))->GetCheck();\n\t}\n\n\tif (m_ptzchlIdx >= 0)\n\t{\n\t\tm_motionCFG[m_chlIdx].struHandle.struPtzLink[m_ptzchlIdx].iType = ((CComboBox*)GetDlgItem(IDC_CHECK_PTZ))->GetCurSel();\n\t\tm_motionCFG[m_chlIdx].struHandle.struPtzLink[m_ptzchlIdx].iValue = GetDlgItemInt(IDC_EDIT_PTZNO);\n\t}\n\t\nskipsave:\n\t//show new ones\n\tint chlIdx = ((CComboBox*)GetDlgItem(IDC_COMBO_VIDEOCHL))->GetCurSel();\n\tif (chlIdx < 0 || ((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->GetCount() < 0)\n\t{\n\t\treturn;\n\t}\n\n\tm_chlIdx = chlIdx;\n\t((CButton*)GetDlgItem(IDC_CHECK_MOTIONENABLE))->SetCheck(m_motionCFG[chlIdx].byMotionEn?1:0);\n\tSetDlgItemInt(IDC_EDIT_SENSELVL, m_motionCFG[chlIdx].wSenseLevel);\n\t\n\tif (((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->GetCount() > 0)\n\t{\n\t\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->SetCurSel(0);\n\t\tm_weekIdx = -1; //prevent from unwanted saving\n\t\tOnSelchangeComboAlarmweek() ;\n\t}\n\t\n\t((CButton*)GetDlgItem(IDC_CHECK_UPLOAD))->SetCheck((m_motionCFG[chlIdx].struHandle.dwActionFlag&DH_ALARM_UPLOAD)?1:0);\n\t((CButton*)GetDlgItem(IDC_CHECK_LOCALTIP))->SetCheck((m_motionCFG[chlIdx].struHandle.dwActionFlag&DH_ALARM_TIP)?1:0);\n\t((CButton*)GetDlgItem(IDC_CHECK_LOCALTOUR))->SetCheck((m_motionCFG[chlIdx].struHandle.dwActionFlag&DH_ALARM_TOUR)?1:0);\n\t((CButton*)GetDlgItem(IDC_CHECK_SENDMAIL))->SetCheck((m_motionCFG[chlIdx].struHandle.dwActionFlag&DH_ALARM_MAIL)?1:0);\n\t((CButton*)GetDlgItem(IDC_CHECK_PTZ))->SetCheck((m_motionCFG[chlIdx].struHandle.dwActionFlag&DH_ALARM_PTZ)?1:0);\n\t((CButton*)GetDlgItem(IDC_CHECK_RECORD))->SetCheck((m_motionCFG[chlIdx].struHandle.dwActionFlag&DH_ALARM_RECORD)?1:0);\n\t((CButton*)GetDlgItem(IDC_CHECK_OUTPUT))->SetCheck((m_motionCFG[chlIdx].struHandle.dwActionFlag&DH_ALARM_OUT)?1:0);\n\t\n\tfor (j = 0; j < m_pDev->Info.byAlarmOutPortNum; j++)\n\t{\n\t\t((CButton*)GetDlgItem(IDC_CHECK_ALMOP1+j))->SetCheck(m_motionCFG[chlIdx].struHandle.byRelAlarmOut[j]?1:0);\n\t}\n\n\tfor (k = 0; k < m_pDev->Info.byChanNum; k++)\n\t{\n\t\t((CButton*)GetDlgItem(IDC_CHECK_RECCH1+k))->SetCheck(m_motionCFG[chlIdx].struHandle.byRecordChannel[k]?1:0);\n\t}\n\n\tif (((CComboBox*)GetDlgItem(IDC_COMBO_ALARMPTZCHL))-> GetCount() > 0)\n\t{\n\t\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMPTZCHL))-> SetCurSel(0);\n\t\tm_ptzchlIdx = -1; //prevent from unwanted saving\n\t\tOnSelchangeComboAlarmptzchl();\n\t}\n}\n\nBOOL CConfigAlarmMotion::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\t\n\tif (!m_pDev)\n\t{\n\t\treturn TRUE;\n\t}\n\n\tCString strMotion;\n\tint i = 0;\n\tfor (i = 0; i < m_pDev->Info.byChanNum; i++)\n\t{\n\t\tstrMotion.Format(ConvertString(\"Channel %d\"), i+1);\n\t\t((CComboBox*)GetDlgItem(IDC_COMBO_VIDEOCHL))->InsertString(i, strMotion);\n\t}\n\tfor (int j = 15; j >= m_pDev->Info.byAlarmOutPortNum; j--)\n\t{\n\t\tGetDlgItem(IDC_CHECK_ALMOP1+j)->ShowWindow(SW_HIDE);\n\t}\n\tfor (int k = 15; k >= m_pDev->Info.byChanNum; k--)\n\t{\n\t\tGetDlgItem(IDC_CHECK_RECCH1+k)->ShowWindow(SW_HIDE);\n\t}\n\t\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(0, ConvertString(\"Sunday\"));\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(1, ConvertString(\"Monday\"));\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(2, ConvertString(\"Tuesday\"));\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(3, ConvertString(\"Wedensday\"));\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(4, ConvertString(\"Thursday\"));\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(5, ConvertString(\"Friday\"));\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(6, ConvertString(\"Saturday\"));\n\t\n\tCString strChl;\n\tfor (int l = 0; l < m_pDev->Info.byChanNum; l++)\n\t{\n\t\tstrChl.Format(\"channel %d\", i+1);\n\t\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMPTZCHL))->InsertString(i, strChl);\n\t}\t\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CConfigAlarmMotion::OnShowWindow(BOOL bShow, UINT nStatus) \n{\n\tCDialog::OnShowWindow(bShow, nStatus);\n\t\n\tShowConfig();\n}\n\nvoid CConfigAlarmMotion::OnSelchangeComboAlarmweek() \n{\n\tif (!m_bReady || m_chlIdx < 0)\n\t{\n\t\treturn;\n\t}\n\n\t//store current time sectors\n\tif (m_weekIdx >= 0)\n\t{\n\t\tint secIdx = 0;\n\t\tfor (int i = 0; i < 6; i++)\n\t\t{\n\t\t\tm_motionCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_motionCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_motionCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\t\n\t\t\tm_motionCFG[m_chlIdx].stSect[m_weekIdx][i].iEndHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_motionCFG[m_chlIdx].stSect[m_weekIdx][i].iEndMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_motionCFG[m_chlIdx].stSect[m_weekIdx][i].iEndSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t}\n\t}\n\n\t//show new time sectors\n\tint weekIdx = ((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->GetCurSel();\n\tif (weekIdx < 0)\n\t{\n\t\treturn;\n\t}\n\tm_weekIdx = weekIdx;\n\n\tint timeCtrlIdx = 0;\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_motionCFG[m_chlIdx].stSect[weekIdx][i].iBeginHour);\n\t\ttimeCtrlIdx++;\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_motionCFG[m_chlIdx].stSect[weekIdx][i].iBeginMin);\n\t\ttimeCtrlIdx++;\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_motionCFG[m_chlIdx].stSect[weekIdx][i].iBeginSec);\n\t\ttimeCtrlIdx++;\n\t\t\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_motionCFG[m_chlIdx].stSect[weekIdx][i].iEndHour);\n\t\ttimeCtrlIdx++;\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_motionCFG[m_chlIdx].stSect[weekIdx][i].iEndMin);\n\t\ttimeCtrlIdx++;\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_motionCFG[m_chlIdx].stSect[weekIdx][i].iEndSec);\n\t\ttimeCtrlIdx++;\n\t}\n}\n\nvoid CConfigAlarmMotion::OnSelchangeComboAlarmptzchl() \n{\n\tif (!m_bReady || m_chlIdx < 0)\n\t{\n\t\treturn;\n\t}\n\n\tif (m_ptzchlIdx >= 0)\n\t{\n\t\tm_motionCFG[m_chlIdx].struHandle.struPtzLink[m_ptzchlIdx].iType = ((CComboBox*)GetDlgItem(IDC_CHECK_PTZ))->GetCurSel();\n\t\tm_motionCFG[m_chlIdx].struHandle.struPtzLink[m_ptzchlIdx].iValue = GetDlgItemInt(IDC_EDIT_PTZNO);\n\t}\n\n\tint ptzchlIdx = ((CComboBox*)GetDlgItem(IDC_COMBO_ALARMPTZCHL))-> GetCount();\n\tif (ptzchlIdx < 0)\n\t{\n\t\treturn;\n\t}\n\tm_ptzchlIdx = ptzchlIdx;\n\t((CComboBox*)GetDlgItem(IDC_CHECK_PTZ))->SetCurSel(m_motionCFG[m_chlIdx].struHandle.struPtzLink[ptzchlIdx].iType);\n\tSetDlgItemInt(IDC_EDIT_PTZNO,m_motionCFG[m_chlIdx].struHandle.struPtzLink[ptzchlIdx].iValue);\n}\n\nvoid CConfigAlarmMotion::OnBtnArea() \n{\n\tCConfigAlarmMotionArea areaDlg;\n\tareaDlg.SetArea((BYTE*)m_motionCFG[m_chlIdx].byDetected);\n\tif (IDOK == areaDlg.DoModal())\n\t{\n\t\tmemcpy(m_motionCFG[m_chlIdx].byDetected, areaDlg.GetArea(), DH_MOTION_ROW*DH_MOTION_COL);\n\t}\n}\n\nvoid CConfigAlarmMotion::GetMotionCFG(DH_MOTION_DETECT_CFG *cfg)\n{\n\tif (!cfg || !m_bReady || m_chlIdx < 0)\n\t{\n\t\treturn;\n\t}\n\n\tm_motionCFG[m_chlIdx].byMotionEn = ((CButton*)GetDlgItem(IDC_CHECK_MOTIONENABLE))->GetCheck();\n\tm_motionCFG[m_chlIdx].wSenseLevel = GetDlgItemInt(IDC_EDIT_SENSELVL);\n\t\n\tif (m_weekIdx >= 0)\n\t{\n\t\tint secIdx = 0;\n\t\tfor (int i = 0; i < 6; i++)\n\t\t{\n\t\t\tm_motionCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_motionCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_motionCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\t\n\t\t\tm_motionCFG[m_chlIdx].stSect[m_weekIdx][i].iEndHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_motionCFG[m_chlIdx].stSect[m_weekIdx][i].iEndMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_motionCFG[m_chlIdx].stSect[m_weekIdx][i].iEndSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t}\n\t}\n\t\n\tm_motionCFG[m_chlIdx].struHandle.dwActionFlag = 0;\n\tm_motionCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_UPLOAD))->GetCheck()?DH_ALARM_UPLOAD:0;\n\tm_motionCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_LOCALTIP))->GetCheck()?DH_ALARM_TIP:0;\n\tm_motionCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_LOCALTOUR))->GetCheck()?DH_ALARM_TOUR:0;\n\tm_motionCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_SENDMAIL))->GetCheck()?DH_ALARM_MAIL:0;\n\tm_motionCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_PTZ))->GetCheck()?DH_ALARM_PTZ:0;\n\tm_motionCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_RECORD))->GetCheck()?DH_ALARM_RECORD:0;\n\tm_motionCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_OUTPUT))->GetCheck()?DH_ALARM_OUT:0;\n\n\tfor (int j = 0; j < m_pDev->Info.byAlarmOutPortNum; j++)\n\t{\n\t\tm_motionCFG[m_chlIdx].struHandle.byRelAlarmOut[j] = ((CButton*)GetDlgItem(IDC_CHECK_ALMOP1+j))->GetCheck();\n\t}\n\n\tfor (int k = 0; k < m_pDev->Info.byChanNum; k++)\n\t{\n\t\tm_motionCFG[m_chlIdx].struHandle.byRecordChannel[k] = ((CButton*)GetDlgItem(IDC_CHECK_RECCH1+k))->GetCheck();\n\t}\n\n\tif (m_ptzchlIdx >= 0)\n\t{\n\t\tm_motionCFG[m_chlIdx].struHandle.struPtzLink[m_ptzchlIdx].iType = ((CComboBox*)GetDlgItem(IDC_CHECK_PTZ))->GetCurSel();\n\t\tm_motionCFG[m_chlIdx].struHandle.struPtzLink[m_ptzchlIdx].iValue = GetDlgItemInt(IDC_EDIT_PTZNO);\n\t}\n\n\tmemcpy(cfg, m_motionCFG, DH_MAX_ALARM_IN_NUM*sizeof(DH_MOTION_DETECT_CFG));\n}\n\nvoid CConfigAlarmMotion::UndoAll()\n{\n\tm_bReady = FALSE;\n\tm_chlIdx = -1;\n\tm_weekIdx = -1;\n\tm_ptzchlIdx = -1;\n}\n","size_bytes":14861},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/User_ModifyGroup.cpp":{"content":"// User_ModifyGroup.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"User_ModifyGroup.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CUser_ModifyGroup dialog\n\n\nCUser_ModifyGroup::CUser_ModifyGroup(CWnd* pParent /*=NULL*/)\n\t: CDialog(CUser_ModifyGroup::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CUser_ModifyGroup)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\n\tm_user_info = NULL;\n\tm_dev = NULL;\n\tm_nGroupIndex = 0;\n}\n\n\nvoid CUser_ModifyGroup::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CUser_ModifyGroup)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CUser_ModifyGroup, CDialog)\n\t//{{AFX_MSG_MAP(CUser_ModifyGroup)\n\tON_BN_CLICKED(IDC_BTN_OK, OnBtnOk)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CUser_ModifyGroup message handlers\n\nBOOL CUser_ModifyGroup::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\t\n\tCRect rect;\n\tGetDlgItem(IDC_RLIST_FRAME)->GetClientRect(&rect);\n\tGetDlgItem(IDC_RLIST_FRAME)->ClientToScreen(&rect);\n\tScreenToClient(&rect);\n\t\n\tBOOL bCreate = m_rightList.Create(WS_VISIBLE | WS_TABSTOP | WS_CHILD | WS_BORDER\n\t\t| TVS_HASBUTTONS | TVS_LINESATROOT | TVS_HASLINES \n\t\t| TVS_DISABLEDRAGDROP, rect, this, 0x1005);\n\t\n\tSetWindowLong(m_rightList.m_hWnd, GWL_STYLE, TVS_CHECKBOXES);\n\t\n\tm_rightList.ShowWindow(SW_SHOW);\n\t\n\tif (!m_user_info || !m_dev)\n\t{\n\t\treturn TRUE;\n\t}\n\t\n\tint i;\n\tCString strRight;\n    HTREEITEM hRoot;\n\tfor (i = 0; i < m_user_info->dwRightNum; i++)\n\t{\n        strRight.Format(\"%d: %s: %s\", m_user_info->rightList[i].dwID, m_user_info->rightList[i].name, m_user_info->rightList[i].memo);\n\t\thRoot = m_rightList.InsertItem(strRight, 0, 0, TVI_ROOT);\n\t\tm_rightList.SetItemData(hRoot, m_user_info->rightList[i].dwID);\n\t}\n\t\n\tRefreshRightList(m_user_info->groupListEx[m_nGroupIndex].rights);\n\t\n\tGetDlgItem(IDC_GPNAME_OLD_EDIT)->SetWindowText(m_user_info->groupListEx[m_nGroupIndex].name);\n\tGetDlgItem(IDC_GPNAME_NEW_EDIT)->SetWindowText(m_user_info->groupListEx[m_nGroupIndex].name);\n\tGetDlgItem(IDC_GPMEMO_OLD_EDIT)->SetWindowText(m_user_info->groupListEx[m_nGroupIndex].memo);\n\tGetDlgItem(IDC_GPMEMO_NEW_EDIT)->SetWindowText(m_user_info->groupListEx[m_nGroupIndex].memo);\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CUser_ModifyGroup::SetEnvrmt(USER_MANAGE_INFO_NEW *info, DWORD gpIdx, DeviceNode *dev)\n{\n\tm_dev = dev;\n\tm_user_info = info;\n\tm_nGroupIndex = gpIdx;\n}\n\nvoid CUser_ModifyGroup::OnBtnOk() \n{\n\tUSER_GROUP_INFO_EX2 gpInfo = { sizeof(USER_GROUP_INFO_EX2)};\n\tgpInfo.dwID = m_user_info->groupListEx[m_nGroupIndex].dwID;\n\tGetDlgItem(IDC_GPNAME_NEW_EDIT)->GetWindowText(gpInfo.name, DH_NEW_USER_NAME_LENGTH);\n\tGetDlgItem(IDC_GPMEMO_NEW_EDIT)->GetWindowText(gpInfo.memo, DH_MEMO_LENGTH);\n\t\n\tint count = m_rightList.GetCount();\n\tHTREEITEM node = m_rightList.GetRootItem();\n\tint rIndex = 0;\n    bool bSelect = false;\n\tfor (int i=0; i<count && node; i++)\n\t{\n\t\tif (m_rightList.GetCheck(node))\n\t\t{\n\t\t\tgpInfo.rights[rIndex] = m_rightList.GetItemData(node);\n\t\t\trIndex++;\n            bSelect  = true;\n\t\t}\n\t\tnode = m_rightList.GetNextItem(node, TVGN_NEXT);\n\t}\n\tgpInfo.dwRightNum = rIndex;\n    if (bSelect == false)\n    {\n        MessageBox(ConvertString(\"Please select at least one right\"));\n        return;\n    }\n\tBOOL bRet = CLIENT_OperateUserInfoNew(m_dev->LoginID, 9, &gpInfo, &m_user_info->groupListEx[m_nGroupIndex], NULL, MAX_TIMEOUT);\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Modify group failed!\"));\n\t}\n\telse\n\t{\n\t\tEndDialog(0);\n\t}\n}\n\nvoid CUser_ModifyGroup::RefreshRightList(DWORD *dwList)\n{\n    int count = m_rightList.GetCount();\n    HTREEITEM node = m_rightList.GetRootItem();\n\n    for (int i = 0; i<count; i++)\n    {\n        m_rightList.SetCheck(node, FALSE);\n        node = m_rightList.GetNextItem(node, TVGN_NEXT);\n    }\n\n    for (int i = 0; i < count; i++)\n    {\n        if(dwList[i] == 0)\n            continue;\n        node = m_rightList.GetRootItem();\n        for (int j = 0;j < count; j++)\n        {\n            if (dwList[i] == m_user_info->rightList[j].dwID)\n            {\n                m_rightList.SetCheck(node, TRUE);         \n                break;\n            }\n            node = m_rightList.GetNextItem(node, TVGN_NEXT);               \n        }\n    }\n}\n","size_bytes":4601},"bin/DemoSrc/playsdkdemo/StdAfx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n//\tPlayDemo.pch will be the pre-compiled header\n//\tstdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n#include \"CharactorTansfer.h\"\n\nCString GetMoudlePath()\n{\n\tTCHAR szAppName[MAX_PATH];\n\tTCHAR szDir[MAX_PATH];\n\tTCHAR szDrive[MAX_PATH];\n\tGetModuleFileName(GetModuleHandle(NULL), szAppName, MAX_PATH);\n\t_tsplitpath(szAppName, szDrive, szDir, NULL, NULL);\n\n\tTCHAR szPath[MAX_PATH];\n\t_tmakepath(szPath, szDrive, szDir, NULL, NULL);\n\n\treturn szPath;\n}\n\n","size_bytes":546},"bin/Demo/MfcDemo/10.AlarmDevice/DlgSetArmMode.cpp":{"content":"// DlgSetArmMode.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgSetArmMode.h\"\n#include \"SubDlgSensorInfoDescription.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgSetArmMode dialog\n\n\nCDlgSetArmMode::CDlgSetArmMode(CWnd* pParent /*=NULL*/, LLONG lLoginId /*=0*/)\n\t: CDialog(CDlgSetArmMode::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgSetArmMode)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_lLoginId = lLoginId;\n    memset(&m_stuOut, 0, sizeof(m_stuOut));\n    m_stuOut.dwSize = sizeof(m_stuOut);\n}\n\n\nvoid CDlgSetArmMode::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgSetArmMode)\n\tDDX_Control(pDX, IDC_SETARMMODE_COMBO_SCENE, m_cmbScene);\n\tDDX_Control(pDX, IDC_SETARMMODE_COMBO_MODE, m_cmbMode);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgSetArmMode, CDialog)\n\t//{{AFX_MSG_MAP(CDlgSetArmMode)\n\tON_BN_CLICKED(IDC_SETARMMODE_BTN_SET, OnSetarmmodeBtnSet)\n\tON_BN_CLICKED(IDC_SETARMMODE_BTN_ALARMSOURCE, OnSetarmmodeBtnAlarmSource)\n\tON_BN_CLICKED(IDC_SETARMMODE_BTN_ALARMLINK, OnSetarmmodeBtnAlarmLink)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgSetArmMode message handlers\n\nBOOL CDlgSetArmMode::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\n\t// TODO: Add extra initialization here\n\tg_SetWndStaticText(this, DLG_SETAMRMODE);\n\t\n\tif (m_lLoginId == 0)\n\t{\n\t\tMessageBox(ConvertString(CString(\"we haven't login a device yet!\"), DLG_SETAMRMODE), ConvertString(\"Prompt\"));\n\t\treturn TRUE;\n\t}\n\t\n\tm_cmbMode.ResetContent();\n\tm_cmbMode.InsertString(-1, ConvertString(\"Unknown\", DLG_SETAMRMODE));\n\tm_cmbMode.InsertString(-1, ConvertString(\"Disarming\", DLG_SETAMRMODE));\n\tm_cmbMode.InsertString(-1, ConvertString(\"Arming\", DLG_SETAMRMODE));\n    m_cmbMode.InsertString(-1, ConvertString(\"ForceArming\", DLG_SETAMRMODE));\n\tm_cmbMode.SetCurSel(0);\n\n\tm_cmbScene.ResetContent();\n\tm_cmbScene.InsertString(-1, ConvertString(\"Unknown\", DLG_SETAMRMODE));\n\tm_cmbScene.InsertString(-1, ConvertString(\"Outdoor\", DLG_SETAMRMODE));\n\tm_cmbScene.InsertString(-1, ConvertString(\"Indoor\", DLG_SETAMRMODE));\n    m_cmbScene.InsertString(-1, ConvertString(\"Whole\", DLG_SETAMRMODE));\n\tm_cmbScene.InsertString(-1, ConvertString(\"RightNow\", DLG_SETAMRMODE));\n\tm_cmbScene.SetCurSel(0);\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t// EXCEPTION: OCX Property Pages should return FALSE\n}\nvoid CDlgSetArmMode::OnSetarmmodeBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n\tif (m_lLoginId == 0)\n\t{\n\t\tMessageBox(ConvertString(CString(\"we haven't login a device yet!\"), DLG_SETAMRMODE), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tCString csPsw;\n\tGetDlgItemText(IDC_SETARMMODE_EDT_PASSWORD, csPsw);\n\t\n\tCTRL_ARM_DISARM_PARAM_EX stuParam = {sizeof(stuParam)};\n    stuParam.stuIn.dwSize = sizeof(stuParam.stuIn);\n    stuParam.stuOut.dwSize = sizeof(stuParam.stuOut);\n\t\n\tstuParam.stuIn.emState = (NET_ALARM_MODE)(m_cmbMode.GetCurSel() - 1);\n\tstuParam.stuIn.emSceneMode = (NET_SCENE_MODE)m_cmbScene.GetCurSel();\t\n\tstuParam.stuIn.szDevPwd = csPsw.GetBuffer(0);\n\tBOOL bRet = CLIENT_ControlDevice(m_lLoginId, DH_CTRL_ARMED_EX, &stuParam, SDK_API_WAIT);\n\tif (bRet)\n    {\n        MessageBox(ConvertString(\"Set Arm Mode successfully.\", DLG_SETAMRMODE), ConvertString(\"Prompt\"));\n        m_stuOut.dwSourceNum = 0;\n        m_stuOut.dwLinkNum = 0;\n\t}\n    else\n    {\n        CString csOut;\n        csOut.Format(\"%s %08x\", ConvertString(\"Set Arm Mode failed:\", DLG_SETAMRMODE), CLIENT_GetLastError());\n        MessageBox(csOut, ConvertString(\"Prompt\"));\n\n        int i = 0;\n        \n        m_stuOut.dwSourceNum = stuParam.stuOut.dwSourceNum;\n        for (; i < sizeof(m_stuOut.nSource)/sizeof(m_stuOut.nSource[0]); i++)\n        {\n            m_stuOut.nSource[i] = stuParam.stuOut.nSource[i];\n        }\n        \n        m_stuOut.dwLinkNum = stuParam.stuOut.dwLinkNum;\n        for (i = 0; i < sizeof(m_stuOut.nLink)/sizeof(m_stuOut.nLink[0]); i++)\n        {\n            m_stuOut.nLink[i] = stuParam.stuOut.nLink[i];\n        }\n    }\n}\n\nvoid CDlgSetArmMode::OnSetarmmodeBtnAlarmSource() \n{\n\t// TODO: Add your control notification handler code here\n    std::vector<int> vecChn;\n    int i = 0;\n    for (; i < m_stuOut.dwSourceNum; i++)\n    {\n        vecChn.push_back(m_stuOut.nSource[i]);\n    }\n    \n    CSubDlgSensorInfoDescription dlg(this, ARM_DISARM_ZONE_MAX);\n\tdlg.SetID(vecChn);\n    dlg.DoModal();\n}\n\nvoid CDlgSetArmMode::OnSetarmmodeBtnAlarmLink() \n{\n\t// TODO: Add your control notification handler code here    \n    std::vector<int> vecChn;\n    int i = 0;\n    for (; i < m_stuOut.dwLinkNum; i++)\n    {\n        vecChn.push_back(m_stuOut.nLink[i]);\n    }\n    \n    CSubDlgSensorInfoDescription dlg(this, ARM_DISARM_ZONE_MAX);\n    dlg.SetID(vecChn);\n    dlg.DoModal();\n}\n","size_bytes":4979},"bin/Demo/MfcDemo/13.FaceRecognition/QueryDownLoad.cpp":{"content":"// QueryDownLoad.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"FaceRecognition.h\"\n#include \"QueryDownLoad.h\"\n\n#define QUERY_FILE_NUM\t50\n#define\tPATH_MAX_LEN\t1024\n#define FILEDOWNLOAD_TIMER_MSEC 62.5\n#define WM_DOWNLOAD_CALLBACK\t(WM_USER + 301)\n\nstruct\tstrCallBackInfo\n{\n\tLLONG lHandle;\n\tDWORD dwTotalSize;\n\tDWORD dwDownLoadSize;\n};\n\nvoid CALLBACK DownLoadPosCallBack(LLONG lPlayHandle, DWORD dwTotalSize, DWORD dwDownLoadSize, LDWORD dwUser)\n{\n\tCQueryDownLoad *dlg = (CQueryDownLoad*)dwUser;\n\tif (dlg == NULL)\n\t{\n\t\treturn;\n\t}\n\tHWND hwnd = dlg->GetSafeHwnd();\n\n\tstrCallBackInfo *pInfo = new strCallBackInfo;\n\tpInfo->lHandle = lPlayHandle;\n\tpInfo->dwTotalSize = dwTotalSize;\n\tpInfo->dwDownLoadSize = dwDownLoadSize;\n\n\t::PostMessage(hwnd, WM_DOWNLOAD_CALLBACK, WPARAM(pInfo) , 0);\n}\n\nIMPLEMENT_DYNAMIC(CQueryDownLoad, CDialog)\n\nCQueryDownLoad::CQueryDownLoad(int nChannelNum, LLONG lLoginid, char *pSoftPath, CWnd* pParent /*=NULL*/)\n: CDialog(CQueryDownLoad::IDD, pParent)\n, m_nChannelNum(nChannelNum)\n, m_lLogin(lLoginid)\n, m_nPage(0)\n, m_lFindHandle(0)\n, m_emQuryType(QUERY_VIDEO)\n, m_playBackHandle(0)\n, m_nTimer(0)\n, m_dwPlayBackTotalSize(0)\n, m_dwPlayBackCurValue(0)\n, m_dwDownLoadCurValue(0)\n, m_dwDownLoadTotalSize(0)\n, m_lDownLoadHandle(0)\n, m_nInfoCount(0)\n, m_pSoftPath(NULL)\n{\n\tif (pSoftPath)\n\t{\n\t\tm_pSoftPath = pSoftPath;\n\t}\n\n\tmemset(&m_DateStart, 0, sizeof(m_DateStart));\n\tmemset(&m_DateEnd, 0, sizeof(m_DateEnd));\n\tm_emSex = EM_DEV_EVENT_FACEDETECT_SEX_TYPE_UNKNOWN;\n\tm_emGlasses = EM_FACEDETECT_GLASSES_UNKNOWN;\n\tm_emMask = EM_MASK_STATE_UNKNOWN;\n\tm_emBeard = EM_BEARD_STATE_UNKNOWN;\n\tmemset(&m_nAge, 0, sizeof(m_nAge) );\n\tmemset(&m_nSimilaryRange, 0, sizeof(m_nSimilaryRange));\n\tm_nQueryType = 0;\n\tm_nAttributeFlag = 0;\n\tm_emEmotion = EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_UNKNOWN;\n}\n\nCQueryDownLoad::~CQueryDownLoad()\n{\n\tClearQueryResultInfoVector();\n\tCloseFindHandle();\n\tClosePlayBackHandle();\n\tCloseDownLoadHandle();\n}\n\nvoid CQueryDownLoad::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\tDDX_Control(pDX, IDC_LIST_QUERY_RESULT, m_lcQueryResult);\n\tDDX_Control(pDX, IDC_COMBO_CHANNEL_QUERY, m_comboQueryChannel);\n\tDDX_Control(pDX, IDC_COMBO_ALARM_TYPE, m_comboEventType);\n\tDDX_Control(pDX, IDC_COMBO_FILE_TYPE, m_comboFileType);\n\tDDX_Control(pDX, IDC_PROGRESS_QUERY2, m_PlayBackProcess);\n\tDDX_Control(pDX, IDC_PROGRESS_QUERY, m_ProcessDownLoad);\n\tDDX_Control(pDX, IDC_COMBO_QUERY_SEX, m_comboSex);\n\tDDX_Control(pDX, IDC_COMBO_QUERY_GLASSES, m_comboGlasses);\n\tDDX_Control(pDX, IDC_COMBO_QUERY_MASK, m_comboMask);\n\tDDX_Control(pDX, IDC_COMBO_QUERY_BREAD, m_comboBeard);\n\tDDX_Control(pDX, IDC_CHECK_ATTRIBUTE_ENABLE, m_AttributeEnable);\n\tDDX_Control(pDX, IDC_COMBO_QUERY_EMOTION, m_comboEmotion);\n}\n\n\nBEGIN_MESSAGE_MAP(CQueryDownLoad, CDialog)\n\tON_BN_CLICKED(IDC_BUTTON_QUERY_START, &CQueryDownLoad::OnBnClickedButtonQueryStart)\n\tON_CBN_SELCHANGE(IDC_COMBO_FILE_TYPE, &CQueryDownLoad::OnCbnSelchangeComboFileType)\n\tON_BN_CLICKED(IDC_BUTTON_QUERY_PREPAGE, &CQueryDownLoad::OnBnClickedButtonQueryPrepage)\n\tON_BN_CLICKED(IDC_BUTTON_QUERY_DOWNLOAD, &CQueryDownLoad::OnBnClickedButtonQueryDownload)\n\tON_BN_CLICKED(IDC_BUTTON_QUERY_NEXTPAGE, &CQueryDownLoad::OnBnClickedButtonQueryNextpage)\n\tON_NOTIFY(NM_DBLCLK, IDC_LIST_QUERY_RESULT, &CQueryDownLoad::OnLvnItemchangedListQueryResult)\n\n\tON_MESSAGE(WM_DOWNLOAD_CALLBACK, &CQueryDownLoad::OnDoDownLoad)\n\tON_WM_TIMER()\n\tON_BN_CLICKED(IDC_CHECK_ATTRIBUTE_ENABLE, &CQueryDownLoad::OnBnClickedCheckAttributeEnable)\n\tON_CBN_SELCHANGE(IDC_COMBO_ALARM_TYPE, &CQueryDownLoad::OnCbnSelchangeComboAlarmType)\nEND_MESSAGE_MAP()\n\nBOOL CQueryDownLoad::OnInitDialog()\n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\tInitControl();\n\t\n\tm_comboEventType.ResetContent();\n\tm_comboEventType.AddString(ConvertString(\"FaceEvent\"));\n\tm_comboEventType.SetCurSel(0);\n\n\tGetDlgItem(IDC_BUTTON_QUERY_DOWNLOAD)->EnableWindow(FALSE);\n\tGetDlgItem(IDC_BUTTON_QUERY_NEXTPAGE)->EnableWindow(FALSE);\n\tGetDlgItem(IDC_BUTTON_QUERY_PREPAGE)->EnableWindow(FALSE);\n\n\tm_PlayBackProcess.SetRange32(0,(int)(m_dwPlayBackTotalSize));\n\tm_PlayBackProcess.SetPos(0);\n\n\tm_ProcessDownLoad.SetRange32(0, (int)m_dwDownLoadTotalSize/1024);\n\tm_ProcessDownLoad.SetPos(0);\n\tif (0 == m_nTimer)\n\t{\n\t\tm_nTimer = SetTimer(1, FILEDOWNLOAD_TIMER_MSEC, NULL);\n\t}\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n}\n\nvoid CQueryDownLoad::InitControl()\n{\n\tm_lcQueryResult.SetExtendedStyle(m_lcQueryResult.GetExtendedStyle() | LVS_EX_HEADERDRAGDROP | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);\n\tm_lcQueryResult.InsertColumn(0,ConvertString(\"Index\"),LVCFMT_LEFT,50,-1);\n\tm_lcQueryResult.InsertColumn(1,ConvertString(\"Channel\"),LVCFMT_LEFT,50,0);\n\tm_lcQueryResult.InsertColumn(2,ConvertString(\"Start Time\"),LVCFMT_LEFT,150,1);\n\tm_lcQueryResult.InsertColumn(3, ConvertString(\"End Time\"), LVCFMT_LEFT,150,2);\n\n\tm_comboFileType.ResetContent();\n\tm_comboFileType.AddString(ConvertString(\"Video\"));\n\tm_comboFileType.AddString(ConvertString(\"Picture\"));\n\tm_comboFileType.SetCurSel(0);\n\n\tm_comboQueryChannel.ResetContent();\n\tm_comboQueryChannel.AddString(ConvertString(\"All\"));\n\tfor(int i=0;i<m_nChannelNum;i++)\n\t{\n\t\tCString str;\n\t\tstr.Format(\"%d\",i + 1);\n\t\tm_comboQueryChannel.AddString(str);\n\t}\n\tm_comboQueryChannel.SetCurSel(0);\n\n\tm_comboGlasses.ResetContent();\n\tm_comboGlasses.AddString(ConvertString(\"Unknown\"));\n\tm_comboGlasses.AddString(ConvertString(\"Not Wear\"));\n\tm_comboGlasses.AddString(ConvertString(\"Wear\"));\n\tm_comboGlasses.SetItemData(0, (DWORD_PTR)EM_FACEDETECT_GLASSES_UNKNOWN);\n\tm_comboGlasses.SetItemData(1, (DWORD_PTR)EM_FACEDETECT_WITHOUT_GLASSES);\n\tm_comboGlasses.SetItemData(2, (DWORD_PTR)EM_FACEDETECT_WITH_GLASSES);\n\tm_comboGlasses.SetCurSel(0);\n\n\tm_comboMask.ResetContent();\n\tm_comboMask.AddString(ConvertString(\"Unknown\"));\n\tm_comboMask.AddString(ConvertString(\"Not Wear\"));\n\tm_comboMask.AddString(ConvertString(\"Wear\"));\n\tm_comboMask.SetItemData(0, (DWORD_PTR)EM_MASK_STATE_UNKNOWN);\n\tm_comboMask.SetItemData(1, (DWORD_PTR)EM_MASK_STATE_NOMASK);\n\tm_comboMask.SetItemData(2, (DWORD_PTR)EM_MASK_STATE_WEAR);\n\tm_comboMask.SetCurSel(0);\n\n\tm_comboSex.ResetContent();\n\tm_comboSex.AddString(ConvertString(\"Unknown\"));\n\tm_comboSex.AddString(ConvertString(\"Male\"));\n\tm_comboSex.AddString(ConvertString(\"Female\"));\n\tm_comboSex.SetItemData(0, (DWORD_PTR)EM_DEV_EVENT_FACEDETECT_SEX_TYPE_UNKNOWN);\n\tm_comboSex.SetItemData(1, (DWORD_PTR)EM_DEV_EVENT_FACEDETECT_SEX_TYPE_MAN);\n\tm_comboSex.SetItemData(2, (DWORD_PTR)EM_DEV_EVENT_FACEDETECT_SEX_TYPE_WOMAN);\n\tm_comboSex.SetCurSel(0);\n\n\tm_comboBeard.ResetContent();\n\tm_comboBeard.AddString(ConvertString(\"Unknown\"));\n\tm_comboBeard.AddString(ConvertString(\"No Beard\"));\n\tm_comboBeard.AddString(ConvertString(\"Have Beard\"));\n\tm_comboBeard.SetItemData(0, (DWORD_PTR)EM_BEARD_STATE_UNKNOWN);\n\tm_comboBeard.SetItemData(1, (DWORD_PTR)EM_BEARD_STATE_NOBEARD);\n\tm_comboBeard.SetItemData(2, (DWORD_PTR)EM_BEARD_STATE_HAVEBEARD);\n\tm_comboBeard.SetCurSel(0);\n\n\tm_comboEmotion.ResetContent();\n\tm_comboEmotion.AddString(ConvertString(\"Unknown\"));\n\tm_comboEmotion.AddString(ConvertString(\"Wear glasses\"));\n\tm_comboEmotion.AddString(ConvertString(\"Smile\"));\n\tm_comboEmotion.AddString(ConvertString(\"Anger\"));\n\tm_comboEmotion.AddString(ConvertString(\"Sadness\"));\n\tm_comboEmotion.AddString(ConvertString(\"Disgust\"));\n\tm_comboEmotion.AddString(ConvertString(\"Fear\"));\n\tm_comboEmotion.AddString(ConvertString(\"Surprise\"));\n\tm_comboEmotion.AddString(ConvertString(\"Neutral\"));\n\tm_comboEmotion.AddString(ConvertString(\"Laugh\"));\n\tm_comboEmotion.AddString(ConvertString(\"No glasses\"));\n\tm_comboEmotion.AddString(ConvertString(\"Happy\"));\n\tm_comboEmotion.AddString(ConvertString(\"Confused\"));\n\tm_comboEmotion.AddString(ConvertString(\"Scream\"));\n\tm_comboEmotion.AddString(ConvertString(\"Wear Sunglasses\"));\n\n\tm_comboEmotion.SetItemData(0, (DWORD_PTR)EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_UNKNOWN);\n\tm_comboEmotion.SetItemData(1, (DWORD_PTR)EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_WEAR_GLASSES);\n\tm_comboEmotion.SetItemData(2, (DWORD_PTR)EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_SMILE);\n\tm_comboEmotion.SetItemData(3, (DWORD_PTR)EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_ANGER);\n\tm_comboEmotion.SetItemData(4, (DWORD_PTR)EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_SADNESS);\n\tm_comboEmotion.SetItemData(5, (DWORD_PTR)EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_DISGUST);\n\tm_comboEmotion.SetItemData(6, (DWORD_PTR)EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_FEAR);\n\tm_comboEmotion.SetItemData(7, (DWORD_PTR)EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_SURPRISE);\n\tm_comboEmotion.SetItemData(8, (DWORD_PTR)EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_NEUTRAL);\n\tm_comboEmotion.SetItemData(9, (DWORD_PTR)EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_LAUGH);\n\tm_comboEmotion.SetItemData(10, (DWORD_PTR)EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_NOGLASSES);\n\tm_comboEmotion.SetItemData(11, (DWORD_PTR)EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_HAPPY);\n\tm_comboEmotion.SetItemData(12, (DWORD_PTR)EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_CONFUSED);\n\tm_comboEmotion.SetItemData(13, (DWORD_PTR)EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_SCREAM);\n\tm_comboEmotion.SetItemData(14, (DWORD_PTR)EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_WEAR_SUNGLASSES);\n\t\n\tm_comboEmotion.SetCurSel(0);\n}\n\nvoid CQueryDownLoad::OnCbnSelchangeComboFileType()\n{\n\tint nSel = m_comboFileType.GetCurSel();\n\tif (m_comboFileType.GetCurSel() == 0)\n\t{\n\t\tm_comboEventType.ResetContent();\n\t\tm_comboEventType.AddString(ConvertString(\"FaceEvent\"));\n\t\tm_comboEventType.SetCurSel(0);\n\n\t\tGetDlgItem(IDC_CHECK_ATTRIBUTE_ENABLE)->EnableWindow(FALSE);\n\n\t}\n\telse if (m_comboFileType.GetCurSel() == 1)\n\t{\n\t\tm_comboEventType.ResetContent();\n\n\t\tm_comboEventType.AddString(ConvertString(\"FaceDetection\"));\n\t\tm_comboEventType.AddString(ConvertString(\"FaceRecognition\"));\n\n\t\tm_comboEventType.SetCurSel(0);\n\n\t\tGetDlgItem(IDC_CHECK_ATTRIBUTE_ENABLE)->EnableWindow(TRUE);\n\t}\n}\n\nvoid CQueryDownLoad::ReceivePlayPos(LLONG lPlayHandle, DWORD dwTotalSize, DWORD dwDownLoadSize)\n{\n\tif (lPlayHandle == m_playBackHandle)\n\t{\n\t\tif (dwDownLoadSize == -1)\n\t\t{\n\t\t\tClosePlayBackHandle();\n\t\t\tm_dwPlayBackCurValue = 100;\n\t\t\tm_dwPlayBackTotalSize = 100;\n\t\t\tClosePlayBackHandle();\n\t\t\tFillCWndWithDefaultColor(GetDlgItem(IDC_STATIC_REALPLAY_PIC));\n\t\t\treturn;\n\t\t}\n\t\tm_dwPlayBackTotalSize = dwTotalSize;\n\t\tm_dwPlayBackCurValue = dwDownLoadSize;\n\t}\n\telse if (lPlayHandle == m_lDownLoadHandle)\n\t{\n\t\tif (dwDownLoadSize == -1)\n\t\t{\n\t\t\tm_dwDownLoadTotalSize = 100;\n\t\t\tm_dwDownLoadCurValue = 100;\n\t\t\tMessageBox(ConvertString(\"Download file success!\"), ConvertString(\"Prompt\"));\n\t\t\tGetDlgItem(IDC_BUTTON_QUERY_DOWNLOAD)->EnableWindow(TRUE);\n\t\t\tCloseDownLoadHandle();\n\t\t\treturn;\n\t\t}\n\t\tm_dwDownLoadTotalSize = dwTotalSize;\n\t\tm_dwDownLoadCurValue = dwDownLoadSize;\n\t}\n}\n\nemQueryType CQueryDownLoad::getCurrentQueryType()\n{\n\temQueryType emRet = QUERY_VIDEO;\n\n\tif (m_comboFileType.GetCurSel() == 0)\n\t{\n\t\temRet = QUERY_VIDEO;\n\t}\n\n\tif (m_comboFileType.GetCurSel() == 1 && m_comboEventType.GetCurSel() == 0)\n\t{\n\t\temRet = QUERY_PICFD;\n\t}\n\n\tif (m_comboFileType.GetCurSel() == 1 && m_comboEventType.GetCurSel() == 1)\n\t{\n\t\temRet = QUERY_PICFR;\n\t}\n\n\treturn emRet;\n}\n\nvoid CQueryDownLoad::OnBnClickedButtonQueryStart()\n{\n\tif (m_lLogin == NULL)\n\t{\n\t\tMessageBox(ConvertString(\"Invalid Login Handle\"), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tCloseFindHandle();\n\tClearQueryResultInfoVector();\n\tm_lcQueryResult.DeleteAllItems();\n\tm_nInfoCount = 0;\n\tm_nPage = 0;\n\n\tint tcheck = m_AttributeEnable.GetCheck();\n\tif (tcheck == BST_CHECKED)\n\t{\n\t\tm_nQueryType = 1;\n\t}\n\telse\n\t{\n\t\tm_nQueryType = 0;\n\t}\n\n\tGetTimeFromUI();\n\tBOOL bRet = GetAttributeFromUI();\n\tif (FALSE == bRet)\n\t{\n\t\tGetDlgItem(IDC_BUTTON_QUERY_PREPAGE)->EnableWindow(FALSE);\n\t\treturn ;\n\t}\n\tBOOL bFind = FALSE;\n\n\tm_emQuryType = getCurrentQueryType();\n\t//query picture by event\n\tif (m_nQueryType == 0)\n\t{\n\t\tif (m_emQuryType == QUERY_VIDEO)\n\t\t{\n\t\t\tbFind = FindFaceVideo();\n\t\t}\n\t\telse if(m_emQuryType == QUERY_PICFD)\n\t\t{\n\t\t\tbFind = FindFaceEventPicture(EVENT_IVS_FACEDETECT);\n\t\t}\n\t\telse if(m_emQuryType == QUERY_PICFR)\n\t\t{\n\t\t\tbFind = FindFaceEventPicture(EVENT_IVS_FACERECOGNITION);\n\t\t}\n\t}\n\n\t//query picture by attribute\n\telse\n\t{\n\t\tif(m_emQuryType == QUERY_PICFD)\n\t\t{\n\t\t\tbFind = FindFaceDetectionPicture();\n\t\t}\n\t\telse if(m_emQuryType == QUERY_PICFR)\n\t\t{\n\t\t\tbFind = FindFaceRecognitionPicture();\n\t\t}\n\t}\n\n\tif (bFind == TRUE)\n\t{\n\t\tint nSearchCount = DoFindNextPageEx(QUERY_FILE_NUM + 1);\n\t\tif (nSearchCount == (QUERY_FILE_NUM + 1) )\n\t\t{\n\t\t\tGetDlgItem(IDC_BUTTON_QUERY_NEXTPAGE)->EnableWindow(TRUE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tGetDlgItem(IDC_BUTTON_QUERY_NEXTPAGE)->EnableWindow(FALSE);\n\t\t}\n\t\tif (nSearchCount > 0)\n\t\t{\n\t\t\tGetDlgItem(IDC_BUTTON_QUERY_DOWNLOAD)->EnableWindow(TRUE);\n\t\t}\n\t}\n\n\tGetDlgItem(IDC_BUTTON_QUERY_PREPAGE)->EnableWindow(FALSE);\n}\n\nBOOL CQueryDownLoad::FindFaceVideo()\n{\n\tNET_IN_MEDIA_QUERY_FILE strMidiaQueryParam;\n\tmemset(&strMidiaQueryParam, 0, sizeof(strMidiaQueryParam));\n\n\tstrMidiaQueryParam.dwSize = sizeof(strMidiaQueryParam);\n\tstrMidiaQueryParam.nMediaType = 2;\t\t\t\t\t//set video search type\n\tstrMidiaQueryParam.nChannelID = m_comboQueryChannel.GetCurSel() - 1;\t//-1 means all channel\n\tstrMidiaQueryParam.nEventLists[0] = EVENT_IVS_FACERECOGNITION;\n\tstrMidiaQueryParam.nEventLists[1] = EVENT_IVS_FACEDETECT;\n\tstrMidiaQueryParam.nEventCount = 2;\t\t\t\t\t//number of events include  FaceDetection and FaceRecognition\n\tstrMidiaQueryParam.emFalgLists[0]= FLAG_TYPE_EVENT;\t\n\tstrMidiaQueryParam.nFalgCount = 1;\t\t\t\t\t\n\n\t//set the begin time\n\tstrMidiaQueryParam.stuStartTime.dwYear = m_DateStart.dwYear;\n\tstrMidiaQueryParam.stuStartTime.dwMonth = m_DateStart.dwMonth;\n\tstrMidiaQueryParam.stuStartTime.dwDay = m_DateStart.dwDay;\n\tstrMidiaQueryParam.stuStartTime.dwHour = m_DateStart.dwHour;\n\tstrMidiaQueryParam.stuStartTime.dwMinute = m_DateStart.dwMinute;\n\tstrMidiaQueryParam.stuStartTime.dwSecond = m_DateStart.dwSecond;\n\n\t//set the end time\n\tstrMidiaQueryParam.stuEndTime.dwYear = m_DateEnd.dwYear;\n\tstrMidiaQueryParam.stuEndTime.dwMonth = m_DateEnd.dwMonth;\n\tstrMidiaQueryParam.stuEndTime.dwDay = m_DateEnd.dwDay;\n\tstrMidiaQueryParam.stuEndTime.dwHour = m_DateEnd.dwHour;\n\tstrMidiaQueryParam.stuEndTime.dwMinute = m_DateEnd.dwMinute;\n\tstrMidiaQueryParam.stuEndTime.dwSecond = m_DateEnd.dwSecond;\n\n\tm_lFindHandle = CLIENT_FindFileEx(m_lLogin, DH_FILE_QUERY_FILE, &strMidiaQueryParam, NULL,DEFAULT_WAIT_TIME);\n\tif (m_lFindHandle == 0)\n\t{\n\t\tMessageBox(ConvertString(\"Query fail\"), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nBOOL CQueryDownLoad::FindFaceDetectionPicture()\n{\n\tMEDIAFILE_FACE_DETECTION_PARAM stuMediaFaceDetectionParam;\n\tmemset(&stuMediaFaceDetectionParam, 0, sizeof(stuMediaFaceDetectionParam));\n\n\tstuMediaFaceDetectionParam.dwSize = sizeof(stuMediaFaceDetectionParam);\n\tstuMediaFaceDetectionParam.stuDetail.dwSize = sizeof(MEDIAFILE_FACE_DETECTION_DETAIL_PARAM);\n\tstuMediaFaceDetectionParam.nChannelID = m_comboQueryChannel.GetCurSel() - 1;\t//-1 means all channel\n\n\t//set the begin time\n\tstuMediaFaceDetectionParam.stuStartTime.dwYear = m_DateStart.dwYear;\n\tstuMediaFaceDetectionParam.stuStartTime.dwMonth = m_DateStart.dwMonth;\n\tstuMediaFaceDetectionParam.stuStartTime.dwDay = m_DateStart.dwDay;\n\tstuMediaFaceDetectionParam.stuStartTime.dwHour = m_DateStart.dwHour;\n\tstuMediaFaceDetectionParam.stuStartTime.dwMinute = m_DateStart.dwMinute;\n\tstuMediaFaceDetectionParam.stuStartTime.dwSecond = m_DateStart.dwSecond;\n\n\t//set the end time\n\tstuMediaFaceDetectionParam.stuEndTime.dwYear = m_DateEnd.dwYear;\n\tstuMediaFaceDetectionParam.stuEndTime.dwMonth = m_DateEnd.dwMonth;\n\tstuMediaFaceDetectionParam.stuEndTime.dwDay = m_DateEnd.dwDay;\n\tstuMediaFaceDetectionParam.stuEndTime.dwHour = m_DateEnd.dwHour;\n\tstuMediaFaceDetectionParam.stuEndTime.dwMinute = m_DateEnd.dwMinute;\n\tstuMediaFaceDetectionParam.stuEndTime.dwSecond = m_DateEnd.dwSecond;\n\n\tstuMediaFaceDetectionParam.emPicType = NET_FACEPIC_TYPE_UNKOWN;\n\tstuMediaFaceDetectionParam.bDetailEnable = FALSE;\n\tstuMediaFaceDetectionParam.bAgeEnable = FALSE;\n\n\tstuMediaFaceDetectionParam.emSex = m_emSex;\n\tstuMediaFaceDetectionParam.emGlasses = m_emGlasses;\n\tstuMediaFaceDetectionParam.emBeard = m_emBeard;\n\tstuMediaFaceDetectionParam.emMask = m_emMask;\n\tstuMediaFaceDetectionParam.bAgeEnable = TRUE;\n\tstuMediaFaceDetectionParam.nAgeRange[0] = m_nAge[0];\n\tstuMediaFaceDetectionParam.nAgeRange[1] = m_nAge[1];\n\tstuMediaFaceDetectionParam.nEmotionValidNum = 1;\n\tstuMediaFaceDetectionParam.emEmotion[0] = m_emEmotion;\n\n\tm_lFindHandle = CLIENT_FindFileEx(m_lLogin, DH_FILE_QUERY_FACE_DETECTION, &stuMediaFaceDetectionParam, NULL,DEFAULT_WAIT_TIME);\n\tif (m_lFindHandle == 0)\n\t{\n\t\tMessageBox(ConvertString(\"Query fail\"), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nBOOL CQueryDownLoad::FindFaceRecognitionPicture()\n{\n\tMEDIAFILE_FACERECOGNITION_PARAM stuMediaFaceRecogitionParam;\n\tmemset(&stuMediaFaceRecogitionParam, 0, sizeof(stuMediaFaceRecogitionParam));\n\n\tstuMediaFaceRecogitionParam.dwSize = sizeof(stuMediaFaceRecogitionParam);\n\tstuMediaFaceRecogitionParam.nChannelId = m_comboQueryChannel.GetCurSel() - 1;\t//-1 means all channel\n\tstuMediaFaceRecogitionParam.nAlarmType = NET_FACERECOGNITION_ALARM_TYPE_ALL;\n\n\t//set the begin time\n\tstuMediaFaceRecogitionParam.stStartTime.dwYear = m_DateStart.dwYear;\n\tstuMediaFaceRecogitionParam.stStartTime.dwMonth = m_DateStart.dwMonth;\n\tstuMediaFaceRecogitionParam.stStartTime.dwDay = m_DateStart.dwDay;\n\tstuMediaFaceRecogitionParam.stStartTime.dwHour = m_DateStart.dwHour;\n\tstuMediaFaceRecogitionParam.stStartTime.dwMinute = m_DateStart.dwMinute;\n\tstuMediaFaceRecogitionParam.stStartTime.dwSecond = m_DateStart.dwSecond;\n\n\t//set the end time\n\tstuMediaFaceRecogitionParam.stEndTime.dwYear = m_DateEnd.dwYear;\n\tstuMediaFaceRecogitionParam.stEndTime.dwMonth = m_DateEnd.dwMonth;\n\tstuMediaFaceRecogitionParam.stEndTime.dwDay = m_DateEnd.dwDay;\n\tstuMediaFaceRecogitionParam.stEndTime.dwHour = m_DateEnd.dwHour;\n\tstuMediaFaceRecogitionParam.stEndTime.dwMinute = m_DateEnd.dwMinute;\n\tstuMediaFaceRecogitionParam.stEndTime.dwSecond = m_DateEnd.dwSecond;\n\tstuMediaFaceRecogitionParam.bSimilaryRangeEnable = TRUE;\n\tstuMediaFaceRecogitionParam.nSimilaryRange[0] = m_nSimilaryRange[0];\n\tstuMediaFaceRecogitionParam.nSimilaryRange[1] = m_nSimilaryRange[1];\n\n\tstuMediaFaceRecogitionParam.abPersonInfoEx = TRUE;\n\tFACERECOGNITION_PERSON_INFOEX\tstPersonInfoEx;\n\tmemset(&stPersonInfoEx, 0, sizeof(stPersonInfoEx) );\n\tif (m_emGlasses == EM_FACEDETECT_WITH_GLASSES)\n\t{\n\t\tstPersonInfoEx.byGlasses = 2;\n\t}\n\telse if (m_emGlasses == EM_FACEDETECT_WITHOUT_GLASSES)\n\t{\n\t\tstPersonInfoEx.byGlasses = 1;\n\t}\n\telse\n\t{\n\t\tstPersonInfoEx.byGlasses = 0;\n\t}\n\tstPersonInfoEx.emBeard = m_emBeard;\n\tstPersonInfoEx.emMask = m_emMask;\n\tstPersonInfoEx.bySex = (BYTE)m_emSex;\n\tstPersonInfoEx.bAgeEnable = TRUE;\n\tstPersonInfoEx.nAgeRange[0] = m_nAge[0];\n\tstPersonInfoEx.nAgeRange[1] = m_nAge[1];\n\tstPersonInfoEx.nEmotionValidNum = 1;\n\tstPersonInfoEx.emEmotions[0] = m_emEmotion;\n\tstuMediaFaceRecogitionParam.stPersonInfoEx = stPersonInfoEx;\n\n\tm_lFindHandle = CLIENT_FindFileEx(m_lLogin, DH_FILE_QUERY_FACE, &stuMediaFaceRecogitionParam, NULL,DEFAULT_WAIT_TIME);\n\tif (m_lFindHandle == 0)\n\t{\n\t\tMessageBox(ConvertString(\"Query fail\"), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nBOOL CQueryDownLoad::FindFaceEventPicture(DWORD dwEventType)\n{\n\tNET_IN_MEDIA_QUERY_FILE strMidiaQueryParam;\n\tmemset(&strMidiaQueryParam, 0, sizeof(strMidiaQueryParam));\n\n\tstrMidiaQueryParam.dwSize = sizeof(strMidiaQueryParam);\n\tstrMidiaQueryParam.nMediaType = 1;\t\t\t\t\t//set video search type\n\tstrMidiaQueryParam.nChannelID = m_comboQueryChannel.GetCurSel() - 1;\t//-1 means all channel\n\tstrMidiaQueryParam.nEventLists[0] = dwEventType;\n\tstrMidiaQueryParam.nEventCount = 1;\t\t\t\t\t//number of events include  FaceDetection and FaceRecognition\n\tstrMidiaQueryParam.emFalgLists[0]= FLAG_TYPE_EVENT;\t\n\tstrMidiaQueryParam.nFalgCount = 1;\t\t\t\t\t\n\n\t//set the begin time\n\tstrMidiaQueryParam.stuStartTime.dwYear = m_DateStart.dwYear;\n\tstrMidiaQueryParam.stuStartTime.dwMonth = m_DateStart.dwMonth;\n\tstrMidiaQueryParam.stuStartTime.dwDay = m_DateStart.dwDay;\n\tstrMidiaQueryParam.stuStartTime.dwHour = m_DateStart.dwHour;\n\tstrMidiaQueryParam.stuStartTime.dwMinute = m_DateStart.dwMinute;\n\tstrMidiaQueryParam.stuStartTime.dwSecond = m_DateStart.dwSecond;\n\n\t//set the end time\n\tstrMidiaQueryParam.stuEndTime.dwYear = m_DateEnd.dwYear;\n\tstrMidiaQueryParam.stuEndTime.dwMonth = m_DateEnd.dwMonth;\n\tstrMidiaQueryParam.stuEndTime.dwDay = m_DateEnd.dwDay;\n\tstrMidiaQueryParam.stuEndTime.dwHour = m_DateEnd.dwHour;\n\tstrMidiaQueryParam.stuEndTime.dwMinute = m_DateEnd.dwMinute;\n\tstrMidiaQueryParam.stuEndTime.dwSecond = m_DateEnd.dwSecond;\n\n\tm_lFindHandle = CLIENT_FindFileEx(m_lLogin, DH_FILE_QUERY_FILE, &strMidiaQueryParam, NULL,DEFAULT_WAIT_TIME);\n\tif (m_lFindHandle == 0)\n\t{\n\t\tMessageBox(ConvertString(\"Query fail\"), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nint CQueryDownLoad::DoFindNextPageEx(int nSearchCount)\n{\n\tint nRetCount = -1;\n\tif (m_nQueryType == 0)\n\t{\n\t\tnRetCount = FindNextFaceEventType(nSearchCount);\n\t}\n\telse\n\t{\n\t\tswitch (m_emQuryType)\n\t\t{\n\t\tcase QUERY_VIDEO:\n\t\t\t{\n\t\t\t\tnRetCount = FindNextFaceVideo(nSearchCount);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase QUERY_PICFD:\n\t\t\t{\n\t\t\t\tnRetCount = FindNextFaceDetectionPicture(nSearchCount);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase QUERY_PICFR:\n\t\t\t{\n\t\t\t\tnRetCount = FindNextFaceRecognitionPicure(nSearchCount);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (nRetCount > 0)\n\t{\n\t\tint nUpdateInfoCount = nRetCount;\n\t\tif (nRetCount == (QUERY_FILE_NUM + 1))\n\t\t{\n\t\t\tnUpdateInfoCount = QUERY_FILE_NUM;\n\t\t}\n\t\tUpdateLcQueryList(nUpdateInfoCount);\n\t}\n\treturn nRetCount;\n}\n\nint CQueryDownLoad::FindNextFaceEventType(int nSearchCount)\n{\n\tint nRetCount = -1;\n\tBOOL bRet = FALSE;\n\tNET_OUT_MEDIA_QUERY_FILE *pMediaFileInfo = NEW NET_OUT_MEDIA_QUERY_FILE[nSearchCount];\n\n\tif (pMediaFileInfo == NULL)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tmemset(pMediaFileInfo, 0, nSearchCount * sizeof(NET_OUT_MEDIA_QUERY_FILE));\n\n\tfor (int i = 0; i < nSearchCount; i++)\n\t{\n\t\tpMediaFileInfo[i].dwSize = sizeof(NET_OUT_MEDIA_QUERY_FILE);\n\t}\n\n\tnRetCount = CLIENT_FindNextFileEx(m_lFindHandle, nSearchCount, (void*)pMediaFileInfo, nSearchCount * sizeof(NET_OUT_MEDIA_QUERY_FILE), NULL,DEFAULT_WAIT_TIME);\n\tif (nRetCount < 0)\n\t{\n\t\tMessageBox(ConvertString(\"Query fail\"), ConvertString(\"Prompt\"));\n\t\tbRet = FALSE;\n\t}\n\n\telse if (0 == nRetCount)\n\t{\n\t\tMessageBox(ConvertString(\"Query Number zero\"), ConvertString(\"Prompt\"));\n\t\tbRet = TRUE;\n\t}\n\telse\n\t{\n\t\tfor (int i = 0; i < nRetCount; i++)\n\t\t{\n\t\t\tNET_OUT_MEDIA_QUERY_FILE* pInfo = &pMediaFileInfo[i];\n\n\t\t\tSTR_RECORDFILE_INFO *recordfile = NEW STR_RECORDFILE_INFO;\n\t\t\tmemset(recordfile, 0, sizeof(STR_RECORDFILE_INFO));\n\t\t\tstrncpy(recordfile->filename, pInfo->szFilePath, sizeof(recordfile->filename) - 1);\n\t\t\trecordfile->size = pInfo->nFileSizeEx;\n\n\t\t\trecordfile->starttime = pInfo->stuStartTime;\n\t\t\trecordfile->endtime = pInfo->stuEndTime;\n\t\t\trecordfile->driveno = pInfo->nDriveNo;\n\t\t\trecordfile->startcluster = pInfo->nCluster;\n\t\t\trecordfile->nRecordFileType = 0;\n\t\t\trecordfile->ch = pInfo->nChannelID;\n\n\t\t\tm_QueryResultInfoVecotr.push_back(recordfile);\n\t\t}\n\t\tbRet = TRUE;\n\t}\n\tif (NULL != pMediaFileInfo)\n\t{\n\t\tdelete []pMediaFileInfo;\n\t\tpMediaFileInfo = NULL;\n\t}\n\treturn nRetCount;\n}\n\nint CQueryDownLoad::FindNextFaceVideo(int nSearchCount)\n{\n\tint nRetCount = -1;\n\tBOOL bRet = FALSE;\n\tNET_OUT_MEDIA_QUERY_FILE *pMediaFileInfo = NEW NET_OUT_MEDIA_QUERY_FILE[nSearchCount];\n\n\tif (pMediaFileInfo == NULL)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tmemset(pMediaFileInfo, 0, nSearchCount * sizeof(NET_OUT_MEDIA_QUERY_FILE));\n\n\tfor (int i = 0; i < nSearchCount; i++)\n\t{\n\t\tpMediaFileInfo[i].dwSize = sizeof(NET_OUT_MEDIA_QUERY_FILE);\n\t}\n\n\tnRetCount = CLIENT_FindNextFileEx(m_lFindHandle, nSearchCount, (void*)pMediaFileInfo, nSearchCount * sizeof(NET_OUT_MEDIA_QUERY_FILE), NULL,DEFAULT_WAIT_TIME);\n\tif (nRetCount < 0)\n\t{\n\t\tMessageBox(ConvertString(\"Query fail\"), ConvertString(\"Prompt\"));\n\t\tbRet = FALSE;\n\t}\n\n\telse if (0 == nRetCount)\n\t{\n\t\tMessageBox(ConvertString(\"Query Number zero\"), ConvertString(\"Prompt\"));\n\t\tbRet = TRUE;\n\t}\n\telse\n\t{\n\t\tfor (int i = 0; i < nRetCount; i++)\n\t\t{\n\t\t\tNET_OUT_MEDIA_QUERY_FILE* pInfo = &pMediaFileInfo[i];\n\n\t\t\tSTR_RECORDFILE_INFO *recordfile = NEW STR_RECORDFILE_INFO;\n\t\t\tmemset(recordfile, 0, sizeof(STR_RECORDFILE_INFO));\n\t\t\tstrncpy(recordfile->filename, pInfo->szFilePath, sizeof(recordfile->filename) - 1);\n\t\t\trecordfile->size = pInfo->nFileSizeEx;\n\n\t\t\trecordfile->starttime = pInfo->stuStartTime;\n\t\t\trecordfile->endtime = pInfo->stuEndTime;\n\t\t\trecordfile->driveno = pInfo->nDriveNo;\n\t\t\trecordfile->startcluster = pInfo->nCluster;\n\t\t\trecordfile->nRecordFileType = 0;\n\t\t\trecordfile->ch = pInfo->nChannelID;\n\n\t\t\tm_QueryResultInfoVecotr.push_back(recordfile);\n\t\t}\n\t\tbRet = TRUE;\n\t}\n\tif (NULL != pMediaFileInfo)\n\t{\n\t\tdelete []pMediaFileInfo;\n\t\tpMediaFileInfo = NULL;\n\t}\n\treturn nRetCount;\n}\n\nint CQueryDownLoad::FindNextFaceDetectionPicture(int nSearchCount)\n{\n\tint nRetCount = -1;\n\tBOOL bRet = FALSE;\n\tMEDIAFILE_FACE_DETECTION_INFO* pMediaFileInfo = NEW MEDIAFILE_FACE_DETECTION_INFO[nSearchCount];\n\n\tif (NULL == pMediaFileInfo)\n\t{\n\t\treturn FALSE;\n\t}\n\tmemset(pMediaFileInfo, 0, nSearchCount * sizeof(MEDIAFILE_FACE_DETECTION_INFO));\n\n\tfor (int i = 0; i < nSearchCount; i++)\n\t{\n\t\t//set dwSize (Must do)\n\t\tpMediaFileInfo[i].dwSize = sizeof(MEDIAFILE_FACE_DETECTION_INFO);\n\t}\n\n\tnRetCount = CLIENT_FindNextFileEx(m_lFindHandle, nSearchCount, (void*)pMediaFileInfo, nSearchCount * sizeof(NET_OUT_MEDIA_QUERY_FILE), NULL,DEFAULT_WAIT_TIME);\n\tif (nRetCount < 0)\n\t{\n\t\tMessageBox(ConvertString(\"Query fail\"), ConvertString(\"Prompt\"));\n\t\tbRet = FALSE;\n\t}\n\n\telse if (0 == nRetCount)\n\t{\n\t\tMessageBox(ConvertString(\"Query Number zero\"), ConvertString(\"Prompt\"));\n\t\tbRet = TRUE;\n\t}\n\telse\n\t{\n\t\tfor (int i = 0; i < nRetCount; i++)\n\t\t{\n\t\t\tMEDIAFILE_FACE_DETECTION_INFO* pInfo = &pMediaFileInfo[i];\n\n\t\t\tSTR_RECORDFILE_INFO *recordfile = NEW STR_RECORDFILE_INFO;\n\t\t\tmemset(recordfile, 0, sizeof(STR_RECORDFILE_INFO));\n\t\t\tstrncpy(recordfile->filename, pInfo->szFilePath, sizeof(recordfile->filename) - 1);\n\t\t\tif (pInfo->sizeEx > 0)\n\t\t\t{\n\t\t\t\trecordfile->size = pInfo->sizeEx;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trecordfile->size = pInfo->size;\n\t\t\t}\n\n\t\t\trecordfile->starttime = pInfo->starttime;\n\t\t\trecordfile->endtime = pInfo->endtime;\n\t\t\trecordfile->driveno = pInfo->bDriveNo;\n\t\t\trecordfile->startcluster = pInfo->nCluster;\n\t\t\trecordfile->nRecordFileType = 4;\t\t//picture type\n\t\t\trecordfile->bHint = pInfo->bHint;\n\t\t\trecordfile->ch = pInfo->ch;\n\n\t\t\tm_QueryResultInfoVecotr.push_back(recordfile);\n\t\t}\n\t\tbRet = TRUE;\n\t}\n\n\tif (NULL != pMediaFileInfo)\n\t{\n\t\tdelete []pMediaFileInfo;\n\t\tpMediaFileInfo = NULL;\n\t}\n\treturn nRetCount;\n}\n\nint CQueryDownLoad::FindNextFaceRecognitionPicure(int nSearchCount)\n{\n\tint nRetCount = -1;\n\tBOOL bRet = FALSE;\n\tMEDIAFILE_FACERECOGNITION_INFO* pMediaFileInfo = NEW MEDIAFILE_FACERECOGNITION_INFO[nSearchCount];\n\n\tif (NULL == pMediaFileInfo)\n\t{\n\t\treturn FALSE;\n\t}\n\tmemset(pMediaFileInfo, 0, nSearchCount * sizeof(MEDIAFILE_FACERECOGNITION_INFO));\n\n\tfor (int i = 0; i < nSearchCount; i++)\n\t{\n\t\t//Set  dwSize (Must do)\n\t\tpMediaFileInfo[i].dwSize = sizeof(MEDIAFILE_FACERECOGNITION_INFO);\n\t\tpMediaFileInfo[i].stGlobalScenePic.dwSize = sizeof(pMediaFileInfo[i].stGlobalScenePic);\n\t\tpMediaFileInfo[i].stObjectPic.dwSize = sizeof(pMediaFileInfo[i].stObjectPic);\n\n\t\tpMediaFileInfo[i].stuCandidatesPic[0].dwSize = sizeof(pMediaFileInfo[i].stuCandidatesPic[0]);\n\t}\n\n\tnRetCount = CLIENT_FindNextFileEx(m_lFindHandle, nSearchCount, (void*)pMediaFileInfo, nSearchCount * sizeof(MEDIAFILE_FACERECOGNITION_INFO), NULL,DEFAULT_WAIT_TIME);\n\tif (nRetCount < 0)\n\t{\n\t\tMessageBox(ConvertString(\"Query fail\"), ConvertString(\"Prompt\"));\n\t\tbRet = FALSE;\n\t}\n\n\telse if (0 == nRetCount)\n\t{\n\t\tMessageBox(ConvertString(\"Query Number zero\"), ConvertString(\"Prompt\"));\n\t\tbRet = TRUE;\n\t}\n\telse\n\t{\n\t\tfor (int i = 0; i < nRetCount; i++)\n\t\t{\n\t\t\tMEDIAFILE_FACERECOGNITION_INFO* pInfo = &pMediaFileInfo[i];\n\n\t\t\tSTR_RECORDFILE_INFO *recordfile = NEW STR_RECORDFILE_INFO;\n\t\t\tmemset(recordfile, 0, sizeof(STR_RECORDFILE_INFO));\n\t\t\tstrncpy(recordfile->filename, pInfo->stObjectPic.szFilePath, sizeof(recordfile->filename) - 1);\n\t\t\trecordfile->starttime = pInfo->stTime;\n\t\t\trecordfile->endtime = pInfo->stTime;\n\t\t\trecordfile->ch = pInfo->nChannelId;\n\t\t\trecordfile->emBeard = pInfo->stuCandidatesEx[0].stPersonInfo.emBeard;\n\t\t\trecordfile->emEmotion = pInfo->stuCandidatesEx[0].stPersonInfo.emEmotion;\n\t\t\trecordfile->emSex = (EM_DEV_EVENT_FACEDETECT_SEX_TYPE)pInfo->stuCandidatesEx[0].stPersonInfo.bySex;\n\n\t\t\tif (pInfo->stuCandidatesEx[0].stPersonInfo.byGlasses == 1)\n\t\t\t{\n\t\t\t\trecordfile->emGlasses = EM_FACEDETECT_WITHOUT_GLASSES;\n\t\t\t}\n\t\t\telse if (pInfo->stuCandidatesEx[0].stPersonInfo.byGlasses == 2)\n\t\t\t{\n\t\t\t\trecordfile->emGlasses = EM_FACEDETECT_WITH_GLASSES;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trecordfile->emGlasses = EM_FACEDETECT_GLASSES_UNKNOWN;\n\t\t\t}\n\t\t\t\n\t\t\trecordfile->emMask = pInfo->stuCandidatesEx[0].stPersonInfo.emMask;\n\t\n\t\t\tm_QueryResultInfoVecotr.push_back(recordfile);\n\t\t}\n\t\tbRet = TRUE;\n\t}\n\n\tif (NULL != pMediaFileInfo)\n\t{\n\t\tdelete []pMediaFileInfo;\n\t\tpMediaFileInfo = NULL;\n\t}\n\treturn nRetCount;\n}\n\nvoid CQueryDownLoad::UpdateLcQueryList(int nInfoNum)\n{\n\tCString strIndex = \"\";\n\tCString strStartTime = \"\";\n\tCString strEndTime = \"\";\n\tCString strChannel = \"\";\n\tCString strInfo = \"\";\n\tm_lcQueryResult.DeleteAllItems();\n\n\tfor (int n = 0; n < nInfoNum; n++)\n\t{\n\t\tstrIndex.Format(\"%d\", m_nPage * QUERY_FILE_NUM + n + 1);\n\t\tSTR_RECORDFILE_INFO *pInfo = m_QueryResultInfoVecotr[m_nPage * QUERY_FILE_NUM + n];\n\t\tstrChannel.Format(\"%d\", pInfo->ch + 1);\n\t\tstrStartTime.Format(\"%d-%02d-%02d %02d:%02d:%02d\",\n\t\t\tpInfo->starttime.dwYear,\n\t\t\tpInfo->starttime.dwMonth,\n\t\t\tpInfo->starttime.dwDay,\n\t\t\tpInfo->starttime.dwHour,\n\t\t\tpInfo->starttime.dwMinute,\n\t\t\tpInfo->starttime.dwSecond);\n\n\t\tstrEndTime.Format(\"%d-%02d-%02d %02d:%02d:%02d\",\n\t\t\tpInfo->endtime.dwYear,\n\t\t\tpInfo->endtime.dwMonth,\n\t\t\tpInfo->endtime.dwDay,\n\t\t\tpInfo->endtime.dwHour,\n\t\t\tpInfo->endtime.dwMinute,\n\t\t\tpInfo->endtime.dwSecond);\n\t\tm_lcQueryResult.InsertItem(n, strIndex);\n\t\tm_lcQueryResult.SetItemText(n, 1, strChannel);\n\t\tm_lcQueryResult.SetItemText(n, 2, strStartTime);\n\t\tm_lcQueryResult.SetItemText(n, 3, strEndTime);\n\t}\n}\n\nvoid CQueryDownLoad::CloseFindHandle()\n{\n\tif (0 == m_lFindHandle)\n\t{\n\t\treturn;\n\t}\n\tBOOL bRet = CLIENT_FindCloseEx(m_lFindHandle);\n\tif (FALSE == bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Stop Qeury fail\"), ConvertString(\"Prompt\"));\n\t}\n\tm_lFindHandle = 0;\n}\n\nvoid CQueryDownLoad::ClearQueryResultInfoVector()\n{\n\tstd::vector<STR_RECORDFILE_INFO*>::iterator it = m_QueryResultInfoVecotr.begin();\n\twhile(it != m_QueryResultInfoVecotr.end())\n\t{\n\t\tSTR_RECORDFILE_INFO *pstGroupInfo = *it;\n\t\tif (pstGroupInfo)\n\t\t{\n\t\t\tit = m_QueryResultInfoVecotr.erase(it);\n\t\t\tdelete pstGroupInfo;\n\t\t\tpstGroupInfo = NULL;\n\t\t}\n\t}\n\tm_QueryResultInfoVecotr.clear();\n}\n\nvoid CQueryDownLoad::OnBnClickedButtonQueryPrepage()\n{\n\tm_nPage--;\n\tUpdateLcQueryList(QUERY_FILE_NUM);\n\tif (m_nPage <= 0)\n\t{\n\t\tGetDlgItem(IDC_BUTTON_QUERY_PREPAGE)->EnableWindow(FALSE);\n\t}\n\tGetDlgItem(IDC_BUTTON_QUERY_NEXTPAGE)->EnableWindow(TRUE);\n}\n\nvoid CQueryDownLoad::OnBnClickedButtonQueryNextpage()\n{\n\tm_nPage++;\n\tint nSize = m_QueryResultInfoVecotr.size();\n\tif ( (m_nPage * QUERY_FILE_NUM + 1) == nSize )\n\t{\n\t\tint nCount = DoFindNextPageEx(QUERY_FILE_NUM);\n\t\tif (nCount == QUERY_FILE_NUM )\n\t\t{\n\t\t\tGetDlgItem(IDC_BUTTON_QUERY_NEXTPAGE)->EnableWindow(TRUE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tGetDlgItem(IDC_BUTTON_QUERY_NEXTPAGE)->EnableWindow(FALSE);\n\t\t\tUpdateLcQueryList(nCount + 1);\n\t\t}\n\t}\n\telse if((m_nPage+1) * QUERY_FILE_NUM > nSize)\n\t{\n\t\tint nUpdateCount = nSize - m_nPage * QUERY_FILE_NUM;\n\t\tUpdateLcQueryList(nUpdateCount);\n\t\tGetDlgItem(IDC_BUTTON_QUERY_NEXTPAGE)->EnableWindow(FALSE);\n\t}\n\telse if ((m_nPage+1) * QUERY_FILE_NUM < nSize)\n\t{\n\t\tUpdateLcQueryList(QUERY_FILE_NUM);\n\t}\n\tGetDlgItem(IDC_BUTTON_QUERY_PREPAGE)->EnableWindow(TRUE);\n}\n\nvoid CQueryDownLoad::OnBnClickedButtonQueryDownload()\n{\n\tCloseDownLoadHandle();\n\tCListCtrl *pQueryResult = (CListCtrl*)GetDlgItem(IDC_LIST_QUERY_RESULT);\n\tint nSel = pQueryResult->GetNextItem(-1, LVNI_SELECTED);\n\tif (nSel == CB_ERR)\n\t{\n\t\tMessageBox(ConvertString(\"Please choose a download file\"), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tGetDlgItem(IDC_BUTTON_QUERY_DOWNLOAD)->EnableWindow(FALSE);\n\n\tswitch(m_emQuryType)\n\t{\n\tcase QUERY_PICFD:\n\t\t{\n\t\t\tDownLoadFaceDetectionPicture(nSel);\n\t\t\tbreak;\n\t\t}\n\tcase QUERY_PICFR:\n\t\t{\n\t\t\tDownLoadFaceRecognitionPicure(nSel);\n\t\t\tbreak;\n\t\t}\n\tcase QUERY_VIDEO:\n\t\t{\n\t\t\tDownLoadFaceVideo(nSel);\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nBOOL CQueryDownLoad::DownLoadFaceDetectionPicture( int nSel)\n{\n\tBOOL bRet = FALSE;\n\n\tSTR_RECORDFILE_INFO* pInfo = m_QueryResultInfoVecotr[m_nPage * QUERY_FILE_NUM + nSel];\n\n\tchar szFileName[256] = {0};\n\t_snprintf(szFileName, sizeof(szFileName)-1,\"\\\\DownLoad\\\\FaceDetection\\\\%d%02lu%02lu%02lu%02lu%02lu%02lu.jpg\",\n\t\tpInfo->ch,\n\t\tpInfo->starttime.dwYear,\n\t\tpInfo->starttime.dwMonth,\n\t\tpInfo->starttime.dwDay,\n\t\tpInfo->starttime.dwHour,\n\t\tpInfo->starttime.dwMinute,\n\t\tpInfo->starttime.dwSecond\n\t\t);\n\n\tchar *pFileName = NULL;\n\tCString filepath = \"\";\n\tif (m_pSoftPath)\n\t{\n\t\tfilepath.Format(\"%s\", m_pSoftPath);\n\t}\n\tCString filename(szFileName);\n\tCString strFile = filepath + filename;\n\tpFileName = strFile.GetBuffer(200);\n\n\tDH_IN_DOWNLOAD_REMOTE_FILE stuRemoteFileParm;\n\tmemset(&stuRemoteFileParm, 0, sizeof(DH_IN_DOWNLOAD_REMOTE_FILE));\n\tstuRemoteFileParm.dwSize = sizeof(DH_IN_DOWNLOAD_REMOTE_FILE);\n\tstuRemoteFileParm.pszFileName = pInfo->filename ;\n\tstuRemoteFileParm.pszFileDst = pFileName;\n\tDH_OUT_DOWNLOAD_REMOTE_FILE fileinfo = {sizeof(DH_OUT_DOWNLOAD_REMOTE_FILE)};\n\n\tBOOL BRet = CLIENT_DownloadRemoteFile(m_lLogin, &stuRemoteFileParm, &fileinfo);\n\tif (BRet == FALSE)\n\t{\n\t\tMessageBox(ConvertString(\"DownLoad file fail\"), ConvertString(\"Prompt\"));\n\t\tbRet = FALSE;\n\t}\n\telse\n\t{\n\t\tbRet = TRUE;\n\t\tMessageBox(ConvertString(\"Download file success!\"), ConvertString(\"Prompt\"));\n\t}\n\n\tGetDlgItem(IDC_BUTTON_QUERY_DOWNLOAD)->EnableWindow(TRUE);\n\treturn bRet;\n}\n\nBOOL CQueryDownLoad::DownLoadFaceRecognitionPicure( int nSel)\n{\n\tBOOL bRet = TRUE;\n\tSTR_RECORDFILE_INFO* pInfo = m_QueryResultInfoVecotr[m_nPage * QUERY_FILE_NUM + nSel];\n\tchar szFileName[128] = {0};\n\t_snprintf(szFileName, sizeof(szFileName)-1,\"\\\\DownLoad\\\\FaceRecognition\\\\%d%02lu%02lu%02lu%02lu%02lu%02lu.jpg\",\n\t\tpInfo->ch,\n\t\tpInfo->starttime.dwYear,\n\t\tpInfo->starttime.dwMonth,\n\t\tpInfo->starttime.dwDay,\n\t\tpInfo->starttime.dwHour,\n\t\tpInfo->starttime.dwMinute,\n\t\tpInfo->starttime.dwSecond\n\t\t);\n\n\tchar *pFileName = NULL;\n\tCString filepath = \"\";\n\tif (m_pSoftPath)\n\t{\n\t\tfilepath.Format(\"%s\", m_pSoftPath);\n\t}\n\tCString filename(szFileName);\n\tCString strFile = filepath + filename;\n\tpFileName = strFile.GetBuffer(200);\n\n\tDH_IN_DOWNLOAD_REMOTE_FILE stuRemoteFileParm;\n\tmemset(&stuRemoteFileParm, 0, sizeof(DH_IN_DOWNLOAD_REMOTE_FILE));\n\tstuRemoteFileParm.dwSize = sizeof(DH_IN_DOWNLOAD_REMOTE_FILE);\n\tstuRemoteFileParm.pszFileName = pInfo->filename ;\n\tstuRemoteFileParm.pszFileDst = pFileName;\n\tDH_OUT_DOWNLOAD_REMOTE_FILE fileinfo = {sizeof(DH_OUT_DOWNLOAD_REMOTE_FILE)};\n\n\tBOOL BRet = CLIENT_DownloadRemoteFile(m_lLogin, &stuRemoteFileParm, &fileinfo);\n\tif (BRet == FALSE)\n\t{\n\t\tMessageBox(ConvertString(\"DownLoad file fail\"), ConvertString(\"Prompt\"));\n\t\tbRet = FALSE;\n\t}\n\telse\n\t{\n\t\tbRet = TRUE;\n\t\tMessageBox(ConvertString(\"Download file success!\"), ConvertString(\"Prompt\"));\n\t}\n\tGetDlgItem(IDC_BUTTON_QUERY_DOWNLOAD)->EnableWindow(TRUE);\n\treturn bRet;\n}\n\nBOOL CQueryDownLoad::DownLoadFaceVideo(int nSel)\n{\n\tBOOL bRet = FALSE;\n\tSTR_RECORDFILE_INFO* pInfo = m_QueryResultInfoVecotr[m_nPage * QUERY_FILE_NUM + nSel];\n\tNET_RECORDFILE_INFO recordfile;\n\tmemset(&recordfile, 0, sizeof(recordfile));\n\tstrncpy(recordfile.filename, pInfo->filename, sizeof(recordfile.filename) - 1);\n\trecordfile.size = pInfo->size;\n\n\trecordfile.starttime = pInfo->starttime;\n\trecordfile.endtime = pInfo->endtime;\n\trecordfile.driveno = pInfo->driveno;\n\trecordfile.startcluster = pInfo->startcluster;\n\trecordfile.nRecordFileType = pInfo->nRecordFileType;\n\trecordfile.ch = pInfo->ch;\n\n\tchar szFileName[128] = {0};\n\t_snprintf(szFileName, sizeof(szFileName)-1, \"\\\\DownLoad\\\\FaceVideo\\\\%d%02lu%02lu%02lu%02lu%02lu%02lu.dav\",\n\t\tpInfo->ch,\n\t\tpInfo->starttime.dwYear,\n\t\tpInfo->starttime.dwMonth,\n\t\tpInfo->starttime.dwDay,\n\t\tpInfo->starttime.dwHour,\n\t\tpInfo->starttime.dwMinute,\n\t\tpInfo->starttime.dwSecond\n\t\t);\n\n\tchar *pFileName = NULL;\n\tCString filepath = \"\";\n\tif (m_pSoftPath)\n\t{\n\t\tfilepath.Format(\"%s\", m_pSoftPath);\n\t}\n\tCString filename(szFileName);\n\tCString strFile = filepath + filename;\n\tpFileName = strFile.GetBuffer(200);\n\n\tm_lDownLoadHandle = CLIENT_DownloadByRecordFileEx(m_lLogin, &recordfile, pFileName, DownLoadPosCallBack, \n\t\t(LDWORD)this, NULL, NULL);\n\n\tif (m_lDownLoadHandle == 0)\n\t{\n\t\tMessageBox(ConvertString(\"DownLoad file fail\"), ConvertString(\"Prompt\"));\n\t\tbRet = FALSE;\n\t\tGetDlgItem(IDC_BUTTON_QUERY_DOWNLOAD)->EnableWindow(TRUE);\n\t}\n\telse\n\t{\n\t\tbRet = TRUE;\n\n\t}\n\treturn bRet;\n}\n\nvoid CQueryDownLoad::OnLvnItemchangedListQueryResult(NMHDR *pNMHDR, LRESULT *pResult)\n{\n\tLPNMLISTVIEW pNMLV = reinterpret_cast<LPNMLISTVIEW>(pNMHDR);\n\n\tClosePlayBackHandle();\n\n\tm_dwPlayBackCurValue = 0;\n\tm_dwPlayBackTotalSize = 0;\n\n\tNET_IN_PLAY_BACK_BY_TIME_INFO stNetin;\n\tNET_OUT_PLAY_BACK_BY_TIME_INFO stNetOut;\n\tmemset(&stNetin, 0, sizeof(NET_IN_PLAY_BACK_BY_TIME_INFO));\n\tmemset(&stNetOut, 0, sizeof(NET_OUT_PLAY_BACK_BY_TIME_INFO));\n\n\tint nChannelId = -1;\n\n\tint nSel = m_lcQueryResult.GetNextItem(-1, LVNI_SELECTED);\n\n\tif (nSel == CB_ERR)\n\t{\n\t\tMessageBox(ConvertString(\"Please choose a valid file!\"), ConvertString(\"Prompt\"));\n\t\t*pResult = 0;\n\t\treturn;\n\t}\n\tswitch (m_emQuryType)\n\t{\n\tcase QUERY_PICFD:\n\t\t{\n\t\t\tFillCWndWithDefaultColor(GetDlgItem(IDC_STATIC_REALPLAY_PIC));\n\t\t\tMessageBox(ConvertString(\"Only Video Support PlayBack!\"), ConvertString(\"Prompt\"));\n\t\t\tbreak;\n\t\t}\n\tcase QUERY_PICFR:\n\t\t{\n\t\t\tFillCWndWithDefaultColor(GetDlgItem(IDC_STATIC_REALPLAY_PIC));\n\t\t\tMessageBox(ConvertString(\"Only Video Support PlayBack!\"), ConvertString(\"Prompt\"));\n\t\t\tbreak;\n\t\t}\n\tcase QUERY_VIDEO:\n\t\t{\n\t\t\tSTR_RECORDFILE_INFO* pInfo = m_QueryResultInfoVecotr[m_nPage * QUERY_FILE_NUM + nSel];\n\t\t\tstNetin.stStartTime = pInfo->starttime;\n\t\t\tstNetin.stStopTime = pInfo->endtime;\n\n\t\t\tnChannelId = pInfo->ch;\n\t\t\tCWnd *pWnd = GetDlgItem(IDC_STATIC_REALPLAY_PIC);\n\t\t\tHWND hwnd = pWnd->GetSafeHwnd();\n\t\t\tstNetin.hWnd = hwnd;\n\t\t\tstNetin.nPlayDirection = 0;\n\t\t\tstNetin.cbDownLoadPos = DownLoadPosCallBack;\n\t\t\tstNetin.dwPosUser = (LDWORD)this;\n\n\t\t\tm_playBackHandle = CLIENT_PlayBackByTimeEx2(m_lLogin, nChannelId, &stNetin, &stNetOut);\n\t\t\tif (m_playBackHandle == 0)\n\t\t\t{\n\t\t\t\tCString str;\n\t\t\t\tstr.Format(\"error :0x%ld\", CLIENT_GetLastError());\n\t\t\t\tMessageBox(str);\n\t\t\t\tMessageBox(ConvertString(\"PlayBack fail\"), ConvertString(\"Prompt\"));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t*pResult = 0;\n}\n\nvoid CQueryDownLoad::ClosePlayBackHandle()\n{\n\tif (m_playBackHandle)\n\t{\n\t\tBOOL bRet = CLIENT_StopPlayBack(m_playBackHandle);\n\t\tif (bRet == FALSE)\n\t\t{\n\t\t\tMessageBox(ConvertString(\"Stop PlayBack fail\"), ConvertString(\"Prompt\"));\n\t\t}\n\t\tm_playBackHandle = 0;\n\t}\n}\n\nvoid CQueryDownLoad::CloseDownLoadHandle()\n{\n\tif (m_lDownLoadHandle)\n\t{\n\t\tCLIENT_StopDownload(m_lDownLoadHandle);\n\t}\n\tm_lDownLoadHandle = 0;\n}\n\nvoid CQueryDownLoad::OnTimer(UINT_PTR nIDEvent)\n{\n\tif(nIDEvent == m_nTimer)\n\t{\n\t\tm_PlayBackProcess.SetRange32(0,(int)(m_dwPlayBackTotalSize));\n\t\tm_PlayBackProcess.SetPos((int)(m_dwPlayBackCurValue) + 1);\n\n\t\tm_ProcessDownLoad.SetRange32(0,(int)(m_dwDownLoadTotalSize/1024));\n\t\tm_ProcessDownLoad.SetPos((int)(m_dwDownLoadCurValue));\n\t}\n\n\tCDialog::OnTimer(nIDEvent);\n}\n\nBOOL CQueryDownLoad::PreTranslateMessage(MSG* pMsg)\n{\n\tif(pMsg->message == WM_KEYDOWN &&\n\t\tpMsg->wParam == VK_RETURN)\n\t{\n\t\treturn TRUE;\n\t}\n\n\treturn CDialog::PreTranslateMessage(pMsg);\n}\n\n//get time from ui\nvoid CQueryDownLoad::GetTimeFromUI()\n{\n\tCDateTimeCtrl *pCDataStart = (CDateTimeCtrl*)GetDlgItem(IDC_DATE_START);\n\tCDateTimeCtrl *pCTimeStart = (CDateTimeCtrl*)GetDlgItem(IDC_TIME_START);\n\tCDateTimeCtrl *pCDataEnd = (CDateTimeCtrl*)GetDlgItem(IDC_DATE_END);\n\tCDateTimeCtrl *pCTimeEnd = (CDateTimeCtrl*)GetDlgItem(IDC_TIME_END);\n\n\tSYSTEMTIME DataStart = {0};\n\tSYSTEMTIME TimeStart = {0};\n\tSYSTEMTIME DataEnd = {0};\n\tSYSTEMTIME TimeEnd = {0};\n\n\tpCDataStart->GetTime(&DataStart);\n\tpCTimeStart->GetTime(&TimeStart);\n\tpCDataEnd->GetTime(&DataEnd);\n\tpCTimeEnd->GetTime(&TimeEnd);\n\n\tm_DateStart.dwYear = DataStart.wYear;\n\tm_DateStart.dwMonth = DataStart.wMonth;\n\tm_DateStart.dwDay = DataStart.wDay;\n\tm_DateStart.dwHour = TimeStart.wHour;\n\tm_DateStart.dwMinute = TimeStart.wMinute;\n\tm_DateStart.dwSecond = TimeStart.wSecond;\n\n\tm_DateEnd.dwYear = DataEnd.wYear;\n\tm_DateEnd.dwMonth = DataEnd.wMonth;\n\tm_DateEnd.dwDay = DataEnd.wDay;\n\tm_DateEnd.dwHour = TimeEnd.wHour;\n\tm_DateEnd.dwMinute = TimeEnd.wMinute;\n\tm_DateEnd.dwSecond = TimeEnd.wSecond;\n}\n\nBOOL CQueryDownLoad::GetAttributeFromUI()\n{\n\tint nSel = m_comboGlasses.GetCurSel();\n\tif (nSel != CB_ERR)\n\t{\n\t\tm_emGlasses = (EM_FACEDETECT_GLASSES_TYPE)m_comboGlasses.GetItemData(nSel);\n\t}\n\t\n\tnSel = m_comboBeard.GetCurSel();\n\tif (nSel != CB_ERR)\n\t{\n\t\tm_emBeard = (EM_BEARD_STATE_TYPE)m_comboBeard.GetItemData(nSel);\n\t}\n\n\tnSel = m_comboMask.GetCurSel();\n\tif (nSel != CB_ERR)\n\t{\n\t\tm_emMask = (EM_MASK_STATE_TYPE)m_comboMask.GetItemData(nSel);\n\t}\n\n\tnSel = m_comboSex.GetCurSel();\n\tif (nSel != CB_ERR)\n\t{\n\t\tm_emSex = (EM_DEV_EVENT_FACEDETECT_SEX_TYPE)m_comboSex.GetItemData(nSel);\n\t}\n\n\tnSel = m_comboEmotion.GetCurSel();\n\tif (nSel != CB_ERR)\n\t{\n\t\tm_emEmotion = (EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE)m_comboEmotion.GetItemData(nSel);\n\t}\n\n\tm_nAge[0] = GetDlgItemInt(IDC_EDIT_AGE1);\n\tm_nAge[1] = GetDlgItemInt(IDC_EDIT_AGE2);\n\n\tif (m_nAge[0] > m_nAge[1] )\n\t{\n\t\tm_nAge[0] = 0;\n\t\tm_nAge[1] = 0;\n\t\tMessageBox(ConvertString(\"Input age error\"), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\n\tm_nSimilaryRange[0] = GetDlgItemInt(IDC_EDIT_SimilaryRange1);\n\tm_nSimilaryRange[1] = GetDlgItemInt(IDC_EDIT_SimilaryRange2);\n\tif (m_nSimilaryRange[0] > m_nSimilaryRange[1] || m_nSimilaryRange[0] < 0 || m_nSimilaryRange[1] > 100)\n\t{\n\t\tm_nSimilaryRange[0] = 0;\n\t\tm_nSimilaryRange[1] = 0;\n\t\tMessageBox(ConvertString(\"Input SimilaryRange error\"), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nLRESULT CQueryDownLoad::OnDoDownLoad(WPARAM wParam, LPARAM lParam)\n{\n\tif (wParam == NULL)\n\t{\n\t\treturn 0;\n\t}\n\n\tstrCallBackInfo *pInfo = (strCallBackInfo *)wParam;\n\tif (pInfo)\n\t{\n\t\tReceivePlayPos(pInfo->lHandle, pInfo->dwTotalSize, pInfo->dwDownLoadSize);\n\t\tdelete pInfo;\n\t\tpInfo = NULL;\n\t}\n\treturn 0;\n}\n\nvoid CQueryDownLoad::OnBnClickedCheckAttributeEnable()\n{\n\tint tcheck = m_AttributeEnable.GetCheck();\n\tif (tcheck == BST_CHECKED)\n\t{\n\t\tGetDlgItem(IDC_COMBO_FILE_TYPE)->EnableWindow(FALSE);\n\n\t\tGetDlgItem(IDC_EDIT_AGE1)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_EDIT_AGE2)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_COMBO_QUERY_BREAD)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_COMBO_QUERY_MASK)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_COMBO_QUERY_SEX)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_COMBO_QUERY_GLASSES)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_COMBO_QUERY_EMOTION)->EnableWindow(TRUE);\n\n\t\tint nSel = m_comboEventType.GetCurSel();\n\t\tif (nSel == 0)\n\t\t{\n\t\t\tGetDlgItem(IDC_EDIT_SimilaryRange1)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_EDIT_SimilaryRange2)->EnableWindow(FALSE);\n\t\t}\n\t\telse if (nSel == 1)\n\t\t{\n\t\t\tGetDlgItem(IDC_EDIT_SimilaryRange1)->EnableWindow(TRUE);\n\t\t\tGetDlgItem(IDC_EDIT_SimilaryRange2)->EnableWindow(TRUE);\n\t\t}\n\n\t\tm_nAttributeFlag = 1;\n\t}\n\telse \n\t{\n\t\tClearAttribute();\n\t\tGetDlgItem(IDC_COMBO_FILE_TYPE)->EnableWindow(TRUE);\n\n\t\tGetDlgItem(IDC_EDIT_AGE1)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_EDIT_AGE2)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_COMBO_QUERY_BREAD)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_COMBO_QUERY_MASK)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_COMBO_QUERY_SEX)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_COMBO_QUERY_GLASSES)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_COMBO_QUERY_EMOTION)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_EDIT_SimilaryRange1)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_EDIT_SimilaryRange2)->EnableWindow(FALSE);\n\n\t\tm_nAttributeFlag = 0;\n\t}\n}\n\nvoid CQueryDownLoad::ClearAttribute()\n{\n\tm_emSex = EM_DEV_EVENT_FACEDETECT_SEX_TYPE_UNKNOWN;\n\tm_emGlasses = EM_FACEDETECT_GLASSES_UNKNOWN;\n\tm_emMask = EM_MASK_STATE_UNKNOWN;\n\tm_emBeard = EM_BEARD_STATE_UNKNOWN;\n\tmemset(&m_nAge, 0, sizeof(m_nAge) );\n\tmemset(&m_nSimilaryRange, 0, sizeof(m_nSimilaryRange));\n\n\tSetDlgItemText(IDC_EDIT_AGE1, \"\");\n\tSetDlgItemText(IDC_EDIT_AGE2, \"\");\n\n\tSetDlgItemText(IDC_EDIT_SimilaryRange1, \"\");\n\tSetDlgItemText(IDC_EDIT_SimilaryRange2, \"\");\n\n\tm_comboGlasses.SetCurSel(0);\n\tm_comboMask.SetCurSel(0);\n\tm_comboSex.SetCurSel(0);\n\tm_comboBeard.SetCurSel(0);\n\tm_comboEmotion.SetCurSel(0);\n}\nvoid CQueryDownLoad::OnCbnSelchangeComboAlarmType()\n{\n\tif (m_nAttributeFlag == 1)\n\t{\n\t\tint nSel = m_comboEventType.GetCurSel();\n\t\tif (nSel == 0)\n\t\t{\n\t\t\tGetDlgItem(IDC_EDIT_SimilaryRange1)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_EDIT_SimilaryRange2)->EnableWindow(FALSE);\n\t\t\tmemset(&m_nSimilaryRange, 0, sizeof(m_nSimilaryRange));\n\t\t\tSetDlgItemText(IDC_EDIT_SimilaryRange1, \"\");\n\t\t\tSetDlgItemText(IDC_EDIT_SimilaryRange2, \"\");\n\t\t}\n\t\telse if (nSel == 1)\n\t\t{\n\t\t\tGetDlgItem(IDC_EDIT_SimilaryRange1)->EnableWindow(TRUE);\n\t\t\tGetDlgItem(IDC_EDIT_SimilaryRange2)->EnableWindow(TRUE);\n\t\t}\n\t}\n}\n","size_bytes":45177},"bin/Demo/MfcDemo/03.Alarm/QueryAlarmState.cpp":{"content":"// QueryAlarmState.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"Alarm.h\"\n#include \"QueryAlarmState.h\"\n#include \"AlarmDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CQueryAlarmState dialog\n\n\nCQueryAlarmState::CQueryAlarmState(CWnd* pParent /*=NULL*/)\n\t: CDialog(CQueryAlarmState::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CQueryAlarmState)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\n\tmemset(&m_stNetAlarmState, 0, sizeof(NET_CLIENT_ALARM_STATE));\n\tm_stNetAlarmState.dwSize = sizeof(NET_CLIENT_ALARM_STATE);\n\n\tmemset(&m_stNetVideoLostState, 0, sizeof(NET_CLIENT_VIDEOLOST_STATE));\n\tm_stNetVideoLostState.dwSize = sizeof(NET_CLIENT_VIDEOLOST_STATE);\n\n\tmemset(&m_stNetMotionDetectState, 0, sizeof(NET_CLIENT_MOTIONDETECT_STATE));\n\tm_stNetMotionDetectState.dwSize = sizeof(NET_CLIENT_MOTIONDETECT_STATE);\n\n\tmemset(m_gShelterAlarm, 0, sizeof(m_gShelterAlarm));\n\tmemset(m_gStaticAlarm, 0, sizeof(m_gStaticAlarm));\n\n\tmemset(&m_stuAlarmArmDisarmState, 0, sizeof(ALARM_ARM_DISARM_STATE_INFO));\t \n}\n\n\nvoid CQueryAlarmState::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CQueryAlarmState)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CQueryAlarmState, CDialog)\n\t//{{AFX_MSG_MAP(CQueryAlarmState)\n\tON_BN_CLICKED(IDC_BUTTON_QUERY, OnDoubleclickedButtonQuery)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CQueryAlarmState message handlers\n\nvoid CQueryAlarmState::OnDoubleclickedButtonQuery() \n{\n\t// TODO: Add your control notification handler code here\n\tint nRet =0 ;\n\tint nRetLen =0;\n\tLLONG lLogin =((CAlarmDlg *)(GetParent()->GetParent()))->m_LoginID;\n\t\n\tmemset(&m_stNetAlarmState,0,sizeof(m_stNetAlarmState));\n\tm_stNetAlarmState.dwSize = sizeof(NET_CLIENT_ALARM_STATE);\n\tnRet = CLIENT_QueryDevState(lLogin,DH_DEVSTATE_ALARM,(char*)&m_stNetAlarmState,sizeof(m_stNetAlarmState),&nRetLen);\n\tif(nRet <= 0 && nRetLen == 0)\n\t{\n\t\tDWORD dwError = CLIENT_GetLastError() & 0x7fffffff;\n\t\tMessageBox(ConvertString(\"Get AlarmState failed!\"), ConvertString(\"Prompt\"));\n\t}\n\tmemset(&m_stNetVideoLostState,0,sizeof(m_stNetVideoLostState));\n\tm_stNetVideoLostState.dwSize = sizeof(NET_CLIENT_VIDEOLOST_STATE);\n\tnRet = CLIENT_QueryDevState(lLogin,DH_DEVSTATE_VIDEOLOST,(char*)&m_stNetVideoLostState,sizeof(m_stNetVideoLostState),&nRetLen);\n\tif(nRet <= 0 && nRetLen == 0)\n\t{\n\t\tDWORD dwError = CLIENT_GetLastError() & 0x7fffffff;\n\t\tMessageBox(ConvertString(\"Get VideoLostState failed!\"), ConvertString(\"Prompt\"));\n\t}\n\tmemset(&m_stNetMotionDetectState,0,sizeof(m_stNetMotionDetectState));\n\tm_stNetMotionDetectState.dwSize = sizeof(NET_CLIENT_MOTIONDETECT_STATE);\n\tnRet = CLIENT_QueryDevState(lLogin,DH_DEVSTATE_MOTIONDETECT,(char*)&m_stNetMotionDetectState,sizeof(m_stNetMotionDetectState),&nRetLen);\n\tif(nRet <= 0 && nRetLen == 0)\n\t{\n\t\tDWORD dwError = CLIENT_GetLastError() & 0x7fffffff;\n\t\tMessageBox(ConvertString(\"Get MotionDetectState failed!\"), ConvertString(\"Prompt\"));\n\t}\n\n\tmemset(m_gShelterAlarm, 0, sizeof(char) * 16);\n\tnRet = CLIENT_QueryDevState(lLogin, DH_DEVSTATE_SHELTER_ALARM, (char*)m_gShelterAlarm, sizeof(char) * 16, &nRetLen);\n\tif (nRet <= 0 && nRetLen == 0)\n\t{\n\t\tDWORD dwError = CLIENT_GetLastError() & 0x7fffffff;\n\t\tMessageBox(ConvertString(\"Get shelter alarm failed!\"), ConvertString(\"Prompt\"));\n\t}\n\n\t//Display alarm \n\tSetAlarmInfo();\n}\n\nvoid CQueryAlarmState::SetAlarmInfo()\n{\n\tint ID1 = IDC_CHECK1;\n\tint ID2 = IDC_CHECK17;\n\tint ID3 = IDC_CHECK33;\n\tint ID4 = IDC_CHECK49;\n\tint ID5 = IDC_CHECK65;\n\tfor(int i=0;i<16;i++)\n\t{\n\t\tif(i<m_stNetAlarmState.alarminputcount)\n\t\t{\n\t\t\t((CButton*)GetDlgItem(ID1 + i))->SetCheck((m_stNetAlarmState.dwAlarmState[0] >> i) & 0x01);\n\t\t\t((CButton*)GetDlgItem(ID1 + i))->EnableWindow(1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t((CButton*)GetDlgItem(ID1 + i))->EnableWindow(0);\n\t\t}\n\t\tif(i < m_stNetVideoLostState.channelcount)\n\t\t{\n\t\t\t((CButton*)GetDlgItem(ID2 + i))->SetCheck((m_stNetVideoLostState.dwAlarmState[0] >> i) & 0x01);\n\t\t\t((CButton*)GetDlgItem(ID3 + i))->SetCheck((m_stNetMotionDetectState.dwAlarmState[0] >> i) & 0x01);\n\t\t\t((CButton*)GetDlgItem(ID4 + i))->SetCheck(m_gShelterAlarm[i]);\n\t\t\t((CButton*)GetDlgItem(ID5 + i))->SetCheck(m_gStaticAlarm[i]);\n\t\t\t\n\t\t\t((CButton*)GetDlgItem(ID2 + i))->EnableWindow(1);\n\t\t\t((CButton*)GetDlgItem(ID3 + i))->EnableWindow(1);\n\t\t\t((CButton*)GetDlgItem(ID4 + i))->EnableWindow(1);\n\t\t\t((CButton*)GetDlgItem(ID5 + i))->EnableWindow(1);\n\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\t((CButton*)GetDlgItem(ID2 + i))->EnableWindow(0);\n\t\t\t((CButton*)GetDlgItem(ID3 + i))->EnableWindow(0);\n\t\t\t((CButton*)GetDlgItem(ID4 + i))->EnableWindow(0);\n\t\t\t((CButton*)GetDlgItem(ID5 + i))->EnableWindow(0);\n\t\t\t\n\t\t}\n\t}\n\n\t((CButton*)GetDlgItem(IDC_CHECK_ARM_DISARM))->SetCheck(m_stuAlarmArmDisarmState.bState);\n}\n\n\nBOOL CQueryAlarmState::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\t// TODO: Add extra initialization here\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CQueryAlarmState::CleanAllInfo() \n{\n\tCleanColum(IDC_CHECK1, 16);\n\tCleanColum(IDC_CHECK17, 16);\n\tCleanColum(IDC_CHECK33, 16);\n\tCleanColum(IDC_CHECK49, 16);\n\tCleanColum(IDC_CHECK65, 16);\n}\n\nvoid CQueryAlarmState::CleanColum(UINT uID, int nLen) \n{\n\tfor(int i = 0; i < nLen; i++)\n\t{\n\t\t((CButton*)GetDlgItem(uID + i))->SetCheck(FALSE);\n\t\t((CButton*)GetDlgItem(uID + i))->EnableWindow(TRUE);\n\t}\n}","size_bytes":5633},"bin/Demo/MfcDemo/19.MasterSlaveSensor/Utils.cpp":{"content":"#include \"StdAfx.h\"\n#include \"Utils.h\"\n\nTCHAR* g_GetIniPath(void)\n{\n\tstatic char pszIniPath[512] = {0};\n\tif( strlen(pszIniPath) == 0 )\n\t{\n\t\tchar szDirBuf[512] = {0};\n\t\tGetCurrentDirectory(512, szDirBuf);\n\t\t_snprintf(pszIniPath, sizeof(pszIniPath), \"%s\\\\langchn.ini\", szDirBuf);\n\t}\n\treturn pszIniPath;\n}\n\nCString ConvertString(CString strText)\n{\n\tchar *val = new char[200];\n\tCString strIniPath,strRet;\n\n\tmemset(val,0,200);\n\tGetPrivateProfileString(\"String\",strText,\"\",\n\t\tval,200,g_GetIniPath());\n\tstrRet = val;\n\tif(strRet.GetLength()==0)\n\t{\n\t\t//If there is no corresponding string in ini file ,then set it to be default value.\n\t\tstrRet=strText;\n\t}\n\tdelete val;\n\treturn strRet;\n}\n\nvoid g_SetWndStaticText(CWnd * pWnd)\n{\n\tCString strCaption,strText;\n\n\t//Set main widnow title \n\tpWnd->GetWindowText(strCaption);\n\tif(strCaption.GetLength()>0)\n\t{\n\t\tstrText=ConvertString(strCaption);\n\t\tpWnd->SetWindowText(strText);\n\t}\n\n\t//Set small window title \n\tCWnd * pChild=pWnd->GetWindow(GW_CHILD);\n\tCString strClassName;\n\twhile(pChild)\n\t{\n\t\t//////////////////////////////////////////////////////////////////////////\t\t\n\t\t//Added by Jackbin 2005-03-11\n\t\tstrClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n\t\tif(strClassName == \"CEdit\")\n\t\t{\n\t\t\t//The next small window \n\t\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t\t\tcontinue;\n\t\t}\n\n\t\t//////////////////////////////////////////////////////////////////////////\t\n\n\t\t//Set current language text in small window\n\t\tpChild->GetWindowText(strCaption);\n\t\tstrText=ConvertString(strCaption);\n\t\tpChild->SetWindowText(strText);\n\n\t\t//The next small window \n\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t}\n}\n\nvoid FillCWndWithDefaultColor(CWnd* cwnd) \n{\n\tif (NULL == cwnd)\n\t{\n\t\treturn;\n\t}\n\n\tCDC* cdc = cwnd->GetDC();\n\tif (NULL == cdc)\n\t{\n\t\treturn;\n\t}\n\n\tRECT rect;\n\tcwnd->GetClientRect(&rect);\n\tCBrush brush(RGB(105,105,105));\n\tcdc->FillRect(&rect, &brush);\n\tcwnd->ReleaseDC(cdc);\n}","size_bytes":1916},"bin/Demo/MfcDemo/00.DevInit/LibQREncode/qrspec.c":{"content":"/*\n * qrencode - QR Code encoder\n *\n * QR Code specification in convenient format. \n * Copyright (C) 2006-2011 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * The following data / specifications are taken from\n * \"Two dimensional symbol -- QR-code -- Basic Specification\" (JIS X0510:2004)\n *  or\n * \"Automatic identification and data capture techniques -- \n *  QR Code 2005 bar code symbology specification\" (ISO/IEC 18004:2006)\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#if HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#ifdef HAVE_LIBPTHREAD\n#include <pthread.h>\n#endif\n\n#include \"qrspec.h\"\n#include \"qrinput.h\"\n\n/******************************************************************************\n * Version and capacity\n *****************************************************************************/\n\ntypedef struct {\n\tint width; //< Edge length of the symbol\n\tint words;  //< Data capacity (bytes)\n\tint remainder; //< Remainder bit (bits)\n\tint ec[4];  //< Number of ECC code (bytes)\n} QRspec_Capacity;\n\n/**\n * Table of the capacity of symbols\n * See Table 1 (pp.13) and Table 12-16 (pp.30-36), JIS X0510:2004.\n */\nstatic const QRspec_Capacity qrspecCapacity[QRSPEC_VERSION_MAX + 1] = {\n\t{  0,    0, 0, {   0,    0,    0,    0}},\n\t{ 21,   26, 0, {   7,   10,   13,   17}}, // 1\n\t{ 25,   44, 7, {  10,   16,   22,   28}},\n\t{ 29,   70, 7, {  15,   26,   36,   44}},\n\t{ 33,  100, 7, {  20,   36,   52,   64}},\n\t{ 37,  134, 7, {  26,   48,   72,   88}}, // 5\n\t{ 41,  172, 7, {  36,   64,   96,  112}},\n\t{ 45,  196, 0, {  40,   72,  108,  130}},\n\t{ 49,  242, 0, {  48,   88,  132,  156}},\n\t{ 53,  292, 0, {  60,  110,  160,  192}},\n\t{ 57,  346, 0, {  72,  130,  192,  224}}, //10\n\t{ 61,  404, 0, {  80,  150,  224,  264}},\n\t{ 65,  466, 0, {  96,  176,  260,  308}},\n\t{ 69,  532, 0, { 104,  198,  288,  352}},\n\t{ 73,  581, 3, { 120,  216,  320,  384}},\n\t{ 77,  655, 3, { 132,  240,  360,  432}}, //15\n\t{ 81,  733, 3, { 144,  280,  408,  480}},\n\t{ 85,  815, 3, { 168,  308,  448,  532}},\n\t{ 89,  901, 3, { 180,  338,  504,  588}},\n\t{ 93,  991, 3, { 196,  364,  546,  650}},\n\t{ 97, 1085, 3, { 224,  416,  600,  700}}, //20\n\t{101, 1156, 4, { 224,  442,  644,  750}},\n\t{105, 1258, 4, { 252,  476,  690,  816}},\n\t{109, 1364, 4, { 270,  504,  750,  900}},\n\t{113, 1474, 4, { 300,  560,  810,  960}},\n\t{117, 1588, 4, { 312,  588,  870, 1050}}, //25\n\t{121, 1706, 4, { 336,  644,  952, 1110}},\n\t{125, 1828, 4, { 360,  700, 1020, 1200}},\n\t{129, 1921, 3, { 390,  728, 1050, 1260}},\n\t{133, 2051, 3, { 420,  784, 1140, 1350}},\n\t{137, 2185, 3, { 450,  812, 1200, 1440}}, //30\n\t{141, 2323, 3, { 480,  868, 1290, 1530}},\n\t{145, 2465, 3, { 510,  924, 1350, 1620}},\n\t{149, 2611, 3, { 540,  980, 1440, 1710}},\n\t{153, 2761, 3, { 570, 1036, 1530, 1800}},\n\t{157, 2876, 0, { 570, 1064, 1590, 1890}}, //35\n\t{161, 3034, 0, { 600, 1120, 1680, 1980}},\n\t{165, 3196, 0, { 630, 1204, 1770, 2100}},\n\t{169, 3362, 0, { 660, 1260, 1860, 2220}},\n\t{173, 3532, 0, { 720, 1316, 1950, 2310}},\n\t{177, 3706, 0, { 750, 1372, 2040, 2430}} //40\n};\n\nint QRspec_getDataLength(int version, QRecLevel level)\n{\n\treturn qrspecCapacity[version].words - qrspecCapacity[version].ec[level];\n}\n\nint QRspec_getECCLength(int version, QRecLevel level)\n{\n\treturn qrspecCapacity[version].ec[level];\n}\n\nint QRspec_getMinimumVersion(int size, QRecLevel level)\n{\n\tint i;\n\tint words;\n\n\tfor(i=1; i<= QRSPEC_VERSION_MAX; i++) {\n\t\twords  = qrspecCapacity[i].words - qrspecCapacity[i].ec[level];\n\t\tif(words >= size) return i;\n\t}\n\n\treturn -1;\n}\n\nint QRspec_getWidth(int version)\n{\n\treturn qrspecCapacity[version].width;\n}\n\nint QRspec_getRemainder(int version)\n{\n\treturn qrspecCapacity[version].remainder;\n}\n\n/******************************************************************************\n * Length indicator\n *****************************************************************************/\n\nstatic const int lengthTableBits[4][3] = {\n\t{10, 12, 14},\n\t{ 9, 11, 13},\n\t{ 8, 16, 16},\n\t{ 8, 10, 12}\n};\n\nint QRspec_lengthIndicator(QRencodeMode mode, int version)\n{\n\tint l;\n\n\tif(!QRinput_isSplittableMode(mode)) return 0;\n\tif(version <= 9) {\n\t\tl = 0;\n\t} else if(version <= 26) {\n\t\tl = 1;\n\t} else {\n\t\tl = 2;\n\t}\n\n\treturn lengthTableBits[mode][l];\n}\n\nint QRspec_maximumWords(QRencodeMode mode, int version)\n{\n\tint l;\n\tint bits;\n\tint words;\n\n\tif(!QRinput_isSplittableMode(mode)) return 0;\n\tif(version <= 9) {\n\t\tl = 0;\n\t} else if(version <= 26) {\n\t\tl = 1;\n\t} else {\n\t\tl = 2;\n\t}\n\n\tbits = lengthTableBits[mode][l];\n\twords = (1 << bits) - 1;\n\tif(mode == QR_MODE_KANJI) {\n\t\twords *= 2; // the number of bytes is required\n\t}\n\n\treturn words;\n}\n\n/******************************************************************************\n * Error correction code\n *****************************************************************************/\n\n/**\n * Table of the error correction code (Reed-Solomon block)\n * See Table 12-16 (pp.30-36), JIS X0510:2004.\n */\nstatic const int eccTable[QRSPEC_VERSION_MAX+1][4][2] = {\n\t{{ 0,  0}, { 0,  0}, { 0,  0}, { 0,  0}},\n\t{{ 1,  0}, { 1,  0}, { 1,  0}, { 1,  0}}, // 1\n\t{{ 1,  0}, { 1,  0}, { 1,  0}, { 1,  0}},\n\t{{ 1,  0}, { 1,  0}, { 2,  0}, { 2,  0}},\n\t{{ 1,  0}, { 2,  0}, { 2,  0}, { 4,  0}},\n\t{{ 1,  0}, { 2,  0}, { 2,  2}, { 2,  2}}, // 5\n\t{{ 2,  0}, { 4,  0}, { 4,  0}, { 4,  0}},\n\t{{ 2,  0}, { 4,  0}, { 2,  4}, { 4,  1}},\n\t{{ 2,  0}, { 2,  2}, { 4,  2}, { 4,  2}},\n\t{{ 2,  0}, { 3,  2}, { 4,  4}, { 4,  4}},\n\t{{ 2,  2}, { 4,  1}, { 6,  2}, { 6,  2}}, //10\n\t{{ 4,  0}, { 1,  4}, { 4,  4}, { 3,  8}},\n\t{{ 2,  2}, { 6,  2}, { 4,  6}, { 7,  4}},\n\t{{ 4,  0}, { 8,  1}, { 8,  4}, {12,  4}},\n\t{{ 3,  1}, { 4,  5}, {11,  5}, {11,  5}},\n\t{{ 5,  1}, { 5,  5}, { 5,  7}, {11,  7}}, //15\n\t{{ 5,  1}, { 7,  3}, {15,  2}, { 3, 13}},\n\t{{ 1,  5}, {10,  1}, { 1, 15}, { 2, 17}},\n\t{{ 5,  1}, { 9,  4}, {17,  1}, { 2, 19}},\n\t{{ 3,  4}, { 3, 11}, {17,  4}, { 9, 16}},\n\t{{ 3,  5}, { 3, 13}, {15,  5}, {15, 10}}, //20\n\t{{ 4,  4}, {17,  0}, {17,  6}, {19,  6}},\n\t{{ 2,  7}, {17,  0}, { 7, 16}, {34,  0}},\n\t{{ 4,  5}, { 4, 14}, {11, 14}, {16, 14}},\n\t{{ 6,  4}, { 6, 14}, {11, 16}, {30,  2}},\n\t{{ 8,  4}, { 8, 13}, { 7, 22}, {22, 13}}, //25\n\t{{10,  2}, {19,  4}, {28,  6}, {33,  4}},\n\t{{ 8,  4}, {22,  3}, { 8, 26}, {12, 28}},\n\t{{ 3, 10}, { 3, 23}, { 4, 31}, {11, 31}},\n\t{{ 7,  7}, {21,  7}, { 1, 37}, {19, 26}},\n\t{{ 5, 10}, {19, 10}, {15, 25}, {23, 25}}, //30\n\t{{13,  3}, { 2, 29}, {42,  1}, {23, 28}},\n\t{{17,  0}, {10, 23}, {10, 35}, {19, 35}},\n\t{{17,  1}, {14, 21}, {29, 19}, {11, 46}},\n\t{{13,  6}, {14, 23}, {44,  7}, {59,  1}},\n\t{{12,  7}, {12, 26}, {39, 14}, {22, 41}}, //35\n\t{{ 6, 14}, { 6, 34}, {46, 10}, { 2, 64}},\n\t{{17,  4}, {29, 14}, {49, 10}, {24, 46}},\n\t{{ 4, 18}, {13, 32}, {48, 14}, {42, 32}},\n\t{{20,  4}, {40,  7}, {43, 22}, {10, 67}},\n\t{{19,  6}, {18, 31}, {34, 34}, {20, 61}},//40\n};\n\nvoid QRspec_getEccSpec(int version, QRecLevel level, int spec[5])\n{\n\tint b1, b2;\n\tint data, ecc;\n\n\tb1 = eccTable[version][level][0];\n\tb2 = eccTable[version][level][1];\n\tdata = QRspec_getDataLength(version, level);\n\tecc  = QRspec_getECCLength(version, level);\n\n\tif(b2 == 0) {\n\t\tspec[0] = b1;\n\t\tspec[1] = data / b1;\n\t\tspec[2] = ecc / b1;\n\t\tspec[3] = spec[4] = 0;\n\t} else {\n\t\tspec[0] = b1;\n\t\tspec[1] = data / (b1 + b2);\n\t\tspec[2] = ecc  / (b1 + b2);\n\t\tspec[3] = b2;\n\t\tspec[4] = spec[1] + 1;\n\t}\n}\n\n/******************************************************************************\n * Alignment pattern\n *****************************************************************************/\n\n/**\n * Positions of alignment patterns.\n * This array includes only the second and the third position of the alignment\n * patterns. Rest of them can be calculated from the distance between them.\n *\n * See Table 1 in Appendix E (pp.71) of JIS X0510:2004.\n */\nstatic const int alignmentPattern[QRSPEC_VERSION_MAX+1][2] = {\n\t{ 0,  0},\n\t{ 0,  0}, {18,  0}, {22,  0}, {26,  0}, {30,  0}, // 1- 5\n\t{34,  0}, {22, 38}, {24, 42}, {26, 46}, {28, 50}, // 6-10\n\t{30, 54}, {32, 58}, {34, 62}, {26, 46}, {26, 48}, //11-15\n\t{26, 50}, {30, 54}, {30, 56}, {30, 58}, {34, 62}, //16-20\n\t{28, 50}, {26, 50}, {30, 54}, {28, 54}, {32, 58}, //21-25\n\t{30, 58}, {34, 62}, {26, 50}, {30, 54}, {26, 52}, //26-30\n\t{30, 56}, {34, 60}, {30, 58}, {34, 62}, {30, 54}, //31-35\n\t{24, 50}, {28, 54}, {32, 58}, {26, 54}, {30, 58}, //35-40\n};\n\n/**\n * Put an alignment marker.\n * @param frame\n * @param width\n * @param ox,oy center coordinate of the pattern\n */\nstatic void QRspec_putAlignmentMarker(unsigned char *frame, int width, int ox, int oy)\n{\n\tstatic const unsigned char finder[] = {\n\t\t0xa1, 0xa1, 0xa1, 0xa1, 0xa1,\n\t\t0xa1, 0xa0, 0xa0, 0xa0, 0xa1,\n\t\t0xa1, 0xa0, 0xa1, 0xa0, 0xa1,\n\t\t0xa1, 0xa0, 0xa0, 0xa0, 0xa1,\n\t\t0xa1, 0xa1, 0xa1, 0xa1, 0xa1,\n\t};\n\tint x, y;\n\tconst unsigned char *s;\n\n\tframe += (oy - 2) * width + ox - 2;\n\ts = finder;\n\tfor(y=0; y<5; y++) {\n\t\tfor(x=0; x<5; x++) {\n\t\t\tframe[x] = s[x];\n\t\t}\n\t\tframe += width;\n\t\ts += 5;\n\t}\n}\n\nstatic void QRspec_putAlignmentPattern(int version, unsigned char *frame, int width)\n{\n\tint d, w, x, y, cx, cy;\n\n\tif(version < 2) return;\n\n\td = alignmentPattern[version][1] - alignmentPattern[version][0];\n\tif(d < 0) {\n\t\tw = 2;\n\t} else {\n\t\tw = (width - alignmentPattern[version][0]) / d + 2;\n\t}\n\n\tif(w * w - 3 == 1) {\n\t\tx = alignmentPattern[version][0];\n\t\ty = alignmentPattern[version][0];\n\t\tQRspec_putAlignmentMarker(frame, width, x, y);\n\t\treturn;\n\t}\n\n\tcx = alignmentPattern[version][0];\n\tfor(x=1; x<w - 1; x++) {\n\t\tQRspec_putAlignmentMarker(frame, width,  6, cx);\n\t\tQRspec_putAlignmentMarker(frame, width, cx,  6);\n\t\tcx += d;\n\t}\n\n\tcy = alignmentPattern[version][0];\n\tfor(y=0; y<w-1; y++) {\n\t\tcx = alignmentPattern[version][0];\n\t\tfor(x=0; x<w-1; x++) {\n\t\t\tQRspec_putAlignmentMarker(frame, width, cx, cy);\n\t\t\tcx += d;\n\t\t}\n\t\tcy += d;\n\t}\n}\n\n/******************************************************************************\n * Version information pattern\n *****************************************************************************/\n\n/**\n * Version information pattern (BCH coded).\n * See Table 1 in Appendix D (pp.68) of JIS X0510:2004.\n */\nstatic const unsigned int versionPattern[QRSPEC_VERSION_MAX - 6] = {\n\t0x07c94, 0x085bc, 0x09a99, 0x0a4d3, 0x0bbf6, 0x0c762, 0x0d847, 0x0e60d,\n\t0x0f928, 0x10b78, 0x1145d, 0x12a17, 0x13532, 0x149a6, 0x15683, 0x168c9,\n\t0x177ec, 0x18ec4, 0x191e1, 0x1afab, 0x1b08e, 0x1cc1a, 0x1d33f, 0x1ed75,\n\t0x1f250, 0x209d5, 0x216f0, 0x228ba, 0x2379f, 0x24b0b, 0x2542e, 0x26a64,\n\t0x27541, 0x28c69\n};\n\nunsigned int QRspec_getVersionPattern(int version)\n{\n\tif(version < 7 || version > QRSPEC_VERSION_MAX) return 0;\n\n\treturn versionPattern[version - 7];\n}\n\n/******************************************************************************\n * Format information\n *****************************************************************************/\n\n/* See calcFormatInfo in tests/test_qrspec.c */\nstatic const unsigned int formatInfo[4][8] = {\n\t{0x77c4, 0x72f3, 0x7daa, 0x789d, 0x662f, 0x6318, 0x6c41, 0x6976},\n\t{0x5412, 0x5125, 0x5e7c, 0x5b4b, 0x45f9, 0x40ce, 0x4f97, 0x4aa0},\n\t{0x355f, 0x3068, 0x3f31, 0x3a06, 0x24b4, 0x2183, 0x2eda, 0x2bed},\n\t{0x1689, 0x13be, 0x1ce7, 0x19d0, 0x0762, 0x0255, 0x0d0c, 0x083b}\n};\n\nunsigned int QRspec_getFormatInfo(int mask, QRecLevel level)\n{\n\tif(mask < 0 || mask > 7) return 0;\n\n\treturn formatInfo[level][mask];\n}\n\n/******************************************************************************\n * Frame\n *****************************************************************************/\n\n/**\n * Cache of initial frames.\n */\n/* C99 says that static storage shall be initialized to a null pointer\n * by compiler. */\nstatic unsigned char *frames[QRSPEC_VERSION_MAX + 1];\n#ifdef HAVE_LIBPTHREAD\nstatic pthread_mutex_t frames_mutex = PTHREAD_MUTEX_INITIALIZER;\n#endif\n\n/**\n * Put a finder pattern.\n * @param frame\n * @param width\n * @param ox,oy upper-left coordinate of the pattern\n */\nstatic void putFinderPattern(unsigned char *frame, int width, int ox, int oy)\n{\n\tstatic const unsigned char finder[] = {\n\t\t0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,\n\t\t0xc1, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc1,\n\t\t0xc1, 0xc0, 0xc1, 0xc1, 0xc1, 0xc0, 0xc1,\n\t\t0xc1, 0xc0, 0xc1, 0xc1, 0xc1, 0xc0, 0xc1,\n\t\t0xc1, 0xc0, 0xc1, 0xc1, 0xc1, 0xc0, 0xc1,\n\t\t0xc1, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc1,\n\t\t0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,\n\t};\n\tint x, y;\n\tconst unsigned char *s;\n\n\tframe += oy * width + ox;\n\ts = finder;\n\tfor(y=0; y<7; y++) {\n\t\tfor(x=0; x<7; x++) {\n\t\t\tframe[x] = s[x];\n\t\t}\n\t\tframe += width;\n\t\ts += 7;\n\t}\n}\n\n\nstatic unsigned char *QRspec_createFrame(int version)\n{\n\tunsigned char *frame, *p, *q;\n\tint width;\n\tint x, y;\n\tunsigned int verinfo, v;\n\n\twidth = qrspecCapacity[version].width;\n\tframe = (unsigned char *)malloc(width * width);\n\tif(frame == NULL) return NULL;\n\n\tmemset(frame, 0, width * width);\n\t/* Finder pattern */\n\tputFinderPattern(frame, width, 0, 0);\n\tputFinderPattern(frame, width, width - 7, 0);\n\tputFinderPattern(frame, width, 0, width - 7);\n\t/* Separator */\n\tp = frame;\n\tq = frame + width * (width - 7);\n\tfor(y=0; y<7; y++) {\n\t\tp[7] = 0xc0;\n\t\tp[width - 8] = 0xc0;\n\t\tq[7] = 0xc0;\n\t\tp += width;\n\t\tq += width;\n\t}\n\tmemset(frame + width * 7, 0xc0, 8);\n\tmemset(frame + width * 8 - 8, 0xc0, 8);\n\tmemset(frame + width * (width - 8), 0xc0, 8);\n\t/* Mask format information area */\n\tmemset(frame + width * 8, 0x84, 9);\n\tmemset(frame + width * 9 - 8, 0x84, 8);\n\tp = frame + 8;\n\tfor(y=0; y<8; y++) {\n\t\t*p = 0x84;\n\t\tp += width;\n\t}\n\tp = frame + width * (width - 7) + 8;\n\tfor(y=0; y<7; y++) {\n\t\t*p = 0x84;\n\t\tp += width;\n\t}\n\t/* Timing pattern */\n\tp = frame + width * 6 + 8;\n\tq = frame + width * 8 + 6;\n\tfor(x=1; x<width-15; x++) {\n\t\t*p =  0x90 | (x & 1);\n\t\t*q =  0x90 | (x & 1);\n\t\tp++;\n\t\tq += width;\n\t}\n\t/* Alignment pattern */\n\tQRspec_putAlignmentPattern(version, frame, width);\n\n\t/* Version information */\n\tif(version >= 7) {\n\t\tverinfo = QRspec_getVersionPattern(version);\n\n\t\tp = frame + width * (width - 11);\n\t\tv = verinfo;\n\t\tfor(x=0; x<6; x++) {\n\t\t\tfor(y=0; y<3; y++) {\n\t\t\t\tp[width * y + x] = 0x88 | (v & 1);\n\t\t\t\tv = v >> 1;\n\t\t\t}\n\t\t}\n\n\t\tp = frame + width - 11;\n\t\tv = verinfo;\n\t\tfor(y=0; y<6; y++) {\n\t\t\tfor(x=0; x<3; x++) {\n\t\t\t\tp[x] = 0x88 | (v & 1);\n\t\t\t\tv = v >> 1;\n\t\t\t}\n\t\t\tp += width;\n\t\t}\n\t}\n\t/* and a little bit... */\n\tframe[width * (width - 8) + 8] = 0x81;\n\n\treturn frame;\n}\n\nunsigned char *QRspec_newFrame(int version)\n{\n\tunsigned char *frame;\n\tint width;\n\n\tif(version < 1 || version > QRSPEC_VERSION_MAX) return NULL;\n\n#ifdef HAVE_LIBPTHREAD\n\tpthread_mutex_lock(&frames_mutex);\n#endif\n\tif(frames[version] == NULL) {\n\t\tframes[version] = QRspec_createFrame(version);\n\t}\n#ifdef HAVE_LIBPTHREAD\n\tpthread_mutex_unlock(&frames_mutex);\n#endif\n\tif(frames[version] == NULL) return NULL;\n\n\twidth = qrspecCapacity[version].width;\n\tframe = (unsigned char *)malloc(width * width);\n\tif(frame == NULL) return NULL;\n\tmemcpy(frame, frames[version], width * width);\n\n\treturn frame;\n}\n\nvoid QRspec_clearCache(void)\n{\n\tint i;\n\n#ifdef HAVE_LIBPTHREAD\n\tpthread_mutex_lock(&frames_mutex);\n#endif\n\tfor(i=1; i<=QRSPEC_VERSION_MAX; i++) {\n\t\tfree(frames[i]);\n\t\tframes[i] = NULL;\n\t}\n#ifdef HAVE_LIBPTHREAD\n\tpthread_mutex_unlock(&frames_mutex);\n#endif\n}\n","size_bytes":15715},"bin/Demo/MfcDemo/16.HumanTrait/stdafx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n// HumanTrait.pch will be the pre-compiled header\n// stdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n\n\n","size_bytes":203},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgAlarm.cpp":{"content":"// DlgCfgAlarm.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgCfgAlarm.h\"\n#include \"SubDlgCfgEventHandler.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgAlarm dialog\n\n\nCDlgCfgAlarm::CDlgCfgAlarm(CWnd* pParent /* = NULL */, LLONG hLoginID /* = NULL */, UINT32 uiAlarmIn /* = 0 */)\n\t: CDialog(CDlgCfgAlarm::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgAlarm)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\tm_uiAlarmIn = uiAlarmIn;\n\t//}}AFX_DATA_INIT\n\n\tm_hLoginID = hLoginID;\n\tmemset(&m_stuInfo, 0, sizeof(m_stuInfo));\n\tm_bNeedResetWaittime = FALSE;\n}\n\n\nvoid CDlgCfgAlarm::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgAlarm)\n\tDDX_Control(pDX, IDC_CFG_ALARM_CHK_LEVEL2, m_chkLevel2);\n\tDDX_Control(pDX, IDC_CFG_ALARM_EDT_NAME, m_edtName);\n\tDDX_Control(pDX, IDC_CFG_ALARM_EDT_ENA_DELAY, m_edtEnableDelay);\n\tDDX_Control(pDX, IDC_CFG_ALARM_EDT_DIS_DELAY, m_edtDisableDelay);\n\tDDX_Control(pDX, IDC_CFG_ALARM_CMB_SENSORTYPE, m_cmbSensorType);\n\tDDX_Control(pDX, IDC_CFG_ALARM_CMB_SENSORMETHOD, m_cmbSensorMethod);\n\tDDX_Control(pDX, IDC_CFG_ALARM_CMB_CHN, m_cmbChn);\n\tDDX_Control(pDX, IDC_CFG_ALARM_CMB_AREATYPE, m_cmbAreaType);\n\tDDX_Control(pDX, IDC_CFG_ALARM_CHK_BYPASS, m_chkByPass);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgAlarm, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgAlarm)\n\tON_BN_CLICKED(IDC_CFG_ALARM_BTN_EVENTHANDLER, OnCfgAlarmBtnEventhandler)\n\tON_BN_CLICKED(IDC_CFG_ALARM_BTN_GET, OnCfgAlarmBtnGet)\n\tON_BN_CLICKED(IDC_CFG_ALARM_BTN_SET, OnCfgAlarmBtnSet)\n\tON_CBN_SELCHANGE(IDC_CFG_ALARM_CMB_CHN, OnSelchangeCfgAlarmCmbChn)\n\tON_BN_CLICKED(IDC_CFG_ALARM_CHK_LEVEL2, OnCfgAlarmChkLevel2)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgAlarm message handlers\n\nBOOL CDlgCfgAlarm::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_ALARM);\n\t// TODO: Add extra initialization here\n\tif (m_hLoginID == 0)\n\t{\n\t\tMessageBox(ConvertString(\"We haven't login yet!\", DLG_CFG_ALARM), ConvertString(\"Prompt\"));\n\t\t//EndDialog(0);\n\t}\n\t\n\tInitDlg();\n\tif (GetConfigFromDevice())\n\t{\n\t\tStuToDlg();\n\t}\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgAlarm::OnCfgAlarmBtnEventhandler() \n{\n\t// TODO: Add your control notification handler code here\n\tCSubDlgCfgEventHandler* pdlgEventHandler = new CSubDlgCfgEventHandler;\n\tif (pdlgEventHandler != NULL)\n\t{\n\t\tpdlgEventHandler->SetEventHandler(m_stuInfo.stuEventHandler);\n\t\tpdlgEventHandler->SetTimeSection(&m_stuInfo.stuTimeSection[0][0]);\n\t\t\n\t\tif (IDOK == pdlgEventHandler->DoModal())\n\t\t{\n\t\t\tm_bNeedResetWaittime = pdlgEventHandler->GetTiemChangeFlag();\n\t\t\tconst CFG_ALARM_MSG_HANDLE& stuEventHandler = pdlgEventHandler->GetEventHandler();\n\t\t\tmemcpy(&m_stuInfo.stuEventHandler, &stuEventHandler, sizeof(CFG_ALARM_MSG_HANDLE));\n\t\t\t\n\t\t\tfor (int i = 0; i < WEEK_DAY_NUM; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < MAX_REC_TSECT; j++)\n\t\t\t\t{\n\t\t\t\t\tconst CFG_TIME_SECTION* pstuTimeSection = pdlgEventHandler->GetTimeSection(i, j);\n\t\t\t\t\tif (pstuTimeSection)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemcpy(&m_stuInfo.stuTimeSection[i][j], pstuTimeSection, sizeof(CFG_TIME_SECTION));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdelete pdlgEventHandler;\n\t\tpdlgEventHandler = NULL;\n\t}\n\telse\n\t{\n\t\tMessageBox(ConvertString(\"new handler dialog error!\", DLG_CFG_ALARM), ConvertString(\"Prompt\"));\n\t}\n\t\n}\n\nvoid CDlgCfgAlarm::OnCfgAlarmBtnGet() \n{\n\t// TODO: Add your control notification handler code here\t\n\tif (GetConfigFromDevice())\n\t{\n\t\tStuToDlg();\n\t}\n}\n\nvoid CDlgCfgAlarm::OnCfgAlarmBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\tSetConfigToDevice();\t\t\n}\n\n//////////////////////////////////////////////////////////////////////////\n// Private method\n\nvoid CDlgCfgAlarm::InitDlg(BOOL bShow /* = TRUE */)\n{\n\tif (!bShow)\n\t{\n\t\tmemset(&m_stuInfo, 0, sizeof(m_stuInfo));\n\t}\n\n\tint i = 0;\n\tint nChannelNum = m_uiAlarmIn == 0 ? 16 : m_uiAlarmIn;\n\n\t// channel\n\tm_cmbChn.ResetContent();\n\tfor (i = 0; i < nChannelNum; i++)\n\t{\n\t\tCString csItem;\n\t\tcsItem.Format(\"%s %02d\", ConvertString(\"Channel\", DLG_CFG_ALARM), i + 1);\n\t\tm_cmbChn.InsertString(-1, csItem);\n\t}\n\tm_cmbChn.SetCurSel(m_stuInfo.nChannelID);\n\n\t// bypass\n\tm_chkByPass.SetCheck(m_stuInfo.bEnable ? BST_UNCHECKED : BST_CHECKED);\n\n\t// defence_area_type\n\tm_cmbAreaType.ResetContent();\n\tfor (i = 0; i < sizeof(stuDemoAreaType) / sizeof(stuDemoAreaType[0]); i++)\n\t{\n\t\tm_cmbAreaType.InsertString(-1, ConvertString(stuDemoAreaType[i].pszName, DLG_CFG_ALARM));\n\t}\n\tm_cmbAreaType.SetCurSel((int)m_stuInfo.emDefenceAreaType);\n\n\t// disable delay\n\tSetDlgItemInt(IDC_CFG_ALARM_EDT_DIS_DELAY, m_stuInfo.nDisDelay, FALSE);\n\n\t// enable delay\n\tSetDlgItemInt(IDC_CFG_ALARM_EDT_ENA_DELAY, m_stuInfo.nEnableDelay, FALSE);\n\n\t// name\n\tSetDlgItemText(IDC_CFG_ALARM_EDT_NAME, m_stuInfo.szChnName);\n\n\t// sensor type: nc or no\n\tm_cmbSensorType.ResetContent();\n\tm_cmbSensorType.InsertString(-1, ConvertString(\"NC\", DLG_CFG_ALARM));\n\tm_cmbSensorType.InsertString(-1, ConvertString(\"NO\", DLG_CFG_ALARM));\n\tm_cmbSensorType.SetCurSel(m_stuInfo.nAlarmType);\n\n\t// sensor method...to be\n\tm_cmbSensorMethod.ResetContent();\n\tfor (i = 0; i < sizeof(stuDemoSenseMethod) / sizeof(stuDemoSenseMethod[0]); i++)\n\t{\n\t\tm_cmbSensorMethod.InsertString(-1, ConvertString(stuDemoSenseMethod[i].pszName, DLG_CFG_ALARM));\n\t}\n\tm_cmbSensorMethod.SetCurSel(int(m_stuInfo.emSense));\n\t\n\t// slot\n\n\t// level1\n\n\t// level2\n}\n\nBOOL CDlgCfgAlarm::SetConfigToDevice()\n{\t\n\tchar szJsonBuf[1024 * 40] = {0};\n\tBOOL bRet = CLIENT_PacketData(CFG_CMD_ALARMINPUT, &m_stuInfo, sizeof(m_stuInfo), szJsonBuf, sizeof(szJsonBuf));\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(CString(\"packet Alarm error...\"), DLG_CFG_ALARM), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t} \n\telse\n\t{\t\t\n\t\tint nSelChn = m_cmbChn.GetCurSel() == -1 ? 0 : m_cmbChn.GetCurSel();\n\t\tint nerror = 0;\n\t\tint nrestart = 0;\n\t\t\n\t\tbRet = CLIENT_SetNewDevConfig((LLONG)m_hLoginID, CFG_CMD_ALARMINPUT, nSelChn, szJsonBuf, 1024*40, &nerror, &nrestart, SDK_API_WAIT);\n\t\tif (!bRet)\n\t\t{\n\t\t\tCString csErr;\n\t\t\tcsErr.Format(\"%s %08x\", ConvertString(\"SetupConfig Alarm failed:\", DLG_CFG_ALARM), CLIENT_GetLastError());\n\t\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"SetConfig Alarm ok!\"), DLG_CFG_ALARM), ConvertString(\"Prompt\"));\n\t\t}\n\t}\n\treturn TRUE;\n}\n\nBOOL CDlgCfgAlarm::GetConfigFromDevice()\n{\n\tchar szJsonBuf[1024 * 40] = {0};\n\tint nerror = 0;\n\tint nSelChn = m_cmbChn.GetCurSel() == -1 ? 0 : m_cmbChn.GetCurSel();\n\tBOOL bRet = CLIENT_GetNewDevConfig((LLONG)m_hLoginID, CFG_CMD_ALARMINPUT, nSelChn, szJsonBuf, 1024*40, &nerror, SDK_API_WAIT);\n\n\tif (bRet)\n\t{\n\t\tDWORD dwRetLen = 0;\n\t\tbRet = CLIENT_ParseData(CFG_CMD_ALARMINPUT, szJsonBuf, (void*)&m_stuInfo, sizeof(m_stuInfo), &dwRetLen);\n\t\tif (!bRet)\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"parse Alarm error...\"), DLG_CFG_ALARM), ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\t\t\t\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"QueryConfig Alarm error:\", DLG_CFG_ALARM), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nvoid CDlgCfgAlarm::DlgToStu()\n{\n\tm_stuInfo.bEnable = m_chkByPass.GetCheck() ? FALSE : TRUE;\n\tm_stuInfo.emDefenceAreaType = (EM_CFG_DEFENCEAREATYPE)m_cmbAreaType.GetCurSel();\n\tm_stuInfo.nDisDelay = GetDlgItemInt(IDC_CFG_ALARM_EDT_DIS_DELAY);\n\tm_stuInfo.nEnableDelay = GetDlgItemInt(IDC_CFG_ALARM_EDT_ENA_DELAY);\n\tGetDlgItemText(IDC_CFG_ALARM_EDT_NAME, m_stuInfo.szChnName, sizeof(m_stuInfo.szChnName));\n\tm_stuInfo.nAlarmType = m_cmbSensorType.GetCurSel();\n\tm_stuInfo.emSense = (EM_SENSE_METHOD)m_cmbSensorMethod.GetCurSel();\n\n\t// slot\n\tm_stuInfo.nSlot = GetDlgItemInt(IDC_CFG_ALARM_EDT_SLOT);\n\n\t// level1\n\tm_stuInfo.nLevel1 = GetDlgItemInt(IDC_CFG_ALARM_EDT_LEVEL1);\n\n\t// level2\n\tif (m_chkLevel2.GetCheck())\n\t{\n\t\tm_stuInfo.abLevel2 = true;\n\t\tm_stuInfo.nLevel2 = GetDlgItemInt(IDC_CFG_ALARM_EDT_LEVEL2);\n\t}\n\telse\n\t{\n\t\tm_stuInfo.abLevel2 = false;\n\t}\n}\n\nvoid CDlgCfgAlarm::StuToDlg()\n{\n\tm_chkByPass.SetCheck(m_stuInfo.bEnable ? BST_UNCHECKED : BST_CHECKED);\n\tm_cmbAreaType.SetCurSel((int)m_stuInfo.emDefenceAreaType);\n\tSetDlgItemInt(IDC_CFG_ALARM_EDT_DIS_DELAY, (UINT)m_stuInfo.nDisDelay, FALSE);\n\tSetDlgItemInt(IDC_CFG_ALARM_EDT_ENA_DELAY, (UINT)m_stuInfo.nEnableDelay, FALSE);\n\tSetDlgItemText(IDC_CFG_ALARM_EDT_NAME, m_stuInfo.szChnName);\n\tm_cmbSensorType.SetCurSel((int)m_stuInfo.nAlarmType);\n\tm_cmbSensorMethod.SetCurSel((int)m_stuInfo.emSense);\n\n\t// slot\n\tSetDlgItemInt(IDC_CFG_ALARM_EDT_SLOT, m_stuInfo.nSlot);\n\n\t// level1\n\tSetDlgItemInt(IDC_CFG_ALARM_EDT_LEVEL1, m_stuInfo.nLevel1);\n\n\t// level2\n\tif (m_stuInfo.abLevel2)\n\t{\n\t\tm_chkLevel2.SetCheck(BST_CHECKED);\n\t\tSetDlgItemInt(IDC_CFG_ALARM_EDT_LEVEL2, m_stuInfo.nLevel2);\n\t\tGetDlgItem(IDC_CFG_ALARM_EDT_LEVEL2)->EnableWindow();\n\t}\n\telse\n\t{\n\t\tm_chkLevel2.SetCheck(BST_UNCHECKED);\n\t\tGetDlgItem(IDC_CFG_ALARM_EDT_LEVEL2)->EnableWindow(FALSE);\n\t}\n}\n\nvoid CDlgCfgAlarm::OnSelchangeCfgAlarmCmbChn() \n{\n\t// TODO: Add your control notification handler code here\n\tint nSel = m_cmbChn.GetCurSel();\n\tif (-1 == nSel)\n\t{\n\t\treturn;\n\t}\n\n\tif (GetConfigFromDevice())\n\t{\n\t\tStuToDlg();\n\t}\n}\n\nvoid CDlgCfgAlarm::OnCfgAlarmChkLevel2() \n{\n\t// TODO: Add your control notification handler code here\n\tif (m_chkLevel2.GetCheck())\n\t{\n\t\tGetDlgItem(IDC_CFG_ALARM_EDT_LEVEL2)->EnableWindow();\n\t}\n\telse\n\t{\n\t\tGetDlgItem(IDC_CFG_ALARM_EDT_LEVEL2)->EnableWindow(FALSE);\n\t}\n}\n","size_bytes":9681},"bin/DemoSrc/WaterCheck_demo/StdAfx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n//\tWaterCheck_demo.pch will be the pre-compiled header\n//\tstdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n#include \"CharactorTansfer.h\"\n\nCString GetMoudlePath()\n{\n\tTCHAR szAppName[MAX_PATH];\n\tTCHAR szDir[MAX_PATH];\n\tTCHAR szDrive[MAX_PATH];\n\tGetModuleFileName(GetModuleHandle(NULL), szAppName, MAX_PATH);\n\t_tsplitpath(szAppName, szDrive, szDir, NULL, NULL);\n\t\n\tTCHAR szPath[MAX_PATH];\n\t_tmakepath(szPath, szDrive, szDir, NULL, NULL);\n\t\n\treturn szPath;\n}\n","size_bytes":554},"bin/Demo/MfcDemo/19.MasterSlaveSensor/MasterSlaverSensor.cpp":{"content":"// MasterSlaverSensor.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"MasterSlaverSensor.h\"\n#include \"MasterSlaverSensorDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CMasterSlaver_watcherApp\n\nBEGIN_MESSAGE_MAP(CMasterSlaver_watcherApp, CWinApp)\n\t//{{AFX_MSG_MAP(CMasterSlaver_watcherApp)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t\t//    DO NOT EDIT what you see in these blocks of generated code!\n\t//}}AFX_MSG\n\tON_COMMAND(ID_HELP, CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CMasterSlaver_watcherApp construction\n\nCMasterSlaver_watcherApp::CMasterSlaver_watcherApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The one and only CMasterSlaver_watcherApp object\n\nCMasterSlaver_watcherApp theApp;\n\n/////////////////////////////////////////////////////////////////////////////\n// CMasterSlaver_watcherApp initialization\n\nBOOL CMasterSlaver_watcherApp::InitInstance()\n{\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t//  of your final executable, you should remove from the following\n\t//  the specific initialization routines you do not need.\n\n#ifdef _AFXDLL\n\tEnable3dControls();\t\t\t// Call this when using MFC in a shared DLL\n#else\n\tEnable3dControlsStatic();\t// Call this when linking to MFC statically\n#endif\n\n\tCMasterSlaver_watcherDlg dlg;\n\tm_pMainWnd = &dlg;\n\tint nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n\n","size_bytes":2180},"bin/Demo/MfcDemo/03.Alarm/DevAlarmDlg.cpp":{"content":"// DevAlarmDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"Alarm.h\"\n#include \"DevAlarmDlg.h\"\n#include \"include/dhnetsdk.h\"\n\n\nstatic const int nMaxAlarmInfoInListCtrl = 100;\n\n// CDevAlarmDlg Dialog\n\nIMPLEMENT_DYNAMIC(CDevAlarmDlg, CDialog)\n\nCDevAlarmDlg::CDevAlarmDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CDevAlarmDlg::IDD, pParent)\n{\n\tm_nAlarmCount = 0;\n}\n\nCDevAlarmDlg::~CDevAlarmDlg()\n{\n}\n\nvoid CDevAlarmDlg::DoDataExchange(CDataExchange* pDX)\n{\n    CDialog::DoDataExchange(pDX);\n    DDX_Control(pDX, IDC_LIST_ALARM, m_listCtrlAlarmInfo);\n}\n\n\nBEGIN_MESSAGE_MAP(CDevAlarmDlg, CDialog)\n    ON_WM_DESTROY()\nEND_MESSAGE_MAP()\n\n\nBOOL CDevAlarmDlg::OnInitDialog()\n{\n    CDialog::OnInitDialog();\n\n    InitListCtrl();\n\n    return TRUE;  // return TRUE unless you set the focus to a control\n    // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nBOOL CDevAlarmDlg::DestroyWindow()\n{\n    ClearAlarmInfo();\n    return CDialog::DestroyWindow();\n}\n\n\nvoid CDevAlarmDlg::InitListCtrl()\n{\n    m_listCtrlAlarmInfo.SetExtendedStyle(m_listCtrlAlarmInfo.GetExtendedStyle() | LVS_EX_HEADERDRAGDROP | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);\n    m_listCtrlAlarmInfo.InsertColumn(0, ConvertString(\"No.\"), LVCFMT_LEFT, 80);\n\t m_listCtrlAlarmInfo.InsertColumn(1, ConvertString(\"Time\"), LVCFMT_LEFT, 150);\n    m_listCtrlAlarmInfo.InsertColumn(2, ConvertString(\"Channel\"), LVCFMT_LEFT, 100);\n    m_listCtrlAlarmInfo.InsertColumn(3, ConvertString(\"Alarm Type\"), LVCFMT_LEFT, 150);   \n    m_listCtrlAlarmInfo.InsertColumn(4, ConvertString(\"Status\"), LVCFMT_LEFT, 100);\t  \n}\n\nvoid CDevAlarmDlg::UpdateAlarmListCtrl(const CAlarmInfoEx& alarmInfo)\n{\n\tm_nAlarmCount ++;\n\n\tint nCount = m_listCtrlAlarmInfo.GetItemCount();\n\tif (nCount >= nMaxAlarmInfoInListCtrl)\n\t{\n\t\tm_listCtrlAlarmInfo.DeleteItem(nCount - 1);\t\n\t}\t\n\n\tLV_ITEM lvi;\n\tlvi.mask=LVIF_TEXT|LVIF_IMAGE|LVIF_PARAM;\n\tlvi.iSubItem = 0;\n\tlvi.pszText = _T(\"\");\n\tlvi.iImage = 0;\n\tlvi.iItem = 0;\n\n\tm_listCtrlAlarmInfo.InsertItem(&lvi);\t\n\n\t// Index\t\n\tchar szIndex[10] = {0};\n\t_itoa_s(m_nAlarmCount, szIndex, 10);\t\t\n\tm_listCtrlAlarmInfo.SetItemText(0, 0, szIndex);\n\n\t// Time\n\tm_listCtrlAlarmInfo.SetItemText(0, 1, ConvertString(alarmInfo.m_strTime));\n\n\t// Channel\n\tCString strChannelID;\n\tstrChannelID.Format(ConvertString(\"Channel %d\"), alarmInfo.m_nChannel);\n\tm_listCtrlAlarmInfo.SetItemText(0, 2, strChannelID);\n\n\t// alarm type\n\tCString strType;\n\tConvertAlarmType2CString(alarmInfo.m_nAlarmType, strType);\n\tm_listCtrlAlarmInfo.SetItemText(0, 3, ConvertString(strType));\n\n\t// State\n\tCString strState = (ALARM_START == alarmInfo.m_emAlarmStatus) ? \"Start\" : \"Stop\" ;\n\tm_listCtrlAlarmInfo.SetItemText(0, 4, ConvertString(strState));\n}\n\n\nvoid CDevAlarmDlg::ConvertAlarmType2CString(int emType, CString& strType)\n{\n\tswitch (emType)\n\t{\n\tcase DH_ALARM_ALARM_EX:\n\t\tstrType = \"External alarm\";\n\t\tbreak;\n\tcase DH_MOTION_ALARM_EX:\n\t\tstrType = \"Motion detection alarm\";\n\t\tbreak;\n\tcase DH_VIDEOLOST_ALARM_EX:\n\t\tstrType = \"Video loss alarm\";\n\t\tbreak;\n\tcase DH_SHELTER_ALARM_EX:\n\t\tstrType = \"Camera masking alarm\";\n\t\tbreak;\n\tcase DH_DISKFULL_ALARM_EX:\n\t\tstrType = \"HDD full alarm\";\n\t\tbreak;\n\tcase DH_DISKERROR_ALARM_EX:\n\t\tstrType = \"HDD error alarm\";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nBOOL CDevAlarmDlg::PreTranslateMessage(MSG* pMsg) \n{\n    if(pMsg->message == WM_KEYDOWN)\n    {\n        //Enter\n        if(pMsg->wParam == VK_RETURN) return TRUE;\n        //ESC\n        if(pMsg->wParam == VK_ESCAPE) return TRUE;\n    }\n\n    return CDialog::PreTranslateMessage(pMsg);\n}\n\nvoid CDevAlarmDlg::ClearAlarmInfo(void)\n{\n\tm_listCtrlAlarmInfo.DeleteAllItems();\n\tm_nAlarmCount = 0;\n}","size_bytes":3598},"bin/Demo/MfcDemo/02.PlayBack/PlayBack.cpp":{"content":"// PlayBack.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"PlayBack.h\"\n#include \"PlayBackDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// PlayBackApp\n\nBEGIN_MESSAGE_MAP(PlayBackApp, CWinApp)\n\t//{{AFX_MSG_MAP(PlayBackApp)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t\t//    DO NOT EDIT what you see in these blocks of generated code!\n\t//}}AFX_MSG\n\tON_COMMAND(ID_HELP, CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// PlayBackApp construction\nTCHAR* g_GetIniPath(void)\n{\n\tstatic char pszIniPath[512] = {0};\n\tif( strlen(pszIniPath) == 0 )\n\t{\n\t\tchar szDirBuf[512] = {0};\n\t\tGetCurrentDirectory(512, szDirBuf);\n\t\t_snprintf(pszIniPath, sizeof(pszIniPath), \"%s\\\\langchn.ini\", szDirBuf);\n\t}\n\treturn pszIniPath;\n}\n\nCString ConvertString(CString strText)\n{\n\tchar *val = new char[200];\n\tCString strIniPath,strRet;\n\t\n\tmemset(val,0,200);\n\tGetPrivateProfileString(\"String\",strText,\"\",\n\t\tval,200,g_GetIniPath());\n\tstrRet = val;\n\tif(strRet.GetLength()==0)\n\t{\n\t\t//If there is no corresponding string in ini file ,then set it to be default value.\n\t\tstrRet=strText;\n\t}\n\tdelete[] val;\n\treturn strRet;\n}\n//Set static text in dialogue box (English->current language)\nvoid g_SetWndStaticText(CWnd * pWnd)\n{\n\tCString strCaption,strText;\n\t\n\t//Set main window title\n\tpWnd->GetWindowText(strCaption);\n\tif(strCaption.GetLength()>0)\n\t{\n\t\tstrText=ConvertString(strCaption);\n\t\tpWnd->SetWindowText(strText);\n\t}\n\t\n\t//Set small window title \n\tCWnd * pChild=pWnd->GetWindow(GW_CHILD);\n\tCString strClassName;\n\twhile(pChild)\n\t{\n\t\t//////////////////////////////////////////////////////////////////////////\t\t\n\t\t//Added by Jackbin 2005-03-11\n\t\tstrClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n\t\tif(strClassName == \"CEdit\")\n\t\t{\n\t\t\t//Next small window \n\t\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t//////////////////////////////////////////////////////////////////////////\t\n\t\t\n\t\t//Set small window current language text \n\t\tpChild->GetWindowText(strCaption);\n\t\tstrText=ConvertString(strCaption);\n\t\tpChild->SetWindowText(strText);\n\t\t\n\t\t//Next small window \n\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t}\n}\n\n\nPlayBackApp::PlayBackApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The one and only PlayBackApp object\n\nPlayBackApp theApp;\n\n/////////////////////////////////////////////////////////////////////////////\n// PlayBackApp initialization\n\nBOOL PlayBackApp::InitInstance()\n{\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t//  of your final executable, you should remove from the following\n\t//  the specific initialization routines you do not need.\n\n#ifdef _AFXDLL\n\tEnable3dControls();\t\t\t// Call this when using MFC in a shared DLL\n#else\n\tEnable3dControlsStatic();\t// Call this when linking to MFC statically\n#endif\n\n\tCPlayBackDlg dlg;\n\tm_pMainWnd = &dlg;\n\tint nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n","size_bytes":3672},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/ScreenPannel.cpp":{"content":"// ScreenPannel.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"ScreenPannel.h\"\n#include \"netsdkdemodlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CScreenPannel class\n\nCScreenPannel::CScreenPannel()\n{\n\tnLastSplit  = 0;\n}\n\nCScreenPannel::~CScreenPannel()\n{\n\t// remove all pages\n\twhile(!m_PageList.IsEmpty())\n\t\tm_PageList.RemoveHead();\n}\n\n\nBEGIN_MESSAGE_MAP(CScreenPannel, CWnd)\n\t//{{AFX_MSG_MAP(CScreenPannel)\n\tON_WM_PAINT()\n\tON_WM_ERASEBKGND()\n\tON_WM_CREATE()\n\tON_WM_DESTROY()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n\n/////////////////////////////////////////////////////////////////////////////\n// CScreenPannel member functions\nvoid CScreenPannel::OnPaint() \n{\n\tCPaintDC dc(this); // device context for painting\n\t\n\t// TODO: Add your message handler code here\n\tUpdateWnd();\n\t// Do not call CWnd::OnPaint() for painting messages\n}\n\nBOOL CScreenPannel::OnEraseBkgnd(CDC* pDC) \n{\n\t// TODO: Add your message handler code here and/or call default\n\tCRect rt;\n\tGetClientRect(&rt);\n\tCBrush br;\n\tbr.CreateSolidBrush(RGB(192,192,192));\n\tpDC->FillRect(&rt,&br);\n\n\treturn TRUE;\n//\treturn CWnd::OnEraseBkgnd(pDC);\n}\n\nint CScreenPannel::OnCreate(LPCREATESTRUCT lpCreateStruct) \n{\n\tif (CWnd::OnCreate(lpCreateStruct) == -1)\n\t\treturn -1;\n\t\n\t// TODO: Add your specialized creation code here\n\tfor(int i = 0; i < DH_MAX_CHANNUM; i++)\n\t{\n\t\tm_wndVideo[i].Create(\n\t\t\tNULL, \n\t\t\tNULL, \n\t\t\tWS_VISIBLE | WS_CHILD,\n\t\t\tCRect(0, 0, 0, 0),\n\t\t\tthis,\n\t\t\t1979,\n\t\t\tNULL);\n\n\t\tm_wndVideo[i].SetWinID(i);\n\t\t\n\t\tAddPage(&m_wndVideo[i]);\n\t}\n\n\tSetActivePage(&m_wndVideo[0], TRUE);\n\tSetDrawActivePage(TRUE, RGB(248,5,182), RGB(248,5,182));\n\n\treturn 0;\n}\n\nint CScreenPannel::SetShowPlayWin(int nMain, int nSub)\n{\n\tif (nSub < 0 || nSub > DH_MAX_CHANNUM)\n\t{\n\t\tnSub = 0;\n\t}\n\n\tint nNum = 16;\n\tint nBegin = 0;\n\tswitch(nMain) \n\t{\n\tcase SPLIT1:\n\t\tnNum = 1;\n\t\tnBegin = nSub;\n\t\tbreak;\n\tcase SPLIT4:\n\t\tnNum = 4;\n\t\tif (nSub >= 12)\n\t\t{\n\t\t\tnBegin = 12;\n\t\t}\n\t\telse if (nSub >= 8)\n\t\t{\n\t\t\tnBegin = 8;\n\t\t}\n\t\telse if (nSub >= 4)\n\t\t{\n\t\t\tnBegin = 4;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnBegin = 0;\n\t\t}\n\n\t\tbreak;\n\tcase SPLIT9:\n\t\tnNum = 9;\n\t\tif (nSub >= 10)\n\t\t{\n\t\t\tnBegin = 7;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnBegin = 0;\n\t\t}\n\t\tbreak;\n\tcase SPLIT16:\n\t\tnNum = 16;\n\t\tnBegin = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tCList<CWnd*, CWnd*> templist;\n\n\tPOSITION pos = m_PageList.GetHeadPosition();\n\twhile(pos != NULL)\n\t{\n\t\tCWnd* pWnd = m_PageList.GetNext(pos);\n\t\tif (pWnd)\n\t\t{\n\t\t\ttemplist.AddTail(pWnd);\n\t\t}\n\t}\n\n\tm_PageList.RemoveAll();\n\n\t/*\n\twhile(m_PageList.GetCount())\n\t{\n\t\tDelPage(GetTailPage());\n\t}\n\t*/\n\t\n\tfor(int i=nBegin; i < (nBegin+nNum); i++)\n\t{\n\t\tAddPage(&m_wndVideo[i], TRUE);\n\t}\n\n\tSetActivePage(&m_wndVideo[nSub], TRUE);\n\n\tpos = templist.GetHeadPosition();\n\twhile(pos != NULL)\n\t{\n\t\tCWnd* pWnd = templist.GetNext(pos);\n\t\tif (pWnd)\n\t\t{\n\t\t\tpWnd->ShowWindow(SW_HIDE);\n\t\t}\n\t}\n\n\ttemplist.RemoveAll();\n\n\treturn m_PageList.GetCount();\n\n\t/*\n\n\tif (m_PageList.GetCount() > nNum)\n\t{\n\t\tint nCnt = m_PageList.GetCount();\n\t\twhile (nCnt > nNum)\n\t\t{\n\t\t\tCWnd* pWnd = DelPage(GetTailPage());\t\n\t\t\tif (!pWnd)\n\t\t\t{\n\t\t\t\tDelPage(GetTailPage());\n\t\t\t}\n\n\t\t\tnCnt = m_PageList.GetCount();\n\t\t}\n\n\t\t//UpdateWnd();\n\t\tSetActivePage(&m_wndVideo[0], TRUE);\n\t}\n\telse if (m_PageList.GetCount() < nNum)\n\t{\n\t\tint nCnt = m_PageList.GetCount();\n\t\twhile (nCnt < nNum)\n\t\t{\n\t\t\tAddPage(&m_wndVideo[nCnt], FALSE);\n\t\t\tnCnt = m_PageList.GetCount();\n\t\t}\n\n\t\t//UpdateWnd();\n\t\tSetActivePage(&m_wndVideo[0], TRUE);\n\t}\n\n\treturn m_PageList.GetCount();\n\t*/\n}\n\nvoid CScreenPannel::OnDestroy() \n{\n\tCWnd::OnDestroy();\n\t\n\t// TODO: Add your message handler code here\n\tfor(int i=0; i < DH_MAX_CHANNUM; i++)\n\t{\n\t\tm_wndVideo[0].DestroyWindow();\n\t}\n}\n\nCWnd * CScreenPannel::GetPage(int nIndex)\n{\n\tif (nIndex >= 0 && nIndex < DH_MAX_CHANNUM)\n\t{\n\t\treturn &m_wndVideo[nIndex];\n\t}\n\n\treturn NULL;\n}\n\n//CScreenPannel::CScreenPannel(CWnd* pParent /*=NULL*/)\n//\t: CDialog(CScreenPannel::IDD, pParent)\n//{\n//\t//{{AFX_DATA_INIT(CScreenPannel)\n//\t\t// NOTE: the ClassWizard will add member initialization here\n//\t//}}AFX_DATA_INIT\n//}\n//\n//\n//void CScreenPannel::DoDataExchange(CDataExchange* pDX)\n//{\n//\tCDialog::DoDataExchange(pDX);\n//\t//{{AFX_DATA_MAP(CScreenPannel)\n//\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n//\t//}}AFX_DATA_MAP\n//}\n//\n//\n//BEGIN_MESSAGE_MAP(CScreenPannel, CDialog)\n//\t//{{AFX_MSG_MAP(CScreenPannel)\n//\t\t// NOTE: the ClassWizard will add message map macros here\n//\t//}}AFX_MSG_MAP\n//END_MESSAGE_MAP()\n//\n///////////////////////////////////////////////////////////////////////////////\n//// CScreenPannel message handlers\n//\n//BOOL CScreenPannel::PreTranslateMessage(MSG* pMsg) \n//{\n//\tif (WM_KEYDOWN == pMsg->message /* && VK_ESCAPE == pMsg->wParam */)\n//\t{\n//\t\tif (VK_ESCAPE == pMsg->wParam)\n//\t\t{\n//\t\t\t((CNetSDKDemoDlg *)AfxGetMainWnd())->ReturnOrignalSplit();\n//\t\t}\n//\n//\t\treturn TRUE;\n//\t}\n//\treturn CDialog::PreTranslateMessage(pMsg);\n//}\n","size_bytes":4980},"bin/Demo/MfcDemo/10.AlarmDevice/DlgVersion.cpp":{"content":"// DlgVersion.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgVersion.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgVersion dialog\n\n\nCDlgVersion::CDlgVersion(CWnd* pParent /* = NULL */, LLONG hLoginId /* = 0 */)\n\t: CDialog(CDlgVersion::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgVersion)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\tm_hLoginId = hLoginId;\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CDlgVersion::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgVersion)\n\tDDX_Control(pDX, IDC_STATIC_VERSION, m_staVersion);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgVersion, CDialog)\n\t//{{AFX_MSG_MAP(CDlgVersion)\n\tON_BN_CLICKED(IDC_VERSION_UPDATE, OnVersionUpdate)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgVersion message handlers\n\nBOOL CDlgVersion::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_VERSION);\n\t\n\t// TODO: Add extra initialization here\n\tOnVersionUpdate();\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgVersion::OnVersionUpdate() \n{\n\t// TODO: Add your control notification handler code here\n\tif (!m_hLoginId)\n\t{\n\t\tMessageBox(ConvertString(CString(\"we haven't login a device yet!\"), DLG_VERSION), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tint nRet = 0;\n\tDHDEV_VERSION_INFO stuInfo = {0};\n\tBOOL bRet = CLIENT_QueryDevState(m_hLoginId, DH_DEVSTATE_SOFTWARE, (char*)&stuInfo, sizeof(stuInfo), &nRet, SDK_API_WAIT);\n\tif (bRet)\n\t{\n\t\tCString csVer;\n\t\tcsVer.Format(\"%s: %s\\r\\n\\\n%s: %s\\r\\n\\\n%s: %04d-%02d-%02d\\r\\n\",\nConvertString(\"Serial\", DLG_VERSION),\n\t\t\tstuInfo.szDevSerialNo,\n\t\t\tConvertString(\"SoftwareVersion\", DLG_VERSION),\n\t\t\tstuInfo.szSoftWareVersion,\n\t\t\tConvertString(\"ReleaseTime\", DLG_VERSION),\n\t\t\t((stuInfo.dwSoftwareBuildDate>>16) & 0xffff),\n\t\t\t((stuInfo.dwSoftwareBuildDate>>8) & 0xff),\n\t\t\t(stuInfo.dwSoftwareBuildDate & 0xff));\n\t\tm_staVersion.SetWindowText(csVer);\n\t} \n\telse\n\t{\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"get Version failed with code :\", DLG_VERSION), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t}\n}\n","size_bytes":2408},"bin/Demo/MfcDemo/09.AccessControl/DlgCfgAccessControl.cpp":{"content":"// DlgCfgAccessControl.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"accesscontrol.h\"\n#include \"DlgCfgAccessControl.h\"\n#include \"SubDlgCfgDoorOpenTimeSection.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgAccessControl dialog\n\n\nCDlgCfgAccessControl::CDlgCfgAccessControl(CWnd* pParent /* = NULL */, LLONG lLoginID /* = 0 */)\n\t: CDialog(CDlgCfgAccessControl::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgAccessControl)\n\t//}}AFX_DATA_INIT\n\tm_lLoginID = lLoginID;\n\tmemset(&m_stuInfo, 0, sizeof(m_stuInfo));\n}\n\n\nvoid CDlgCfgAccessControl::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgAccessControl)\n\tDDX_Control(pDX, IDC_ACCESSCONTROL_CHK_FIRSTENTER_REMOTECHECK, m_chkRemoteCheck);\n\tDDX_Control(pDX, IDC_ACCESSCONTROL_CHK_FIRSTENTER_ENABLE, m_chkFirstEnterEnable);\n\tDDX_Control(pDX, IDC_ACCESSCONTROL_CMB_FIRSTENTER_STATUS, m_cbFirstEnterStatus);\n\tDDX_Control(pDX, IDC_ACCESSCONTROL_CMB_CHANNEL, m_cmbChannel);\n\tDDX_Control(pDX, IDC_ACCESSCONTROL_CMB_OPENTIMEINDEX, m_cmbOpenTimeIndex);\n\tDDX_Control(pDX, IDC_ACCESSCONTROL_CMB_OPENMETHOD, m_cmbOpenMethod);\n\tDDX_Control(pDX, IDC_ACCESSCONTROL_CHK_SENSOR, m_chkSensor);\n\tDDX_Control(pDX, IDC_ACCESSCONTROL_CHK_REPEATENTERALARM, m_chkRepeatEnterAlarm);\n\tDDX_Control(pDX, IDC_ACCESSCONTROL_CHK_DURESSALARM, m_chkDuressAlarm);\n\tDDX_Control(pDX, IDC_ACCESSCONTROL_CHK_DOORNOTCLOSEALARM, m_chkDoorNotCloseAlarm);\n\tDDX_Control(pDX, IDC_ACCESSCONTROL_CHK_BREAKINALARM, m_chkBreakAlarm);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgAccessControl, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgAccessControl)\n\tON_BN_CLICKED(IDC_ACCESSCONTROL_BTN_TIMESECTION, OnAccessControlBtnTimeSection)\n\tON_BN_CLICKED(IDC_ACCESSCONTROL_BTN_GET, OnAccessControlBtnGet)\n\tON_BN_CLICKED(IDC_ACCESSCONTROL_BTN_SET, OnAccessControlBtnSet)\n\tON_CBN_SELCHANGE(IDC_ACCESSCONTROL_CMB_CHANNEL, OnSelchangeAccesscontrolCmbChannel)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgAccessControl private method\n\nvoid CDlgCfgAccessControl::InitDlg()\n{\n\tint i = 0;\n\n\t// channel\n\tm_cmbChannel.ResetContent();\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%s%d\", ConvertString(\"Channel\", DLG_CFG_ACCESS_CONTROL), i + 1);\n\t\tm_cmbChannel.InsertString(-1, csInfo);\n\t}\n\tm_cmbChannel.SetCurSel(0);\n\n\t// door open method\n\tm_cmbOpenMethod.ResetContent();\n\tfor (i = 0; i < sizeof(stuDemoOpenMethod)/sizeof(stuDemoOpenMethod[0]); i++)\n\t{\n\t\tm_cmbOpenMethod.InsertString(-1, ConvertString(stuDemoOpenMethod[i].szName));\n\t}\n\tm_cmbOpenMethod.SetCurSel(-1);\n    m_cmbOpenMethod.SetDroppedWidth(160);\n\tm_stuInfo.abDoorOpenMethod = true;\n\n\t// door unlock hold time\n\tm_stuInfo.abUnlockHoldInterval = true;\n\n\t// door close timeout\n\tm_stuInfo.abCloseTimeout = true;\n\n\t// open time index in config of AccessTimeSchedule, start from 0\n\tm_cmbOpenTimeIndex.ResetContent();\n\tfor (i = 0; i < 128; i++)\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%02d\", i);\n\t\tm_cmbOpenTimeIndex.InsertString(-1, csInfo);\n\t}\n\n\t// first enter status\n\tm_cbFirstEnterStatus.ResetContent();\n\tstatic const char* szFirstEnterStat[] = \n\t{\t\"Unknown\", \n\t\t\"KeepOpen\", \n\t\t\"Normal\"\n\t};\n\tfor (i=0; i<3; i++)\n\t{\n\t\tm_cbFirstEnterStatus.InsertString(-1, ConvertString(szFirstEnterStat[i], DLG_CFG_ACCESS_CONTROL));\n\t}\n\tm_cbFirstEnterStatus.SetCurSel((int)m_stuInfo.stuFirstEnterInfo.emStatus);\n\n\tSetDlgItemInt(IDC_ACCESSCONTROL_EDT_FIRSTENTER_TIMERINDEX, 0);\n\n\tm_cmbOpenTimeIndex.SetCurSel(-1);\n\tm_stuInfo.abOpenAlwaysTimeIndex = true;\n\n\t// holiday record set recNo\n\tm_stuInfo.abHolidayTimeIndex = true;\n\n\t// break in alarm enable\n\t//m_stuInfo.abBreakInAlarmEnable = true;\n\tm_chkBreakAlarm.SetCheck(BST_UNCHECKED);\n\n\t// repeat enter alarm enable\n\t//m_stuInfo.abRepeatEnterAlarmEnable = true;\n\tm_chkRepeatEnterAlarm.SetCheck(BST_UNCHECKED);\n\n\t// door not close enable\n\t//m_stuInfo.abDoorNotClosedAlarmEnable = true;\n\tm_chkDoorNotCloseAlarm.SetCheck(BST_UNCHECKED);\n\n\t// duress alarm enable\n\t//m_stuInfo.abDuressAlarmEnable = true;\n\tm_chkDuressAlarm.SetCheck(BST_UNCHECKED);\n\n\t// sensor alarm enable\n\t//m_stuInfo.abSensorEnable = true;\n\tm_chkSensor.SetCheck(BST_UNCHECKED);\n\n\t// first enter\n\t//m_stuInfo.abFirstEnterEnable = true;\n\tm_chkFirstEnterEnable.SetCheck(BST_UNCHECKED);\n\n    // remote check\n    //m_stuInfo.abRemoteCheck = true;\n    m_chkRemoteCheck.SetCheck(BST_UNCHECKED);\n}\n\nBOOL CDlgCfgAccessControl::SetConfigToDevice()\n{\n\tint nChn = m_cmbChannel.GetCurSel();\n\tif (-1 == nChn)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tchar szJsonBuf[1024 * 40] = {0};\n\tBOOL bRet = CLIENT_PacketData(CFG_CMD_ACCESS_EVENT, &m_stuInfo, sizeof(m_stuInfo), szJsonBuf, sizeof(szJsonBuf));\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(CString(\"packet AccessControl error...\"), DLG_CFG_ACCESS_CONTROL), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t} \n\telse\n\t{\t\t\n\t\tint nerror = 0;\n\t\tint nrestart = 0;\n\t\t\n\t\tbRet = CLIENT_SetNewDevConfig((LLONG)m_lLoginID, CFG_CMD_ACCESS_EVENT, nChn, szJsonBuf, 1024*40, &nerror, &nrestart, 5000);\n\t\tif (!bRet)\n\t\t{\n\t\t\tCString csErr;\n\t\t\tcsErr.Format(\"%s 0x%08x...\", ConvertString(\"SetupConfig AccessControl failed:\", DLG_CFG_ACCESS_CONTROL), CLIENT_GetLastError());\n\t\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"SetConfig AccessControl ok!\"), DLG_CFG_ACCESS_CONTROL), ConvertString(\"Prompt\"));\n\t\t}\n\t}\n\treturn TRUE;\n}\n\nBOOL CDlgCfgAccessControl::GetConfigFromDevice()\n{\n\tint nChn = m_cmbChannel.GetCurSel();\n\tif (-1 == nChn)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tchar szJsonBuf[1024 * 40] = {0};\n\tint nerror = 0;\n\tBOOL bRet = CLIENT_GetNewDevConfig((LLONG)m_lLoginID, CFG_CMD_ACCESS_EVENT, nChn, szJsonBuf, 1024*40, &nerror, 5000);\n\t\n\tif (bRet)\n\t{\n\t\tDWORD dwRetLen = 0;\n\t\tbRet = CLIENT_ParseData(CFG_CMD_ACCESS_EVENT, szJsonBuf, (void*)&m_stuInfo, sizeof(m_stuInfo), &dwRetLen);\n\t\tif (!bRet)\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"parse AccessControl error...\"), DLG_CFG_ACCESS_CONTROL), ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\t\t\t\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s 0x%08x\", ConvertString(\"QueryConfig AccessControl error:\", DLG_CFG_ACCESS_CONTROL),\n\t\t\tCLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nvoid CDlgCfgAccessControl::DlgToStu()\n{\n\t// door open method\n    int nMethodIndex = m_cmbOpenMethod.GetCurSel();\n    if (nMethodIndex >= 0 && nMethodIndex < sizeof(stuDemoOpenMethod)/sizeof(stuDemoOpenMethod[0]))\n    {\n        m_stuInfo.emDoorOpenMethod = (CFG_DOOR_OPEN_METHOD)stuDemoOpenMethod[nMethodIndex].emOpenMethod;\n    }\n    else\n    {\n        m_stuInfo.emDoorOpenMethod = CFG_DOOR_OPEN_METHOD_UNKNOWN;\n    }\n\t\n\t// door unlock hold time\n\tm_stuInfo.nUnlockHoldInterval = GetDlgItemInt(IDC_ACCESSCONTROL_EDT_UNLOCKHOLD, NULL, TRUE);\n\t\n\t// door close timeout\n\tm_stuInfo.nCloseTimeout = GetDlgItemInt(IDC_ACCESSCONTROL_EDT_CLOSETIMEOUT, NULL, TRUE);\n\t\n\t// open time index in config of AccessTimeSchedule, start from 0\n\tm_stuInfo.nOpenAlwaysTimeIndex = m_cmbOpenTimeIndex.GetCurSel();\n\t\n\t// holiday record set recNo\n\tm_stuInfo.nHolidayTimeRecoNo = GetDlgItemInt(IDC_ACCESSCONTROL_EDT_HOLIDAYTIMERECNO, NULL, TRUE);\n\n\t// first enter status\n\tm_stuInfo.stuFirstEnterInfo.emStatus = static_cast<CFG_ACCESS_FIRSTENTER_STATUS>(m_cbFirstEnterStatus.GetCurSel());\n\n\t// first enter time index\n\tm_stuInfo.stuFirstEnterInfo.nTimeIndex = GetDlgItemInt(IDC_ACCESSCONTROL_EDT_FIRSTENTER_TIMERINDEX);\n\t\n\t// break in alarm enable\n\tif (m_chkBreakAlarm.GetCheck())\n\t{\n        m_stuInfo.abBreakInAlarmEnable = true;\n\t\tm_stuInfo.bBreakInAlarmEnable = TRUE;\n\t}\n\telse\n\t{\n\t\tm_stuInfo.bBreakInAlarmEnable = FALSE;\n\t}\n\t\n\t// repeat enter alarm enable\n\tif (m_chkRepeatEnterAlarm.GetCheck())\n\t{\n        m_stuInfo.abRepeatEnterAlarmEnable = true;\n\t\tm_stuInfo.bRepeatEnterAlarm = TRUE;\n\t}\n\telse\n\t{\n\t\tm_stuInfo.bRepeatEnterAlarm = FALSE;\n\t}\n\t\n\t// door not close enable\n\tif (m_chkDoorNotCloseAlarm.GetCheck())\n\t{\n        m_stuInfo.abDoorNotClosedAlarmEnable = true;\n\t\tm_stuInfo.bDoorNotClosedAlarmEnable = TRUE;\n\t}\n\telse\n\t{\n\t\tm_stuInfo.bDoorNotClosedAlarmEnable = FALSE;\n\t}\n\t\n\t// duress alarm enable\n\tif (m_chkDuressAlarm.GetCheck())\n\t{\n        m_stuInfo.abDuressAlarmEnable = true;\n\t\tm_stuInfo.bDuressAlarmEnable = TRUE;\n\t}\n\telse\n\t{\n\t\tm_stuInfo.bDuressAlarmEnable = FALSE;\n\t}\n\t\n\t// sensor alarm enable\n\tif (m_chkSensor.GetCheck())\n\t{\n        m_stuInfo.abSensorEnable = true;\n\t\tm_stuInfo.bSensorEnable = TRUE;\n\t}\n\telse\n\t{\n\t\tm_stuInfo.bSensorEnable = FALSE;\n\t}\n\n\t// time section...\n\n\t// first enter enable\n\tif (m_chkFirstEnterEnable.GetCheck())\n\t{\n        m_stuInfo.abFirstEnterEnable = true;\n\t\tm_stuInfo.stuFirstEnterInfo.bEnable = TRUE;\n\t}\n\telse\n\t{\n\t\tm_stuInfo.stuFirstEnterInfo.bEnable = FALSE;\n\t}\n\n    // remote check\n    if (m_chkRemoteCheck.GetCheck())\n    {\n        m_stuInfo.abRemoteCheck = true;\n        m_stuInfo.bRemoteCheck = TRUE;\n    }\n    else\n    {\n        m_stuInfo.bRemoteCheck = FALSE;\n    }\n}\n\nvoid CDlgCfgAccessControl::StuToDlg()\n{\n\t// door open method\n    BOOL bMethodFound = FALSE;\n    for (int i = 0; i < sizeof(stuDemoOpenMethod)/sizeof(stuDemoOpenMethod[0]); i++)\n    {\n        if (m_stuInfo.emDoorOpenMethod == stuDemoOpenMethod[i].emOpenMethod)\n        {\n            bMethodFound = TRUE;\n            m_cmbOpenMethod.SetCurSel(i);\n            break;\n        }\n    }\n    if (!bMethodFound)\n    {\n        m_cmbOpenMethod.SetCurSel(-1);\n    }\n\n\t// door unlock hold time\n\tSetDlgItemInt(IDC_ACCESSCONTROL_EDT_UNLOCKHOLD, m_stuInfo.nUnlockHoldInterval);\n\t\n\t// door close timeout\n\tSetDlgItemInt(IDC_ACCESSCONTROL_EDT_CLOSETIMEOUT, m_stuInfo.nCloseTimeout);\n\t\n\t// open time index in config of AccessTimeSchedule, start from 0\n\tm_cmbOpenTimeIndex.SetCurSel(m_stuInfo.nOpenAlwaysTimeIndex);\n\t\n\t// holiday record set recNo\n\tSetDlgItemInt(IDC_ACCESSCONTROL_EDT_HOLIDAYTIMERECNO, m_stuInfo.nHolidayTimeRecoNo);\n\n\t// first enter time index\n\tSetDlgItemInt(IDC_ACCESSCONTROL_EDT_FIRSTENTER_TIMERINDEX, m_stuInfo.stuFirstEnterInfo.nTimeIndex);\n\n\t// first enter status\n\tm_cbFirstEnterStatus.SetCurSel((int)m_stuInfo.stuFirstEnterInfo.emStatus);\n\n\t\n\t// break in alarm enable\n    if (m_stuInfo.abBreakInAlarmEnable)\n    {\n        if (m_stuInfo.bBreakInAlarmEnable)\n        {\n            m_chkBreakAlarm.SetCheck(BST_CHECKED);\n        }\n        else\n        {\n            m_chkBreakAlarm.SetCheck(BST_UNCHECKED);\n        }\n    }\n    else\n    {\n        m_chkBreakAlarm.SetCheck(BST_UNCHECKED);\n    }\n\t\n\t// repeat enter alarm enable\n    if (m_stuInfo.abRepeatEnterAlarmEnable)\n    {\n        if (m_stuInfo.bRepeatEnterAlarm)\n        {\n            m_chkRepeatEnterAlarm.SetCheck(BST_CHECKED);\n        }\n        else\n        {\n            m_chkRepeatEnterAlarm.SetCheck(BST_UNCHECKED);\n        }\n    }\n    else\n    {\n        m_chkRepeatEnterAlarm.SetCheck(BST_UNCHECKED);\n    }\n\t\n\t// door not close enable\n    if (m_stuInfo.abDoorNotClosedAlarmEnable)\n    {\n        if (m_stuInfo.bDoorNotClosedAlarmEnable)\n        {\n            m_chkDoorNotCloseAlarm.SetCheck(BST_CHECKED);\n        }\n        else\n        {\n            m_chkDoorNotCloseAlarm.SetCheck(BST_UNCHECKED);\n        }\n    } \n    else\n    {\n        m_chkDoorNotCloseAlarm.SetCheck(BST_UNCHECKED);\n    }\n\t\n\t// duress alarm enable\n    if (m_stuInfo.abDuressAlarmEnable)\n    {\n        if (m_stuInfo.bDuressAlarmEnable)\n        {\n            m_chkDuressAlarm.SetCheck(BST_CHECKED);\n        }\n        else\n        {\n            m_chkDuressAlarm.SetCheck(BST_UNCHECKED);\n        }\n    } \n    else\n    {\n        m_chkDuressAlarm.SetCheck(BST_UNCHECKED);\n    }\n\t\n\t// sensor alarm enable\n    if (m_stuInfo.abSensorEnable)\n    {\n        if (m_stuInfo.bSensorEnable)\n        {\n            m_chkSensor.SetCheck(BST_CHECKED);\n        }\n        else\n        {\n            m_chkSensor.SetCheck(BST_UNCHECKED);\n        }\n    }\n    else\n    {\n        m_chkSensor.SetCheck(BST_UNCHECKED);\n    }\n\t\n\t// time section...\n\n\t//first enter enable\n    if (m_stuInfo.abFirstEnterEnable)\n    {\n        if (m_stuInfo.stuFirstEnterInfo.bEnable)\n        {\n            m_chkFirstEnterEnable.SetCheck(BST_CHECKED);\n        }\n        else\n        {\n            m_chkFirstEnterEnable.SetCheck(BST_UNCHECKED);\n        }\n    }\n    else\n    {\n        m_chkFirstEnterEnable.SetCheck(BST_UNCHECKED);\n    }\n\n    // remote check\n    if (m_stuInfo.abRemoteCheck)\n    {\n        if (m_stuInfo.bRemoteCheck)\n        {\n            m_chkRemoteCheck.SetCheck(BST_CHECKED);\n        }\n        else\n        {\n            m_chkRemoteCheck.SetCheck(BST_UNCHECKED);\n        }\n    }\n    else\n    {\n        m_chkRemoteCheck.SetCheck(BST_UNCHECKED);\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgAccessControl message handlers\n\nBOOL CDlgCfgAccessControl::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_ACCESS_CONTROL);\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\tif (GetConfigFromDevice())\n\t{\n\t\tStuToDlg();\n\t}\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgAccessControl::OnAccessControlBtnTimeSection() \n{\n\t// TODO: Add your control notification handler code here\n\tCSubDlgCfgDoorOpenTimeSection dlg(this);\n\tdlg.SetTimeSection(&m_stuInfo.stuDoorTimeSection[0][0]);\n\tif (IDOK == dlg.DoModal())\n\t{\n\t\tfor (int i = 0; i < WEEK_DAY_NUM; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < MAX_DOOR_TIME_SECTION; j++)\n\t\t\t{\n\t\t\t\tconst CFG_DOOROPEN_TIMESECTION_INFO* pstuTimeSection = dlg.GetTimeSection(i, j);\n\t\t\t\tif (pstuTimeSection)\n\t\t\t\t{\n\t\t\t\t\tmemcpy(&m_stuInfo.stuDoorTimeSection[i][j], pstuTimeSection, sizeof(CFG_DOOROPEN_TIMESECTION_INFO));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid CDlgCfgAccessControl::OnAccessControlBtnGet() \n{\n\t// TODO: Add your control notification handler code here\n\tif (GetConfigFromDevice())\n\t{\n\t\tStuToDlg();\n\t}\n}\n\nvoid CDlgCfgAccessControl::OnAccessControlBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\tSetConfigToDevice();\n}\n\nvoid CDlgCfgAccessControl::OnSelchangeAccesscontrolCmbChannel() \n{\n\t// TODO: Add your control notification handler code here\n\tOnAccessControlBtnGet();\n}\n","size_bytes":14228},"bin/Demo/MfcDemo/09.AccessControl/DlgCfgNTP.cpp":{"content":"// DlgCfgNTP.cpp : implementation file\n//\n#include \"stdafx.h\"\n#include \"AccessControl.h\"\n#include \"DlgCfgNTP.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgNTP dialog\n\n\nCDlgCfgNTP::CDlgCfgNTP(CWnd* pParent /* = NULL */, LLONG lLoginId /* = NULL */)\n\t: CDialog(CDlgCfgNTP::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgNTP)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\tm_lLoginId = lLoginId;\n\t//}}AFX_DATA_INIT\n\tmemset(&m_stuInfo, 0, sizeof(m_stuInfo));\n}\n\n\nvoid CDlgCfgNTP::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgNTP)\n\tDDX_Control(pDX, IDC_CFG_NTP_CMB_TIMEZONE, m_cmbTimeZone);\n\tDDX_Control(pDX, IDC_CFG_NTP_CHK_ENABLE, m_chkEnable);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgNTP, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgNTP)\n\tON_BN_CLICKED(IDC_CFG_NTP_BTN_GET, OnCfgNtpBtnGet)\n\tON_BN_CLICKED(IDC_CFG_NTP_BTN_SET, OnCfgNtpBtnSet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgNTP private method\n\nvoid CDlgCfgNTP::InitDlg()\n{\n\t// enable\n\tm_chkEnable.SetCheck(BST_UNCHECKED);\n\n\t// name\n\tSetDlgItemText(IDC_CFG_NTP_EDT_NAME, \"\");\n\n\t// port\n\tSetDlgItemInt(IDC_CFG_NTP_EDT_PORT, 0, FALSE);\n\n\t// update period\n\tSetDlgItemInt(IDC_CFG_NTP_EDT_UPDATEPERIOD, 0, FALSE);\n\n\t// time zone\n\tm_cmbTimeZone.ResetContent();\n\tfor (int i = 0; i < sizeof(DemoTimeZone) / sizeof(DemoTimeZone[0]); i++)\n\t{\n\t\tm_cmbTimeZone.InsertString(-1, DemoTimeZone[i].pszName);\n\t}\n\tm_cmbTimeZone.SetCurSel(-1);\n\n\t// description\n\tSetDlgItemText(IDC_CFG_NTP_EDT_DESCRIPTION, \"\");\n}\n\nvoid CDlgCfgNTP::StuToDlg()\n{\n\tm_chkEnable.SetCheck(m_stuInfo.bEnable ? BST_CHECKED : BST_UNCHECKED);\n\tSetDlgItemText(IDC_CFG_NTP_EDT_NAME, m_stuInfo.szAddress);\n\tSetDlgItemInt(IDC_CFG_NTP_EDT_PORT, m_stuInfo.nPort, FALSE);\n\tSetDlgItemInt(IDC_CFG_NTP_EDT_UPDATEPERIOD, m_stuInfo.nUpdatePeriod, FALSE);\n\tm_cmbTimeZone.SetCurSel((int)m_stuInfo.emTimeZoneType);\n\tSetDlgItemText(IDC_CFG_NTP_EDT_DESCRIPTION, m_stuInfo.szTimeZoneDesc);\n}\n\nvoid CDlgCfgNTP::DlgToStu()\n{\n\tm_stuInfo.bEnable = m_chkEnable.GetCheck() ? TRUE : FALSE;\n\tGetDlgItemText(IDC_CFG_NTP_EDT_NAME, m_stuInfo.szAddress, sizeof(m_stuInfo.szAddress));\n\tm_stuInfo.nPort = GetDlgItemInt(IDC_CFG_NTP_EDT_PORT, NULL, FALSE);\n\tm_stuInfo.nUpdatePeriod = GetDlgItemInt(IDC_CFG_NTP_EDT_UPDATEPERIOD, NULL, FALSE);\n\tm_stuInfo.emTimeZoneType = (EM_CFG_TIME_ZONE_TYPE)m_cmbTimeZone.GetCurSel();\n\tGetDlgItemText(IDC_CFG_NTP_EDT_DESCRIPTION, m_stuInfo.szTimeZoneDesc, sizeof(m_stuInfo.szTimeZoneDesc));\n}\n\nBOOL CDlgCfgNTP::GetConfig()\n{\n\tchar szJsonBuf[1024 * 10] = {0};\n\tint nErr = 0, nRestart = 0;\n\tBOOL bRet = CLIENT_GetNewDevConfig(m_lLoginId, CFG_CMD_NTP,\n\t\t-1, szJsonBuf, sizeof(szJsonBuf), &nErr, SDK_API_WAIT);\n\tif (bRet)\n\t{\n\t\tCFG_NTP_INFO stuInfo = {sizeof(CFG_NTP_INFO)};  \n\t\t\n\t\tDWORD dwRetLen = 0;\n\t\tbRet = CLIENT_ParseData(CFG_CMD_NTP, szJsonBuf, (void*)&stuInfo, sizeof(stuInfo), &dwRetLen);\n\t\tif (!bRet)\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"parse NTP error...\"), DLG_CFG_NTP), ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(&m_stuInfo, &stuInfo, sizeof(CFG_NTP_INFO));\n\t\t}\n\t}\n\telse\n\t{\t\t\t\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x...\\r\\n\\r\\n%s\", ConvertString(\"get Config NTP error:\", DLG_CFG_NTP),\n\t\t\tCLIENT_GetLastError(), szJsonBuf);\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nBOOL CDlgCfgNTP::SetConfig()\n{\n\tchar szJsonBuf[1024 * 10] = {0};\n\tBOOL bRet = CLIENT_PacketData(CFG_CMD_NTP, &m_stuInfo, sizeof(m_stuInfo), szJsonBuf, sizeof(szJsonBuf));\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(CString(\"packet NTP error...\"), DLG_CFG_NTP));\n\t\treturn FALSE;\n\t} \n\telse\n\t{\n#if 0\n\t\tWriteLog(szJsonBuf);\n#endif\t\n\t\tint nErr = 0, nRestart = 0;\n\t\tBOOL bRetSetupCfg = CLIENT_SetNewDevConfig(m_lLoginId, CFG_CMD_NTP,\n\t\t\t-1, szJsonBuf, strlen(szJsonBuf), &nErr, &nRestart, SDK_API_WAIT);\n\t\tif (!bRetSetupCfg)\n\t\t{\n\t\t\tCString csErr;\n\t\t\tcsErr.Format(\"%s %08x...\", ConvertString(\"SetupConfig NTP failed:\", DLG_CFG_NTP), CLIENT_GetLastError());\n\t\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"SetConfig NTP ok!\"), DLG_CFG_NTP), ConvertString(\"Prompt\"));\n\t\t}\n\t}\n\treturn TRUE;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgNTP message handlers\n\nBOOL CDlgCfgNTP::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_NTP);\n\t\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\tif (GetConfig())\n\t{\n\t\tStuToDlg();\n\t}\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t// EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgNTP::OnCfgNtpBtnGet() \n{\n\t// TODO: Add your control notification handler code here\n\tif (GetConfig())\n\t{\n\t\tStuToDlg();\n\t}\t\n}\n\nvoid CDlgCfgNTP::OnCfgNtpBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\tSetConfig();\n}\n","size_bytes":5076},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgWireless.cpp":{"content":"// DlgCfgWireless.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgCfgWireless.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgWireless dialog\n\n\nCDlgCfgWireless::CDlgCfgWireless(CWnd* pParent /*=NULL*/, LLONG lLoginId /*= 0*/)\n\t: CDialog(CDlgCfgWireless::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgWireless)\n\tm_lLoginId = lLoginId;\n\t//}}AFX_DATA_INIT\n\tmemset(&m_stuInfo, 0, sizeof(m_stuInfo));\n}\n\n\nvoid CDlgCfgWireless::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgWireless)\n\tDDX_Control(pDX, IDC_WIRELESS_CHK_ENABLE, m_chkEnable);\n\tDDX_Control(pDX, IDC_WIRELESS_CMB_DAY3GFLUXTATIC, m_cmbFluxTactic);\n\tDDX_Control(pDX, IDC_WIRELESS_CMB_DAY3GFLUXACTION, m_cmbFluxAction);\n\tDDX_Control(pDX, IDC_WIRELESS_CMB_APN, m_cmbAPN);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgWireless, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgWireless)\n\tON_BN_CLICKED(IDC_WIRELESS_BTN_SET, OnSet)\n\tON_BN_CLICKED(IDC_CANCEL, OnCancel)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgWireless private method\n\nvoid CDlgCfgWireless::InitDlg()\n{\n\tint i = 0;\n\n\t// Enable\n\tm_chkEnable.SetCheck(BST_UNCHECKED);\n\n\t// KeepAlive\n\tSetDlgItemInt(IDC_WIRELESS_EDT_KEEPALIVE, 0, FALSE);\n\n\t// APN\n\tm_cmbAPN.ResetContent();\n\tfor (i = 0; i < sizeof(stuDemoAPN) /  sizeof(stuDemoAPN[0]); i++)\n\t{\n\t\tm_cmbAPN.InsertString(-1, stuDemoAPN[i].pszName);\n\t}\n\tm_cmbAPN.SetCurSel(-1);\n\n\t// UserName\n\tSetDlgItemText(IDC_WIRELESS_EDT_USERNAME, \"\");\n\n\t// Password\n\tSetDlgItemText(IDC_WIRELESS_EDT_PASSWORD, \"\");\n\n\t// Day3GFluxTactic\n\tm_cmbFluxTactic.ResetContent();\n\tfor (i = 0; i < sizeof(stuDemoFluxTactic) / sizeof(stuDemoFluxTactic[0]); i++)\n\t{\n\t\tm_cmbFluxTactic.InsertString(-1, ConvertString(stuDemoFluxTactic[i].pszName, DLG_CFG_WIRELESS));\n\t}\n\tm_cmbFluxTactic.SetCurSel(-1);\n\n\t// Day3GFluxUp\n\tSetDlgItemInt(IDC_WIRELESS_EDT_DAY3GFLUXUP, 0, FALSE);\n\n\t// Day3GFluxUse\n\tSetDlgItemInt(IDC_WIRELESS_EDT_DAY3GFLUXUSE, 0, FALSE);\n\n\t// Day3GFluxAction\n\tm_cmbFluxAction.ResetContent();\n\tfor (i = 0; i < sizeof(stuDemoFluxAction) / sizeof(stuDemoFluxAction[0]); i++)\n\t{\n\t\tm_cmbFluxAction.InsertString(-1, ConvertString(stuDemoFluxAction[i].pszName, DLG_CFG_WIRELESS));\n\t}\n\tm_cmbFluxAction.SetCurSel(-1);\n}\n\nvoid CDlgCfgWireless::StuToDlg()\n{\t\n\t// Enable\n\tm_chkEnable.SetCheck(m_stuInfo.bEnable ? BST_CHECKED : BST_UNCHECKED);\n\n\t// KeepAlive\n\tSetDlgItemInt(IDC_WIRELESS_EDT_KEEPALIVE, m_stuInfo.nKeepAlive, FALSE);\n\n\t// APN\n\tm_cmbAPN.SetCurSel((int)m_stuInfo.emAPN);\n\n\t// UserName\n\tSetDlgItemText(IDC_WIRELESS_EDT_USERNAME, m_stuInfo.szUseName);\n\n\t// Password\n\tSetDlgItemText(IDC_WIRELESS_EDT_PASSWORD, m_stuInfo.szPassword);\n\n\t// Day3GFluxTactic\n\tm_cmbFluxTactic.SetCurSel((int)m_stuInfo.emDay3GFluxTactic);\n\t\n\t// Day3GFluxUp\n\tSetDlgItemInt(IDC_WIRELESS_EDT_DAY3GFLUXUP, m_stuInfo.dwDay3GFluxUp, FALSE);\n\t\n\t// Day3GFluxUse\n\tSetDlgItemInt(IDC_WIRELESS_EDT_DAY3GFLUXUSE, m_stuInfo.dwDay3GFluxUse, FALSE);\n\t\n\t// Day3GFluxAction\n\tm_cmbFluxAction.SetCurSel((int)m_stuInfo.emDay3GFluxAction);\n}\n\nvoid CDlgCfgWireless::DlgToStu()\n{\t\n\t// Enable\n\tm_stuInfo.bEnable = m_chkEnable.GetCheck();\n\t\n\t// KeepAlive\n\tm_stuInfo.nKeepAlive = GetDlgItemInt(IDC_WIRELESS_EDT_KEEPALIVE, NULL, FALSE);\n\t\n\t// APN\n\tm_stuInfo.emAPN = (EM_CFG_APN)m_cmbAPN.GetCurSel();\n\t\n\t// UserName\n\tGetDlgItemText(IDC_WIRELESS_EDT_USERNAME, m_stuInfo.szUseName, sizeof(m_stuInfo.szUseName));\n\t\n\t// Password\n\tGetDlgItemText(IDC_WIRELESS_EDT_PASSWORD, m_stuInfo.szPassword, sizeof(m_stuInfo.szPassword));\n\t\n\t// Day3GFluxTactic\n\tm_stuInfo.emDay3GFluxTactic = (EM_CFG_DAY3GFLUXTACTIC)m_cmbFluxTactic.GetCurSel();\n\t\n\t// Day3GFluxUp\n\tm_stuInfo.dwDay3GFluxUp = GetDlgItemInt(IDC_WIRELESS_EDT_DAY3GFLUXUP, NULL, FALSE);\n\t\n\t// Day3GFluxUse\n\tm_stuInfo.dwDay3GFluxUse = GetDlgItemInt(IDC_WIRELESS_EDT_DAY3GFLUXUSE, NULL, FALSE);\n\t\n\t// Day3GFluxAction\n\tm_stuInfo.emDay3GFluxAction = (EM_CFG_DAY3GFLUXACTION)m_cmbFluxAction.GetCurSel();\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgWireless message handlers\n\nBOOL CDlgCfgWireless::OnInitDialog()\n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_WIRELESS);\n\t\n\tif (0 == m_lLoginId)\n\t{\n\t\tMessageBox(ConvertString(CString(\"we haven't login a device yet!\"), DLG_CFG_WIRELESS), ConvertString(\"Prompt\"));\n\t\treturn TRUE;\n\t}\n\t\n\tInitDlg();\n\tif (GetCurrentStrategy())\n\t{\n\t\tStuToDlg();\n\t}\n\n// \tUpdateData(FALSE);\t\n\treturn TRUE; \n}\n\nBOOL CDlgCfgWireless::GetCurrentStrategy()\n{\n\tchar szJsonBuf[1024*32] = {0};\t\n\tint nErr = 0;\n\tBOOL bRet = CLIENT_GetNewDevConfig(m_lLoginId, CFG_CMD_WIRELESS,\n\t\t-1, szJsonBuf, sizeof(szJsonBuf), &nErr, SDK_API_WAIT);\n\tif (!bRet)\n\t{\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"Query wireless failed:\", DLG_CFG_WIRELESS), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\n\tCFG_WIRELESS_INFO stuWireless = {0};\n\tDWORD dwRetLen = 0;\n\tbRet = CLIENT_ParseData(CFG_CMD_WIRELESS, szJsonBuf, (void*)&stuWireless, sizeof(stuWireless), &dwRetLen);\n\tif (!bRet || dwRetLen != sizeof(stuWireless))\n\t{\n\t\tMessageBox(ConvertString(\"Parse wireless failed.\", DLG_CFG_WIRELESS), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\telse\n\t{\n\t\tmemcpy(&m_stuInfo, &stuWireless, sizeof(CFG_WIRELESS_INFO));\n\t}\n\n\treturn TRUE;\n}\n\nvoid CDlgCfgWireless::OnSet() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\n\n\tchar szJsonBuf[1024*32] = {0};\n\n\tBOOL bRet = CLIENT_PacketData(CFG_CMD_WIRELESS, (void*)&m_stuInfo, sizeof(m_stuInfo), szJsonBuf, sizeof(szJsonBuf));\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Packet wireless failed.\", DLG_CFG_WIRELESS), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tint nErr = 0, nRestart = 0;\n\tbRet = CLIENT_SetNewDevConfig(m_lLoginId, CFG_CMD_WIRELESS,\n\t\t-1, szJsonBuf, strlen(szJsonBuf), &nErr, &nRestart, SDK_API_WAIT);\n\tif (!bRet)\n\t{\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"Setup wireless failed :\", DLG_CFG_WIRELESS), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\t\n\tMessageBox(ConvertString(\"Setup wireless successfully.\", DLG_CFG_WIRELESS), ConvertString(\"Prompt\"));\n\treturn;\n}\n\nvoid CDlgCfgWireless::OnCancel() \n{\n\t// TODO: Add your control notification handler code here\n\tCDialog::OnCancel();\n}\n","size_bytes":6444},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/User_ModifyPsw.cpp":{"content":"// User_ModifyPsw.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"User_ModifyPsw.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CUser_ModifyPsw dialog\n\n\nCUser_ModifyPsw::CUser_ModifyPsw(CWnd* pParent /*=NULL*/)\n\t: CDialog(CUser_ModifyPsw::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CUser_ModifyPsw)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_user_info = NULL;\n\tm_dev = NULL;\n\tm_nUserIndex = 0;\n}\n\n\nvoid CUser_ModifyPsw::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CUser_ModifyPsw)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CUser_ModifyPsw, CDialog)\n\t//{{AFX_MSG_MAP(CUser_ModifyPsw)\n\tON_BN_CLICKED(IDC_BTN_OK, OnBtnOk)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CUser_ModifyPsw message handlers\n\nBOOL CUser_ModifyPsw::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\n\tif (!m_dev || !m_user_info)\n\t{\n\t\treturn TRUE;\n\t}\n\n\tGetDlgItem(IDC_NAME_EDIT)->SetWindowText(m_user_info->userList[m_nUserIndex].name);\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CUser_ModifyPsw::SetEnvrmt(USER_MANAGE_INFO_NEW *info, DWORD userIdx, DeviceNode *dev)\n{\n\tm_dev = dev;\n\tm_user_info = info;\n\tm_nUserIndex = userIdx;\n}\n\nvoid CUser_ModifyPsw::OnBtnOk() \n{\n\tUSER_INFO_NEW newInfo = { sizeof(USER_INFO_NEW) };\n\tUSER_INFO_NEW oldInfo = { sizeof(USER_INFO_NEW) };\n\tchar tmp1[DH_NEW_USER_PSW_LENGTH] = {0};\n\tchar tmp2[DH_NEW_USER_PSW_LENGTH] = {0};\n\tGetDlgItem(IDC_NEW_PSW_EDIT1)->GetWindowText(tmp1, DH_NEW_USER_PSW_LENGTH);\n\tGetDlgItem(IDC_NEW_PSW_EDIT2)->GetWindowText(tmp2, DH_NEW_USER_PSW_LENGTH);\n\tif (strcmp(tmp1, tmp2) != 0)\n\t{\n\t\tMessageBox(ConvertString(\"The password is not match, please input again\"),  ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tstrncpy(newInfo.passWord, tmp1, DH_NEW_USER_PSW_LENGTH-1);\n\tstrncpy(oldInfo.name, m_user_info->userList[m_nUserIndex].name, DH_USER_NAME_LENGTH_EX-1);\n\tGetDlgItem(IDC_OLD_PSW_EDIT)->GetWindowText(tmp1, DH_NEW_USER_PSW_LENGTH);\n\tstrncpy(oldInfo.passWord, tmp1, DH_NEW_USER_PSW_LENGTH-1);\n\n\tBOOL bRet = CLIENT_OperateUserInfoNew(m_dev->LoginID, 6, (void *)&newInfo, &oldInfo, NULL, MAX_TIMEOUT);\n\tif (!bRet)\n    {\n        int nError = CLIENT_GetLastError();\n        if(nError == NET_RETURN_DATA_ERROR)\tMessageBox(ConvertString(\"checkout return data error!\"), ConvertString(\"Prompt\"));\n        else if(nError == NET_ILLEGAL_PARAM) MessageBox(ConvertString(\"Input error!\"), ConvertString(\"Prompt\"));\n        else if(nError == NET_USER_PWD) MessageBox(ConvertString(\"Reserved account is not able to modify password!\"), ConvertString(\"Prompt\"));\n        else if(nError == NET_USER_FLASEPWD) MessageBox(ConvertString(\"Invalid password!\"), ConvertString(\"Prompt\"));\n        else if(nError == NET_USER_NOMATCHING) MessageBox(ConvertString(\"The password is not matching!\"), ConvertString(\"Prompt\"));\n        else MessageBox(ConvertString(\"Modify user password failed!\"), ConvertString(\"Prompt\"));\n\t}\n\telse\n\t{\n\t\tEndDialog(0);\n\t}\n}\n","size_bytes":3349},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/ConfigAlarmAlarm.cpp":{"content":"// ConfigAlarmAlarm.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"ConfigAlarmAlarm.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CConfigAlarmAlarm dialog\n\n\nCConfigAlarmAlarm::CConfigAlarmAlarm(CWnd* pParent /*=NULL*/)\n\t: CDialog(CConfigAlarmAlarm::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CConfigAlarmAlarm)\n\t//}}AFX_DATA_INIT\n\tm_pDev = 0;\n\tmemset(m_alarmCFG, 0, DH_MAX_ALARM_IN_NUM*sizeof(DH_ALARMIN_CFG));\n\tm_bReady = FALSE;\n\tm_almIdx = -1;\n\tm_weekIdx = -1;\n\tm_ptzchlIdx = -1;\n\n\tm_dontsave  = 0;\n}\n\n\nvoid CConfigAlarmAlarm::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CConfigAlarmAlarm)\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CConfigAlarmAlarm, CDialog)\n\t//{{AFX_MSG_MAP(CConfigAlarmAlarm)\n\tON_WM_SHOWWINDOW()\n\tON_CBN_SELCHANGE(IDC_COMBO_ALARMIN, OnSelchangeComboAlarmin)\n\tON_CBN_SELCHANGE(IDC_COMBO_ALARMWEEK, OnSelchangeComboAlarmweek)\n\tON_CBN_SELCHANGE(IDC_COMBO_ALARMPTZCHL, OnSelchangeComboAlarmptzchl)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CConfigAlarmAlarm message handlers\n\nvoid CConfigAlarmAlarm::SetAlarmInCFG(DH_ALARMIN_CFG *cfg)\n{\n\tif (!cfg)\n\t{\n\t\treturn;\n\t}\n\tmemcpy(m_alarmCFG, cfg, DH_MAX_ALARM_IN_NUM*sizeof(DH_ALARMIN_CFG));\n\n\tDWORD dwActMask = m_alarmCFG[0].struHandle.dwActionMask;\n\t//sentence if some functions enabled\n\tGetDlgItem(IDC_CHECK_UPLOAD)->EnableWindow((dwActMask & DH_ALARM_UPLOAD)?TRUE:FALSE);\n\tGetDlgItem(IDC_CHECK_LOCALTIP)->EnableWindow((dwActMask & DH_ALARM_TIP)?TRUE:FALSE);\n\tGetDlgItem(IDC_CHECK_LOCALTOUR)->EnableWindow((dwActMask & DH_ALARM_TOUR)?TRUE:FALSE);\n\tGetDlgItem(IDC_CHECK_SENDMAIL)->EnableWindow((dwActMask & DH_ALARM_MAIL)?TRUE:FALSE);\n\n\t//sentence if ptz enabled\n\tBOOL bPTZEn = (dwActMask & DH_ALARM_PTZ)?TRUE:FALSE;\n\tGetDlgItem(IDC_CHECK_PTZ)->EnableWindow(bPTZEn);\n\tGetDlgItem(IDC_COMBO_ALARMPTZCHL)->EnableWindow(bPTZEn);\n\tGetDlgItem(IDC_COMBO_ALARMPTZ)->EnableWindow(bPTZEn);\n\tGetDlgItem(IDC_EDIT_PTZNO)->EnableWindow(bPTZEn);\n\t\n\t//sentence if record enabled\n\tBOOL bRecEn = (dwActMask & DH_ALARM_RECORD)?TRUE:FALSE;\n\tGetDlgItem(IDC_CHECK_RECORD)->EnableWindow(bRecEn);\n\tfor (int i = 0; i < 16; i++)\n\t{\n\t\tGetDlgItem(IDC_CHECK_RECCH1+i)->EnableWindow(bRecEn);\n\t}\n\n\t//sentence if alarm output enabled\n\tBOOL bOutEn = (dwActMask & DH_ALARM_OUT)?TRUE:FALSE;\n\tGetDlgItem(IDC_CHECK_OUTPUT)->EnableWindow(bOutEn);\n\tfor (int j = 0; j < 16; j++)\n\t{\n\t\tGetDlgItem(IDC_CHECK_ALMOP1+j)->EnableWindow(bOutEn);\n\t}\n\n\tm_bReady = TRUE;\n}\n\nvoid CConfigAlarmAlarm::SetDevice(DeviceNode *pDev)\n{\n\tm_pDev = pDev;\n}\n\nvoid CConfigAlarmAlarm::ShowConfig()\n{\n\tif (!m_bReady)\n\t{\n\t\treturn;\n\t}\n\n\tif (((CComboBox*)GetDlgItem(IDC_COMBO_ALARMIN))->GetCount() < 0)\n\t{\n\t\treturn;\n\t}\n\n\t//show\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMIN))->SetCurSel(0);\n\tOnSelchangeComboAlarmin();\n}\n\nvoid CConfigAlarmAlarm::OnShowWindow(BOOL bShow, UINT nStatus) \n{\n\tCDialog::OnShowWindow(bShow, nStatus);\n\t\n\tShowConfig();\n}\n\nBOOL CConfigAlarmAlarm::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\t\n\tif (!m_pDev)\n\t{\n\t\treturn TRUE;\n\t}\n\n\tCString strAlm;\n\tint i = 0;\n\tfor (i = 0; i < m_pDev->Info.byAlarmInPortNum; i++)\n\t{\n\t\tstrAlm.Format(\"Alarm %d\", i+1);\n\t\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMIN))->InsertString(i, strAlm);\n\t}\n\tfor (int j = 15; j >= m_pDev->Info.byAlarmOutPortNum; j--)\n\t{\n\t\tGetDlgItem(IDC_CHECK_ALMOP1+j)->ShowWindow(SW_HIDE);\n\t}\n\tfor (int k = 15; k >= m_pDev->Info.byChanNum; k--)\n\t{\n\t\tGetDlgItem(IDC_CHECK_RECCH1+k)->ShowWindow(SW_HIDE);\n\t}\n\t\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(0, ConvertString(\"Sunday\"));\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(1, ConvertString(\"Monday\"));\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(2, ConvertString(\"Tuesday\"));\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(3, ConvertString(\"Wedensday\"));\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(4, ConvertString(\"Thursday\"));\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(5, ConvertString(\"Friday\"));\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(6, ConvertString(\"Saturday\"));\n\t\n\tCString strChl;\n\tfor (int l = 0; l < m_pDev->Info.byChanNum; l++)\n\t{\n\t\tstrChl.Format(ConvertString(\"channel %d\"), i+1);\n\t\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMPTZCHL))->InsertString(i, strChl);\n\t}\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CConfigAlarmAlarm::OnSelchangeComboAlarmin() \n{\n\tif (!m_bReady)\n\t{\n\t\treturn;\n\t}\n\tint i,j,k;\n\n\t//store current config\n\tif (m_almIdx < 0)\n\t{\n\t\tgoto skipsave;\n\t}\n\tm_alarmCFG[m_almIdx].byAlarmEn = ((CButton*)GetDlgItem(IDC_CHECK_ALARMENABLE))->GetCheck();\n\tm_alarmCFG[m_almIdx].byAlarmType = ((CComboBox*)GetDlgItem(IDC_COMBO_ALARMTYPE))->GetCurSel();\n\t\n\tif (m_weekIdx >= 0)\n\t{\n\t\tint secIdx = 0;\n\t\tfor (i = 0; i < 6; i++)\n\t\t{\n\t\t\tm_alarmCFG[m_almIdx].stSect[m_weekIdx][i].iBeginHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_alarmCFG[m_almIdx].stSect[m_weekIdx][i].iBeginMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_alarmCFG[m_almIdx].stSect[m_weekIdx][i].iBeginSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\t\n\t\t\tm_alarmCFG[m_almIdx].stSect[m_weekIdx][i].iEndHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_alarmCFG[m_almIdx].stSect[m_weekIdx][i].iEndMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_alarmCFG[m_almIdx].stSect[m_weekIdx][i].iEndSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t}\n\t}\n\t\n\tm_alarmCFG[m_almIdx].struHandle.dwActionFlag = 0;\n\tm_alarmCFG[m_almIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_UPLOAD))->GetCheck()?DH_ALARM_UPLOAD:0;\n\tm_alarmCFG[m_almIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_LOCALTIP))->GetCheck()?DH_ALARM_TIP:0;\n\tm_alarmCFG[m_almIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_LOCALTOUR))->GetCheck()?DH_ALARM_TOUR:0;\n\tm_alarmCFG[m_almIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_SENDMAIL))->GetCheck()?DH_ALARM_MAIL:0;\n\tm_alarmCFG[m_almIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_PTZ))->GetCheck()?DH_ALARM_PTZ:0;\n\tm_alarmCFG[m_almIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_RECORD))->GetCheck()?DH_ALARM_RECORD:0;\n\tm_alarmCFG[m_almIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_OUTPUT))->GetCheck()?DH_ALARM_OUT:0;\n\n\tfor (j = 0; j < m_pDev->Info.byAlarmOutPortNum; j++)\n\t{\n\t\tm_alarmCFG[m_almIdx].struHandle.byRelAlarmOut[j] = ((CButton*)GetDlgItem(IDC_CHECK_ALMOP1+j))->GetCheck();\n\t}\n\n\tfor (k = 0; k < m_pDev->Info.byChanNum; k++)\n\t{\n\t\tm_alarmCFG[m_almIdx].struHandle.byRecordChannel[k] = ((CButton*)GetDlgItem(IDC_CHECK_RECCH1+k))->GetCheck();\n\t}\n\n\tif (m_ptzchlIdx >= 0)\n\t{\n\t\tm_alarmCFG[m_almIdx].struHandle.struPtzLink[m_ptzchlIdx].iType = ((CComboBox*)GetDlgItem(IDC_CHECK_PTZ))->GetCurSel();\n\t\tm_alarmCFG[m_almIdx].struHandle.struPtzLink[m_ptzchlIdx].iValue = GetDlgItemInt(IDC_EDIT_PTZNO);\n\t}\n\nskipsave:\n\t//show new ones\n\tint almIdx = ((CComboBox*)GetDlgItem(IDC_COMBO_ALARMIN))->GetCurSel();\n\tif (almIdx < 0 || ((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->GetCount() < 0)\n\t{\n\t\treturn;\n\t}\n\n\tm_almIdx = almIdx;\n\t((CButton*)GetDlgItem(IDC_CHECK_ALARMENABLE))->SetCheck(m_alarmCFG[almIdx].byAlarmEn?1:0);\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMTYPE))->SetCurSel(m_alarmCFG[almIdx].byAlarmType);\n\t\n\tif (((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->GetCount() > 0)\n\t{\n\t\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->SetCurSel(0);\n\t\tm_weekIdx = -1; //prevent from unwanted saving\n\t\tOnSelchangeComboAlarmweek() ;\n\t}\n\t\n\t((CButton*)GetDlgItem(IDC_CHECK_UPLOAD))->SetCheck((m_alarmCFG[almIdx].struHandle.dwActionFlag&DH_ALARM_UPLOAD)?1:0);\n\t((CButton*)GetDlgItem(IDC_CHECK_LOCALTIP))->SetCheck((m_alarmCFG[almIdx].struHandle.dwActionFlag&DH_ALARM_TIP)?1:0);\n\t((CButton*)GetDlgItem(IDC_CHECK_LOCALTOUR))->SetCheck((m_alarmCFG[almIdx].struHandle.dwActionFlag&DH_ALARM_TOUR)?1:0);\n\t((CButton*)GetDlgItem(IDC_CHECK_SENDMAIL))->SetCheck((m_alarmCFG[almIdx].struHandle.dwActionFlag&DH_ALARM_MAIL)?1:0);\n\t((CButton*)GetDlgItem(IDC_CHECK_PTZ))->SetCheck((m_alarmCFG[almIdx].struHandle.dwActionFlag&DH_ALARM_PTZ)?1:0);\n\t((CButton*)GetDlgItem(IDC_CHECK_RECORD))->SetCheck((m_alarmCFG[almIdx].struHandle.dwActionFlag&DH_ALARM_RECORD)?1:0);\n\t((CButton*)GetDlgItem(IDC_CHECK_OUTPUT))->SetCheck((m_alarmCFG[almIdx].struHandle.dwActionFlag&DH_ALARM_OUT)?1:0);\n\t\n\tfor (j = 0; j < m_pDev->Info.byAlarmOutPortNum; j++)\n\t{\n\t\t((CButton*)GetDlgItem(IDC_CHECK_ALMOP1+j))->SetCheck(m_alarmCFG[almIdx].struHandle.byRelAlarmOut[j]?1:0);\n\t}\n\n\tfor (k = 0; k < m_pDev->Info.byChanNum; k++)\n\t{\n\t\t((CButton*)GetDlgItem(IDC_CHECK_RECCH1+k))->SetCheck(m_alarmCFG[almIdx].struHandle.byRecordChannel[k]?1:0);\n\t}\n\n\tif (((CComboBox*)GetDlgItem(IDC_COMBO_ALARMPTZCHL))-> GetCount() > 0)\n\t{\n\t\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMPTZCHL))-> SetCurSel(0);\n\t\tm_ptzchlIdx = -1; //prevent from unwanted saving\n\t\tOnSelchangeComboAlarmptzchl();\n\t}\n}\n\nvoid CConfigAlarmAlarm::OnSelchangeComboAlarmweek() \n{\n\tif (!m_bReady)\n\t{\n\t\treturn;\n\t}\n\n\tif (m_almIdx < 0)\n\t{\n\t\treturn;\n\t}\n\n\t//store current time sectors\n\tif (m_weekIdx >= 0)\n\t{\n\t\tint secIdx = 0;\n\t\tfor (int i = 0; i < 6; i++)\n\t\t{\n\t\t\tm_alarmCFG[m_almIdx].stSect[m_weekIdx][i].iBeginHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_alarmCFG[m_almIdx].stSect[m_weekIdx][i].iBeginMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_alarmCFG[m_almIdx].stSect[m_weekIdx][i].iBeginSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\t\n\t\t\tm_alarmCFG[m_almIdx].stSect[m_weekIdx][i].iEndHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_alarmCFG[m_almIdx].stSect[m_weekIdx][i].iEndMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_alarmCFG[m_almIdx].stSect[m_weekIdx][i].iEndSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t}\n\t}\n\n\t//show new time sectors\n\tint weekIdx = ((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->GetCurSel();\n\tif (weekIdx < 0)\n\t{\n\t\treturn;\n\t}\n\tm_weekIdx = weekIdx;\n\n\tint timeCtrlIdx = 0;\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_alarmCFG[m_almIdx].stSect[weekIdx][i].iBeginHour);\n\t\ttimeCtrlIdx++;\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_alarmCFG[m_almIdx].stSect[weekIdx][i].iBeginMin);\n\t\ttimeCtrlIdx++;\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_alarmCFG[m_almIdx].stSect[weekIdx][i].iBeginSec);\n\t\ttimeCtrlIdx++;\n\t\t\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_alarmCFG[m_almIdx].stSect[weekIdx][i].iEndHour);\n\t\ttimeCtrlIdx++;\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_alarmCFG[m_almIdx].stSect[weekIdx][i].iEndMin);\n\t\ttimeCtrlIdx++;\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_alarmCFG[m_almIdx].stSect[weekIdx][i].iEndSec);\n\t\ttimeCtrlIdx++;\n\t}\n}\n\nvoid CConfigAlarmAlarm::OnSelchangeComboAlarmptzchl() \n{\n\tif (!m_bReady || m_almIdx < 0)\n\t{\n\t\treturn;\n\t}\n\n\tif (m_ptzchlIdx >= 0)\n\t{\n\t\tm_alarmCFG[m_almIdx].struHandle.struPtzLink[m_ptzchlIdx].iType = ((CComboBox*)GetDlgItem(IDC_CHECK_PTZ))->GetCurSel();\n\t\tm_alarmCFG[m_almIdx].struHandle.struPtzLink[m_ptzchlIdx].iValue = GetDlgItemInt(IDC_EDIT_PTZNO);\n\t}\n\n\tint ptzchlIdx = ((CComboBox*)GetDlgItem(IDC_COMBO_ALARMPTZCHL))-> GetCount();\n\tif (ptzchlIdx < 0)\n\t{\n\t\treturn;\n\t}\n\tm_ptzchlIdx = ptzchlIdx;\n\t((CComboBox*)GetDlgItem(IDC_CHECK_PTZ))->SetCurSel(m_alarmCFG[m_almIdx].struHandle.struPtzLink[ptzchlIdx].iType);\n\tSetDlgItemInt(IDC_EDIT_PTZNO,m_alarmCFG[m_almIdx].struHandle.struPtzLink[ptzchlIdx].iValue);\n}\n\nvoid CConfigAlarmAlarm::GetAlarmInCFG(DH_ALARMIN_CFG *cfg)\n{\n\tif (!cfg || !m_bReady || m_almIdx < 0)\n\t{\n\t\treturn;\n\t}\n\n\tm_alarmCFG[m_almIdx].byAlarmEn = ((CButton*)GetDlgItem(IDC_CHECK_ALARMENABLE))->GetCheck();\n\tm_alarmCFG[m_almIdx].byAlarmType = ((CComboBox*)GetDlgItem(IDC_COMBO_ALARMTYPE))->GetCurSel();\n\t\n\tif (m_weekIdx >= 0)\n\t{\n\t\tint secIdx = 0;\n\t\tfor (int i = 0; i < 6; i++)\n\t\t{\n\t\t\tm_alarmCFG[m_almIdx].stSect[m_weekIdx][i].iBeginHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_alarmCFG[m_almIdx].stSect[m_weekIdx][i].iBeginMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_alarmCFG[m_almIdx].stSect[m_weekIdx][i].iBeginSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\t\n\t\t\tm_alarmCFG[m_almIdx].stSect[m_weekIdx][i].iEndHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_alarmCFG[m_almIdx].stSect[m_weekIdx][i].iEndMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_alarmCFG[m_almIdx].stSect[m_weekIdx][i].iEndSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t}\n\t}\n\t\n\tm_alarmCFG[m_almIdx].struHandle.dwActionFlag = 0;\n\tm_alarmCFG[m_almIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_UPLOAD))->GetCheck()?DH_ALARM_UPLOAD:0;\n\tm_alarmCFG[m_almIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_LOCALTIP))->GetCheck()?DH_ALARM_TIP:0;\n\tm_alarmCFG[m_almIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_LOCALTOUR))->GetCheck()?DH_ALARM_TOUR:0;\n\tm_alarmCFG[m_almIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_SENDMAIL))->GetCheck()?DH_ALARM_MAIL:0;\n\tm_alarmCFG[m_almIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_PTZ))->GetCheck()?DH_ALARM_PTZ:0;\n\tm_alarmCFG[m_almIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_RECORD))->GetCheck()?DH_ALARM_RECORD:0;\n\tm_alarmCFG[m_almIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_OUTPUT))->GetCheck()?DH_ALARM_OUT:0;\n\n\tfor (int j = 0; j < m_pDev->Info.byAlarmOutPortNum; j++)\n\t{\n\t\tm_alarmCFG[m_almIdx].struHandle.byRelAlarmOut[j] = ((CButton*)GetDlgItem(IDC_CHECK_ALMOP1+j))->GetCheck();\n\t}\n\n\tfor (int k = 0; k < m_pDev->Info.byChanNum; k++)\n\t{\n\t\tm_alarmCFG[m_almIdx].struHandle.byRecordChannel[k] = ((CButton*)GetDlgItem(IDC_CHECK_RECCH1+k))->GetCheck();\n\t}\n\n\tif (m_ptzchlIdx >= 0)\n\t{\n\t\tm_alarmCFG[m_almIdx].struHandle.struPtzLink[m_ptzchlIdx].iType = ((CComboBox*)GetDlgItem(IDC_CHECK_PTZ))->GetCurSel();\n\t\tm_alarmCFG[m_almIdx].struHandle.struPtzLink[m_ptzchlIdx].iValue = GetDlgItemInt(IDC_EDIT_PTZNO);\n\t}\n\n\tmemcpy(cfg, m_alarmCFG, DH_MAX_ALARM_IN_NUM*sizeof(DH_ALARMIN_CFG));\n}\n\nvoid CConfigAlarmAlarm::UndoAll()\n{\n\tm_bReady = FALSE;\n\tm_almIdx = -1;\n\tm_weekIdx = -1;\n\tm_ptzchlIdx = -1;\n}\n","size_bytes":14353},"bin/Demo/MfcDemo/14.GateDemo/GateDemo.cpp":{"content":"// GateDemo.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"GateDemo.h\"\n#include \"GateDemoDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\n\n// CGateDemoApp\n\nBEGIN_MESSAGE_MAP(CGateDemoApp, CWinApp)\n\tON_COMMAND(ID_HELP, &CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n\n// CGateDemoApp construction\n\nCGateDemoApp::CGateDemoApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n\n// The one and only CGateDemoApp object\n\nCGateDemoApp theApp;\n\n\n// CGateDemoApp initialization\n\nBOOL CGateDemoApp::InitInstance()\n{\n\t// InitCommonControlsEx() is required on Windows XP if an application\n\t// manifest specifies use of ComCtl32.dll version 6 or later to enable\n\t// visual styles.  Otherwise, any window creation will fail.\n\tINITCOMMONCONTROLSEX InitCtrls;\n\tInitCtrls.dwSize = sizeof(InitCtrls);\n\t// Set this to include all the common control classes you want to use\n\t// in your application.\n\tInitCtrls.dwICC = ICC_WIN95_CLASSES;\n\tInitCommonControlsEx(&InitCtrls);\n\n\tCWinApp::InitInstance();\n\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t// of your final executable, you should remove from the following\n\t// the specific initialization routines you do not need\n\t// Change the registry key under which our settings are stored\n\t// TODO: You should modify this string to be something appropriate\n\t// such as the name of your company or organization\n\tSetRegistryKey(_T(\"Local AppWizard-Generated Applications\"));\n\n\tCGateDemoDlg dlg;\n\tm_pMainWnd = &dlg;\n\tINT_PTR nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n","size_bytes":2032},"bin/Demo/MfcDemo/10.AlarmDevice/AudioBoardcastDlg.cpp":{"content":"// AudioBoardcastDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"AudioBoardcastDlg.h\"\n#include \"LoginDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CAudioBoardcastDlg dialog\n\n\nCAudioBoardcastDlg::CAudioBoardcastDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CAudioBoardcastDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CAudioBoardcastDlg)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CAudioBoardcastDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CAudioBoardcastDlg)\n\tDDX_Control(pDX, IDC_LIST_DEVICE, m_lbDevice);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CAudioBoardcastDlg, CDialog)\n\t//{{AFX_MSG_MAP(CAudioBoardcastDlg)\n\tON_BN_CLICKED(IDC_BTN_ADD, OnBtnAdd)\n\tON_BN_CLICKED(IDC_BTN_DEL, OnBtnDel)\n\tON_BN_CLICKED(IDC_BTN_START, OnBtnStart)\n\tON_BN_CLICKED(IDC_BTN_STOP, OnBtnStop)\n\tON_WM_DESTROY()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CAudioBoardcastDlg message handlers\n\nBOOL CAudioBoardcastDlg::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\t// TODO: Add extra initialization here\n\tg_SetWndStaticText(this, DLG_TALK_BOARDCAST);\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CAudioBoardcastDlg::OnBtnAdd() \n{\n\tCLoginDlg dlg;\n\tif (dlg.DoModal() == IDOK)\n\t{\n\t\tBOOL bRet = FALSE;\n\t\tLLONG lLoginID = dlg.GetLoginHandle();\n\t\t\n\t\tNET_TALK_EX stuTalkInfo = { sizeof(NET_TALK_EX) };\n\t\tstrncpy(stuTalkInfo.szMulticastAddr, \"234.5.6.7\", sizeof(stuTalkInfo.szMulticastAddr) - 1);\n\t\tstuTalkInfo.wMulticastLocalPort = 56789;\n\t\tstuTalkInfo.wMulticastRemotePort = 54321;\n\t\tCLIENT_SetDeviceMode(lLoginID, DH_TALK_MODE3, &stuTalkInfo);\n\n\t\tDHDEV_TALKDECODE_INFO stuAudioFmt;\n\t\tmemset(&stuAudioFmt, 0, sizeof(stuAudioFmt));\n\t\tstuAudioFmt.encodeType = DH_TALK_PCM;\n\t\tstuAudioFmt.dwSampleRate = 16000;\n\t\tstuAudioFmt.nAudioBit = 16;\n\t\tstuAudioFmt.nPacketPeriod = 0;\t\n\t\tCLIENT_SetDeviceMode(lLoginID, DH_TALK_ENCODE_TYPE, &stuAudioFmt);\n\n\t\tif (CLIENT_AudioBroadcastAddDev(lLoginID))\n\t\t{\n\t\t\tif (CLIENT_RecordStartEx(lLoginID))\n\t\t\t{\n\t\t\t\tbRet = TRUE;\n\t\t\t\tint nIndex = m_lbDevice.AddString(dlg.GetDeviceAddr());\n\t\t\t\tm_lbDevice.SetItemDataPtr(nIndex, (void*)lLoginID);\n\t\t\t\tm_lbDevice.SetCurSel(nIndex);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCLIENT_AudioBroadcastDelDev(lLoginID);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!bRet)\n\t\t{\n\t\t\tCLIENT_Logout(lLoginID);\n\t\t\tMessageBox(ConvertString(\"Add broadcast device error.\", DLG_TALK_BOARDCAST), ConvertString(\"Prompt\"));\n\t\t}\n\t}\n}\n\nvoid CAudioBoardcastDlg::OnBtnDel() \n{\n\tint nIndex = m_lbDevice.GetCurSel();\n\tif (nIndex >= 0)\n\t{\n\t\tLLONG lLoginID = (LLONG)m_lbDevice.GetItemDataPtr(nIndex);\n\n\t\tCLIENT_RecordStopEx(lLoginID);\n\t\tCLIENT_AudioBroadcastDelDev(lLoginID);\n\t\tCLIENT_Logout(lLoginID);\n\n\t\tm_lbDevice.DeleteString(nIndex);\n\t\tint nCount = m_lbDevice.GetCount();\n\t\tif (nIndex >= nCount)\n\t\t{\n\t\t\tnIndex = nCount - 1;\n\t\t}\n\t\tm_lbDevice.SetCurSel(nIndex);\n\t}\n}\n\nvoid CAudioBoardcastDlg::OnBtnStart() \n{\n\n}\n\nvoid CAudioBoardcastDlg::OnBtnStop() \n{\n\t// TODO: Add your control notification handler code here\n\t\n}\n\nvoid CAudioBoardcastDlg::OnDestroy() \n{\n\tCDialog::OnDestroy();\n\n\tint nCount = m_lbDevice.GetCount();\n\tfor (int i = nCount - 1; i >= 0; --i)\n\t{\n\t\tLLONG lLoginID = (LLONG)m_lbDevice.GetItemDataPtr(i);\n\t\tCLIENT_AudioBroadcastDelDev(lLoginID);\n\t\tCLIENT_Logout(lLoginID);\n\t}\t\n}\n","size_bytes":3593},"bin/Demo/MfcDemo/03.Alarm/AlarmInfo.cpp":{"content":"// AlarmInfo.cpp: implementation of the CAlarmInfo class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"AlarmInfo.h\"\n\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\n//////////////////////////////////////////////////////////////////////\n// Construction/Destruction\n//////////////////////////////////////////////////////////////////////\n\n\nCAlarmInfoEx::CAlarmInfoEx()\n{\n\tm_nAlarmType = 0;\t\t\n\tm_nChannel = 0;\n\tm_emAlarmStatus = ALARM_STOP;\n\tm_strTime = \"\";\n}\n\nCAlarmInfoEx::~CAlarmInfoEx()\n{\n\t\n}","size_bytes":599},"bin/Demo/MfcDemo/24.VTODemo/Utils.cpp":{"content":"#include \"StdAfx.h\"\n#include \"Utils.h\"\n\nTCHAR* g_GetIniPath(void)\n{\n\tstatic char pszIniPath[512] = {0};\n\tif( strlen(pszIniPath) == 0 )\n\t{\n\t\tchar szDirBuf[512] = {0};\n\t\tGetCurrentDirectory(512, szDirBuf);\n\t\t_snprintf(pszIniPath, sizeof(pszIniPath), \"%s\\\\langchn.ini\", szDirBuf);\n\t}\n\treturn pszIniPath;\n}\n\nCString ConvertString(CString strText)\n{\n\tchar *val = new char[200];\n\tCString strIniPath,strRet;\n\n\tmemset(val,0,200);\n\tGetPrivateProfileString(\"String\",strText,\"\",\n\t\tval,200,g_GetIniPath());\n\tstrRet = val;\n\tif(strRet.GetLength()==0)\n\t{\n\t\t//If there is no corresponding string in ini file ,then set it to be default value.\n\t\tstrRet=strText;\n\t}\n\tdelete val;\n\treturn strRet;\n}\n\nvoid g_SetWndStaticText(CWnd * pWnd)\n{\n\tCString strCaption,strText;\n\n\t//Set main widnow title \n\tpWnd->GetWindowText(strCaption);\n\tif(strCaption.GetLength()>0)\n\t{\n\t\tstrText=ConvertString(strCaption);\n\t\tpWnd->SetWindowText(strText);\n\t}\n\n\t//Set small window title \n\tCWnd * pChild=pWnd->GetWindow(GW_CHILD);\n\tCString strClassName;\n\twhile(pChild)\n\t{\n\t\t//////////////////////////////////////////////////////////////////////////\t\t\n\t\t//Added by Jackbin 2005-03-11\n\t\tstrClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n\t\tif(strClassName == \"CEdit\")\n\t\t{\n\t\t\t//The next small window \n\t\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t\t\tcontinue;\n\t\t}\n\n\t\t//////////////////////////////////////////////////////////////////////////\t\n\n\t\t//Set current language text in small window\n\t\tpChild->GetWindowText(strCaption);\n\t\tstrText=ConvertString(strCaption);\n\t\tpChild->SetWindowText(strText);\n\n\t\t//The next small window \n\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t}\n}\n\nvoid FillCWndWithDefaultColor(CWnd* cwnd) \n{\n\tif (NULL == cwnd)\n\t{\n\t\treturn;\n\t}\n\n\tCDC* cdc = cwnd->GetDC();\n\tif (NULL == cdc)\n\t{\n\t\treturn;\n\t}\n\n\tRECT rect;\n\tcwnd->GetClientRect(&rect);\n\tCBrush brush(RGB(105,105,105));\n\tcdc->FillRect(&rect, &brush);\n\tcwnd->ReleaseDC(cdc);\n}\n","size_bytes":1917},"bin/Demo/MfcDemo/00.DevInit/MylistCtrl.cpp":{"content":"// MylistCtrl.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"searchdevice.h\"\n#include \"MylistCtrl.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CMylistCtrl\n\nCMylistCtrl::CMylistCtrl()\n{\n}\n\nCMylistCtrl::~CMylistCtrl()\n{\n}\n\n\nBEGIN_MESSAGE_MAP(CMylistCtrl, CListCtrl)\n\t//{{AFX_MSG_MAP(CMylistCtrl)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t//}}AFX_MSG_MAP\n    ON_NOTIFY_REFLECT(NM_CUSTOMDRAW, OnNMCustomdraw) \nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CMylistCtrl message handlers\nvoid CMylistCtrl::OnNMCustomdraw(NMHDR *pNMHDR, LRESULT *pResult)    \n{    \n    // TODO: Add your control notification handler code here     \n    *pResult = CDRF_DODEFAULT;    \n    NMLVCUSTOMDRAW * lplvdr=(NMLVCUSTOMDRAW*)pNMHDR;    \n    NMCUSTOMDRAW &nmcd = lplvdr->nmcd;  \n\t//Judge status\n    switch(lplvdr->nmcd.dwDrawStage)     \n    {    \n    case CDDS_PREPAINT:    \n        {    \n            *pResult = CDRF_NOTIFYITEMDRAW;    \n            break;    \n        }\n\t\t\n    case CDDS_ITEMPREPAINT:     \n        {    \n            TEXT_BK tb;  \n            if(MapItemColor.Lookup(nmcd.dwItemSpec, tb))    \n            {    \n                lplvdr->clrText = tb.colText;     \n                lplvdr->clrTextBk = tb.colTextBk;    \n                *pResult = CDRF_DODEFAULT;    \n            }    \n        }    \n        break;    \n    }    \n}    \n  \nvoid CMylistCtrl::ClearColor()  \n{  \n    MapItemColor.RemoveAll();  \n}  \n  \nvoid CMylistCtrl::SetItemColor(DWORD iItem, COLORREF TextColor, COLORREF TextBkColor)  \n{    \n    TEXT_BK tb;  \n    tb.colText = TextColor;  \n    tb.colTextBk = TextBkColor;  \n    \n\t//set a line color\n    MapItemColor.SetAt(iItem, tb);     \n    //re-dyeing\n\tthis->RedrawItems(iItem, iItem);\n           \n    this->SetFocus();        \n    UpdateWindow();    \n}    \n    \nvoid CMylistCtrl::SetAllItemColor(DWORD iItem, COLORREF TextColor, COLORREF TextBkColor)    \n{     \n    TEXT_BK tb;  \n    tb.colText = TextColor;  \n    tb.colTextBk = TextBkColor;  \n  \n    if(iItem > 0)    \n    {    \n        for(DWORD numItem = 0; numItem < iItem ;numItem ++)    \n        {       \n            MapItemColor.SetAt(numItem, tb);    \n            this->RedrawItems(numItem, numItem);    \n        }    \n    }    \n      \n    return;     \n}   \n\n\n","size_bytes":2455},"bin/Demo/MfcDemo/21.PassengerFlow/Utils.cpp":{"content":"#include \"StdAfx.h\"\n#include \"Utils.h\"\n\nTCHAR* g_GetIniPath(void)\n{\n\tstatic char pszIniPath[512] = {0};\n\tif( strlen(pszIniPath) == 0 )\n\t{\n\t\tchar szDirBuf[512] = {0};\n\t\tGetCurrentDirectory(512, szDirBuf);\n\t\t_snprintf(pszIniPath, sizeof(pszIniPath), \"%s\\\\langchn.ini\", szDirBuf);\n\t}\n\treturn pszIniPath;\n}\n\nCString ConvertString(CString strText)\n{\n\tchar szval[200] = {0};\n\tCString strIniPath,strRet;\n\n\tGetPrivateProfileString(\"String\",strText,\"\",\n\t\tszval,200,g_GetIniPath());\n\tstrRet = szval;\n\tif(strRet.GetLength()==0)\n\t{\n\t\t//If there is no corresponding string in ini file ,then set it to be default value.\n\t\tstrRet=strText;\n\t}\n\treturn strRet;\n}\n\nvoid g_SetWndStaticText(CWnd * pWnd)\n{\n\tCString strCaption,strText;\n\n\t//Set main widnow title \n\tpWnd->GetWindowText(strCaption);\n\tif(strCaption.GetLength()>0)\n\t{\n\t\tstrText=ConvertString(strCaption);\n\t\tpWnd->SetWindowText(strText);\n\t}\n\n\t//Set small window title \n\tCWnd * pChild=pWnd->GetWindow(GW_CHILD);\n\tCString strClassName;\n\twhile(pChild)\n\t{\n\t\t//////////////////////////////////////////////////////////////////////////\t\t\n\t\t//Added by Jackbin 2005-03-11\n\t\tstrClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n\t\tif(strClassName == \"CEdit\")\n\t\t{\n\t\t\t//The next small window \n\t\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t\t\tcontinue;\n\t\t}\n\n\t\t//////////////////////////////////////////////////////////////////////////\t\n\n\t\t//Set current language text in small window\n\t\tpChild->GetWindowText(strCaption);\n\t\tstrText=ConvertString(strCaption);\n\t\tpChild->SetWindowText(strText);\n\n\t\t//The next small window \n\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t}\n}\n\nvoid FillCWndWithDefaultColor(CWnd* cwnd) \n{\n\tif (NULL == cwnd)\n\t{\n\t\treturn;\n\t}\n\n\tCDC* cdc = cwnd->GetDC();\n\tif (NULL == cdc)\n\t{\n\t\treturn;\n\t}\n\n\tRECT rect;\n\tcwnd->GetClientRect(&rect);\n\tCBrush brush(RGB(105,105,105));\n\tcdc->FillRect(&rect, &brush);\n\tcwnd->ReleaseDC(cdc);\n}","size_bytes":1883},"bin/Demo/MfcDemo/00.DevInit/LibQREncode/mask.c":{"content":"/*\n * qrencode - QR Code encoder\n *\n * Masking.\n * Copyright (C) 2006-2011 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#if HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <errno.h>\n\n#include \"qrencode.h\"\n#include \"qrspec.h\"\n#include \"mask.h\"\n\n__STATIC int Mask_writeFormatInformation(int width, unsigned char *frame, int mask, QRecLevel level)\n{\n\tunsigned int format;\n\tunsigned char v;\n\tint i;\n\tint blacks = 0;\n\n\tformat = QRspec_getFormatInfo(mask, level);\n\n\tfor(i=0; i<8; i++) {\n\t\tif(format & 1) {\n\t\t\tblacks += 2;\n\t\t\tv = 0x85;\n\t\t} else {\n\t\t\tv = 0x84;\n\t\t}\n\t\tframe[width * 8 + width - 1 - i] = v;\n\t\tif(i < 6) {\n\t\t\tframe[width * i + 8] = v;\n\t\t} else {\n\t\t\tframe[width * (i + 1) + 8] = v;\n\t\t}\n\t\tformat= format >> 1;\n\t}\n\tfor(i=0; i<7; i++) {\n\t\tif(format & 1) {\n\t\t\tblacks += 2;\n\t\t\tv = 0x85;\n\t\t} else {\n\t\t\tv = 0x84;\n\t\t}\n\t\tframe[width * (width - 7 + i) + 8] = v;\n\t\tif(i == 0) {\n\t\t\tframe[width * 8 + 7] = v;\n\t\t} else {\n\t\t\tframe[width * 8 + 6 - i] = v;\n\t\t}\n\t\tformat= format >> 1;\n\t}\n\n\treturn blacks;\n}\n\n/**\n * Demerit coefficients.\n * See Section 8.8.2, pp.45, JIS X0510:2004.\n */\n#define N1 (3)\n#define N2 (3)\n#define N3 (40)\n#define N4 (10)\n\n#define MASKMAKER(__exp__) \\\n\tint x, y;\\\n\tint b = 0;\\\n\\\n\tfor(y=0; y<width; y++) {\\\n\t\tfor(x=0; x<width; x++) {\\\n\t\t\tif(*s & 0x80) {\\\n\t\t\t\t*d = *s;\\\n\t\t\t} else {\\\n\t\t\t\t*d = *s ^ ((__exp__) == 0);\\\n\t\t\t}\\\n\t\t\tb += (int)(*d & 1);\\\n\t\t\ts++; d++;\\\n\t\t}\\\n\t}\\\n\treturn b;\n\nstatic int Mask_mask0(int width, const unsigned char *s, unsigned char *d)\n{\n\tMASKMAKER((x+y)&1)\n}\n\nstatic int Mask_mask1(int width, const unsigned char *s, unsigned char *d)\n{\n\tMASKMAKER(y&1)\n}\n\nstatic int Mask_mask2(int width, const unsigned char *s, unsigned char *d)\n{\n\tMASKMAKER(x%3)\n}\n\nstatic int Mask_mask3(int width, const unsigned char *s, unsigned char *d)\n{\n\tMASKMAKER((x+y)%3)\n}\n\nstatic int Mask_mask4(int width, const unsigned char *s, unsigned char *d)\n{\n\tMASKMAKER(((y/2)+(x/3))&1)\n}\n\nstatic int Mask_mask5(int width, const unsigned char *s, unsigned char *d)\n{\n\tMASKMAKER(((x*y)&1)+(x*y)%3)\n}\n\nstatic int Mask_mask6(int width, const unsigned char *s, unsigned char *d)\n{\n\tMASKMAKER((((x*y)&1)+(x*y)%3)&1)\n}\n\nstatic int Mask_mask7(int width, const unsigned char *s, unsigned char *d)\n{\n\tMASKMAKER((((x*y)%3)+((x+y)&1))&1)\n}\n\n#define maskNum (8)\ntypedef int MaskMaker(int, const unsigned char *, unsigned char *);\nstatic MaskMaker *maskMakers[maskNum] = {\n\tMask_mask0, Mask_mask1, Mask_mask2, Mask_mask3,\n\tMask_mask4, Mask_mask5, Mask_mask6, Mask_mask7\n};\n\n#ifdef WITH_TESTS\nunsigned char *Mask_makeMaskedFrame(int width, unsigned char *frame, int mask)\n{\n\tunsigned char *masked;\n\n\tmasked = (unsigned char *)malloc(width * width);\n\tif(masked == NULL) return NULL;\n\n\tmaskMakers[mask](width, frame, masked);\n\n\treturn masked;\n}\n#endif\n\nunsigned char *Mask_makeMask(int width, unsigned char *frame, int mask, QRecLevel level)\n{\n\tunsigned char *masked;\n\n\tif(mask < 0 || mask >= maskNum) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tmasked = (unsigned char *)malloc(width * width);\n\tif(masked == NULL) return NULL;\n\n\tmaskMakers[mask](width, frame, masked);\n\tMask_writeFormatInformation(width, masked, mask, level);\n\n\treturn masked;\n}\n\n\n//static int n1;\n//static int n2;\n//static int n3;\n//static int n4;\n\n__STATIC int Mask_calcN1N3(int length, int *runLength)\n{\n\tint i;\n\tint demerit = 0;\n\tint fact;\n\n\tfor(i=0; i<length; i++) {\n\t\tif(runLength[i] >= 5) {\n\t\t\tdemerit += N1 + (runLength[i] - 5);\n\t\t\t//n1 += N1 + (runLength[i] - 5);\n\t\t}\n\t\tif((i & 1)) {\n\t\t\tif(i >= 3 && i < length-2 && (runLength[i] % 3) == 0) {\n\t\t\t\tfact = runLength[i] / 3;\n\t\t\t\tif(runLength[i-2] == fact &&\n\t\t\t\t   runLength[i-1] == fact &&\n\t\t\t\t   runLength[i+1] == fact &&\n\t\t\t\t   runLength[i+2] == fact) {\n\t\t\t\t\tif(i == 3 || runLength[i-3] >= 4 * fact) {\n\t\t\t\t\t\tdemerit += N3;\n\t\t\t\t\t\t//n3 += N3;\n\t\t\t\t\t} else if(i+4 >= length || runLength[i+3] >= 4 * fact) {\n\t\t\t\t\t\tdemerit += N3;\n\t\t\t\t\t\t//n3 += N3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn demerit;\n}\n\n__STATIC int Mask_calcN2(int width, unsigned char *frame)\n{\n\tint x, y;\n\tunsigned char *p;\n\tunsigned char b22, w22;\n\tint demerit = 0;\n\n\tp = frame + width + 1;\n\tfor(y=1; y<width; y++) {\n\t\tfor(x=1; x<width; x++) {\n\t\t\tb22 = p[0] & p[-1] & p[-width] & p [-width-1];\n\t\t\tw22 = p[0] | p[-1] | p[-width] | p [-width-1];\n\t\t\tif((b22 | (w22 ^ 1))&1) {\n\t\t\t\tdemerit += N2;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\tp++;\n\t}\n\n\treturn demerit;\n}\n\n__STATIC int Mask_calcRunLength(int width, unsigned char *frame, int dir, int *runLength)\n{\n\tint head;\n\tint i;\n\tunsigned char *p;\n\tint pitch;\n\n\tpitch = (dir==0)?1:width;\n\tif(frame[0] & 1) {\n\t\trunLength[0] = -1;\n\t\thead = 1;\n\t} else {\n\t\thead = 0;\n\t}\n\trunLength[head] = 1;\n\tp = frame + pitch;\n\n\tfor(i=1; i<width; i++) {\n\t\tif((p[0] ^ p[-pitch]) & 1) {\n\t\t\thead++;\n\t\t\trunLength[head] = 1;\n\t\t} else {\n\t\t\trunLength[head]++;\n\t\t}\n\t\tp += pitch;\n\t}\n\n\treturn head + 1;\n}\n\n__STATIC int Mask_evaluateSymbol(int width, unsigned char *frame)\n{\n\tint x, y;\n\tint demerit = 0;\n\tint runLength[QRSPEC_WIDTH_MAX + 1];\n\tint length;\n\n\tdemerit += Mask_calcN2(width, frame);\n\n\tfor(y=0; y<width; y++) {\n\t\tlength = Mask_calcRunLength(width, frame + y * width, 0, runLength);\n\t\tdemerit += Mask_calcN1N3(length, runLength);\n\t}\n\n\tfor(x=0; x<width; x++) {\n\t\tlength = Mask_calcRunLength(width, frame + x, 1, runLength);\n\t\tdemerit += Mask_calcN1N3(length, runLength);\n\t}\n\n\treturn demerit;\n}\n\nunsigned char *Mask_mask(int width, unsigned char *frame, QRecLevel level)\n{\n\tint i;\n\tunsigned char *mask, *bestMask;\n\tint minDemerit = INT_MAX;\n\tint blacks;\n\tint bratio;\n\tint demerit;\n\tint w2 = width * width;\n\n\tmask = (unsigned char *)malloc(w2);\n\tif(mask == NULL) return NULL;\n\tbestMask = NULL;\n\n\tfor(i=0; i<maskNum; i++) {\n//\t\tn1 = n2 = n3 = n4 = 0;\n\t\tdemerit = 0;\n\t\tblacks = maskMakers[i](width, frame, mask);\n\t\tblacks += Mask_writeFormatInformation(width, mask, i, level);\n\t\tbratio = (200 * blacks + w2) / w2 / 2; /* (int)(100*blacks/w2+0.5) */\n\t\tdemerit = (abs(bratio - 50) / 5) * N4;\n//\t\tn4 = demerit;\n\t\tdemerit += Mask_evaluateSymbol(width, mask);\n//\t\tprintf(\"(%d,%d,%d,%d)=%d\\n\", n1, n2, n3 ,n4, demerit);\n\t\tif(demerit < minDemerit) {\n\t\t\tminDemerit = demerit;\n\t\t\tfree(bestMask);\n\t\t\tbestMask = mask;\n\t\t\tmask = (unsigned char *)malloc(w2);\n\t\t\tif(mask == NULL) break;\n\t\t}\n\t}\n\tfree(mask);\n\treturn bestMask;\n}\n","size_bytes":6954},"bin/Demo/MfcDemo/13.FaceRecognition/Util.cpp":{"content":"#include \"StdAfx.h\"\n#include \"Util.h\"\n\nTCHAR* g_GetIniPath(void)\n{\n\tstatic char pszIniPath[512] = {0};\n\tif( strlen(pszIniPath) == 0 )\n\t{\n\t\tchar szDirBuf[512] = {0};\n\t\tGetCurrentDirectory(512, szDirBuf);\n\t\t_snprintf(pszIniPath, sizeof(pszIniPath), \"%s\\\\langchn.ini\", szDirBuf);\n\t}\n\treturn pszIniPath;\n}\n\nCString ConvertString(CString strText)\n{\n\tchar *val = new char[200];\n\tCString strIniPath,strRet;\n\n\tmemset(val,0,200);\n\tGetPrivateProfileString(\"String\",strText,\"\",\n\t\tval,200,g_GetIniPath());\n\tstrRet = val;\n\tif(strRet.GetLength()==0)\n\t{\n\t\t//If there is no corresponding string in ini file ,then set it to be default value.\n\t\tstrRet=strText;\n\t}\n\tdelete val;\n\treturn strRet;\n}\n\nvoid g_SetWndStaticText(CWnd * pWnd)\n{\n\tCString strCaption,strText;\n\t\n\t//Set main widnow title \n\tpWnd->GetWindowText(strCaption);\n\tif(strCaption.GetLength()>0)\n\t{\n\t\tstrText=ConvertString(strCaption);\n\t\tpWnd->SetWindowText(strText);\n\t}\n\t\n\t//Set small window title \n\tCWnd * pChild=pWnd->GetWindow(GW_CHILD);\n\tCString strClassName;\n\twhile(pChild)\n\t{\n\t\t//////////////////////////////////////////////////////////////////////////\t\t\n\t\t//Added by Jackbin 2005-03-11\n\t\tstrClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n\t\tif(strClassName == \"CEdit\")\n\t\t{\n\t\t\t//The next small window \n\t\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t//////////////////////////////////////////////////////////////////////////\t\n\t\t\n\t\t//Set current language text in small window\n\t\tpChild->GetWindowText(strCaption);\n\t\tstrText=ConvertString(strCaption);\n\t\tpChild->SetWindowText(strText);\n\t\t\n\t\t//The next small window \n\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t}\n}\n\nvoid FillCWndWithDefaultColor(CWnd* cwnd) \n{\n\tif (NULL == cwnd)\n\t{\n\t\treturn;\n\t}\n\n\tCDC* cdc = cwnd->GetDC();\n\tif (NULL == cdc)\n\t{\n\t\treturn;\n\t}\n\n\tRECT rect;\n\tcwnd->GetClientRect(&rect);\n\tCBrush brush(RGB(105,105,105));\n\tcdc->FillRect(&rect, &brush);\n\tcwnd->ReleaseDC(cdc);\n}","size_bytes":1923},"bin/Demo/MfcDemo/05.Talk/Talk.cpp":{"content":"// Talk.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"Talk.h\"\n#include \"TalkDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CTalkApp\n\nBEGIN_MESSAGE_MAP(CTalkApp, CWinApp)\n\t//{{AFX_MSG_MAP(CTalkApp)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t\t//    DO NOT EDIT what you see in these blocks of generated code!\n\t//}}AFX_MSG\n\tON_COMMAND(ID_HELP, CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CTalkApp construction\n\nstd::string I2Str(const int v)\n{\n    char szVal[10] = {0};\n    _itoa(v, szVal, 32);\n    return std::string(szVal);\n}\n\nCString ConvertString(CString strText)\n{\n\tchar *val = new char[200];\n\tCString strIniPath,strRet;\n\t\n\tmemset(val,0,200);\n\tGetPrivateProfileString(\"String\",strText,\"\",\n\t\tval,200,\"./langchn.ini\");\n\tstrRet = val;\n\tif(strRet.GetLength()==0)\n\t{\n\t\t//If there is no corresponding string in ini file.Please set it to default value(English).\n\t\tstrRet=strText;\n\t}\n\tdelete val;\n\treturn strRet;\n}\n//Set static text in dialogue box(English->current language)\nvoid g_SetWndStaticText(CWnd * pWnd)\n{\n\tCString strCaption,strText;\n\t\n\t//Set main window title \n\tpWnd->GetWindowText(strCaption);\n\tif(strCaption.GetLength()>0)\n\t{\n\t\tstrText=ConvertString(strCaption);\n\t\tpWnd->SetWindowText(strText);\n\t}\n\t\n\t//Set small window title \n\tCWnd * pChild=pWnd->GetWindow(GW_CHILD);\n\tCString strClassName;\n\twhile(pChild)\n\t{\n\t\t//////////////////////////////////////////////////////////////////////////\t\t\n\t\t//Added by Jackbin 2005-03-11\n\t\tstrClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n\t\tif(strClassName == \"CEdit\")\n\t\t{\n\t\t\t//The next small window \n\t\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t//////////////////////////////////////////////////////////////////////////\t\n\t\t\n\t\t//Set current language text in small window\n\t\tpChild->GetWindowText(strCaption);\n\t\tstrText=ConvertString(strCaption);\n\t\tpChild->SetWindowText(strText);\n\t\t\n\t\t//The next small window \n\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t}\n}\n\n\nCTalkApp::CTalkApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The one and only CTalkApp object\n\nCTalkApp theApp;\n\n/////////////////////////////////////////////////////////////////////////////\n// CTalkApp initialization\nBOOL CTalkApp::InitInstance()\n{\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t//  of your final executable, you should remove from the following\n\t//  the specific initialization routines you do not need.\n\n#ifdef _AFXDLL\n\tEnable3dControls();\t\t\t// Call this when using MFC in a shared DLL\n#else\n\tEnable3dControlsStatic();\t// Call this when linking to MFC statically\n#endif\n\n\tCTalkDlg dlg;\n\tm_pMainWnd = &dlg;\n\tINT_PTR nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n\nint CTalkApp::ExitInstance() \n{\n\t// TODO: Add your specialized code here and/or call the base class\n\n\treturn CWinApp::ExitInstance();\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":3679},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgSerial.cpp":{"content":"// DlgCfgSerial.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgCfgSerial.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgSerial dialog\n\nCDlgCfgSerial::CDlgCfgSerial(CWnd* pParent /*=NULL*/, LLONG lLoginID /*=NULL*/)\n\t: CDialog(CDlgCfgSerial::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgSerial)\n\tm_csChannel = _T(\"\");\n\tm_csProtocol = _T(\"\");\n\tm_lLoginId = lLoginID;\n\t//}}AFX_DATA_INIT\n\tmemset(&m_stuComm, 0, sizeof(m_stuComm));\n}\n\n\nvoid CDlgCfgSerial::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgSerial)\n\tDDX_Control(pDX, IDC_SERIAL_CMB_PROTOCOL, m_cbProtocol);\n\tDDX_Control(pDX, IDC_SERIAL_CMB_CHN, m_cbChannel);\n\tDDX_Control(pDX, IDC_SERIAL_CMB_STOPBIT, m_cbStopBit);\n\tDDX_Control(pDX, IDC_SERIAL_CMB_VERIFY, m_cbVerify);\n\tDDX_Control(pDX, IDC_SERIAL_CMB_DATABIT, m_cbDataBit);\n\tDDX_Control(pDX, IDC_SERIAL_CMB_BAUDRATE, m_cbBaudRate);\n\tDDX_Text(pDX, IDC_SERIAL_CMB_CHN, m_csChannel);\n\tDDX_Text(pDX, IDC_SERIAL_EDT_PROTOCOL, m_csProtocol);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgSerial, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgSerial)\n\tON_BN_CLICKED(IDC_SERIAL_BTN_SET, OnButtonSet)\n\tON_CBN_SELCHANGE(IDC_SERIAL_CMB_CHN, OnSelchangeCfgSerialCmbChn)\n\tON_CBN_SELENDCANCEL(IDC_SERIAL_CMB_PROTOCOL, OnSelendcancelSerialCmbProtocol)\n\tON_CBN_SELENDCANCEL(IDC_SERIAL_CMB_DATABIT, OnSelendcancelComboDatabit)\n\tON_CBN_SELENDCANCEL(IDC_SERIAL_CMB_STOPBIT, OnSelendcancelComboStopbit)\n\tON_CBN_SELENDCANCEL(IDC_SERIAL_CMB_VERIFY, OnSelendcancelComboVerify)\n\tON_CBN_SELENDCANCEL(IDC_SERIAL_CMB_BAUDRATE, OnSelendcancelComboBaudrate)\n\tON_BN_CLICKED(IDC_SERIAL_BTN_GET, OnButtonGet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgSerial private method\n\nvoid CDlgCfgSerial::InitDlg()\n{\n\tint i = 0;\n\n\tfor (i = 0; i < MAX_COMM_NUM; i++)\n\t{\n\t\tCString csTemp;\n\t\tcsTemp.Format(\"%s %02d\", ConvertString(\"Channel\", DLG_CFG_SERIAL), i + 1);\n\t\tm_cbChannel.InsertString(-1, csTemp);\n\t}\n\tm_cbChannel.SetCurSel(-1);\n\n\tfor (i = 0; i < sizeof(DemoCommProtocol) / sizeof(DemoCommProtocol[0]); i++)\n\t{\n\t\tm_cbProtocol.InsertString(-1, DemoCommProtocol[i].pszName);\n\t}\n\tm_cbProtocol.SetCurSel(-1);\n\n\tm_cbDataBit.InsertString(0, \"5\");\n\tm_cbDataBit.InsertString(1, \"6\");\n\tm_cbDataBit.InsertString(2, \"7\");\n\tm_cbDataBit.InsertString(3, \"8\");\n\tm_cbDataBit.SetCurSel(-1);\n\t\n\tm_cbVerify.InsertString(0, ConvertString(\"None\", DLG_CFG_SERIAL));\n\tm_cbVerify.InsertString(1, ConvertString(\"Odd\", DLG_CFG_SERIAL));\n\tm_cbVerify.InsertString(2, ConvertString(\"Even\", DLG_CFG_SERIAL));\n\tm_cbVerify.SetCurSel(-1);\n\t\n\tm_cbStopBit.InsertString(0, \"1\");\n\tm_cbStopBit.InsertString(1, \"1.5\");\n\tm_cbStopBit.InsertString(2, \"2\");\n\tm_cbStopBit.SetCurSel(-1);\n\t\n\tm_cbBaudRate.InsertString(-1, \"300\");\n\tm_cbBaudRate.InsertString(-1, \"600\");\n\tm_cbBaudRate.InsertString(-1, \"1200\");\n\tm_cbBaudRate.InsertString(-1, \"2400\");\n\tm_cbBaudRate.InsertString(-1, \"4800\");\n\tm_cbBaudRate.InsertString(-1, \"9600\");\n\tm_cbBaudRate.InsertString(-1, \"19200\");\n\tm_cbBaudRate.InsertString(-1, \"38400\");\n\tm_cbBaudRate.InsertString(-1, \"57600\");\n\tm_cbBaudRate.InsertString(-1, \"115200\");\n\tm_cbBaudRate.SetCurSel(-1);\n}\n\nvoid CDlgCfgSerial::StuToDlg()\n{\n\tint nSel = m_cbChannel.GetCurSel();\n\tif (-1 == nSel || nSel >= MAX_COMM_NUM)\n\t{\n\t\tnSel = 0;\n\t}\n\n\t// channel\n\tm_cbChannel.SetCurSel(nSel);\n\n\t// protocol\n\tif (0 == strcmp(m_stuComm.stuComms[nSel].szProtocolName, \"DH-ALARM\"))\n\t{\n\t\tm_cbProtocol.SetCurSel((int)em_CommProtocol_DHAlarm);\n\t}\n\telse\n\t{\n\t\tm_cbProtocol.SetCurSel((int)em_CommProtocol_Unknown);\n\t}\n\n\t// mode\n\n\t// bus\n\n\t// databit\n\tm_cbDataBit.SetCurSel((int)m_stuComm.stuComms[nSel].stuAttribute.byDataBit);\n\n\t// stopbit\n\tm_cbStopBit.SetCurSel((int)m_stuComm.stuComms[nSel].stuAttribute.byStopBit);\n\n\t// parity\n\tm_cbVerify.SetCurSel((int)m_stuComm.stuComms[nSel].stuAttribute.byParity);\n\n\t// baudrate\n\tm_cbBaudRate.SetCurSel((int)m_stuComm.stuComms[nSel].stuAttribute.byBaudRate);\n\n\t// address=> ignore by alarm-device\n}\n\nvoid CDlgCfgSerial::DlgToStu()\n{\n\tint nSel = m_cbChannel.GetCurSel();\n\tif (-1 == nSel || nSel >= MAX_COMM_NUM)\n\t{\n\t\treturn;\n\t}\n\n\t// protocol\n\tmemset(m_stuComm.stuComms[nSel].szProtocolName, 0, sizeof(MAX_PROTOCOL_NAME_LEN));\n\n\tif (em_CommProtocol_Unknown == m_cbProtocol.GetCurSel())\n\t{\n\t\t// nothing to be filled with\n\t}\n\telse if (em_CommProtocol_DHAlarm == m_cbProtocol.GetCurSel())\n\t{\n\t\tCString csProtocol;\n\t\tm_cbProtocol.GetWindowText(csProtocol);\n\t\tstrncpy(m_stuComm.stuComms[nSel].szProtocolName,\n\t\t\tcsProtocol,\n\t\t\t__min(MAX_PROTOCOL_NAME_LEN - 1, csProtocol.GetLength()));\n\t}\n\n\t// mode, read-only\n\n\t// bus, read-only\n\n\t// databit\n\tm_stuComm.stuComms[nSel].stuAttribute.byDataBit = (BYTE)m_cbDataBit.GetCurSel();\n\n\t// stopbit\n\tm_stuComm.stuComms[nSel].stuAttribute.byStopBit = (BYTE)m_cbStopBit.GetCurSel();\n\n\t// parity\n\tm_stuComm.stuComms[nSel].stuAttribute.byParity = (BYTE)m_cbVerify.GetCurSel();\n\n\t// baudrate\n\tm_stuComm.stuComms[nSel].stuAttribute.byBaudRate = (BYTE)m_cbBaudRate.GetCurSel();\n}\n\nBOOL CDlgCfgSerial::GetCommConfig()\n{\n\n\tchar szJsonBuf[1024] = {0};\n\tint nErr = 0, nRestart = 0;\n\tBOOL bRet = CLIENT_GetNewDevConfig(m_lLoginId, CFG_CMD_COMM,\n\t\t-1, szJsonBuf, sizeof(szJsonBuf), &nErr, SDK_API_WAIT);\n\tif (!bRet)\n\t{\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"GetDevConfig COMM error:\", DLG_CFG_SERIAL),CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\t\n\tCFG_COMMGROUP_INFO stuComPara = {0};\n\tDWORD dwRetLen = 0;\n\t\n\tbRet = CLIENT_ParseData(CFG_CMD_COMM, szJsonBuf, &stuComPara, sizeof(CFG_COMMGROUP_INFO), &dwRetLen);\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Parse data for serial para failed.\", DLG_CFG_SERIAL), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\t\n\tmemcpy(&m_stuComm, &stuComPara, sizeof(CFG_COMMGROUP_INFO));\n\treturn TRUE;\n}\n\nBOOL CDlgCfgSerial::SetCommConfig()\n{\n\tchar szJsonBuf[1024] = {0};\n\tBOOL bRet = CLIENT_PacketData(CFG_CMD_COMM, &m_stuComm, sizeof(CFG_COMMGROUP_INFO), szJsonBuf, sizeof(szJsonBuf));\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Packet data for serial failed.\", DLG_CFG_SERIAL), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\n\tint nErr = 0, nRestart = 0;\n\tbRet = CLIENT_SetNewDevConfig(m_lLoginId, CFG_CMD_COMM,\n\t\t\t-1, szJsonBuf, strlen(szJsonBuf), &nErr, &nRestart, SDK_API_WAIT);\n\n\tif (!bRet)\n\t{\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"SetupConfig Comm failed:\", DLG_CFG_SERIAL), CLIENT_GetLastError());\n\t\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\t\n\tMessageBox(ConvertString(\"Set serial para success.\", DLG_CFG_SERIAL), ConvertString(\"Prompt\"));\n\treturn TRUE;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgSerial message handlers\n\nvoid CDlgCfgSerial::OnButtonGet() \n{\n\t// TODO: Add your control notification handler code here\n\t//CDialog::OnCancel();\n\tif (GetCommConfig())\n\t{\n\t\tStuToDlg();\n\t}\n}\n\nvoid CDlgCfgSerial::OnButtonSet() \n{\n\t// TODO: Add your control notification handler code here\n\tif (0 == m_lLoginId)\n\t{\n\t\tMessageBox(ConvertString(\"we haven't login a device yet!\", DLG_CFG_SERIAL), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tSetCommConfig();\n}\n\nBOOL CDlgCfgSerial::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_SERIAL);\n\t\n\t// TODO: Add extra initialization here\n\tif (!m_lLoginId)\n\t{\n\t\tMessageBox(ConvertString(\"we haven't login a device yet!\", DLG_CFG_SERIAL), ConvertString(\"Prompt\"));\n\t\t//return TRUE;\n\t}\n\n\tInitDlg();\n\tGetCommConfig();\n\tStuToDlg();\n\tUpdateData(FALSE);\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgSerial::OnSelchangeCfgSerialCmbChn() \n{\n\t// TODO: Add your control notification handler code here\n\tStuToDlg();\n}\n\nvoid CDlgCfgSerial::OnSelendcancelSerialCmbProtocol() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n}\n\nvoid CDlgCfgSerial::OnSelendcancelComboDatabit() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n}\n\nvoid CDlgCfgSerial::OnSelendcancelComboStopbit() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n}\n\nvoid CDlgCfgSerial::OnSelendcancelComboVerify() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n}\n\nvoid CDlgCfgSerial::OnSelendcancelComboBaudrate() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n}\n","size_bytes":8572},"bin/Demo/MfcDemo/13.FaceRecognition/EditGroupDlg.cpp":{"content":"// EditGroupDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"FaceRecognition.h\"\n#include \"EditGroupDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CEditGroupDlg dialog\n\n\nCEditGroupDlg::CEditGroupDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CEditGroupDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CEditGroupDlg)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CEditGroupDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CEditGroupDlg)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CEditGroupDlg, CDialog)\n\t//{{AFX_MSG_MAP(CEditGroupDlg)\n\t\t// NOTE: the ClassWizard will add message map macros here\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CEditGroupDlg message handlers\n\nBOOL CEditGroupDlg::PreTranslateMessage(MSG* pMsg)\n{\n\tif(pMsg->message == WM_KEYDOWN &&\n\t\tpMsg->wParam == VK_RETURN)\n\t{\n\t\treturn TRUE;\n\t}\n\n\treturn CDialog::PreTranslateMessage(pMsg);\n}\n","size_bytes":1209},"bin/Demo/MfcDemo/00.DevInit/DevInit.cpp":{"content":"// DevInit.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"DevInit.h\"\n#include \"DevInitDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDevInitApp\n\nBEGIN_MESSAGE_MAP(CDevInitApp, CWinApp)\n\t//{{AFX_MSG_MAP(CDevInitApp)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t\t//    DO NOT EDIT what you see in these blocks of generated code!\n\t//}}AFX_MSG\n\tON_COMMAND(ID_HELP, CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDevInitApp construction\nTCHAR* g_GetIniPath(void)\n{\n\tstatic char pszIniPath[512] = {0};\n\tif( strlen(pszIniPath) == 0 )\n\t{\n\t\tchar szDirBuf[512] = {0};\n\t\tGetCurrentDirectory(512, szDirBuf);\n\t\tsprintf(pszIniPath, \"%s\\\\langchn.ini\", szDirBuf);\n\t}\n\treturn pszIniPath;\n}\n\nCString ConvertString(CString strText)\n{\n\tchar *val = new char[200];\n\tCString strIniPath,strRet;\n\t\n\tmemset(val,0,200);\n\tGetPrivateProfileString(\"String\",strText,\"\",\n\t\tval,200,g_GetIniPath());\n\tstrRet = val;\n\tif(strRet.GetLength()==0)\n\t{\n\t\t//If there is no corresponding string in ini file ,then set it to be default value.\n\t\tstrRet=strText;\n\t}\n\tdelete val;\n\treturn strRet;\n}\n//Set static text in dialogue box (English->current language)\nvoid g_SetWndStaticText(CWnd * pWnd)\n{\n\tCString strCaption,strText;\n\t\n\t//Set main window title\n\tpWnd->GetWindowText(strCaption);\n\tif(strCaption.GetLength()>0)\n\t{\n\t\tstrText=ConvertString(strCaption);\n\t\tpWnd->SetWindowText(strText);\n\t}\n\t\n\t//Set small window title \n\tCWnd * pChild=pWnd->GetWindow(GW_CHILD);\n\tCString strClassName;\n\twhile(pChild)\n\t{\n\t\t//////////////////////////////////////////////////////////////////////////\t\t\n\t\t//Added by Jackbin 2005-03-11\n\t\tstrClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n\t\tif(strClassName == \"CEdit\")\n\t\t{\n\t\t\t//Next small window \n\t\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t//////////////////////////////////////////////////////////////////////////\t\n\t\t\n\t\t//Set small window current language text \n\t\tpChild->GetWindowText(strCaption);\n\t\tstrText=ConvertString(strCaption);\n\t\tpChild->SetWindowText(strText);\n\t\t\n\t\t//Next small window \n\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t}\n}\nCDevInitApp::CDevInitApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The one and only CDevInitApp object\n\nCDevInitApp theApp;\n\n/////////////////////////////////////////////////////////////////////////////\n// CDevInitApp initialization\n\nBOOL CDevInitApp::InitInstance()\n{\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t//  of your final executable, you should remove from the following\n\t//  the specific initialization routines you do not need.\n\n#ifdef _AFXDLL\n\tEnable3dControls();\t\t\t// Call this when using MFC in a shared DLL\n#else\n\tEnable3dControlsStatic();\t// Call this when linking to MFC statically\n#endif\n\n\tCDevInitDlg dlg;\n\tm_pMainWnd = &dlg;\n\tint nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n","size_bytes":3642},"bin/Demo/MfcDemo/09.AccessControl/DlgCfgNetwork.cpp":{"content":"// DlgCfgNetwork.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AccessControl.h\"\n#include \"DlgCfgNetwork.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgNetwork dialog\n\n\nCDlgCfgNetwork::CDlgCfgNetwork(CWnd* pParent /*=NULL*/, LLONG lLoginID)\n\t: CDialog(CDlgCfgNetwork::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgNetwork)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\tm_lLoginID = lLoginID;\n\t//}}AFX_DATA_INIT\n\tmemset(&m_stuNetwork, 0, sizeof(m_stuNetwork));\n}\n\n\nvoid CDlgCfgNetwork::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgNetwork)\n\tDDX_Control(pDX, IDC_NETWORK_MASK, m_ctlMask);\n\tDDX_Control(pDX, IDC_NETWORK_IP, m_ctlIp);\n\tDDX_Control(pDX, IDC_NETWORK_GATEWAY, m_ctlGateway);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgNetwork, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgNetwork)\n\tON_BN_CLICKED(IDC_NETWORK_BTN_CANCEL, OnBtnCancel)\n\tON_BN_CLICKED(IDC_NETWORK_BTN_SET, OnBtnSet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgNetwork message handlers\n\nBOOL CDlgCfgNetwork::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_NETWORK);\n\t\n\t// TODO: Add extra initialization here\n\tm_ctlIp.SetAddress(0, 0, 0, 0);\n\tm_ctlMask.SetAddress(0, 0, 0, 0);\n\tm_ctlGateway.SetAddress(0, 0, 0, 0);\n\n\tGetNetworkPara();\n\tUpdateData(FALSE);\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgNetwork::OnBtnCancel() \n{\n\t// TODO: Add your control notification handler code here\n\tCDialog::OnCancel();\n}\n\nvoid CDlgCfgNetwork::OnBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n\tUpdateData(TRUE);\n\n\tif (0 == m_lLoginID)\n\t{\n\t\tMessageBox(ConvertString(\"we haven't login a device yet!\", DLG_CFG_NETWORK), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tCString csIp, csMask, csGateway;\n\tm_ctlIp.GetWindowText(csIp);\n\tm_ctlMask.GetWindowText(csMask);\n\tm_ctlGateway.GetWindowText(csGateway);\n\n//\tCFG_NETWORK_INFO stuNetworkPara = {0};\n\tCFG_NETWORK_INFO& stuNetworkPara = m_stuNetwork;\n\tstuNetworkPara.nInterfaceNum = 1;\n\tstrncpy(stuNetworkPara.stuInterfaces[0].szIP, csIp, MAX_ADDRESS_LEN-1);\n\tstrncpy(stuNetworkPara.stuInterfaces[0].szSubnetMask, csMask, MAX_ADDRESS_LEN-1);\n\tstrncpy(stuNetworkPara.stuInterfaces[0].szDefGateway, csGateway, MAX_ADDRESS_LEN-1);\n\n\tchar szJsonBuf[1024] = {0};\n\tBOOL nRet = CLIENT_PacketData(CFG_CMD_NETWORK, &stuNetworkPara, sizeof(CFG_NETWORK_INFO), szJsonBuf, sizeof(szJsonBuf));\n\tif (!nRet)\n\t{\n\t\tMessageBox(ConvertString(\"Packet network json buffer failed.\", DLG_CFG_NETWORK), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tint nErr = 0, nRestart = 0;\n\tnRet = CLIENT_SetNewDevConfig(m_lLoginID, CFG_CMD_NETWORK,\n\t\t-1, szJsonBuf, strlen(szJsonBuf), &nErr, &nRestart, SDK_API_WAIT);\n\tif (!nRet)\n\t{\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x...\", ConvertString(\"SetupConfig network failed:\", DLG_CFG_NETWORK), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn ;\n\t}\n\n \tMessageBox(ConvertString(\"send network parameters successfully.\", DLG_CFG_NETWORK), ConvertString(\"Prompt\"));\n\n\treturn;\n}\n\nvoid CDlgCfgNetwork::GetNetworkPara()\n{\n\tif (0 == m_lLoginID)\n\t{\n\t\tMessageBox(ConvertString(\"we haven't login a device yet!\", DLG_CFG_NETWORK), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\tchar szJsonBuf[1024] = {0};\n\tint nErr = 0;\n\tBOOL bRet = CLIENT_GetNewDevConfig(m_lLoginID, CFG_CMD_NETWORK,\n\t\t-1, szJsonBuf, sizeof(szJsonBuf), &nErr, SDK_API_WAIT);\n\tif (!bRet)\n\t{\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x...\", ConvertString(\"GetConfig network failed:\", DLG_CFG_NETWORK), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tCFG_NETWORK_INFO stNetworkInfo = {0};\n\tDWORD dwRetLen = 0;\n\tbRet = CLIENT_ParseData(CFG_CMD_NETWORK, szJsonBuf, &stNetworkInfo, sizeof(stNetworkInfo), &dwRetLen);\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Parse network jason failed.\", DLG_CFG_NETWORK), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tif (0 == stNetworkInfo.stuInterfaces[0].szIP[0] \n\t\t|| 0 == stNetworkInfo.stuInterfaces[0].szSubnetMask[0]\n\t\t|| 0 == stNetworkInfo.stuInterfaces[0].szDefGateway[0])\n\t{\n\t\tMessageBox(ConvertString(\"Invalidate ip parameters.\", DLG_CFG_NETWORK), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tmemcpy(&m_stuNetwork, &stNetworkInfo, sizeof(CFG_NETWORK_INFO));\n\n\tm_ctlIp.SetWindowText(stNetworkInfo.stuInterfaces[0].szIP);\n\tm_ctlMask.SetWindowText(stNetworkInfo.stuInterfaces[0].szSubnetMask);\n\tm_ctlGateway.SetWindowText(stNetworkInfo.stuInterfaces[0].szDefGateway);\n\n#if 0\n\tDWORD dwIp = ntohl(inet_addr(stNetworkInfo.stuInterfaces[0].szIP));\n\tm_ctlIp.SetAddress(dwIp);\n\n\tDWORD dwMask = ntohl(inet_addr(stNetworkInfo.stuInterfaces[0].szSubnetMask));\n\tm_ctlMask.SetAddress(dwMask);\n\n\tDWORD dwGateway = ntohl(inet_addr(stNetworkInfo.stuInterfaces[0].szDefGateway));\n\tm_ctlGateway.SetAddress(dwGateway);\n#endif\n}\n","size_bytes":5101},"bin/Demo/MfcDemo/11.Attendance/CAttendanceObserver.cpp":{"content":"#include \"stdafx.h\"\n#include \"CAttendanceObserver.h\"\n\nCAttendanceObserver::CAttendanceObserver()\n{\n\t\n}\n\nCAttendanceObserver::~CAttendanceObserver()\n{\n\t\n}\n\nint CAttendanceObserver::updateAttendanceInfo(ATTENDANCE_MSG_TYPE msgType, void *pMsgInfo, BYTE *pBuffer, DWORD dwBufSize)\n{\n\treturn 0;\n}","size_bytes":292},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgMobile.cpp":{"content":"// DlgCfgMobile.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgCfgMobile.h\"\n#include <list>\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgMobile dialog\n\n\nCDlgCfgMobile::CDlgCfgMobile(CWnd* pParent /* = NULL */, LLONG lLoginId /* = 0 */)\n\t: CDialog(CDlgCfgMobile::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgMobile)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\tm_lLoginId = lLoginId;\n\t//}}AFX_DATA_INIT\n\tmemset(&m_stuInfo, 0, sizeof(m_stuInfo));\n}\n\n\nvoid CDlgCfgMobile::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgMobile)\n\tDDX_Control(pDX, IDC_MOBILE_CHK_ENABLE, m_chkEnable);\n\tDDX_Control(pDX, IDC_MOBILE_LIST_RECEIVENUMBER, m_lsNumberList);\n\tDDX_Control(pDX, IDC_MOBILE_CMB_TYPE, m_cmbType);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgMobile, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgMobile)\n\tON_BN_CLICKED(IDC_MOBILE_BTN_ADDNUMBER, OnMobileBtnAddnumber)\n\tON_BN_CLICKED(IDC_MOBILE_BTN_DELNUMBER, OnMobileBtnDelnumber)\n\tON_BN_CLICKED(IDC_MOBILE_BTN_GET, OnMobileBtnGet)\n\tON_BN_CLICKED(IDC_MOBILE_BTN_SET, OnMobileBtnSet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// Private methods\n\nvoid CDlgCfgMobile::InitDlg(BOOL bShow /* = TRUE */)\n{\n\tm_chkEnable.SetCheck(BST_UNCHECKED);\n\n\tfor (int i = 0; i < sizeof(stuDemoMsgType) / sizeof(stuDemoMsgType[0]); i++)\n\t{\n\t\tm_cmbType.InsertString(-1, ConvertString(stuDemoMsgType[i].pszName, DLG_CFG_MOBILE));\n\t}\n\n\tSetDlgItemText(IDC_MOBILE_EDT_TITLE, m_stuInfo.stuEventMsgSending.szTitle);\n\n\tm_lsNumberList.SetExtendedStyle(m_lsNumberList.GetExtendedStyle()\n\t\t| LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);\n\tm_lsNumberList.DeleteAllItems();\n\tm_lsNumberList.InsertColumn(0, ConvertString(\"Seq\", DLG_CFG_MOBILE), LVCFMT_LEFT, 60);\n\tm_lsNumberList.InsertColumn(1, ConvertString(\"Number\", DLG_CFG_MOBILE), LVCFMT_LEFT, 160);\n}\n\nBOOL CDlgCfgMobile::SetConfigToDevice()\n{\n\tchar szJsonBuf[1024 * 10] = {0};\n\tBOOL bRet = CLIENT_PacketData(CFG_CMD_MOBILE, &m_stuInfo, sizeof(m_stuInfo), szJsonBuf, sizeof(szJsonBuf));\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(CString(\"packet Mobile error...\"), DLG_CFG_MOBILE), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t} \n\telse\n\t{\n#if 0\n\t\tWriteLog(szJsonBuf);\n#endif\t\n\t\tint nErr = 0, nRestart = 0;\n\t\tBOOL bRetSetupCfg = CLIENT_SetNewDevConfig(m_lLoginId, CFG_CMD_MOBILE,\n\t\t\t-1, szJsonBuf, strlen(szJsonBuf), &nErr, &nRestart, SDK_API_WAIT);\n\t\tif (!bRetSetupCfg)\n\t\t{\n\t\t\tCString csErr;\n\t\t\tcsErr.Format(\"%s %08x\", ConvertString(\"SetupConfig Mobile failed:\", DLG_CFG_MOBILE), CLIENT_GetLastError());\n\t\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"SetConfig Mobile ok!\"), DLG_CFG_MOBILE), ConvertString(\"Prompt\"));\n\t\t}\n\t}\n\treturn TRUE;\n}\n\nBOOL CDlgCfgMobile::GetConfigFromDevice()\n{\n\tchar szJsonBuf[1024 * 10] = {0};\n\tint nErr = 0;\n\tBOOL bRet = CLIENT_GetNewDevConfig(m_lLoginId, CFG_CMD_MOBILE,\n\t\t-1, szJsonBuf, sizeof(szJsonBuf), &nErr, SDK_API_WAIT);\n\tif (bRet)\n\t{\n\t\tCFG_MOBILE_INFO stuInfo = {0};\n\t\tDWORD dwRetLen = 0;\n\t\tbRet = CLIENT_ParseData(CFG_CMD_MOBILE, szJsonBuf, (void*)&stuInfo, sizeof(stuInfo), &dwRetLen);\n\t\tif (!bRet)\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"parse Mobile error...\"), DLG_CFG_MOBILE), ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(&m_stuInfo, &stuInfo, sizeof(CFG_MOBILE_INFO));\n\t\t}\n\t}\n\telse\n\t{\t\t\t\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"QueryConfig Mobile error:\", DLG_CFG_MOBILE), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nvoid CDlgCfgMobile::StuToDlg()\n{\n\t// enable\n\tm_chkEnable.SetCheck(m_stuInfo.stuEventMsgSending.bEnable ? BST_CHECKED : BST_UNCHECKED);\n\n\t// type\n\tm_cmbType.SetCurSel((int)m_stuInfo.stuEventMsgSending.emMsgType);\n\n\t// title\n\tSetDlgItemText(IDC_MOBILE_EDT_TITLE, m_stuInfo.stuEventMsgSending.szTitle);\n\n\t// number list\n\tm_lsNumberList.DeleteAllItems();\n\tint nCount = __min(m_stuInfo.stuEventMsgSending.dwReceiverCount, MAX_RECEIVER_NUM);\n\tfor (int i = 0; i < nCount; i++)\n\t{\n\t\tm_lsNumberList.InsertItem(i, \"\");\n\n\t\tchar szSeq[8] = {0};\n\t\t_itoa(i, szSeq, 10);\n\t\tm_lsNumberList.SetItemText(i, 0, szSeq);\n\t\tm_lsNumberList.SetItemText(i, 1, m_stuInfo.stuEventMsgSending.szReceiverNumbersList[i]);\n\t}\n}\n\nvoid CDlgCfgMobile::DlgToStu()\n{\n\t// enable\n\tm_stuInfo.stuEventMsgSending.bEnable = m_chkEnable.GetCheck() ? TRUE : FALSE;\n\t\n\t// type\n\tm_stuInfo.stuEventMsgSending.emMsgType = m_cmbType.GetCurSel() == -1 ? EM_MSG_UNKNOWN : (EM_MSG_TYPE)m_cmbType.GetCurSel();\n\n\t// title\n\tCString strTitle;\n\tGetDlgItemText(IDC_MOBILE_EDT_TITLE, strTitle);\n\tmemset(m_stuInfo.stuEventMsgSending.szTitle, 0, MAX_NAME_LEN);\n\tif (strTitle.GetLength())\n\t{\n\t\tstrncpy(m_stuInfo.stuEventMsgSending.szTitle, strTitle, __min(strTitle.GetLength(), MAX_NAME_LEN));\n\t}\n\n\t// number list\n\tint nCount = m_lsNumberList.GetItemCount();\n\tnCount = __min(nCount, MAX_RECEIVER_NUM);\n\tm_stuInfo.stuEventMsgSending.dwReceiverCount = nCount;\n\tmemset(m_stuInfo.stuEventMsgSending.szReceiverNumbersList, 0, sizeof(m_stuInfo.stuEventMsgSending.szReceiverNumbersList));\n\tfor (int i = 0; i < nCount; i++)\n\t{\n\t\tCString strNumber = m_lsNumberList.GetItemText(i, 1);\n\t\tstrncpy(m_stuInfo.stuEventMsgSending.szReceiverNumbersList[i], \n\t\t\tstrNumber, \n\t\t\tMAX_MSG_NUMBER_LEN - 1);\n\t}\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgMobile message handlers\n\nBOOL CDlgCfgMobile::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_MOBILE);\n\t\n\t// TODO: Add extra initialization here\t\n\tif (0 == m_lLoginId)\n\t{\n\t\tMessageBox(ConvertString(CString(\"We haven't login yet!\"), DLG_CFG_MOBILE), ConvertString(\"Prompt\"));\n\t\t//EndDialog(0);\n\t}\n\t\n\tInitDlg();\n\tOnMobileBtnGet();\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgMobile::OnMobileBtnAddnumber() \n{\n\t// TODO: Add your control notification handler code here\n\tCString csNumber;\n\tGetDlgItemText(IDC_MOBILE_EDT_NUMBER, csNumber);\n\tif (!csNumber.GetLength())\n\t{\n\t\treturn;\n\t}\n\t\n\tint nCount = m_lsNumberList.GetItemCount();\n\tm_lsNumberList.InsertItem(nCount, _T(\"\"));\n\t\n\tchar szSeq[10] = {0};\n\t_itoa(nCount + 1, szSeq, 10);\n\tm_lsNumberList.SetItemText(nCount, 0, szSeq);\n\tm_lsNumberList.SetItemText(nCount, 1, csNumber);\t\n}\n\nvoid CDlgCfgMobile::OnMobileBtnDelnumber() \n{\n\t// TODO: Add your control notification handler code here\n\tPOSITION pItem = m_lsNumberList.GetFirstSelectedItemPosition();\n\tif (pItem)\n\t{\n\t\tint nSel = m_lsNumberList.GetNextSelectedItem(pItem);\n\t\tCString csSelNum = m_lsNumberList.GetItemText(nSel, 1);\n\n\t\t{\n\t\t\ttypedef std::list<CString> lsItem;\n\t\t\tlsItem lsNumberItem;\n\t\t\tint nCount = m_lsNumberList.GetItemCount();\n\t\t\tfor (int i = 0; i < nCount; i++)\n\t\t\t{\n\t\t\t\tCString csItem = m_lsNumberList.GetItemText(i, 1);\n\t\t\t\tlsNumberItem.push_back(csItem);\n\t\t\t}\n\n\t\t\tlsItem::iterator it = lsNumberItem.begin();\n\t\t\twhile (it != lsNumberItem.end())\n\t\t\t{\n\t\t\t\tCString csNum = *it;\n\t\t\t\tif (csNum == csSelNum)\n\t\t\t\t{\n\t\t\t\t\tlsNumberItem.erase(it++);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tit++;\n\t\t\t}\n\n\t\t\tm_lsNumberList.DeleteAllItems();\n\t\t\tit = lsNumberItem.begin();\n\n\t\t\tfor (int j = 0; j < lsNumberItem.size(); j++)\n\t\t\t{\n\t\t\t\tCString csItem = *it++;\n\n\t\t\t\tm_lsNumberList.InsertItem(j, \"\");\n\n\t\t\t\tchar szSeq[8] = {0};\n\t\t\t\t_itoa(j + 1, szSeq, 10);\n\t\t\t\tm_lsNumberList.SetItemText(j, 0, szSeq);\n\t\t\t\tm_lsNumberList.SetItemText(j, 1, csItem);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid CDlgCfgMobile::OnMobileBtnGet() \n{\n\t// TODO: Add your control notification handler code here\n\tif (GetConfigFromDevice())\n\t{\n\t\tStuToDlg();\n\t}\n}\n\nvoid CDlgCfgMobile::OnMobileBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\tSetConfigToDevice();\n}\n","size_bytes":7974},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/ConfigAlarm.cpp":{"content":"// ConfigAlarm.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"ConfigAlarm.h\"\n#include \"NetSDKDemoDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CConfigAlarm dialog\n\n\nCConfigAlarm::CConfigAlarm(CWnd* pParent /*=NULL*/)\n\t: CDialog(CConfigAlarm::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CConfigAlarm)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_pDev = 0;\n\tmemset(&m_almCFG, 0, sizeof(DHDEV_ALARM_SCHEDULE));\n\tm_bInited = FALSE;\n}\n\n\nvoid CConfigAlarm::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CConfigAlarm)\n\tDDX_Control(pDX, IDC_TAB_ALARMBOARD, m_alarmBoard);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CConfigAlarm, CDialog)\n\t//{{AFX_MSG_MAP(CConfigAlarm)\n\tON_NOTIFY(TCN_SELCHANGE, IDC_TAB_ALARMBOARD, OnSelchangeTabAlarmboard)\n\tON_WM_SHOWWINDOW()\n\tON_BN_CLICKED(IDC_UNDO_ALL, OnUndoAll)\n\tON_BN_CLICKED(IDC_APPLY, OnApply)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CConfigAlarm message handlers\n\n\n#define PRIVATE_ALARM_UPLOAD\t\t0x00000001\n#define PRIVATE_ALARM_RECORD\t\t0x00000002\n#define PRIVATE_ALARM_PTZ\t\t0x00000004\n#define PRIVATE_ALARM_MAIL\t\t0x00000008\n#define PRIVATE_ALARM_TOUR\t\t0x00000010\n#define PRIVATE_ALARM_TIP\t\t0x00000020\n#define PRIVATE_ALARM_OUT\t\t0x00000040\n\n// #define PRIVATE_MOTION_ROW\t\t12\n// #define PRIVATE_MOTION_COL\t\t16\t\n\nvoid CConfigAlarm::OnSelchangeTabAlarmboard(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\tswitch(m_alarmBoard.GetCurSel())\n\t{\n\tcase 0: //alarm in\n\t\tm_alarmInDlg.ShowWindow(SW_SHOW);\n\t\tm_blindDlg.ShowWindow(SW_HIDE);\n\t\tm_diskDlg.ShowWindow(SW_HIDE);\n\t\tm_motionDlg.ShowWindow(SW_HIDE);\n\t\tm_vlostDlg.ShowWindow(SW_HIDE);\n\t\tbreak;\n\tcase 1: //motion\n\t\tm_motionDlg.ShowWindow(SW_SHOW);\n\t\tm_alarmInDlg.ShowWindow(SW_HIDE);\n\t\tm_blindDlg.ShowWindow(SW_HIDE);\n\t\tm_diskDlg.ShowWindow(SW_HIDE);\n\t\tm_vlostDlg.ShowWindow(SW_HIDE);\n\t\tbreak;\n\tcase 2: //video lost\n\t\tm_vlostDlg.ShowWindow(SW_SHOW);\n\t\tm_alarmInDlg.ShowWindow(SW_HIDE);\n\t\tm_blindDlg.ShowWindow(SW_HIDE);\n\t\tm_diskDlg.ShowWindow(SW_HIDE);\n\t\tm_motionDlg.ShowWindow(SW_HIDE);\n\t\tbreak;\n\tcase 3: //blind\n\t\tm_blindDlg.ShowWindow(SW_SHOW);\n\t\tm_alarmInDlg.ShowWindow(SW_HIDE);\n\t\tm_diskDlg.ShowWindow(SW_HIDE);\n\t\tm_motionDlg.ShowWindow(SW_HIDE);\n\t\tm_vlostDlg.ShowWindow(SW_HIDE);\n\t\tbreak;\n\tcase 4: //disk\n\t\tm_diskDlg.ShowWindow(SW_SHOW);\n\t\tm_alarmInDlg.ShowWindow(SW_HIDE);\n\t\tm_blindDlg.ShowWindow(SW_HIDE);\n\t\tm_motionDlg.ShowWindow(SW_HIDE);\n\t\tm_vlostDlg.ShowWindow(SW_HIDE);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t*pResult = 0;\n}\n\n\nBOOL CConfigAlarm::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\t\n\tm_alarmBoard.InsertItem(0, ConvertString(MSG_ALARMCFG_ALARMIN));\n\tm_alarmBoard.InsertItem(1, ConvertString(MSG_ALARMCFG_MOTION));\n\tm_alarmBoard.InsertItem(2, ConvertString(MSG_ALARMCFG_VIDEOLOST));\n\tm_alarmBoard.InsertItem(3, ConvertString(MSG_ALARMCFG_BLINE));\n\n\tm_alarmInDlg.SetDevice(m_pDev);\n\tm_blindDlg.SetDevice(m_pDev);\n\tm_motionDlg.SetDevice(m_pDev);\n\tm_vlostDlg.SetDevice(m_pDev);\n\n\tm_alarmInDlg.Create(IDD_CONFIG_ALARM_ALARM, &m_alarmBoard);\n\tm_blindDlg.Create(IDD_CONFIG_ALARM_BLIND, &m_alarmBoard);\n\tm_diskDlg.Create(IDD_CONFIG_ALARM_DISK, &m_alarmBoard);\n\tm_motionDlg.Create(IDD_CONFIG_ALARM_MOTION, &m_alarmBoard);\n\tm_vlostDlg.Create(IDD_CONFIG_ALARM_VLOST, &m_alarmBoard);\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CConfigAlarm::GetConfig()\n{\n\tif (!m_pDev || m_bInited)\n\t{\n\t\treturn;\n\t}\n\t\n\tDWORD retlen = 0;\n\tBOOL bRet = CLIENT_GetDevConfig(m_pDev->LoginID, DH_DEV_ALARMCFG, 0,\n\t\t\t\t\t\t\t\t&m_almCFG, sizeof(DHDEV_ALARM_SCHEDULE), &retlen, CONFIG_WAITTIME);\n\tif (!bRet || retlen != sizeof(DHDEV_ALARM_SCHEDULE))\n\t{\n\t\t((CNetSDKDemoDlg*)AfxGetMainWnd())->LastError();\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tm_bInited = TRUE;\n\t}\n\t\n\tm_alarmInDlg.SetAlarmInCFG(m_almCFG.struLocalAlmIn);\n\tm_blindDlg.SetBlindCFG(m_almCFG.struBlind);\n\tm_motionDlg.SetMotionCFG(m_almCFG.struMotion);\n\tm_vlostDlg.SetVlostCFG(m_almCFG.struVideoLost);\n\n\tm_alarmBoard.SetCurSel(0);\n\tm_alarmInDlg.ShowWindow(SW_SHOW);\n\tm_blindDlg.ShowWindow(SW_HIDE);\n\tm_diskDlg.ShowWindow(SW_HIDE);\n\tm_motionDlg.ShowWindow(SW_HIDE);\n\tm_vlostDlg.ShowWindow(SW_HIDE);\n}\n\nvoid CConfigAlarm::SetDevice(DeviceNode *pDev)\n{\n\tm_pDev = pDev;\n}\n\nvoid CConfigAlarm::OnShowWindow(BOOL bShow, UINT nStatus) \n{\n\tCDialog::OnShowWindow(bShow, nStatus);\n\n\tGetConfig();\n}\n\nvoid CConfigAlarm::OnUndoAll() \n{\n\tm_bInited = FALSE;\n\n\tm_alarmInDlg.UndoAll();\n\tm_blindDlg.UndoAll();\n\tm_motionDlg.UndoAll();\n\tm_vlostDlg.UndoAll();\n\n\tGetConfig();\n}\n\nvoid CConfigAlarm::OnApply() \n{\n\tm_alarmInDlg.GetAlarmInCFG(m_almCFG.struLocalAlmIn);\n\tm_blindDlg.GetBlindCFG(m_almCFG.struBlind);\n\tm_motionDlg.GetMotionCFG(m_almCFG.struMotion);\n\tm_vlostDlg.GetVlostCFG(m_almCFG.struVideoLost);\n\n\tBOOL bRet = CLIENT_SetDevConfig(m_pDev->LoginID, DH_DEV_ALARMCFG, 0,\n\t\t\t\t\t\t\t\t&m_almCFG, sizeof(DHDEV_ALARM_SCHEDULE), CONFIG_WAITTIME);\n\tif (!bRet)\n\t{\n\t\t((CNetSDKDemoDlg*)AfxGetMainWnd())->LastError();\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tMessageBox(ConvertString(MSG_CONFIG_SUCCESS), \"OK\");\n\t}\n}","size_bytes":5306},"bin/Demo/MfcDemo/10.AlarmDevice/DlgExtendedBypass.cpp":{"content":"// DlgExtendedBypass.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgExtendedBypass.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgExtendedBypass dialog\n\nCDlgExtendedBypass::CDlgExtendedBypass(CWnd* pParent, BOOL bNeedMode, int nWantToSetChannelCount)\n\t: CDialog(CDlgExtendedBypass::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgExtendedBypass)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_bNeedMode = bNeedMode;\n \tm_nWantToSetChannelCount = nWantToSetChannelCount;\n\tmemset(m_nExtendedChannel, 0, sizeof(m_nExtendedChannel));\n\tfor (int i = 0; i < MAX_CHANNEL_COUNT*sizeof(DWORD)*8; ++i)\n\t{\t\n\t\tm_emExtendedMode[i] = NET_BYPASS_MODE_UNKNOW;\n\t}\n\n\tm_nLastCount = 0;\n\tm_nActualCount = 0;\n}\n\n\nvoid CDlgExtendedBypass::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgExtendedBypass)\n\tDDX_Control(pDX, IDOK, m_btnOk);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgExtendedBypass, CDialog)\n\t//{{AFX_MSG_MAP(CDlgExtendedBypass)\n\tON_WM_DESTROY()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgExtendedBypass message handlers\nBOOL CDlgExtendedBypass::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_EXTENDED_BYPASS);\n\t// TODO: Add extra initialization here\n\tif (m_bNeedMode)\n\t{\n\t\tCreateWithModeDialog();\n\t\tStuToDlg();\n\t} \n\telse\n\t{\n\t\tCreateWithoutModeDialog();\n\t}\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t// EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgExtendedBypass::OnOK() \n{\n\t// TODO: Add extra validation here\n\tDlgToStu();\n\tCDialog::OnOK();\n}\n\nvoid CDlgExtendedBypass::StuToDlg()\n{\n\tint nTempChannel = 0;\n\tfor (int i = 0; i < m_nLastCount; ++i)\n\t{\n\t\tnTempChannel = m_nExtendedChannel[i];\n\t\tif (m_emExtendedMode[i] == NET_BYPASS_MODE_BYPASS)\n\t\t{\n\t\t\tcBtnExtendedMode[nTempChannel].SetCheck(BST_CHECKED);\n\t\t}\n\t}\n}\n\nvoid CDlgExtendedBypass::DlgToStu()\n{\n\tfor (int i = 0; i < MAX_CHANNEL_COUNT*sizeof(DWORD)*8; i++)\n\t{\t\t\n\t\tif (BST_CHECKED == cBtnExtendedChannel[i].GetCheck())\n\t\t{\n\t\t\tm_nExtendedChannel[m_nActualCount] = i;\n\t\t\t++m_nActualCount;\n\t\t\tif (m_nActualCount >= m_nWantToSetChannelCount)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\t\n\t}\n}\nvoid CDlgExtendedBypass::OnDestroy() \n{\n\tCDialog::OnDestroy();\n\t\n\t// TODO: Add your message handler code here\n\t\n}\n\nvoid CDlgExtendedBypass::CreateWithModeDialog()\n{\n\tint i = 0, j = 0, k = 0;\n\tfor (i = 0; i < MAX_CHANNEL_COUNT*sizeof(DWORD)*8; ++i)\n\t{\n\t\tif (i%20 == 0)\n\t\t{\n\t\t\tk = 0;\n\t\t\t++j;\n\t\t}\n\t\tchar szIndex[32] = {0};\n\t\t_itoa(i + 1, szIndex, 10);\n\t\tcBtnExtendedChannel[i].Create(szIndex, WS_CHILD|WS_VISIBLE|BS_AUTOCHECKBOX|BS_DEFPUSHBUTTON, CRect(10+50*k, 30*j+30*j, 60+50*k, 30+30*j+30*j), this, 100+i);\n\t\tcBtnExtendedMode[i].Create(\"\", WS_CHILD|WS_VISIBLE|BS_AUTOCHECKBOX|BS_DEFPUSHBUTTON, CRect(10+50*k, 30*j+30*j+30, 60+50*k, 60+30*j+30*j), this, 600+i);\n\t\t++k;\n\t}\n\tMoveWindow(0, 0, 1050, 550+30*j);\n\tCenterWindow();\n\tCRect cRectTemp;\n\tGetDlgItem(IDOK)->GetClientRect(cRectTemp);\n\tGetDlgItem(IDOK)->MoveWindow(350, 470+30*j, cRectTemp.Width(), cRectTemp.Height());\n\tGetDlgItem(IDCANCEL)->GetClientRect(cRectTemp);\n\tGetDlgItem(IDCANCEL)->MoveWindow(470, 470+30*j, cRectTemp.Width(), cRectTemp.Height());\n}\n\nvoid CDlgExtendedBypass::CreateWithoutModeDialog()\n{\n\tint i = 0, j = 0, k = 0;\n\tfor (i = 0; i < MAX_CHANNEL_COUNT*sizeof(DWORD)*8; ++i)\n\t{\n\t\tif (i%20 == 0)\n\t\t{\n\t\t\tk = 0;\n\t\t\t++j;\n\t\t}\n\t\tchar szIndex[32] = {0};\n\t\t_itoa(i + 1, szIndex, 10);\n\t\tcBtnExtendedChannel[i].Create(szIndex, WS_CHILD|WS_VISIBLE|BS_AUTOCHECKBOX|BS_DEFPUSHBUTTON, CRect(10+50*k, 30*j, 60+50*k, 30+30*j), this, 100+i);\n\t\t++k;\n\t}\n\tMoveWindow(0, 0, 1050, 130+30*j);\n\tCenterWindow();\n\tCRect cRectTemp;\n\tGetDlgItem(IDOK)->GetClientRect(cRectTemp);\n\tGetDlgItem(IDOK)->MoveWindow(350, 50+30*j, cRectTemp.Width(), cRectTemp.Height());\n\tGetDlgItem(IDCANCEL)->GetClientRect(cRectTemp);\n\tGetDlgItem(IDCANCEL)->MoveWindow(470, 50+30*j, cRectTemp.Width(), cRectTemp.Height());\n}\n","size_bytes":4158},"bin/DemoSrc/playsdkdemo/IState.cpp":{"content":"// IState.cpp: implementation of the IState class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"PlayDemo.h\"\n#include \"IState.h\"\n\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\n//////////////////////////////////////////////////////////////////////\n// Construction/Destruction\n//////////////////////////////////////////////////////////////////////\n\n","size_bytes":455},"bin/Demo/MfcDemo/10.AlarmDevice/DHPtzMenu.cpp":{"content":"// DHPtzMenu.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DHPtzMenu.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDHPtzMenu dialog\n\n\nCDHPtzMenu::CDHPtzMenu(CWnd* pParent /*=NULL*/)\n\t: CDialog(CDHPtzMenu::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDHPtzMenu)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_Channel=-1;\n\tm_DeviceID=0;\n}\n\n\nvoid CDHPtzMenu::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDHPtzMenu)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDHPtzMenu, CDialog)\n\t//{{AFX_MSG_MAP(CDHPtzMenu)\n\tON_BN_CLICKED(IDC_OPR_UP, OnOprUp)\n\tON_BN_CLICKED(IDC_OPR_DOWN, OnOprDown)\n\tON_BN_CLICKED(IDC_OPR_LEFT, OnOprLeft)\n\tON_BN_CLICKED(IDC_OPR_RIGHT, OnOprRight)\n\tON_BN_CLICKED(IDC_OPR_OPENMENU, OnOprOpenmenu)\n\tON_BN_CLICKED(IDC_OPR_CLOSEMENU, OnOprClosemenu)\n\tON_BN_CLICKED(IDC_OPR_OK, OnOprOk)\n\tON_BN_CLICKED(IDC_OPR_CANCEL, OnOprCancel)\n\tON_WM_CANCELMODE()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDHPtzMenu message handlers\n\nvoid CDHPtzMenu::SetPtzParam(LLONG iHandle, int iChannel)\n{\n\tm_DeviceID = iHandle;\n\tm_Channel = iChannel;\n}\n\nvoid CDHPtzMenu::PtzMemuControl(DWORD dwCommand)\n{\n\tif(0 != m_DeviceID)\n\t{\n\t\tBOOL bRet = CLIENT_DHPTZControl(m_DeviceID, m_Channel,dwCommand ,0,0,0,FALSE);\n\t\tif(!bRet)\n\t\t{\t\n\t\t\tMessageBox(ConvertString(\"operate PTZ menu \"), ConvertString(\"Prompt\"));\n\t\t}\n\t}\n}\n\n//Move up \nvoid CDHPtzMenu::OnOprUp() \n{\n\t// TODO: Add your control notification handler code here\n\tPtzMemuControl(DH_EXTPTZ_MENUUP);\n}\n\n//Move down \nvoid CDHPtzMenu::OnOprDown() \n{\n\t// TODO: Add your control notification handler code here\n\tPtzMemuControl(DH_EXTPTZ_MENUDOWN);\n}\n\n//Move left \nvoid CDHPtzMenu::OnOprLeft() \n{\n\t// TODO: Add your control notification handler code here\n\tPtzMemuControl(DH_EXTPTZ_MENULEFT);\n}\n\n//Move right \nvoid CDHPtzMenu::OnOprRight() \n{\n\t// TODO: Add your control notification handler code here\n\tPtzMemuControl(DH_EXTPTZ_MENURIGHT);\n}\n\n//Open menu \nvoid CDHPtzMenu::OnOprOpenmenu() \n{\n\t// TODO: Add your control notification handler code here\n\tPtzMemuControl(DH_EXTPTZ_OPENMENU);\n}\n\n//Close menu \nvoid CDHPtzMenu::OnOprClosemenu() \n{\n\t// TODO: Add your control notification handler code here\n\tPtzMemuControl(DH_EXTPTZ_CLOSEMENU);\n}\n\n//Confirm \nvoid CDHPtzMenu::OnOprOk() \n{\n\t// TODO: Add your control notification handler code here\n\tPtzMemuControl(DH_EXTPTZ_MENUOK);\n}\n\n//Cancel \nvoid CDHPtzMenu::OnOprCancel() \n{\n\t// TODO: Add your control notification handler code here\n\tPtzMemuControl(DH_EXTPTZ_MENUCANCEL);\n}\n\nBOOL CDHPtzMenu::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\t// TODO: Add extra initialization here\n\tg_SetWndStaticText(this);\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDHPtzMenu::OnCancelMode() \n{\n\tCDialog::OnCancelMode();\n\t\n\t// TODO: Add your message handler code here\n\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":3546},"bin/Demo/MfcDemo/03.Alarm/NewAlarm.cpp":{"content":"// NewAlarm.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"ClientDemo1.h\"\n#include \"NewAlarm.h\"\n#include \"resource.h\"\n#include <math.h>\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CNewAlarm dialog\nvoid CNewAlarm::SetAlarmInfo(BYTE *dwAlarm,CDlgChn* dlgAlarm, int nAlarmCount)\n{\n\tdlgAlarm->SetChnState(dwAlarm, nAlarmCount);\n}\n\nvoid CNewAlarm::SetSoundAlarmInfo(DH_NEW_SOUND_ALARM_STATE &stuSoundAlarm,DWORD\tdwID)\n{\n\tchar szBuf[2048] ={0};\n\tint nCount =stuSoundAlarm.channelcount;\n\tfor(int i=0;i<nCount;i++)\n\t{\n\t\tchar szTempBuf[256];\n\t\tmemset(szTempBuf,0,sizeof(char)*256);\n\t\tsprintf(szTempBuf\n\t\t\t,\"channel:%d type:%d volume:%d \\n\"\n\t\t\t,stuSoundAlarm.SoundAlarmInfo[i].channel\n\t\t\t,stuSoundAlarm.SoundAlarmInfo[i].alarmType\n\t\t\t,stuSoundAlarm.SoundAlarmInfo[i].volume);\n\t\tstrcat(szBuf,szTempBuf);\n\t}\n\tSetDlgItemText(dwID,szBuf);\n}\nvoid CNewAlarm::SetCheckBox(int nChannelCount, int nInputAlarmCount)\n{\n\t\t\n}\n\nvoid CNewAlarm::SetAlarmDecoderAlarm(ALARM_DECODER_ALARM & stuAlarmDecoderAlarm)\n{\n\tif(stuAlarmDecoderAlarm.nAlarmDecoderNum <= 0)\n\t{\n\t\treturn ;\n\t}\n\tUINT uID[8];//7:Now it supports max 8 alarm decoders.\n\tuID[0] = IDC_ARRAY_DECODER00;\n\tuID[1] = IDC_ARRAY_DECODER10;\n\tuID[2] = IDC_ARRAY_DECODER20;\n\tuID[3] = IDC_ARRAY_DECODER30;\n\tuID[4] = IDC_ARRAY_DECODER40;\n\tuID[5] = IDC_ARRAY_DECODER50;\n\tuID[6] = IDC_ARRAY_DECODER60;\n\tuID[7] = IDC_ARRAY_DECODER70;\n\t\n\t//Clear all CheckBox.\n\tfor(int iClear = 0; iClear < 8; iClear++)\n\t{\n\t\tfor(int jCheck = 0; jCheck < 8; jCheck++)\n\t\t{\n\t\t\t((CButton *)GetDlgItem(uID[iClear] + jCheck))->SetCheck(0);\n\t\t}\n\t}\n\n\tWORD wAlarmData = 0;//To get alarm data \n\tfor(int i = 0; i < stuAlarmDecoderAlarm.nAlarmDecoderNum; i++)\n\t{\n\t\twAlarmData = (unsigned short)stuAlarmDecoderAlarm.stuAlarmDecoder[i].dwAlarmDecoder;\n\t\tfor(int j = 0; j < 8; j++)//8:Bit means the 8 input ports of alarm decoder \n\t\t{\n\t\t\t((CButton *)GetDlgItem(uID[i] + j))->SetCheck(wAlarmData & 0x0001);//Get the alarm information from the lowest bit \n\t\t\twAlarmData >>= 0x0001;\n\t\t}\n\t}\n}\n\nvoid CNewAlarm::SetAlarmAlarmArmDisarmState(ALARM_ARM_DISARM_STATE_INFO & stuAlarmArmDisarmstate)\n{\n\t((CButton *)GetDlgItem(IDC_CHECK1))->SetCheck(stuAlarmArmDisarmstate.bState);\n}\nCNewAlarm::CNewAlarm(CWnd* pParent /*=NULL*/)\n\t: CDialog(CNewAlarm::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CNewAlarm)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CNewAlarm::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CNewAlarm)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CNewAlarm, CDialog)\n\t//{{AFX_MSG_MAP(CNewAlarm)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CNewAlarm message handlers\n\nBOOL CNewAlarm::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\t// TODO: Add extra initialization here\n\tg_SetWndStaticText(this);\n\n\tm_dlgDiskError.Create(IDD_DIALOG_CHN, this);\n\tm_dlgDiskFull.Create(IDD_DIALOG_CHN, this);\n\tm_dlgDynamic.Create(IDD_DIALOG_CHN, this);\n\tm_dlgShelter.Create(IDD_DIALOG_CHN, this);\n\tm_dlgVideoLost.Create(IDD_DIALOG_CHN, this);\n\tm_dlgOutput.Create(IDD_DIALOG_CHN, this);\n\n\tm_dlgDiskError.Attach(IDC_STATIC_DISKERROR, this);\n\tm_dlgDiskFull.Attach(IDC_STATIC_DISKFULL, this);\n\tm_dlgDynamic.Attach(IDC_STATIC_DYNAMIC, this);\n\tm_dlgShelter.Attach(IDC_STATIC_SHELTER, this);\n\tm_dlgVideoLost.Attach(IDC_STATIC_VIDEOLOST, this);\n\tm_dlgOutput.Attach(IDC_STATIC_OUTPUT, this);\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CNewAlarm::CleanAllInfo()\n{\n\tBYTE alarmInfo[32] = {0};\n\tm_dlgDiskError.SetChnState(alarmInfo, 32);\n\tm_dlgDiskFull.SetChnState(alarmInfo, 32);\n\tm_dlgDynamic.SetChnState(alarmInfo, 32);\n\tm_dlgShelter.SetChnState(alarmInfo, 32);\n\tm_dlgVideoLost.SetChnState(alarmInfo, 32);\n\tm_dlgOutput.SetChnState(alarmInfo, 32);\n\n\tCleanColum(IDC_ARRAY_DECODER00, 8);\n\tCleanColum(IDC_ARRAY_DECODER10, 8);\n\tCleanColum(IDC_ARRAY_DECODER20, 8);\n\tCleanColum(IDC_ARRAY_DECODER30, 8);\n\tCleanColum(IDC_ARRAY_DECODER40, 8);\n\tCleanColum(IDC_ARRAY_DECODER50, 8);\n\tCleanColum(IDC_ARRAY_DECODER60, 8);\n\tCleanColum(IDC_ARRAY_DECODER70, 8);\n} \n\nvoid CNewAlarm::CleanColum(UINT uID, int nLen) \n{\n\tfor(int i = 0; i < nLen; i++)\n\t{\n\t//\t((CButton*)GetDlgItem(uID + i))->SetCheck(FALSE);\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":4603},"bin/Demo/MfcDemo/10.AlarmDevice/PlayWnd.cpp":{"content":"#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"PlayWnd.h\"\n#include \"PtzScreen.h\"\n#include \"AlarmDeviceDlg.h\"\n\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CPlayWnd dialog\n\n\nCPlayWnd::CPlayWnd():m_nWndID(0), m_FlagRect(FALSE),bIsPlaying(false)\n{\t\n\t//{{AFX_DATA_INIT(CPlayWnd)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\nBEGIN_MESSAGE_MAP(CPlayWnd, CWnd)\n\t//{{AFX_MSG_MAP(CPlayWnd)\n\tON_WM_ERASEBKGND()\n\tON_WM_CONTEXTMENU()\n\tON_WM_LBUTTONDOWN()\n\tON_WM_MBUTTONUP()\n\tON_WM_MOUSEMOVE()\n\tON_WM_ACTIVATE()\n\tON_WM_CREATE()\n\tON_WM_TIMER()\n//\tON_WM_ACTIVATEAPP()\n\t//}}AFX_MSG_MAP\n\tON_COMMAND_RANGE(VIDEO_MENU_BASE, VIDEO_MENU_END, OnVideoMenu)\n\tON_MESSAGE(VIDEO_REPAINT, OnRepaintWnd)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CPlayWnd message handlers\nBOOL CPlayWnd::OnEraseBkgnd(CDC* pDC) \n{\n\t// TODO: Add your message handler code here and/or call default\n\tCRect rt;\n\tGetClientRect(&rt);\n\tCBrush br;\n\tbr.CreateSolidBrush(VIDEO_BACK_COLOR);\n\tpDC->FillRect(&rt,&br);\n\n\treturn TRUE;\t\n}\n\nLRESULT CPlayWnd::DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam) \n{\n\t// TODO: Add your specialized code here and/or call the base class\n\tCPtzScreen *pContainer = (CPtzScreen *)GetParent();\t\n\tif(pContainer)\n\t{\n\t\tswitch(message)\n\t\t{\t\n\t\tcase WM_LBUTTONUP:\n\t\t\t{\t\t\t\t\n\t\t\t\tpointEnd.x = LOWORD(lParam);\n\t\t\t\tpointEnd.y = HIWORD(lParam);\n\t\t\t\tif(m_FlagRect == TRUE)\n\t\t\t\t{\n\t\t\t\t\tm_FlagRect =FALSE;\n\t\t\t\t\tKillTimer(2);\n\t\t\t\t\tRECT rt;\n\t\t\t\t\tGetClientRect(&rt);\n\t\t\t\t\tpContainer->m_pRectEventFunc(rt,pointStart,pointEnd,pContainer->m_dwRectEvent);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WM_MOUSEMOVE:\n\t\t\t{\t\t\t\t\n\t\t\t\tRECT rt;\n\t\t\t\tGetClientRect(&rt);\n\t\t\t\tlong x = LOWORD(lParam);\n\t\t\t\tlong y = HIWORD(lParam);\n\t\t\t\tx = x>rt.right?rt.right:x;\n\t\t\t\tx = x<rt.left?rt.left:x;\n\t\t\t\ty = y>rt.bottom?rt.bottom:y;\n\t\t\t\ty = y<rt.top?rt.top:y;\n\t\t\t\tpointEnd.x = x;\n\t\t\t\tpointEnd.y = y;\t\t\t\t\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WM_LBUTTONDOWN:\n\t\t\t{\t\n                pContainer->SetActivePage(this);    \n                if (pContainer->m_pMessageProc)      \n                {\n                    pContainer->m_pMessageProc(m_nWndID, WM_RBUTTONDOWN, pContainer->m_dwMessageUser);\n                }\t\n                if (bIsPlaying == false)\n                {\n                    break;\n                }\n                pointStart.x = LOWORD(lParam);\n                pointStart.y = HIWORD(lParam);\n                m_FlagRect =TRUE;\n                SetTimer(2,16,NULL);\n                \t\n                break;\n            }\n\t\tcase WM_LBUTTONDBLCLK:\n\t\t\t{\n\t\t\t\tBOOL bMulti = pContainer->GetMultiScreen();\n\t\t\t\tpContainer->SetMultiScreen(!bMulti);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn CWnd::DefWindowProc(message, wParam, lParam);\n}\n\nvoid CPlayWnd::OnContextMenu(CWnd* pWnd, CPoint point) \n{\n\t// TODO: Add your message handler code here\n\tCPtzScreen *pContainer = (CPtzScreen *)GetParent();\n\tpContainer->SetActivePage(this);\n\n// \tCClientDemoDlg *pMainWnd = (CClientDemoDlg *)(AfxGetApp()->GetMainWnd());\n// \tCDialogTransmit * pTransWnd = (CDialogTransmit *)pMainWnd->m_pTabTransmit;\n\n\tCMenu menu;\n\tmenu.CreatePopupMenu();\n\tmenu.AppendMenu(MF_STRING | pContainer->GetFullScreen()    ? MF_CHECKED : MF_UNCHECKED, VIDEO_MENU_FULLSCREEN, ConvertString(NAME_MENU_FULLSCREEN));\n\tmenu.AppendMenu(MF_STRING | pContainer->GetMultiScreen()    ? MF_CHECKED : MF_UNCHECKED, \tVIDEO_MENU_MULTISCREEN, ConvertString(NAME_MENU_MULTISCREEN));\n\tmenu.AppendMenu(MF_STRING | pContainer->GetAutoAdjustPos() ? MF_CHECKED : MF_UNCHECKED, VIDEO_MENU_AUTOADJUST, ConvertString(NAME_MENU_AUTOADJUST));\n\tmenu.AppendMenu(MF_STRING | pContainer->m_pGetParams(m_nWndID, 0, pContainer->m_dwGetParams) ? MF_CHECKED : MF_UNCHECKED, VIDEO_MENU_EXITDECODE, ConvertString(NAME_MENU_EXITDECODE));\n\tmenu.AppendMenu(MF_STRING | pContainer->m_pGetParams(m_nWndID, 1, pContainer->m_dwGetParams) ? MF_CHECKED : MF_UNCHECKED, VIDEO_MENU_EXITCYCLE, ConvertString(NAME_MENU_EXITCYCLE));\n\n\tTrackPopupMenu( \n\t\tmenu.m_hMenu, \n\t\tTPM_LEFTALIGN, \n\t\tpoint.x, \n\t\tpoint.y,\n\t\t0,\n\t\tm_hWnd,\n\t\tNULL);\n}\n\nvoid CPlayWnd::OnVideoMenu(UINT nID)\n{\n\tCPtzScreen *pContainer = (CPtzScreen *)GetParent();\n// \tCClientDemoDlg *pMainWnd = (CClientDemoDlg *)(AfxGetApp()->GetMainWnd());\n// \tCDialogTransmit * pTransWnd = (CDialogTransmit *)pMainWnd->m_pTabTransmit;\n\n\tswitch(nID)\n\t{\n\tcase VIDEO_MENU_FULLSCREEN:\n\t\tpContainer->SetFullScreen(!pContainer->GetFullScreen());\n\t\tbreak;\n\tcase VIDEO_MENU_MULTISCREEN:\n\t\tpContainer->SetMultiScreen(!pContainer->GetMultiScreen());\n\t\tbreak;\n\tcase VIDEO_MENU_AUTOADJUST:\n\t\tpContainer->SetAutoAdjustPos(!pContainer->GetAutoAdjustPos());\n\t\tbreak;\n\tcase VIDEO_MENU_PRINTSCREEN:\n\t\tbreak;\n\tcase VIDEO_MENU_RECORDVIDEO:\n\t\tbreak;\n\tcase VIDEO_MENU_EXITDECODE:\n\t\tpContainer->m_pSetParams(m_nWndID, 0, pContainer->m_dwSetParams);\n\t\tbreak;\n\tcase VIDEO_MENU_EXITCYCLE:\n\t\tpContainer->m_pSetParams(m_nWndID, 1, pContainer->m_dwSetParams);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nLRESULT CPlayWnd::OnRepaintWnd(WPARAM wParam, LPARAM lParam)\n{\n\tInvalidate();\n\t\n\treturn 0;\n}\n\nBOOL CPlayWnd::DestroyWindow() \n{\n\treturn CWnd::DestroyWindow();\n}\n\nvoid CPlayWnd::OnLButtonDown(UINT nFlags, CPoint point) \n{\n\t// TODO: Add your message handler code here and/or call default\n\tCWnd::OnLButtonDown(nFlags, point);\n}\n\nvoid CPlayWnd::OnMButtonUp(UINT nFlags, CPoint point) \n{\n\t// TODO: Add your message handler code here and/or call default\n\tCWnd::OnMButtonUp(nFlags, point);\n}\n\nvoid CPlayWnd::OnMouseMove(UINT nFlags, CPoint point) \n{\n\t// TODO: Add your message handler code here and/or call default\n\tCWnd::OnMouseMove(nFlags, point);\n}\n\nvoid CPlayWnd::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized) \n{\n\tCWnd::OnActivate(nState, pWndOther, bMinimized);\n\t\n\t// TODO: Add your message handler code here\n\t\n}\n\n#ifdef WIN64\nvoid CPlayWnd::OnTimer(UINT_PTR nIDEvent)\n#elif defined(_WIN32)\nvoid CPlayWnd::OnTimer(UINT nIDEvent) \n#endif\n{\n    if (bIsPlaying == false)\n    {\n        return;\n    }\n\t// TODO: Add your message handler code here and/or call default\n\tif(nIDEvent ==2)\n\t{\n\t\tif(m_FlagRect == TRUE)\n\t\t{\n\t\t\tCDC *pdc = GetDC();\n\t\t\tRECT  rt;\n\t\t\trt.left =  pointStart.x;\n\t\t\trt.top =   pointStart.y;\t\t\n\t\t\trt.right = \tpointEnd.x;\n\t\t\trt.bottom = pointEnd.y;\n\t\t\tpdc->Draw3dRect(&rt,RGB(255,0,0),RGB(255,0,0));\n\t\t\tReleaseDC(pdc);\n\t\t}\n\t}\n\tCWnd::OnTimer(nIDEvent);\n}\n\nvoid CPlayWnd::OnActivateApp(BOOL bActive, HTASK hTask) \n{\n//\tCWnd::OnActivateApp(bActive, hTask);\n\t\n\t// TODO: Add your message handler code here\n\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":6973},"bin/Demo/MfcDemo/22.ThermalCamera/RuleDlg.cpp":{"content":"// RuleDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"ThermalCamera.h\"\n#include \"RuleDlg.h\"\n#include \"GlobalDlg.h\"\n#include \"ThermalCameraDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CRuleDlg dialog\n\n\nCRuleDlg::CRuleDlg(CWnd* pParent /*=NULL*/,LLONG lLoginId, int nChannel)\n\t: CDialog(CRuleDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CRuleDlg)\n\tm_nRuleAmount = 0;\n\tm_nPresetNum = 0;\n\tm_nRule = 0;\n\tm_szCustomName = _T(\"\");\n\tm_nCooddinatecount = 0;\n\tm_nX = 0;\n\tm_nY = 0;\n\tm_nPeriod = 0;\n\tm_nAlarmid = 0;\n\tm_fHysteresis = 0.0f;\n\tm_fThreshold = 0.0f;\n\tm_nDrationTime = 0;\n\tm_fObjectEmissivity = 0.0f;\n\tm_nObjectDistance = 0;\n\tm_nRefalectedTemp = 0;\n\tm_nAlarmAmount = 0;\n\t//}}AFX_DATA_INIT\n    m_iLoginID = lLoginId;\n    m_nChannel = nChannel;\n}\n\n\nvoid CRuleDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CRuleDlg)\n\tDDX_Control(pDX, IDC_COMBO_ALARMID, m_Combo_AlarmID);\n\tDDX_Control(pDX, IDC_COMBO_LOCALCONFIG, m_Combo_LocalConfig);\n\tDDX_Control(pDX, IDC_COMBO_RULEID, m_Combo_Ruleid);\n\tDDX_Control(pDX, IDC_COMBO_ALARMENABLE, m_Combo_AlarmEnable);\n\tDDX_Control(pDX, IDC_COMBO_CONDITION, m_Combo_Condition);\n\tDDX_Control(pDX, IDC_COMBO_RESULTTYPE, m_Combo_ResultType);\n\tDDX_Control(pDX, IDC_COMBO_POINTNUM, m_Combo_PointNum);\n\tDDX_Control(pDX, IDC_COMBO_MODETYPE, m_Combo_ModeType);\n\tDDX_Control(pDX, IDC_COMBO_ENABLE, m_ComboEnable);\n\tDDX_Text(pDX, IDC_EDIT_RULEAMOUNT, m_nRuleAmount);\n\tDDX_Text(pDX, IDC_EDIT_PRESETNUM, m_nPresetNum);\n\tDDX_Text(pDX, IDC_EDIT_RULENUM, m_nRule);\n\tDDX_Text(pDX, IDC_EDIT_CUSTOMNAME, m_szCustomName);\n\tDDX_Text(pDX, IDC_EDIT_COORDINATECOUNT, m_nCooddinatecount);\n\tDDX_Text(pDX, IDC_EDIT_X, m_nX);\n\tDDX_Text(pDX, IDC_EDIT_Y, m_nY);\n\tDDX_Text(pDX, IDC_EDIT_PERIOD, m_nPeriod);\n\tDDX_Text(pDX, IDC_EDIT_ALARMID, m_nAlarmid);\n\tDDX_Text(pDX, IDC_EDIT_HYSTERESIS, m_fHysteresis);\n\tDDX_Text(pDX, IDC_EDIT_THRESHOLD, m_fThreshold);\n\tDDX_Text(pDX, IDC_EDIT_DURATION, m_nDrationTime);\n\tDDX_Text(pDX, IDC_EDIT_COEFFICIENT, m_fObjectEmissivity);\n\tDDX_Text(pDX, IDC_EDIT_DISTANCE, m_nObjectDistance);\n\tDDX_Text(pDX, IDC_EDIT_REFALECTED, m_nRefalectedTemp);\n\tDDX_Text(pDX, IDC_EDIT_ALARMAMOUNT, m_nAlarmAmount);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CRuleDlg, CDialog)\n\t//{{AFX_MSG_MAP(CRuleDlg)\n\tON_BN_CLICKED(IDC_BTN_GET, OnBtnGet)\n\tON_BN_CLICKED(IDC_BTN_SET, OnBtnSet)\n\tON_CBN_SELCHANGE(IDC_COMBO_RULEID, OnSelchangeComboRuleid)\n\tON_CBN_SELCHANGE(IDC_COMBO_POINTNUM, OnSelchangeComboPointnum)\n\tON_CBN_SELCHANGE(IDC_COMBO_ALARMID, OnSelchangeComboAlarmid)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CRuleDlg message handlers\n\nBOOL CRuleDlg::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n    GetRuleConfig(0,0,0);\n    UpdateData(FALSE);\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nBOOL CRuleDlg::GetRuleConfig(int RuleID,int pointID,int AlarmID)\n{\t\n    int nBufferLen = 40*512;\n    CFG_RADIOMETRY_RULE_INFO *stuRuleOutInfo = new CFG_RADIOMETRY_RULE_INFO;\n\tif (NULL == stuRuleOutInfo)\n\t{\n\t\treturn FALSE;\n\t}\n\n    memset(stuRuleOutInfo,0,sizeof(CFG_RADIOMETRY_RULE_INFO));\n    char szJsonBuf[40*512] = {0};    \n    int nerror = 0;\n    BOOL bRet = FALSE;\n\tbRet = CLIENT_GetNewDevConfig(m_iLoginID,CFG_CMD_THERMOMETRY_RULE,m_nChannel,szJsonBuf,nBufferLen,&nerror,3000);\n    if (0 != bRet)\n    {\n        DWORD dwRetLen = 0;\n        bRet = CLIENT_ParseData(CFG_CMD_THERMOMETRY_RULE,szJsonBuf,(char*)stuRuleOutInfo,sizeof(CFG_RADIOMETRY_RULE_INFO),&dwRetLen);\n        if (!bRet)\n        {\n\t\t\tbRet = FALSE;\n            MessageBox(ConvertString(\"getconfig error\"), ConvertString(\"Prompt\"));\n\t\t\tgoto e_clearup;            \n        }\n        else\n        {\n            if (RuleID>stuRuleOutInfo->nCount)\n            {\n\t\t\t\tbRet = FALSE;\n\t\t\t\tgoto e_clearup;                \n            }\n            else\n            {\n                int index = 0;\n                CString str;\n                m_nRuleAmount = stuRuleOutInfo->nCount;\n                m_Combo_Ruleid.ResetContent();\n\t\t\t\tint i = 0;\n                for (i = 0;i<m_nRuleAmount;++i)\n                {\n                    str.Format(\"%d\",i);\n                    index = m_Combo_Ruleid.AddString(str);\n                    m_Combo_Ruleid.SetItemData(index,i);\n                }\n                m_Combo_Ruleid.SetCurSel(0);\n                m_ComboEnable.SetCurSel(stuRuleOutInfo->stRule[RuleID].bEnable);\n                m_nPresetNum = stuRuleOutInfo->stRule[RuleID].nPresetId;\n                m_nRule = stuRuleOutInfo->stRule[RuleID].nRuleId;\n                m_szCustomName = stuRuleOutInfo->stRule[RuleID].szName;\n                m_Combo_ModeType.SetCurSel(stuRuleOutInfo->stRule[RuleID].nMeterType);\n                m_nPeriod = stuRuleOutInfo->stRule[RuleID].nSamplePeriod;\n                m_nCooddinatecount = stuRuleOutInfo->stRule[RuleID].nCoordinateCnt;\n                m_Combo_LocalConfig.SetCurSel(stuRuleOutInfo->stRule[RuleID].stLocalParameters.bEnable);\n                m_fObjectEmissivity = stuRuleOutInfo->stRule[RuleID].stLocalParameters.fObjectEmissivity;\n                m_nObjectDistance = stuRuleOutInfo->stRule[RuleID].stLocalParameters.nObjectDistance;\n                m_nRefalectedTemp = stuRuleOutInfo->stRule[RuleID].stLocalParameters.nRefalectedTemp;\n                m_Combo_PointNum.ResetContent();\n                for(i = 0;i<m_nCooddinatecount;++i)\n                {\n                    index = 0;\n                    str.Format(\"%d\",i);\n                    index = m_Combo_PointNum.AddString(str);\n                    m_Combo_PointNum.SetItemData(index,i);\n                }\n                m_Combo_PointNum.SetCurSel(0);\n                m_nX = stuRuleOutInfo->stRule[RuleID].stCoordinates[pointID].nX;\n                m_nY = stuRuleOutInfo->stRule[RuleID].stCoordinates[pointID].nY;\n                m_nAlarmAmount = stuRuleOutInfo->stRule[RuleID].nAlarmSettingCnt;\n                m_Combo_AlarmID.ResetContent();\n                for(i = 0;i<m_nAlarmAmount;++i)\n                {\n                    index = 0;\n                    str.Format(\"%d\",i);\n                    index = m_Combo_AlarmID.AddString(str);\n                    m_Combo_AlarmID.SetItemData(index,i);\n                }\n                m_Combo_AlarmID.SetCurSel(0);\n                m_nAlarmid = stuRuleOutInfo->stRule[RuleID].stAlarmSetting[AlarmID].nId;  \n                m_Combo_AlarmEnable.SetCurSel(stuRuleOutInfo->stRule[RuleID].stAlarmSetting[AlarmID].bEnable);\n                m_Combo_ResultType.SetCurSel(stuRuleOutInfo->stRule[RuleID].stAlarmSetting[AlarmID].nResultType);\n                m_Combo_Condition.SetCurSel(stuRuleOutInfo->stRule[RuleID].stAlarmSetting[AlarmID].nAlarmCondition);\n                m_fThreshold = stuRuleOutInfo->stRule[RuleID].stAlarmSetting[AlarmID].fThreshold;\n                m_fHysteresis = stuRuleOutInfo->stRule[RuleID].stAlarmSetting[AlarmID].fHysteresis;\n                m_nDrationTime = stuRuleOutInfo->stRule[RuleID].stAlarmSetting[AlarmID].nDuration;\n\n\t\t\t\tbRet = TRUE;\n            }\n        }\n    } \n    else\n    {\n        MessageBox(ConvertString(\"getconfig error\"), ConvertString(\"Prompt\"));\n\t\tbRet = FALSE;\n\t\tgoto e_clearup;      \n    }\n\ne_clearup:\n    if (stuRuleOutInfo != NULL)\n    {\n        delete stuRuleOutInfo;\n        stuRuleOutInfo = NULL;\n    }\n    return bRet;\n}\n\nBOOL CRuleDlg::SetRuleConfig()\n{\n    UpdateData();\n    CFG_RADIOMETRY_RULE_INFO *stuRuleOutInfo = new CFG_RADIOMETRY_RULE_INFO;\n\tif(NULL == stuRuleOutInfo)\n\t{\n\t\treturn FALSE;\n\t}\n\n    memset(stuRuleOutInfo,0,sizeof(*stuRuleOutInfo));\n    stuRuleOutInfo->nCount = m_nRuleAmount;\n    int i = m_Combo_Ruleid.GetCurSel();\n    int j = m_Combo_PointNum.GetCurSel();\n    int l = m_Combo_AlarmID.GetCurSel();\n    stuRuleOutInfo->stRule[i].bEnable = m_ComboEnable.GetCurSel();\n    stuRuleOutInfo->stRule[i].nPresetId = m_nPresetNum;\n    stuRuleOutInfo->stRule[i].nRuleId = m_nRule;\n    strncpy(stuRuleOutInfo->stRule[i].szName,(LPCTSTR)m_szCustomName,sizeof(stuRuleOutInfo->stRule[i].szName) - 1);\n    stuRuleOutInfo->stRule[i].nMeterType = m_Combo_ModeType.GetCurSel();\n    stuRuleOutInfo->stRule[i].nSamplePeriod = m_nPeriod;\n    stuRuleOutInfo->stRule[i].nCoordinateCnt = m_nCooddinatecount;\n    stuRuleOutInfo->stRule[i].stLocalParameters.bEnable = m_Combo_LocalConfig.GetCurSel();\n    stuRuleOutInfo->stRule[i].stLocalParameters.fObjectEmissivity = m_fObjectEmissivity;\n    stuRuleOutInfo->stRule[i].stLocalParameters.nObjectDistance = m_nObjectDistance;\n    stuRuleOutInfo->stRule[i].stLocalParameters.nRefalectedTemp =  m_nRefalectedTemp;\n    stuRuleOutInfo->stRule[i].stCoordinates[j].nX = m_nX;\n    stuRuleOutInfo->stRule[i].stCoordinates[j].nY = m_nY;\n    m_nAlarmid = stuRuleOutInfo->stRule[i].stAlarmSetting[l].nId = m_nAlarmid;  \n    stuRuleOutInfo->stRule[i].stAlarmSetting[l].bEnable = m_Combo_AlarmEnable.GetCurSel();\n    stuRuleOutInfo->stRule[i].stAlarmSetting[l].nResultType = m_Combo_ResultType.GetCurSel();\n    stuRuleOutInfo->stRule[i].stAlarmSetting[l].nAlarmCondition = m_Combo_Condition.GetCurSel();\n    stuRuleOutInfo->stRule[i].stAlarmSetting[l].fThreshold = m_fThreshold;\n    stuRuleOutInfo->stRule[i].stAlarmSetting[l].fHysteresis = m_fHysteresis;\n    stuRuleOutInfo->stRule[i].stAlarmSetting[l].nDuration = m_nDrationTime;\n    char szJsonBuf[512 * 40] = {0};\n    BOOL bRet = CLIENT_PacketData(CFG_CMD_THERMOMETRY, stuRuleOutInfo, sizeof(*stuRuleOutInfo), szJsonBuf, sizeof(szJsonBuf));\n    if (!bRet)\n    {\n        DWORD dwError = CLIENT_GetLastError() & 0x7fffffff;\n    } \n    else\n    {\n        int nerror = 0;\n        int nrestart = 0;\n        int nChannelID = -1;\n        bRet = CLIENT_SetNewDevConfig(m_iLoginID, CFG_CMD_THERMOMETRY, nChannelID, szJsonBuf, sizeof(szJsonBuf), &nerror, &nrestart, 3000);\n        if (!bRet)\n        {\n            DWORD dwError = CLIENT_GetLastError() & 0x7fffffff;\n        }\n        \n    }\n    UpdateData(FALSE);\n\tdelete stuRuleOutInfo;\n\tstuRuleOutInfo = NULL;\n    return FALSE;\n}\n\n\n\nvoid CRuleDlg::OnBtnGet() \n{\n    \n\tGetRuleConfig(0,0,0);\n    UpdateData(FALSE);\n}\n\nvoid CRuleDlg::OnBtnSet() \n{\n\tSetRuleConfig();\n}\n\nvoid CRuleDlg::OnSelchangeComboRuleid() \n{\n    UpdateData();\n\tint i = m_Combo_Ruleid.GetCurSel();\n    int j = m_Combo_PointNum.GetCurSel();\n    int l = m_Combo_AlarmID.GetCurSel();\n    GetRuleConfig(i,j,l);\n    m_Combo_Ruleid.SetCurSel(i);\n    m_Combo_PointNum.SetCurSel(j);\n    m_Combo_AlarmID.SetCurSel(l);\n    UpdateData(FALSE);\n}\n\nvoid CRuleDlg::OnSelchangeComboPointnum() \n{\n    UpdateData();\n    int i = m_Combo_Ruleid.GetCurSel();\n    int j = m_Combo_PointNum.GetCurSel();\n    int l = m_Combo_AlarmID.GetCurSel();\n    GetRuleConfig(i,j,l);\n    m_Combo_Ruleid.SetCurSel(i);\n    m_Combo_PointNum.SetCurSel(j);\n    m_Combo_AlarmID.SetCurSel(l);\n    UpdateData(FALSE);\n}\n\nvoid CRuleDlg::OnSelchangeComboAlarmid() \n{\n    UpdateData();\n    int i = m_Combo_Ruleid.GetCurSel();\n    int j = m_Combo_PointNum.GetCurSel();\n    int l = m_Combo_AlarmID.GetCurSel();\n    GetRuleConfig(i,j,l);\n    m_Combo_Ruleid.SetCurSel(i);\n    m_Combo_PointNum.SetCurSel(j);\n    m_Combo_AlarmID.SetCurSel(l);\n    UpdateData(FALSE);\n}\n","size_bytes":11330},"bin/Demo/MfcDemo/01.RealPlayAndPTZControl/RealPlayAndPTZControl.cpp":{"content":"// RealPlayAndPTZControl.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"RealPlayAndPTZControl.h\"\n#include \"RealPlayAndPTZControlDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CRealPlayAndPTZControlApp\n\nBEGIN_MESSAGE_MAP(CRealPlayAndPTZControlApp, CWinApp)\n\t//{{AFX_MSG_MAP(CRealPlayAndPTZControlApp)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t\t//    DO NOT EDIT what you see in these blocks of generated code!\n\t//}}AFX_MSG\n\tON_COMMAND(ID_HELP, CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CRealPlayAndPTZControlApp construction\n\nCString ConvertString(CString strText)\n{\n\tchar *val = new char[200];\n\tCString strIniPath,strRet;\n\t\n\tmemset(val,0,200);\n\tGetPrivateProfileString(\"String\",strText,\"\",\n\t\tval,200,\"./langchn.ini\");\n\tstrRet = val;\n\tif(strRet.GetLength()==0)\n\t{\n\t\t//If there is no corresponding string in ini file then set it to be default value(English)\n\t\tstrRet=strText;\n\t}\n\tdelete val;\n\treturn strRet;\n}\n//Set static text in dialogux box (English->current language)  \nvoid g_SetWndStaticText(CWnd * pWnd)\n{\n\tCString strCaption,strText;\n\t\n\t//Set main widnow title \n\tpWnd->GetWindowText(strCaption);\n\tif(strCaption.GetLength()>0)\n\t{\n\t\tstrText=ConvertString(strCaption);\n\t\tpWnd->SetWindowText(strText);\n\t}\n\t\n\t//Set small window title \n\tCWnd * pChild=pWnd->GetWindow(GW_CHILD);\n\tCString strClassName;\n\twhile(pChild)\n\t{\n\t\t//////////////////////////////////////////////////////////////////////////\t\t\n\t\t//Added by Jackbin 2005-03-11\n\t\tstrClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n\t\tif(strClassName == \"CEdit\")\n\t\t{\n\t\t\t//The next small window \n\t\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t//////////////////////////////////////////////////////////////////////////\t\n\t\t\n\t\t//Set current language text in small window\n\t\tpChild->GetWindowText(strCaption);\n\t\tstrText=ConvertString(strCaption);\n\t\tpChild->SetWindowText(strText);\n\t\t\n\t\t//The next small window \n\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t}\n}\n\nCRealPlayAndPTZControlApp::CRealPlayAndPTZControlApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The one and only CRealPlayAndPTZControlApp object\n\nCRealPlayAndPTZControlApp theApp;\n\n/////////////////////////////////////////////////////////////////////////////\n// CRealPlayAndPTZControlApp initialization\n\nBOOL CRealPlayAndPTZControlApp::InitInstance()\n{\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t//  of your final executable, you should remove from the following\n\t//  the specific initialization routines you do not need.\n\n#ifdef _AFXDLL\n\tEnable3dControls();\t\t\t// Call this when using MFC in a shared DLL\n#else\n\tEnable3dControlsStatic();\t// Call this when linking to MFC statically\n#endif\n\n\tCRealPlayAndPTZControlDlg dlg;\n\tm_pMainWnd = &dlg;\n\tINT_PTR nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n","size_bytes":3623},"bin/Demo/MfcDemo/12.DeviceControlAndTimeSynchronization/StdAfx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n//\tDeviceControlAndTimeSynchronization.pch will be the pre-compiled header\n//\tstdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":291},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/User_AddGroup.cpp":{"content":"// User_AddGroup.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"User_AddGroup.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CUser_AddGroup dialog\n\n\nCUser_AddGroup::CUser_AddGroup(CWnd* pParent /*=NULL*/)\n\t: CDialog(CUser_AddGroup::IDD, pParent)\n{\n\tm_user_info = 0;\n\tm_dev = 0;\n\t//{{AFX_DATA_INIT(CUser_AddGroup)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CUser_AddGroup::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CUser_AddGroup)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CUser_AddGroup, CDialog)\n\t//{{AFX_MSG_MAP(CUser_AddGroup)\n\tON_BN_CLICKED(IDC_BTN_OK, OnBtnOk)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CUser_AddGroup message handlers\n\nBOOL CUser_AddGroup::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\t\n\tCRect rect;\n\tGetDlgItem(IDC_RLIST_FRAME)->GetClientRect(&rect);\n\tGetDlgItem(IDC_RLIST_FRAME)->ClientToScreen(&rect);\n\tScreenToClient(&rect);\n\t\n\tBOOL bCreate = m_rightList.Create(WS_VISIBLE | WS_TABSTOP | WS_CHILD | WS_BORDER\n\t\t| TVS_HASBUTTONS | TVS_LINESATROOT | TVS_HASLINES \n\t\t| TVS_DISABLEDRAGDROP, rect, this, 0x1005);\n\t\n\tSetWindowLong(m_rightList.m_hWnd, GWL_STYLE, TVS_CHECKBOXES);\n\t\n\tm_rightList.ShowWindow(SW_SHOW);\n\t\n\tif (!m_user_info || !m_dev)\n\t{\n\t\treturn TRUE;\n\t}\n\t\n\tCString strRight;\n    HTREEITEM hRoot;\n\tfor (int i = 0; i < m_user_info->dwRightNum; i++)\n\t{\n        strRight.Format(\"%d: %s: %s\", m_user_info->rightList[i].dwID, m_user_info->rightList[i].name, m_user_info->rightList[i].memo);\n\t\thRoot = m_rightList.InsertItem(strRight, 0, 0, TVI_ROOT);\n\t\tm_rightList.SetItemData(hRoot, m_user_info->rightList[i].dwID);\n\t}\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CUser_AddGroup::SetEnvrmt(USER_MANAGE_INFO_NEW *info, DeviceNode *dev)\n{\n\tm_user_info = info;\n\tm_dev = dev;\n}\n\nvoid CUser_AddGroup::OnBtnOk() \n{\n\tUSER_GROUP_INFO_EX2 ugInfo = { sizeof(USER_GROUP_INFO_EX2)};\n\tugInfo.dwID = m_user_info->dwGroupNum + 1;\n\tGetDlgItem(IDC_NAME_EDIT)->GetWindowText(ugInfo.name, DH_NEW_USER_NAME_LENGTH);\n\tGetDlgItem(IDC_MEMO_EDIT)->GetWindowText(ugInfo.memo, DH_MEMO_LENGTH);\n\t\n\tint count = m_rightList.GetCount();\n\tHTREEITEM node = m_rightList.GetRootItem();\n\tint rIndex = 0;\n    bool bSelect = false;\n\tfor (int i=0; i<count && node; i++)\n\t{\n\t\tif (m_rightList.GetCheck(node))\n\t\t{\n\t\t\tugInfo.rights[rIndex] = m_rightList.GetItemData(node);\n\t\t\trIndex++;\n            bSelect  = true;\n\t\t}\n\t\tnode = m_rightList.GetNextItem(node, TVGN_NEXT);\n\t}\n    if (bSelect == false)\n    {\n        MessageBox(ConvertString(\"Please select at least one right\"));\n        return;\n    }\n\tugInfo.dwRightNum = rIndex;\n\tBOOL bRet = CLIENT_OperateUserInfoNew(m_dev->LoginID, 7/*type: add user group*/, &ugInfo, 0, NULL, MAX_TIMEOUT);\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Add group failed!\"));\n\t}\n\telse\n\t{\n\t\tEndDialog(0);\n\t}\n}\n","size_bytes":3248},"bin/Demo/MfcDemo/10.AlarmDevice/BSWndContainer.cpp":{"content":"// BSWndContainer.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"BSWndContainer.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CBSWndContainer\n\nCBSWndContainer::CBSWndContainer()\n{\n\t// init active page pointer\n\tm_pActivePage\t= NULL;\n\n\t// init window state\n\tm_bFullScreen\t= FALSE;\t// Full screen sign \n\tm_bMultiScreen\t= TRUE;\t\t// Multiple-window sign \n\tm_bAutoAdjustPos= FALSE;\t// Auto adjust sign \n\n\tSetDrawActivePage(TRUE);\t//\tEnable frame\n\n\tm_nShowPortion=100;\t\t\t//\tDisplay proportion \n}\n\nCBSWndContainer::~CBSWndContainer()\n{\n\t// remove all pages\n\twhile(!m_PageList.IsEmpty())\n\t\tm_PageList.RemoveHead();\n}\n\n\nBEGIN_MESSAGE_MAP(CBSWndContainer, CWnd)\n\t//{{AFX_MSG_MAP(CBSWndContainer)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n\n/////////////////////////////////////////////////////////////////////////////\n// CBSWndContainer member functions\n\n///////////////////////////////////////////////////\n// call this function to create container object.\n// it is override from cwnd class\nBOOL CBSWndContainer::Create( LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext )\n{\n\tdwStyle|=WS_EX_TOOLWINDOW;\n\treturn CWnd::Create(lpszClassName,lpszWindowName,dwStyle,rect,pParentWnd,nID,pContext );\n}\n\n\n///////////////////////////////////////////////////\n// call this function to add a page wnd to \n// container. if success retrun TRUE,else return \n// FALSE.\nBOOL CBSWndContainer::AddPage(CWnd *pWnd, BOOL bRepaint)\n{\n\t// check parameter\n\tif(\t!pWnd || !IsWindow(pWnd->m_hWnd) )\treturn FALSE;\n\n\t// check list \n\tPOSITION pos=m_PageList.Find(pWnd);\n\tif(pos!=NULL) \n\t{\n\t\tTRACE(\"This Window has been added to container, the operation will terminate.\\n\");\n\t\treturn TRUE;\n\t}\n\n\t// added page\n\tm_PageList.AddTail(pWnd);\n\n\tif( m_bDrawActive ) DrawActivePage(FALSE);\n\n\t// reset active page\n\tSetActivePage(pWnd, bRepaint);\n\n\treturn TRUE;\n}\n\n///////////////////////////////////////////////////\n// call this function to remove a page wnd from\n// container. \nCWnd *CBSWndContainer::DelPage(CWnd *pWnd)\n{\n\t// check list\n\tPOSITION pos=m_PageList.Find(pWnd);\n\tif(pos==NULL)\n\t{\n\t\tTRACE(\"This Window is not a member of container, the operation will terminate.\\n\");\n\t\treturn NULL;\n\t}\n\tif(pWnd==m_pActivePage)\n\t\tif(m_pActivePage==GetPrevPage(pWnd))//m_PageList.IsEmpty()?NULL:m_PageList.GetHead();\n\t\t\tm_pActivePage=NULL;\n\t\telse m_pActivePage=GetPrevPage(pWnd);\n\t\n\tm_PageList.RemoveAt(pos);\n\n\tif (pWnd)\n\t{\n\t\tpWnd->ShowWindow(SW_HIDE);\n\t}\n\n//\tInvalidate();\n\n\treturn pWnd;\n}\n\n///////////////////////////////////////////////////\n// call this function to remove active page from\n// container.\nCWnd *CBSWndContainer::DelPage()\n{\n\treturn DelPage(m_pActivePage);\n}\n\n///////////////////////////////////////////////////\n// call this function to set a page to be active\n// page.\nvoid CBSWndContainer::SetActivePage(CWnd *pWnd, BOOL bRepaint)\n{\n\t// check parameter\n\tif(\t!pWnd || !IsWindow(pWnd->m_hWnd) )\treturn;\n\n\t// if pWnd is the Active Page, return \n\tif( m_pActivePage==pWnd ) return;\n\n\t// check list\n\tPOSITION pos=m_PageList.Find(pWnd);\n\tif(pos==NULL)\n\t{\n\t\tTRACE(\"__This Window is not a member of container, the operation will terminate.\\n\");\n\t\treturn;\n\t}\n\n\tif(bRepaint) UpdateWnd();\n\n\tif( m_bDrawActive ) DrawActivePage(FALSE);\n\n\tm_pActivePage=pWnd;\n\n\tif( m_bDrawActive ) DrawActivePage(TRUE);\n}\n\n///////////////////////////////////////////////////\n// call this function to get the active page's\n// pointer. if no active page,return NULL;\nCWnd *CBSWndContainer::GetActivePage()\n{\n\treturn m_pActivePage;\n}\n\nCWnd *CBSWndContainer::GetTailPage()\n{\n\treturn m_PageList.GetTail();\n}\n\n///////////////////////////////////////////////////\n// call this function to get the next page by\n// the page that user defined. if the defined \n// page is not find in container, return NULL.\nCWnd *CBSWndContainer::GetNextPage(CWnd *pWnd)\n{\n\t// check parameter\n\tif(\t!pWnd || !IsWindow(pWnd->m_hWnd) ) return NULL;\n\n\t// check list\n\tPOSITION pos=m_PageList.Find(pWnd);\n\tif(pos==NULL)\n\t{\n\t\tTRACE(\"This Window is not a member of container, the operation will terminate.\\n\");\n\t\treturn NULL;\n\t}\n\t\n\t//\n\tm_PageList.GetNext(pos);\n\tif(pos==NULL)\n\t\treturn m_PageList.GetHead();\n\telse \n\t\treturn m_PageList.GetNext(pos);\n}\n\n///////////////////////////////////////////////////\n// call this function to get the prev page by\n// the page that user defined. if the defined\n// page is not find in container,return NULL.\nCWnd *CBSWndContainer::GetPrevPage(CWnd *pWnd)\n{\n\t// check parameter\n\tif(\t!pWnd || !IsWindow(pWnd->m_hWnd) ) return NULL;\n\n\t// check list\n\tPOSITION pos=m_PageList.Find(pWnd);\n\tif(pos==NULL)\n\t{\n\t\tTRACE(\"This Window is not a member of container, the operation will terminate.\\n\");\n\t\treturn NULL;\n\t}\n\t\n\t//\n\tm_PageList.GetPrev(pos);\n\tif(pos==NULL)\n\t\treturn m_PageList.GetTail();\n\telse \n\t\treturn m_PageList.GetPrev(pos);\n}\n\nCWnd *CBSWndContainer::GetPage(int nIndex)\n{\n\tCWnd *pRet = NULL;\n\tPOSITION pos = m_PageList.FindIndex(nIndex);\n\tif(pos == NULL) return pRet;\n\n\treturn m_PageList.GetAt(pos);\n}\n\nint CBSWndContainer::GetCount() const\n{\n\treturn m_PageList.GetCount();\n}\n\n///////////////////////////////////////////////////\n// call this function to  page wnds,when\n// the window is resized.\nvoid CBSWndContainer::UpdateWnd()\n{\n\tif(!IsWindowVisible()||IsIconic()) return;\n/////////////////////\n//Calculate display total zone \n\n\t//To get current window device coordinates\n\tCRect rtContainer;\n\tGetClientRect(&rtContainer);\n\tGetShowRect(&rtContainer);\n\trtContainer.DeflateRect(1,1);\n\n\t//Adjust Container position \n\tif(m_bAutoAdjustPos)\t\t\n\t\tAdjustRect(&rtContainer);\n\n/////////////////////\n//\n\tif(m_bMultiScreen)\n\t{ //Multiple-window status \n\t\tCRect rt;\n\t\tint nCount=m_PageList.GetCount();\n\t\tint i=0;\n\t\tfor(POSITION pos=m_PageList.GetHeadPosition();pos!=NULL;)\n\t\t{\n\t\t\tCWnd *p=m_PageList.GetNext(pos);\n\n\t\t\trt=rtContainer;\n\t\t\tCalcPageRect(&rt,i,nCount);\n\t\t\trt.DeflateRect(WINDOW_SPACE,WINDOW_SPACE,WINDOW_SPACE,WINDOW_SPACE); \n\t\t\tp->MoveWindow(&rt);\n\t\t\tp->ShowWindow(SW_SHOW);\n\t\t\ti++;\n\t\t}\n\t\tif( m_bDrawActive && m_PageList.GetCount()>1 ) DrawActivePage(TRUE);\n\t}\n\telse\n\t{ //One-window status \n\t\tfor(POSITION pos=m_PageList.GetHeadPosition();pos!=NULL;)\n\t\t{\n\t\t\tCWnd *p=m_PageList.GetNext(pos);\n\t\t\tif(p==m_pActivePage)\n\t\t\t\tp->MoveWindow(&rtContainer);\n\t\t\telse \n\t\t\t{\n\t\t\t\tif(m_bFullScreen)\n\t\t\t\t\tp->MoveWindow(0,0,1,1);\n\t\t\t\telse\n\t\t\t\t\tp->MoveWindow(rtContainer.right+1,rtContainer.bottom+1,1,1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n///////////////////////////////////////////////////\n// full screen\nvoid CBSWndContainer::SetFullScreen(BOOL bFlag)\n{\n\tif(bFlag==m_bFullScreen) return;\n\n\tif( bFlag )\n\t{//Full screen \n\t\t//Get displayer resolution \n\t\tint cx=GetSystemMetrics(SM_CXSCREEN);\n\t\tint cy=GetSystemMetrics(SM_CYSCREEN);\n\n\t\t//Save position information \n\t\tGetWindowPlacement(&_temppl);\n\t\t//Modify style \n\t\tModifyStyle(WS_CHILD,WS_POPUP);\n\t\t//Modify main-window \n\t\t_tempparent=SetParent(NULL);\n\t\t_tempparent->ShowWindow(SW_HIDE);\n\t\t//Move window \n\t\tMoveWindow(0,0,cx,cy);\n\t//\tSetWindowPos(&wndTopMost,0,0,cx,cy,NULL);\n\t}\n\telse\n\t{//Restore\n\t\t//Restore main window \n\t\t_tempparent->ShowWindow(SW_SHOW);\n\t\tSetParent(_tempparent);\n\t\t//Restore style \n\t\tModifyStyle(WS_POPUP,WS_CHILD);\n\t\t//Restore position \n\t\tSetWindowPlacement(&_temppl);\n\t}\n\n\tm_bFullScreen=bFlag;\n\tInvalidate();\n}\nBOOL CBSWndContainer::GetFullScreen()\n{\n\treturn m_bFullScreen;\n}\n\n///////////////////////////////////////////////////\n// multiscreen\nvoid CBSWndContainer::SetMultiScreen(BOOL bFlag)\n{\n\tif(m_bMultiScreen==bFlag) return;\n\tm_bMultiScreen=bFlag;\n\tInvalidate();\n}\nBOOL CBSWndContainer::GetMultiScreen()\n{\n\treturn m_bMultiScreen;\n}\n\n//////////////////////////////////////////////////\n// autoadjustpos\nvoid CBSWndContainer::SetAutoAdjustPos(BOOL bFlag)\n{\n\tif(m_bAutoAdjustPos==bFlag) return;\n\tm_bAutoAdjustPos=bFlag;\n\tInvalidate();\n}\nBOOL CBSWndContainer::GetAutoAdjustPos()\n{\n\treturn m_bAutoAdjustPos;\n}\n\n//////////////////////////////////////////////////\n// draw active page\nvoid CBSWndContainer::SetDrawActivePage(BOOL bFlag,COLORREF clrTopLeft,COLORREF clrBottomRight)\n{\n\tif(m_bDrawActive==bFlag) return;\n\tif(bFlag)\n\t{\n\t\tm_clrTopLeft=clrTopLeft;\n\t\tm_clrBottomRight=clrBottomRight;\n\t}\n\tm_bDrawActive=bFlag;\n\tDrawActivePage(bFlag);\n}\nBOOL CBSWndContainer::GetDrawActivePage()\n{\n\treturn m_bDrawActive;\n}\n\n//////////////////////////////////////////////////\n//\tDisplay percentage \n//\t40 <= nPortion <=100\nvoid CBSWndContainer::SetShowPortion(int nPortion)\n{\n\tif(m_nShowPortion==nPortion) return;\n\tif(m_nShowPortion<40) m_nShowPortion=40;\n\tif(m_nShowPortion>100) m_nShowPortion=100;\n\tm_nShowPortion=nPortion;\n\tInvalidate();\n}\nint  CBSWndContainer::GetShowPortion()\n{\n\treturn m_nShowPortion;\n}\n\n///////////////////////////////////////////////////\n// clean the no useful page in the container,\n// return the page count.\nint CBSWndContainer::UpdateList()\n{\n\tPOSITION posPrev;\n\tfor(POSITION pos=m_PageList.GetHeadPosition();pos!=NULL;)\n\t{\n\t\tposPrev=pos;\n\t\tCWnd *p=m_PageList.GetNext(pos);\n\t\tif(!IsWindow(p->m_hWnd))\n\t\t\tm_PageList.RemoveAt(posPrev);\n\t}\n\treturn m_PageList.GetCount();\n}\n\n///////////////////////////////////////////////////\n// get a rect by the index of a child\nvoid CBSWndContainer::CalcPageRect(LPRECT lpRect,int nIndex,int nPageCount)\n{\n\tif((nPageCount<=0)||(nIndex>=nPageCount))\n\t{\n\t\tlpRect->left=lpRect->right=lpRect->top=lpRect->bottom=0;\n\t\treturn;\n\t}\n//get row count\n\tint nRow=0;\n\twhile((nRow)*(nRow)<nPageCount) nRow++;\n\n//get singledlg width and height\n\tint nWidth=(lpRect->right-lpRect->left)/nRow;\n\tint nHeight=(lpRect->bottom-lpRect->top)/nRow;\n\n//get top-left point\n\tCPoint pt;\n\tpt.x=lpRect->left+nWidth*(nIndex%nRow);\n\tpt.y=lpRect->top+nHeight*(nIndex/nRow);\n\n//set rect return back\n\tlpRect->left=pt.x;\n\tlpRect->top=pt.y;\n\tlpRect->right=lpRect->left+nWidth;\n\tlpRect->bottom=lpRect->top+nHeight;\n}\n\n///////////////////////////////////////////////////\n// adjust a rect by defined proportion \nvoid CBSWndContainer::AdjustRect(LPRECT lpRect)\n{\n\tint nWidth=lpRect->right-lpRect->left;\n\tint nHeight=lpRect->bottom-lpRect->top;\n\tCPoint pt((lpRect->left+lpRect->right)/2,(lpRect->top+lpRect->bottom)/2);\n\n\tint nTemp=nWidth*8/11;\n\tif(nTemp>nHeight)\n\t{\n\t\tnWidth=nHeight*11/8;\n\t}\n\telse if(nTemp<nHeight)\n\t{\n\t\tnHeight=nTemp;\n\t}\n\tlpRect->left=pt.x-nWidth/2;\n\tlpRect->right=pt.x+nWidth/2;\n\tlpRect->top=pt.y-nHeight/2;\n\tlpRect->bottom=pt.y+nHeight/2;\n}\n\n///////////////////////////////////////////////////\n//To get display zone in proportion \nvoid CBSWndContainer::GetShowRect(LPRECT lpRect)\n{\n\tif(m_nShowPortion<40) m_nShowPortion=40;\n\tif(m_nShowPortion>100) m_nShowPortion=100;\n\n\tint nWidth\t= lpRect->right-lpRect->left;\n\tint nHeight\t= lpRect->bottom-lpRect->top;\n\n\tint nNewWidth\t= (int)(nWidth*m_nShowPortion/100);\n\tint nNewHeight\t= (int)(nHeight*m_nShowPortion/100);\n\n\tint ndx\t= ( nWidth-nNewWidth )/2;\n\tint ndy = ( nHeight-nNewHeight )/2;\n\n\tlpRect->left\t= lpRect->left\t+ ndx;\n\tlpRect->top\t\t= lpRect->top\t+ ndy;\n\tlpRect->right\t= lpRect->left\t+ nNewWidth;\n\tlpRect->bottom\t= lpRect->top\t+ nNewHeight;\t\n}\n\n///////////////////////////////////////////////////\n// draw the frame of active page\nvoid CBSWndContainer::DrawActivePage(BOOL bFlag)\n{\n\tif( !m_bMultiScreen || \n\t\t!m_pActivePage\t|| \n\t\tm_PageList.GetCount()<2 \n\t\t) return;\n\n\tCRect rt;\n\tm_pActivePage->GetWindowRect(&rt);\n\tScreenToClient(&rt);\n\trt.InflateRect(1,1);\n\n\tif(bFlag)\n\t{\n\t\tCDC *pDC=GetDC();\n\t\tif(!pDC) return;\n\n//\t\tpDC->Draw3dRect(&rt,m_clrTopLeft, m_clrBottomRight);\t\n\t\tpDC->Draw3dRect(&rt,RGB(255,0,0), RGB(255,0,0));\n\n\t\tReleaseDC(pDC);\n\t}\n\telse\n\t\tInvalidateRect(&rt);\n}\n\n\n","size_bytes":11638},"bin/Demo/MfcDemo/04.CapturePicture/StdAfx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n//\tCapturePicture.pch will be the pre-compiled header\n//\tstdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":251},"bin/Demo/MfcDemo/13.FaceRecognition/FaceMutex.cpp":{"content":"#include \"stdafx.h\"\n#include \"FaceMutex.h\"\n\n\nCFaceMutex::CFaceMutex()\n{\n\tInitializeCriticalSection(&m_critclSection);\n}\n\nCFaceMutex::~CFaceMutex()\n{\n\tDeleteCriticalSection(&m_critclSection);\n}\n\nint CFaceMutex::Lock()\n{\n\tEnterCriticalSection(&m_critclSection);\n\treturn 0;\n}\n\nint CFaceMutex::UnLock()\n{\n\tLeaveCriticalSection(&m_critclSection);\n\treturn 0;\n}","size_bytes":354},"bin/DemoSrc/playsdkdemo/CutFileDlg.cpp":{"content":"// CutFileDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"PlayDemo.h\"\n#include \"CutFileDlg.h\"\n#include \"Player.h\"\n#include \"LanguageConvertor.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CCutFileDlg dialog\n\n\nCCutFileDlg::CCutFileDlg(CString originfile,CWnd* pParent /*=NULL*/)\n\t: CDialog(CCutFileDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CCutFileDlg)\n\tm_cutType = 0;\n\tm_realStartPos = 0;\n\tm_endpos = 0;\n\tm_originfile = originfile;\n\tm_realStartPos = 0;\n\tm_realEndPos = 0;\n\tm_startpos = 0;\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CCutFileDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CCutFileDlg)\n\tDDX_Radio(pDX, IDC_RADIO_FRAME, m_cutType);\n\tDDX_Text(pDX, IDC_EDIT_STARTPOS, m_startpos);\n\tDDX_Text(pDX, IDC_EDIT_ENDPOS, m_endpos);\n\tDDX_Text(pDX, IDC_EDIT_REALSTART, m_realStartPos);\n\tDDX_Text(pDX, IDC_EDIT_REALEND, m_realEndPos);\n\t//}}AFX_DATA_MAP\n}\n\nBOOL CCutFileDlg::OnInitDialog()\n{\n\tCDialog::OnInitDialog();\n\t\n\tLANG_SETWNDSTATICTEXT(this);\n\n\t//get range of the framenum and time.\n\tm_nMaxTime=CPlayer::Instance()->GetTotalTime();\n\tm_nMaxFrameNum=\tCPlayer::Instance()->GetTotalFrame();\n\tCString s_range;\n\ts_range.Format(_T(\"%s:         %d--%d\\r\\n%s(Sec):     %d--%d\\r\\n\"),\n\t\tLANG_CS(\"Frame Range\"), 0, m_nMaxFrameNum -1, LANG_CS(\"Time Range\"), 0, m_nMaxTime);\n\tGetDlgItem(IDC_RANGEVALUE)->SetWindowText(s_range);\n\n\treturn TRUE;\n}\n\nBEGIN_MESSAGE_MAP(CCutFileDlg, CDialog)\n\t//{{AFX_MSG_MAP(CCutFileDlg)\n\tON_BN_CLICKED(IDC_BUTTON_SAVE, OnButtonSave)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CCutFileDlg message handlers\n\nvoid CCutFileDlg::OnButtonSave() \n{\n\t// TODO: Add your control notification handler code here\n\tCString strEdit1,strEdit2;\n\tGetDlgItemTextW(IDC_EDIT_STARTPOS,strEdit1);\n\tGetDlgItemTextW(IDC_EDIT_ENDPOS,strEdit2);\n\tif(strEdit1.IsEmpty() || strEdit2.IsEmpty())\n\t{\n\t\tAfxMessageBox(LANG_CS(\"Please enter an integer.\"));\n\t\treturn;\n\t}\n\n\tif (UpdateData(true) == 0)\n\t\treturn;\n\n\tint startPos = m_startpos;\n\tint endPos = m_endpos;\n\n\tm_cutType = ((CButton*)GetDlgItem(IDC_RADIO_FRAME))->GetCheck()?CUTBYFRAMENUM:CUTBYTIME;\n\tif (m_cutType == CUTBYFRAMENUM)  //By Frame number\n\t{\n\t\tif (startPos < 0 || startPos > m_nMaxFrameNum -1\n\t\t\t|| endPos< 0 || endPos > m_nMaxFrameNum -1\n\t\t\t|| startPos > endPos)\n\t\t{\n\t\t\tAfxMessageBox(LANG_CS(\"Input number error!\"));\n\t\t\treturn ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*To unify frame no. and time, the frame no. \n\t\t\tstarts from 0 and time starts from 0; frame no.\n\t\t\trequires operation before unified use of GetKeyFramePos and GetNextKeyFramePos port*/\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (startPos < 0|| startPos > m_nMaxTime\n\t\t\t|| endPos < 0|| endPos > m_nMaxTime\n\t\t\t|| startPos > endPos)\n\t\t{\n\t\t\tAfxMessageBox(LANG_CS(\"Input number error!\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tCPlayer::Instance()->GetKeyFramePos(startPos*((m_cutType == 0)?1:1000), m_cutType+1, &m_RealBegin);\n\tCPlayer::Instance()->GetNextKeyFramePos(endPos*((m_cutType == 0)?1:1000), m_cutType+1, &m_RealEnd);\n\n\tLONGLONG newfilelen = 0;\n\tCFile file_in(m_originfile,CFile::modeRead|CFile::typeBinary|CFile::shareDenyNone);\n\tif (m_RealBegin.nFrameNum > m_RealEnd.nFrameNum)\n\t{\n\t\tAfxMessageBox(LANG_CS(\"Input number error!\"));\n\t\treturn ;\n\t}\n\telse if((m_cutType == 0 && (m_RealEnd.nFrameNum) < endPos) ||\n\t\t(m_cutType == 1 && m_RealEnd.nFrameTime < ((endPos)*1000)))\n\t{\n\t\t// This situation usually happens when cut last few frames.\n\t\tnewfilelen = file_in.GetLength() - m_RealBegin.nFilePos;\n\t\tm_realEndPos = (m_cutType == 0)?(CPlayer::Instance()->GetTotalFrame()-1):(CPlayer::Instance()->GetTotalTime());\n\t}\n\telse\n\t{\n\t\tm_realEndPos = (m_cutType == 0)?(m_RealEnd.nFrameNum):((m_RealEnd.nFrameTime/1000));\n\t\tnewfilelen = m_RealEnd.nFilePos+ m_RealEnd.nFrameLen - m_RealBegin.nFilePos ;\n\t}\n\tm_realStartPos = (m_cutType == 0)?(m_RealBegin.nFrameNum):(m_RealBegin.nFrameTime/1000); \n\n\tTCHAR szFilters[]= _T(\"dav Files (*.dav)|*.dav|All Files (*.*)|*.*||\");\n\tCFileDialog FileChooser (FALSE, _T(\"dav\"), _T(\"*.dav\"), OFN_FILEMUSTEXIST,szFilters, this);\n\tCString savefile ;\n\tif (FileChooser.DoModal()==IDOK)\n\t{\n\t\tsavefile = FileChooser.GetPathName();\n\t\tUpdateData(FALSE);\n\t}\n\telse \n\t{\n\t\tUpdateData(FALSE);\n\t\treturn;\n\t}\n\n\t/*Copy portion that is to be cut into new file*/\n\tCFile file_out(savefile,CFile::modeWrite|CFile::typeBinary|CFile::modeCreate);\n\t\n\tconst int nSize = 2048;\n\tint nBlock = newfilelen/nSize;\n\tchar *pBuf = new char[nSize];\n\tmemset(pBuf, 0, nSize);\n\n\tif (m_RealBegin.nFilePos < (1<<31))\n\t\tfile_in.Seek(m_RealBegin.nFilePos,SEEK_SET);\n\telse\n\t{\n\t\tDWORD zgf = file_in.Seek(m_RealBegin.nFilePos/2,SEEK_SET);\n\t\tzgf = file_in.Seek(m_RealBegin.nFilePos - m_RealBegin.nFilePos/2,SEEK_CUR);\n\t}\n\t\n\tfor (DWORD i = 0 ; i < nBlock ; i++ )\n\t{\n\t\tfile_in.Read(pBuf,nSize);\n\t\tfile_out.Write(pBuf,nSize);\n\t}\n\tDWORD nRemain = newfilelen - nBlock*nSize;\n\tif (nRemain > 0)\n\t{\n\t\tfile_in.Read(pBuf,nRemain);\n\t\tfile_out.Write(pBuf,nRemain);\n\t}\n\tdelete[] pBuf;\n\tfile_out.Close();\t\n}\n\nBOOL CCutFileDlg::PreTranslateMessage(MSG* pMsg) \n{\n\t// TODO: Add your specialized code here and/or call the base class\n\n\t/*Prevent user to close the box by pressing enter */\n\tif (pMsg->wParam == VK_RETURN && pMsg->message == WM_KEYDOWN)\n\t{\n\t\tOnButtonSave();\n\t\treturn 1;\n\t}\n\telse if(pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_ESCAPE)\n\t\treturn 1;\n\treturn CDialog::PreTranslateMessage(pMsg);\n}\n","size_bytes":5487},"bin/Demo/MfcDemo/20.MonitorWall/src/Util.cpp":{"content":"#include \"StdAfx.h\"\n#include \"Util.h\"\n\nint MsgBoxFmt( HWND hWnd, UINT uType, LPCTSTR lpszCaption, LPCTSTR lpszTextFmt, ... )\n{\n\tTCHAR szText[1024] = {0};\n\t\n\tva_list args;\n\tva_start(args, lpszTextFmt);  \n    _vstprintf(szText, lpszTextFmt, args);\n\tva_end(args);\n\t\n\treturn MessageBox(hWnd, szText, lpszCaption, uType);\n}\n\nint _MsgBoxErr( HWND hWnd, UINT uType, LPCTSTR lpszCaption, LPCTSTR lpszMsg )\n{\n\tCString str = LMIC(lpszMsg);\n\tstr += \" \";\n\tstr += LMIC(_T(\"Code:\"));\n\n\tCString strCode;\n\tstrCode.Format(_T(\" 0x%08X\"), CLIENT_GetLastError());\n\tstr += strCode;\n\n\treturn MessageBox(hWnd, str, lpszCaption, uType);\n}\n","size_bytes":615},"bin/Demo/MfcDemo/15.HeatMap/HeatMap.cpp":{"content":"// HeatMap.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"HeatMap.h\"\n#include \"HeatMapDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\n\n// CHeatMapApp\n\nBEGIN_MESSAGE_MAP(CHeatMapApp, CWinApp)\n\tON_COMMAND(ID_HELP, &CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n\n// CHeatMapApp construction\n\nCHeatMapApp::CHeatMapApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n\n// The one and only CHeatMapApp object\n\nCHeatMapApp theApp;\n\n\n// CHeatMapApp initialization\n\nBOOL CHeatMapApp::InitInstance()\n{\n\t// InitCommonControlsEx() is required on Windows XP if an application\n\t// manifest specifies use of ComCtl32.dll version 6 or later to enable\n\t// visual styles.  Otherwise, any window creation will fail.\n\tINITCOMMONCONTROLSEX InitCtrls;\n\tInitCtrls.dwSize = sizeof(InitCtrls);\n\t// Set this to include all the common control classes you want to use\n\t// in your application.\n\tInitCtrls.dwICC = ICC_WIN95_CLASSES;\n\tInitCommonControlsEx(&InitCtrls);\n\n\tCWinApp::InitInstance();\n\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t// of your final executable, you should remove from the following\n\t// the specific initialization routines you do not need\n\t// Change the registry key under which our settings are stored\n\t// TODO: You should modify this string to be something appropriate\n\t// such as the name of your company or organization\n\tSetRegistryKey(_T(\"Local AppWizard-Generated Applications\"));\n\n\tCHeatMapDlg dlg;\n\tm_pMainWnd = &dlg;\n\tINT_PTR nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n\nTCHAR* g_GetIniPath(void)\n{\n    static char pszIniPath[512] = {0};\n    if( strlen(pszIniPath) == 0 )\n    {\n        char szDirBuf[512] = {0};\n        GetCurrentDirectory(512, szDirBuf);\n        _snprintf_s(pszIniPath, 512, \"%s\\\\langchn.ini\", szDirBuf);\n    }\n    return pszIniPath;\n}\n\nCString ConvertString(CString strText)\n{\n    char val[200] = {0};\n    CString strIniPath,strRet;\n    GetPrivateProfileString(\"String\",strText,\"\", val,200,g_GetIniPath());\n    strRet = val;\n    if(strRet.GetLength()==0)\n    {\n        //If there is no corresponding string in ini file ,then set it to be default value.\n        strRet=strText;\n    }\n    return strRet;\n}\n//Set static text in dialogue box (English->current language)\nvoid g_SetWndStaticText(CWnd * pWnd)\n{\n    CString strCaption,strText;\n\n    //Set main window title\n    pWnd->GetWindowText(strCaption);\n    if(strCaption.GetLength()>0)\n    {\n        strText=ConvertString(strCaption);\n        pWnd->SetWindowText(strText);\n    }\n\n    //Set small window title \n    CWnd * pChild=pWnd->GetWindow(GW_CHILD);\n    CString strClassName;\n    while(pChild)\n    {\n        //////////////////////////////////////////////////////////////////////////\t\t\n        //Added by Jackbin 2005-03-11\n        strClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n        if(strClassName == \"CEdit\")\n        {\n            //Next small window \n            pChild=pChild->GetWindow(GW_HWNDNEXT);\n            continue;\n        }\n\n        //////////////////////////////////////////////////////////////////////////\t\n\n        //Set small window current language text \n        pChild->GetWindowText(strCaption);\n        strText=ConvertString(strCaption);\n        pChild->SetWindowText(strText);\n\n        //Next small window \n        pChild=pChild->GetWindow(GW_HWNDNEXT);\n    }\n}\n\n","size_bytes":3841},"bin/Demo/MfcDemo/13.FaceRecognition/AddPersonDlg.cpp":{"content":"// AddPersonDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"FaceRecognition.h\"\n#include \"AddPersonDlg.h\"\n#include <atlconv.h>\n#include <assert.h>\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CAddPersonDlg dialog\n\n\nCAddPersonDlg::CAddPersonDlg(const LLONG lLoginHandle, const char *pszGroupID, const char *pszGroupName, const int nOpreateType, CANDIDATE_INFOEX *pstCandidateInfo, CWnd* pParent /*=NULL*/)\n\t: CDialog(CAddPersonDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CAddPersonDlg)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);\n\tmemset(m_szGroupId, 0, sizeof(m_szGroupId));\n\tstrncpy(m_szGroupId, pszGroupID, sizeof(m_szGroupId)-1);\n\tmemset(m_szGroupName, 0, sizeof(m_szGroupName));\n\tstrncpy(m_szGroupName, pszGroupName, sizeof(m_szGroupName)-1);\n\tmemset(m_szFilePath, 0, sizeof(m_szFilePath));\n\tm_lLoginID = lLoginHandle;\n\tm_nOpreateType = nOpreateType;\n\tmemset(&m_stCandiDateInfo, 0, sizeof(m_stCandiDateInfo));\n\tif (NULL != pstCandidateInfo)\n\t{\n\t\tmemcpy(&m_stCandiDateInfo, pstCandidateInfo, sizeof(m_stCandiDateInfo));\n\t}\n\tmemset(&m_stAddPersonInfo, 0, sizeof(m_stAddPersonInfo));\n}\n\nCAddPersonDlg::~CAddPersonDlg()\n{\n\n}\n\nBOOL CAddPersonDlg::OnInitDialog()\n{\n\tCDialog::OnInitDialog();\n\n\tg_SetWndStaticText(this);\n\n\tSetIcon(m_hIcon, TRUE);\t\t\t// Set big icon\n\tSetIcon(m_hIcon, FALSE);\t\t// Set small icon\n\n\tif (1 == m_nOpreateType) // add\n\t{\n\t\tSetWindowText(ConvertString(\"Add PersonInfo\"));\n\t}\n\telse if (2 == m_nOpreateType) // edit\n\t{\n\t\tSetWindowText(ConvertString(\"Edit PersonInfo\"));\n\n\t\tchar szSoftPath[512] = {0};\n\t\tint filelen = GetModuleFileName(NULL, szSoftPath, 512);\n\t\tint k = filelen;\n\t\twhile (szSoftPath[k] != '\\\\')\n\t\t{\n\t\t\tk--;\n\t\t}\n\t\tszSoftPath[k+1] = '\\0';\n\t\tCString filepath(szSoftPath);\n\t\tCString filename(\"Face\\\\RemoteFace\\\\SepectPerson.jpg\");\n\t\tCString strFile = filepath + filename;\n\t\tchar *pFileDst = strFile.GetBuffer(256);\n\t\tm_pPersonAddPic.SetImageFile(pFileDst);\n\n\t\tSYSTEMTIME daTime = {0};\n\t\tCDateTimeCtrl* pBirth = (CDateTimeCtrl*)GetDlgItem(IDC_AddPersonBirthDay);\n\t\t//invalid data\n\t\tif (m_stCandiDateInfo.stPersonInfo.wYear ==0 | \n\t\t\tm_stCandiDateInfo.stPersonInfo.byMonth ==0 |\n\t\t\tm_stCandiDateInfo.stPersonInfo.byDay == 0)\n\t\t{\n\t\t\tdaTime.wYear = 1900;\n\t\t\tdaTime.wMonth = 01;\n\t\t\tdaTime.wDay = 01;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdaTime.wYear = m_stCandiDateInfo.stPersonInfo.wYear;\n\t\t\tdaTime.wMonth = m_stCandiDateInfo.stPersonInfo.byMonth;\n\t\t\tdaTime.wDay = m_stCandiDateInfo.stPersonInfo.byDay;\n\t\t}\n\t\tpBirth->SetTime(&daTime);\n\t}\n\t\n\tm_cbSexType.ResetContent();\n\t\n\tm_cbSexType.InsertString(-1, ConvertString(\"Unlimited\"));\n\tm_cbSexType.InsertString(-1, ConvertString(\"Male\"));\n\tm_cbSexType.InsertString(-1, ConvertString(\"Female\"));\n\t\n\tm_cbSexType.SetCurSel(0);\n\t\n\tm_cbCardType.ResetContent();\n\t\n\tm_cbCardType.InsertString(-1, ConvertString(\"Unlimited\"));\n\tm_cbCardType.InsertString(-1, ConvertString(\"IC\"));\n\tm_cbCardType.InsertString(-1, ConvertString(\"Passport\"));\n\t\n\tm_cbCardType.SetCurSel(0);\n\n\tSetDlgItemText(IDC_EDIT_ADD_NAME, m_stCandiDateInfo.stPersonInfo.szPersonName);\n\tSetDlgItemText(IDC_EDIT_ADD_CARDID, m_stCandiDateInfo.stPersonInfo.szID);\n\n\tSetDlgItemText(IDC_AddPersonGroupID, m_szGroupId);\n\tSetDlgItemText(IDC_AddPersonGroupName, m_szGroupName);\n\t\n\tm_cbSexType.SetCurSel(m_stCandiDateInfo.stPersonInfo.bySex);\n\tm_cbCardType.SetCurSel(m_stCandiDateInfo.stPersonInfo.byIDType);\n\t\n\treturn TRUE;  // return TRUE  unless you set the focus to a control\n}\n\nvoid CAddPersonDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CAddPersonDlg)\n\tDDX_Control(pDX, IDC_COMBO_ADD_SEX, m_cbSexType);\n\tDDX_Control(pDX, IDC_COMBO_ADD_ACRDTYPE, m_cbCardType);\n\tDDX_Control(pDX, IDC_AddPersonBirthDay, m_BirthDay);\n\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n\tDDX_Control(pDX, IDC_STATIC_PERSON_PIC, m_pPersonAddPic);\n}\n\n\nBEGIN_MESSAGE_MAP(CAddPersonDlg, CDialog)\n\t//{{AFX_MSG_MAP(CAddPersonDlg)\n\tON_BN_CLICKED(IDC_OPEN_PIC, OnOpenPic)\n\t//}}AFX_MSG_MAP\n\tON_BN_CLICKED(IDOK, &CAddPersonDlg::OnBnClickedOk)\n\tON_WM_PAINT()\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CAddPersonDlg message handlers\n\nvoid CAddPersonDlg::OnOpenPic() \n{\n\tUSES_CONVERSION;\n\n\tchar *pFilePath = NULL;\n\tCString PicPath;\n\tCFileDialog dlg(TRUE, NULL, NULL, NULL, \n\t\t\"JPG files(*.jpg, *.JPG) | *.jpg; *.JPG |\", NULL);\n\tif (dlg.DoModal() == IDOK)\n\t{\n\t\tPicPath = dlg.GetPathName();\n\t\tpFilePath = PicPath.GetBuffer(512);\n\t\tmemcpy(m_szFilePath, pFilePath, sizeof(m_szFilePath));\n\n\t\tm_pPersonAddPic.SetImageFile(PicPath);\n\n\t}\n}\n\nvoid CAddPersonDlg::OnBnClickedOk()\n{\n\tNET_IN_OPERATE_FACERECONGNITIONDB stuInParam = {sizeof(stuInParam)};\n\tNET_OUT_OPERATE_FACERECONGNITIONDB stuOutParam = {sizeof(stuOutParam)};\n\n\tstuInParam.bUsePersonInfoEx = TRUE;\n\n\tif (m_nOpreateType == FACE_PERSON_ADD)\n\t{\n\t\tstuInParam.emOperateType = NET_FACERECONGNITIONDB_ADD;\n\t}\n\telse if (m_nOpreateType == FACE_PERSON_EDIT)\n\t{\n\t\tstuInParam.emOperateType = NET_FACERECONGNITIONDB_MODIFY;\n\t\tif (strlen(m_stCandiDateInfo.stPersonInfo.szUID))\n\t\t{\n\t\t\tstrncpy(stuInParam.stPersonInfoEx.szUID, m_stCandiDateInfo.stPersonInfo.szUID, sizeof(stuInParam.stPersonInfoEx.szUID)-1);\n\t\t}\n\t}\n\n\tCString strName;\n\tGetDlgItemText(IDC_EDIT_ADD_NAME, strName);\n\tchar *pstrName = (LPSTR)(LPCSTR)strName;\n\tstrncpy(stuInParam.stPersonInfoEx.szPersonName, pstrName, sizeof(stuInParam.stPersonInfoEx.szPersonName)-1);\n\tstuInParam.stPersonInfoEx.bySex = m_cbSexType.GetCurSel();\n\tstuInParam.stPersonInfoEx.byIDType = m_cbCardType.GetCurSel();\n\tCString strCardID;\n\tGetDlgItemText(IDC_EDIT_ADD_CARDID, strCardID);\n\tchar *pstrCardID = (LPSTR)(LPCSTR)strCardID;\n\tstrncpy(stuInParam.stPersonInfoEx.szID, pstrCardID, sizeof(stuInParam.stPersonInfoEx.szID)-1);\n\n\tCDateTimeCtrl *pCDataStart = (CDateTimeCtrl*)GetDlgItem(IDC_AddPersonBirthDay);\n\tSYSTEMTIME pstTime = {0};\n\t\n\tDWORD dwResult = m_BirthDay.GetTime(&pstTime);\n\tif (dwResult == GDT_VALID)\n\t{\n\t\tstuInParam.stPersonInfoEx.wYear = pstTime.wYear;\n\t\tstuInParam.stPersonInfoEx.byMonth = pstTime.wMonth;\n\t\tstuInParam.stPersonInfoEx.byDay = pstTime.wDay;\n\t}\n\n\tFILE *fPic = NULL;\n\tBOOL bRet = FALSE;\n\n\tstrncpy(stuInParam.stPersonInfoEx.szGroupName, m_szGroupName, sizeof(stuInParam.stPersonInfoEx.szGroupName)-1);\n\tstrncpy(stuInParam.stPersonInfoEx.szGroupID, m_szGroupId, sizeof(stuInParam.stPersonInfoEx.szGroupID)-1);\n\n\tif (strlen(m_szFilePath) > 0)\n\t{\n\t\tfPic = fopen(m_szFilePath, \"rb+\");\n\t\tif (fPic)\n\t\t{\n\t\t\tfseek(fPic, 0, SEEK_END);\n\t\t\tint nLength = ftell(fPic);\n\t\t\tif (nLength <= 0)\n\t\t\t{\n\t\t\t\tgoto FREE_RETURN;\n\t\t\t}\n\t\t\trewind(fPic);\n\n\t\t\tstuInParam.nBufferLen = nLength;\n\t\t\tstuInParam.pBuffer = new char[stuInParam.nBufferLen];\n\t\t\tif (NULL == stuInParam.pBuffer)\n\t\t\t{\n\t\t\t\tMessageBox(ConvertString(\"Memory error\"), \"\");\n\t\t\t\tgoto FREE_RETURN;\n\t\t\t}\n\t\t\tmemset(stuInParam.pBuffer, 0, stuInParam.nBufferLen);\n\t\t\tint nReadLen = fread(stuInParam.pBuffer, 1, nLength, fPic);\n\t\t\tif (nReadLen != nLength)\n\t\t\t{\n\t\t\t\tgoto FREE_RETURN;\n\t\t\t}\n\n\t\t\tstuInParam.stPersonInfoEx.wFacePicNum = 1;\n\t\t\tstuInParam.stPersonInfoEx.szFacePicInfo[0].dwOffSet = 0;\n\t\t\tstuInParam.stPersonInfoEx.szFacePicInfo[0].dwFileLenth = nLength;\n\t\t}\n\t}\n\n\tbRet = CLIENT_OperateFaceRecognitionDB(m_lLoginID, &stuInParam, &stuOutParam, DEFAULT_WAIT_TIME);\n\tif (!bRet)\n\t{\n\t\tif (FACE_PERSON_ADD == m_nOpreateType)\n\t\t{\n\t\t\tMessageBox(ConvertString(\"Failed to add this person info!\"), \"\");\n\t\t}\n\t\telse if (FACE_PERSON_EDIT == m_nOpreateType)\n\t\t{\n\t\t\tMessageBox(ConvertString(\"Failed to modify this person info!\"), \"\");\n\t\t}\n\t\tgoto FREE_RETURN;\n\t}\n\telse\n\t{\n\t\tif (FACE_PERSON_ADD == m_nOpreateType)\n\t\t{\n\t\t\tMessageBox(ConvertString(\"Success to add this person info!\"), \"\");\n\t\t}\n\t\telse if (FACE_PERSON_EDIT == m_nOpreateType)\n\t\t{\n\t\t\tMessageBox(ConvertString(\"Success to modify this person info!\"), \"\");\n\t\t}\n\t}\n\n\tmemcpy(&m_stAddPersonInfo, &stuInParam.stPersonInfoEx, sizeof(m_stAddPersonInfo));\n\tif (FACE_PERSON_ADD == m_nOpreateType)\n\t{\n\t\tstrncpy(m_stAddPersonInfo.szUID, stuOutParam.szUID, sizeof(m_stAddPersonInfo.szUID)-1);\n\t}\n\nFREE_RETURN:\n\tif (stuInParam.pBuffer)\n\t{\n\t\tdelete[] stuInParam.pBuffer;\n\t\tstuInParam.pBuffer = NULL;\n\t}\n\n\tif (fPic)\n\t{\n\t\tfclose(fPic);\n\t\tfPic = NULL;\n\t}\n}\n\nBOOL CAddPersonDlg::PreTranslateMessage(MSG* pMsg)\n{\n\tif(pMsg->message == WM_KEYDOWN &&\n\t\tpMsg->wParam == VK_RETURN)\n\t{\n\t\treturn TRUE;\n\t}\n\n\treturn CDialog::PreTranslateMessage(pMsg);\n}\n","size_bytes":8543},"bin/Demo/MfcDemo/10.AlarmDevice/DlgAnalogAlarmChannels.cpp":{"content":"// DlgAnalogAlarmChannels.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgAnalogAlarmChannels.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgAnalogAlarmChannels dialog\n\n\nCDlgAnalogAlarmChannels::CDlgAnalogAlarmChannels(CWnd* pParent /*=NULL*/, LLONG lLoginId)\n\t: CDialog(CDlgAnalogAlarmChannels::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgAnalogAlarmChannels)\n\tm_edtMaxCount = 0;\n\tm_edtRetCount = 0;\n\t//}}AFX_DATA_INIT\n\tm_lLoginId = lLoginId;\n\tmemset(&m_stuInfo, 0, sizeof(NET_ANALOGALARM_CHANNELS));\n\tm_stuInfo.dwSize = sizeof(NET_ANALOGALARM_CHANNELS);\n}\n\n\nvoid CDlgAnalogAlarmChannels::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgAnalogAlarmChannels)\n\tDDX_Control(pDX, IDC_ANALOGALARMCHANNELS_LIST_ANALOGCHANNELMAP, m_listAnalogChannelMap);\n\tDDX_Text(pDX, IDC_ANALOGALARMCHANNELS_EDIT_MAXCOUNT, m_edtMaxCount);\n\tDDX_Text(pDX, IDC_ANALOGALARMCHANNELS_EDIT_RETCOUNT, m_edtRetCount);\n\t//}}AFX_DATA_MAP\n\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgAnalogAlarmChannels, CDialog)\n\t//{{AFX_MSG_MAP(CDlgAnalogAlarmChannels)\n\tON_BN_CLICKED(IDC_ANALOGALARMCHANNELS_BTN_GET, OnAnalogalarmchannelsBtnGet)\n\tON_WM_DESTROY()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgAnalogAlarmChannels message handlers\n\nBOOL CDlgAnalogAlarmChannels::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_ANALOGALARMCHANNELS);\n\t// TODO: Add extra initialization here\n\tif (m_lLoginId == 0)\n\t{\n\t\tMessageBox(ConvertString(\"Please login first!\", DLG_ANALOGALARMCHANNELS), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\tGetDlgItem(IDC_ANALOGALARMCHANNELS_EDIT_RETCOUNT)->EnableWindow(FALSE);\n\t//SetDlgItemInt(IDC_ANALOGALARMCHANNELS_EDIT_MAXCOUNT, 16, FALSE);\n\tm_listAnalogChannelMap.SetExtendedStyle(m_listAnalogChannelMap.GetExtendedStyle()| LVS_EX_HEADERDRAGDROP | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES );\n\tm_listAnalogChannelMap.InsertColumn(0, ConvertString(\"Index\", DLG_ANALOGALARMCHANNELS), LVCFMT_LEFT, 60, -1);\n\tm_listAnalogChannelMap.InsertColumn(1, ConvertString(\"Slot\", DLG_ANALOGALARMCHANNELS), LVCFMT_LEFT, 60, -1);\n\tm_listAnalogChannelMap.InsertColumn(2, ConvertString(\"Level1\", DLG_ANALOGALARMCHANNELS), LVCFMT_LEFT, 60, -1);\n\tm_listAnalogChannelMap.InsertColumn(3, ConvertString(\"Level2\", DLG_ANALOGALARMCHANNELS), LVCFMT_LEFT, 60, -1);\n\tm_listAnalogChannelMap.InsertColumn(4, ConvertString(\"Name\", DLG_ANALOGALARMCHANNELS), LVCFMT_LEFT, 150, -1);\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgAnalogAlarmChannels::OnAnalogalarmchannelsBtnGet() \n{\n\t// TODO: Add your control notification handler code here\n\tif (!ApplyMemory())\n\t{\n\t\tMessageBox(ConvertString(\"new error!!!\", DLG_ANALOGALARMCHANNELS), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\tif (getInfoFromDevice())\n\t{\n\t\tShowInfo();\n\t}\n}\n\nBOOL CDlgAnalogAlarmChannels::getInfoFromDevice()\n{\n\tint nRetLen = 0;\n\tBOOL bRet = CLIENT_QueryDevState(m_lLoginId, DH_DEVSTATE_ANALOGALARM_CHANNELS, \n\t\t(char*)&m_stuInfo, sizeof(NET_ANALOGALARM_CHANNELS), &nRetLen, SDK_API_WAIT);\n\tif (!bRet)\n\t{\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"Query AnalogAlarmChannel failed:\", DLG_ANALOGALARMCHANNELS), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t} \n\telse\n\t{\n\t\treturn TRUE;\n\t}\n}\n\nBOOL CDlgAnalogAlarmChannels::ApplyMemory()\n{\n\tm_stuInfo.nMaxAnalogAlarmChannels = GetDlgItemInt(IDC_ANALOGALARMCHANNELS_EDIT_MAXCOUNT);\n\tif (m_stuInfo.nMaxAnalogAlarmChannels > 0)\n\t{\n\t\tif (m_stuInfo.pstuChannelInfo != NULL)\n\t\t{\n\t\t\tdelete []m_stuInfo.pstuChannelInfo;\n\t\t\tm_stuInfo.pstuChannelInfo = NULL;\n\t\t}\n\t\tm_stuInfo.pstuChannelInfo = new NET_ANALOGALARM_CHANNELS_INFO[m_stuInfo.nMaxAnalogAlarmChannels];\n\t\tif (m_stuInfo.pstuChannelInfo == NULL)\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t\tmemset(m_stuInfo.pstuChannelInfo, 0, sizeof(NET_ANALOGALARM_CHANNELS_INFO) * m_stuInfo.nMaxAnalogAlarmChannels);\n\t\tfor (int i = 0; i < m_stuInfo.nMaxAnalogAlarmChannels; i++)\n\t\t{\n\t\t\tm_stuInfo.pstuChannelInfo[i].dwSize = sizeof(NET_ANALOGALARM_CHANNELS_INFO);\n\t\t}\n\t}\n\t\n\treturn TRUE;\n}\n\nvoid CDlgAnalogAlarmChannels::ShowInfo()\n{\n\tSetDlgItemInt(IDC_ANALOGALARMCHANNELS_EDIT_RETCOUNT, m_stuInfo.nRetAnalogAlarmChannels, FALSE);\n\tint i = 0, nExAlarmRptIndex = 0;\n\tint nMinCount = __min(m_stuInfo.nRetAnalogAlarmChannels, m_stuInfo.nMaxAnalogAlarmChannels);\n\tm_listAnalogChannelMap.DeleteAllItems();\n\tfor (i = 0; i < nMinCount; ++i)\n\t{\n\t\tchar szIndex[10] = {0};\n\t\tchar szSlot[10] = {0};\n\t\tchar szLevel1[10] = {0};\n\t\tchar szLevel2[10] = {0};\n\t\t_itoa(i + 1, szIndex, 10);\n\t\t_itoa(m_stuInfo.pstuChannelInfo[i].nSlot, szSlot, 10);\n\t\t_itoa(m_stuInfo.pstuChannelInfo[i].nLevel1, szLevel1, 10);\n\t\t_itoa(m_stuInfo.pstuChannelInfo[i].nLevel2, szLevel2, 10);\n\t\tm_listAnalogChannelMap.InsertItem(nExAlarmRptIndex, NULL);\n\t\tm_listAnalogChannelMap.SetItemText(nExAlarmRptIndex, 0, szIndex);\n\t\tm_listAnalogChannelMap.SetItemText(nExAlarmRptIndex, 1, szSlot);\n\t\tm_listAnalogChannelMap.SetItemText(nExAlarmRptIndex, 2, szLevel1);\n\t\tm_listAnalogChannelMap.SetItemText(nExAlarmRptIndex, 3, szLevel2);\n\t\tm_listAnalogChannelMap.SetItemText(nExAlarmRptIndex, 4, m_stuInfo.pstuChannelInfo[i].szName);\n\t\tnExAlarmRptIndex++;\n\t}\n}\n\nvoid CDlgAnalogAlarmChannels::OnDestroy() \n{\n\tCDialog::OnDestroy();\n\t\n\t// TODO: Add your message handler code here\n\tif (m_stuInfo.pstuChannelInfo != NULL)\n\t{\n\t\tdelete []m_stuInfo.pstuChannelInfo;\n\t\tm_stuInfo.pstuChannelInfo = NULL;\n\t}\n\n}\n","size_bytes":5680},"bin/Demo/MfcDemo/22.ThermalCamera/GlobalDlg.cpp":{"content":"// GlobalDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"ThermalCamera.h\"\n#include \"GlobalDlg.h\"\n#include \"ThermalCameraDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CGlobalDlg dialog\n\n\nCGlobalDlg::CGlobalDlg(CWnd* pParent /*=NULL*/,LLONG lLoginId)\n\t: CDialog(CGlobalDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CGlobalDlg)\n\tm_nHumidity = 0;\n\tm_fAtmosphericTemp = 0.0f;\n\tm_fCoefficient = 0.0f;\n\tm_nDistance = 0;\n\tm_fReflectedTemp = 0.0f;\n\tm_nSatTemp = 0;\n\tm_nMaxTemp = 0;\n\tm_nMidTemp = 0;\n\tm_nMinTemp = 0;\n\tm_nBottom = 0;\n\tm_nLeft = 0;\n\tm_nRight = 0;\n\tm_nTop = 0;\n\tm_nHighAlpha = 0;\n\tm_nHighBlue = 0;\n\tm_nHighGreen = 0;\n\tm_nHighRed = 0;\n\tm_nLowAlpha = 0;\n\tm_nLowBlue = 0;\n\tm_nLowGreen = 0;\n\tm_nLowRed = 0;\n\t//}}AFX_DATA_INIT\n    m_iLoginID = lLoginId;\n}\n\n\nvoid CGlobalDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CGlobalDlg)\n\tDDX_Control(pDX, IDC_COMBO_UNIT, m_Combo_Unit);\n\tDDX_Control(pDX, IDC_COMBO_SWITCH, m_Combo_Switch);\n\tDDX_Control(pDX, IDC_COMBO_HOTSPOTFOLLOW, m_Combo_HotSpotFollow);\n\tDDX_Control(pDX, IDC_COMBO_COLORBAR, m_Combo_ColorBar);\n\tDDX_Control(pDX, IDC_COMBO_COLORBATCH, m_Combo_ColorBatch);\n\tDDX_Text(pDX, IDC_EDIT_RELATIVE_HUMIDITY, m_nHumidity);\n\tDDX_Text(pDX, IDC_EDIT_ATMOSPHERICTEMP, m_fAtmosphericTemp);\n\tDDX_Text(pDX, IDC_EDIT_COEFFICIENT, m_fCoefficient);\n\tDDX_Text(pDX, IDC_EDIT_DISTANCE, m_nDistance);\n\tDDX_Text(pDX, IDC_EDIT_RETEMP, m_fReflectedTemp);\n\tDDX_Text(pDX, IDC_EDIT_SATURATIONTEMP, m_nSatTemp);\n\tDDX_Text(pDX, IDC_EDIT_MAXTEMP, m_nMaxTemp);\n\tDDX_Text(pDX, IDC_EDIT_MIDTEMP, m_nMidTemp);\n\tDDX_Text(pDX, IDC_EDIT_MINTEMP, m_nMinTemp);\n\tDDX_Text(pDX, IDC_EDIT_COLORTEMP_BOTTOM, m_nBottom);\n\tDDX_Text(pDX, IDC_EDIT_COLORTEMP_LEFT, m_nLeft);\n\tDDX_Text(pDX, IDC_EDIT_COLORTEMP_RIGHT, m_nRight);\n\tDDX_Text(pDX, IDC_EDIT_COLORTEMP_TOP, m_nTop);\n\tDDX_Text(pDX, IDC_EDIT_HIGH_ALPHA, m_nHighAlpha);\n\tDDX_Text(pDX, IDC_EDIT_HIGH_BLUE, m_nHighBlue);\n\tDDX_Text(pDX, IDC_EDIT_HIGH_GREEN, m_nHighGreen);\n\tDDX_Text(pDX, IDC_EDIT_HIGH_RED, m_nHighRed);\n\tDDX_Text(pDX, IDC_EDIT_LOW_ALPHA, m_nLowAlpha);\n\tDDX_Text(pDX, IDC_EDIT_LOW_BLUE, m_nLowBlue);\n\tDDX_Text(pDX, IDC_EDIT_LOW_GREEN, m_nLowGreen);\n\tDDX_Text(pDX, IDC_EDIT_LOW_RED, m_nLowRed);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CGlobalDlg, CDialog)\n\t//{{AFX_MSG_MAP(CGlobalDlg)\n\tON_BN_CLICKED(IDC_BTN_SET, OnBtnSet)\n\tON_BN_CLICKED(IDC_BTN_GET, OnBtnGet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CGlobalDlg message handlers\n\nBOOL CGlobalDlg::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n    char szJsonBuf[1024 * 40] = {0};\n    int nerror = 0;\n    int nChannel = 1;\n    \n    BOOL ret = CLIENT_GetNewDevConfig(m_iLoginID,CFG_CMD_THERMOMETRY,nChannel,szJsonBuf,1024*40,&nerror,3000);\n    if (0 != ret)\n    {\n        CFG_THERMOMETRY_INFO stuInfo = {0};\n        DWORD dwRetLen = 0;\n        ret = CLIENT_ParseData(CFG_CMD_THERMOMETRY,szJsonBuf,(void*)&stuInfo,sizeof(stuInfo),&dwRetLen);\n        if (!ret)\n        {\n            return FALSE;\n        }\n        else\n        {\n            m_nHumidity = stuInfo.nRelativeHumidity;\n            m_fAtmosphericTemp = stuInfo.fAtmosphericTemperature;\n            m_fCoefficient = stuInfo.fObjectEmissivity;\n            m_nDistance = stuInfo.nObjectDistance;\n            m_fReflectedTemp = stuInfo.fReflectedTemperature;\n            m_Combo_ColorBatch.SetCurSel(stuInfo.bIsothermEnable);\n            m_Combo_Unit.SetCurSel(stuInfo.nTemperatureUnit);\n            m_nMinTemp = stuInfo.nMinLimitTemp;\n            m_nMidTemp = stuInfo.nMediumTemp;\n            m_nMaxTemp = stuInfo.nMaxLimitTemp;\n            m_nSatTemp = stuInfo.nSaturationTemp;\n            m_nTop = stuInfo.stIsothermRect.nTop;\n            m_nLeft = stuInfo.stIsothermRect.nLeft;\n            m_nRight = stuInfo.stIsothermRect.nRight;\n            m_nBottom = stuInfo.stIsothermRect.nBottom;\n            m_Combo_ColorBar.SetCurSel(stuInfo.bColorBarDisplay);\n            m_Combo_HotSpotFollow.SetCurSel(stuInfo.bHotSpotFollow);\n            m_Combo_Switch.SetCurSel(stuInfo.bTemperEnable);\n            m_nHighRed = stuInfo.stHighCTMakerColor.nRed;\n            m_nHighBlue = stuInfo.stHighCTMakerColor.nBlue;\n            m_nHighGreen = stuInfo.stHighCTMakerColor.nGreen;\n            m_nHighAlpha = stuInfo.stHighCTMakerColor.nAlpha;\n            m_nLowRed = stuInfo.stLowCTMakerColor.nRed;\n            m_nLowBlue = stuInfo.stLowCTMakerColor.nBlue;\n            m_nLowGreen = stuInfo.stLowCTMakerColor.nGreen;\n            m_nLowAlpha = stuInfo.stLowCTMakerColor.nAlpha;\n        }\n    }\n    else\n    {\n        return FALSE;\n    }\n\t\n\tUpdateData(FALSE);\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\n\nvoid CGlobalDlg::OnBtnSet() \n{\n    UpdateData();\n    CFG_THERMOMETRY_INFO stuInfo = {0};\n    stuInfo.nRelativeHumidity = m_nHumidity;\n    stuInfo.fAtmosphericTemperature = m_fAtmosphericTemp;\n    stuInfo.fObjectEmissivity = m_fCoefficient;\n    stuInfo.nObjectDistance = m_nDistance;\n    stuInfo.fReflectedTemperature = m_fReflectedTemp;\n    stuInfo.bIsothermEnable = m_Combo_ColorBatch.GetCurSel();\n    stuInfo.nTemperatureUnit = m_Combo_Unit.GetCurSel();\n    stuInfo.nMinLimitTemp = m_nMinTemp;\n    stuInfo.nMediumTemp = m_nMidTemp;\n    stuInfo.nMaxLimitTemp = m_nMaxTemp;\n    stuInfo.nSaturationTemp = m_nSatTemp;\n    stuInfo.stIsothermRect.nTop = m_nTop;\n    stuInfo.stIsothermRect.nLeft = m_nLeft;\n    stuInfo.stIsothermRect.nRight = m_nRight;\n    stuInfo.stIsothermRect.nBottom = m_nBottom;\n    stuInfo.bColorBarDisplay = m_Combo_ColorBar.GetCurSel();\n    stuInfo.bHotSpotFollow = m_Combo_HotSpotFollow.GetCurSel();\n    stuInfo.bTemperEnable = m_Combo_Switch.GetCurSel();\n    stuInfo.stHighCTMakerColor.nRed = m_nHighRed;\n    stuInfo.stHighCTMakerColor.nBlue = m_nHighBlue;\n    stuInfo.stHighCTMakerColor.nGreen = m_nHighGreen;\n    stuInfo.stHighCTMakerColor.nAlpha = m_nHighAlpha;\n    stuInfo.stLowCTMakerColor.nRed = m_nLowRed;\n    stuInfo.stLowCTMakerColor.nBlue = m_nLowBlue;\n    stuInfo.stLowCTMakerColor.nGreen = m_nLowGreen;\n    stuInfo.stLowCTMakerColor.nAlpha = m_nLowAlpha;\n    char szJsonBuf[1024 * 40] = {0};\n    BOOL bRet = CLIENT_PacketData(CFG_CMD_THERMOMETRY, &stuInfo, sizeof(stuInfo), szJsonBuf, sizeof(szJsonBuf));\n    if (!bRet)\n    {\n        \n    } \n    else\n    {\n        int nerror = 0;\n        int nrestart = 0;\n        int nChannelID = -1;\n        bRet = CLIENT_SetNewDevConfig(m_iLoginID, CFG_CMD_THERMOMETRY, nChannelID, szJsonBuf, strlen(szJsonBuf), &nerror, &nrestart, 3000);\n        if (!bRet)\n        {\n            \n        }\n        \n    }\n}\n\nvoid CGlobalDlg::OnBtnGet() \n{\n    char szJsonBuf[1024 * 40] = {0};\n    int nerror = 0;\n    int nChannel = -1;\n    \n    BOOL ret = CLIENT_GetNewDevConfig(m_iLoginID,CFG_CMD_THERMOMETRY,nChannel,szJsonBuf,1024*40,&nerror,3000);\n    if (0 != ret)\n    {\n        CFG_THERMOMETRY_INFO stuInfo = {0};\n        DWORD dwRetLen = 0;\n        ret = CLIENT_ParseData(CFG_CMD_THERMOMETRY,szJsonBuf,(char*)&stuInfo,sizeof(stuInfo),&dwRetLen);\n        if (!ret)\n        {\n            MessageBox(ConvertString(\"getconfig error\"), ConvertString(\"Prompt\"));\n            return ;\n        }\n        else\n        {\n            m_nHumidity = stuInfo.nRelativeHumidity;\n            m_fAtmosphericTemp = stuInfo.fAtmosphericTemperature;\n            m_fCoefficient = stuInfo.fObjectEmissivity;\n            m_nDistance = stuInfo.nObjectDistance;\n            m_fReflectedTemp = stuInfo.fReflectedTemperature;\n            m_Combo_ColorBatch.SetCurSel(stuInfo.bIsothermEnable);\n            m_Combo_Unit.SetCurSel(stuInfo.nTemperatureUnit);\n            m_nMinTemp = stuInfo.nMinLimitTemp;\n            m_nMidTemp = stuInfo.nMediumTemp;\n            m_nMaxTemp = stuInfo.nMaxLimitTemp;\n            m_nSatTemp = stuInfo.nSaturationTemp;\n            m_nTop = stuInfo.stIsothermRect.nTop;\n            m_nLeft = stuInfo.stIsothermRect.nLeft;\n            m_nRight = stuInfo.stIsothermRect.nRight;\n            m_nBottom = stuInfo.stIsothermRect.nBottom;\n            m_Combo_ColorBar.SetCurSel(stuInfo.bColorBarDisplay);\n            m_Combo_HotSpotFollow.SetCurSel(stuInfo.bHotSpotFollow);\n            m_Combo_Switch.SetCurSel(stuInfo.bTemperEnable);\n            m_nHighRed = stuInfo.stHighCTMakerColor.nRed;\n            m_nHighBlue = stuInfo.stHighCTMakerColor.nBlue;\n            m_nHighGreen = stuInfo.stHighCTMakerColor.nGreen;\n            m_nHighAlpha = stuInfo.stHighCTMakerColor.nAlpha;\n            m_nLowRed = stuInfo.stLowCTMakerColor.nRed;\n            m_nLowBlue = stuInfo.stLowCTMakerColor.nBlue;\n            m_nLowGreen = stuInfo.stLowCTMakerColor.nGreen;\n            m_nLowAlpha = stuInfo.stLowCTMakerColor.nAlpha;\n            \n        }\n    }\n    else\n    {\n        MessageBox(ConvertString(\"getconfig error\"), ConvertString(\"Prompt\"));\n        return ;\n    }\n    \n\tUpdateData(FALSE);\n}\n","size_bytes":9073},"bin/Demo/MfcDemo/10.AlarmDevice/DlgSetNetWorkParam.cpp":{"content":"// DlgSetNetWorkParam.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgSetNetWorkParam.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgSetNetWorkParam dialog\n\n\nCDlgSetNetWorkParam::CDlgSetNetWorkParam(CWnd* pParent /*=NULL*/, LLONG lLoginId /*=0*/)\n\t: CDialog(CDlgSetNetWorkParam::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgSetNetWorkParam)\n\tm_edConnectBufSize = 0;\n\tm_edConnectTime = 0;\n\tm_edConnectTryNum = 0;\n\tm_edGetDevInfoTime = 0;\n\tm_edPicBufSize = 0;\n\tm_edPlaybackBufSize = 0;\n\tm_edSearchRecordTime = 0;\n\tm_edSubConnectSpaceTime = 0;\n\tm_edSubDisconnectTime = 0;\n\tm_edWaittime = 0;\n\tm_edGetConnInfoTime = 0;\n\t//}}AFX_DATA_INIT\n\tm_lLoginId = lLoginId;\n\tmemset(&m_stuInfo, 0, sizeof(NET_PARAM));\n}\n\nvoid CDlgSetNetWorkParam::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgSetNetWorkParam)\n\tDDX_Control(pDX, IDC_SETNETWORKPARAM_CMB_NETTYPE, m_cmbNetType);\n\tDDX_Text(pDX, IDC_SETNETWORKPARAM_EDT_CONNECTBUFSIZE, m_edConnectBufSize);\n\tDDX_Text(pDX, IDC_SETNETWORKPARAM_EDT_CONNECTTIME, m_edConnectTime);\n\tDDX_Text(pDX, IDC_SETNETWORKPARAM_EDT_CONNECTTRYNUM, m_edConnectTryNum);\n\tDDX_Text(pDX, IDC_SETNETWORKPARAM_EDT_GETDEVINFOTIME, m_edGetDevInfoTime);\n\tDDX_Text(pDX, IDC_SETNETWORKPARAM_EDT_PICBUFSIZE, m_edPicBufSize);\n\tDDX_Text(pDX, IDC_SETNETWORKPARAM_EDT_PLAYBACKBUFSIZE, m_edPlaybackBufSize);\n\tDDX_Text(pDX, IDC_SETNETWORKPARAM_EDT_SEARCHRECORDTIME, m_edSearchRecordTime);\n\tDDX_Text(pDX, IDC_SETNETWORKPARAM_EDT_SUBCONNECTSPACETIME, m_edSubConnectSpaceTime);\n\tDDX_Text(pDX, IDC_SETNETWORKPARAM_EDT_SUBDISCONNETTIME, m_edSubDisconnectTime);\n\tDDX_Text(pDX, IDC_SETNETWORKPARAM_EDT_WAITTIME, m_edWaittime);\n\tDDX_Text(pDX, IDC_SETNETWORKPARAM_EDT_GETCONNINFOTIME, m_edGetConnInfoTime);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgSetNetWorkParam, CDialog)\n\t//{{AFX_MSG_MAP(CDlgSetNetWorkParam)\n\tON_BN_CLICKED(IDC_SETNETWORKPARAM_BTN_SET, OnSetnetworkparamBtnSet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgSetNetWorkParam message handlers\n\nBOOL CDlgSetNetWorkParam::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\t// TODO: Add extra initialization here\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_SETNETWORKPARAM);\n\t\n\tif (m_lLoginId == 0)\n\t{\n\t\tMessageBox(ConvertString(CString(\"we haven't login a device yet!\"), DLG_SETNETWORKPARAM), ConvertString(\"Prompt\"));\n\t\treturn TRUE;\n\t}\n\t\n\tm_cmbNetType.ResetContent();\n\tm_cmbNetType.InsertString(-1, ConvertString(\"LAN\", DLG_SETNETWORKPARAM));\n\tm_cmbNetType.InsertString(-1, ConvertString(\"WAN\", DLG_SETNETWORKPARAM));\n\n\tInit();\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t// EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgSetNetWorkParam::OnSetnetworkparamBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n\tif (m_lLoginId == 0)\n\t{\n\t\tMessageBox(ConvertString(CString(\"we haven't login a device yet!\"), DLG_SETNETWORKPARAM), ConvertString(\"Prompt\"));\n\t\treturn ;\n\t}\n\tDlgToStu();\n\tCLIENT_SetNetworkParam(&m_stuInfo);\n\tMessageBox(ConvertString(CString(\"set network param ok!\"), DLG_SETNETWORKPARAM), ConvertString(\"Prompt\"));\n}\n\nvoid CDlgSetNetWorkParam::Init()\n{\n\tm_edConnectBufSize = 250;\n\tm_edConnectTime = 1500;\n\tm_edConnectTryNum = 1;\n\tm_edGetDevInfoTime = 1000;\n\tm_edPicBufSize = 2;\n\tm_edPlaybackBufSize = 4;\n\tm_edSearchRecordTime = 3000;\n\tm_edSubConnectSpaceTime = 10;\n\tm_edSubDisconnectTime = 60000;\n\tm_edWaittime = 5000;\n\tm_edGetConnInfoTime = 1000;\n\tm_cmbNetType.SetCurSel(0);\n\tUpdateData(FALSE);\n}\n\nvoid CDlgSetNetWorkParam::DlgToStu()\n{\n\tUpdateData(TRUE);\n\tm_stuInfo.nWaittime = m_edWaittime;\n\tm_stuInfo.nConnectTime = m_edConnectTime;\n\tm_stuInfo.nConnectTryNum = m_edConnectTryNum;\n\tm_stuInfo.nSubConnectSpaceTime = m_edSubConnectSpaceTime;\n\tm_stuInfo.nGetDevInfoTime = m_edGetDevInfoTime;\n\tm_stuInfo.nConnectBufSize = m_edConnectBufSize * 1024;\n\tm_stuInfo.nGetConnInfoTime = m_edGetConnInfoTime;\n\tm_stuInfo.nSearchRecordTime = m_edSearchRecordTime;\n\tm_stuInfo.nsubDisconnetTime = m_edSubDisconnectTime;\n\tm_stuInfo.byNetType = m_cmbNetType.GetCurSel();\n\tm_stuInfo.byPlaybackBufSize = m_edPlaybackBufSize;\n\tm_stuInfo.nPicBufSize = m_edPicBufSize * 1024 * 1024;\n}\n","size_bytes":4381},"bin/Demo/MfcDemo/13.FaceRecognition/PersonOpreateDlg.cpp":{"content":"// PersonOpreateDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"FaceRecognition.h\"\n#include \"PersonOpreateDlg.h\"\n#include \"AddPersonDlg.h\"\n#include <atlconv.h>\n#include <assert.h>\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CPersonOpreateGlg dialog\n\n\nCPersonOpreateGlg::CPersonOpreateGlg(const LLONG lLoginHandle, const char* pszGroupId, const char* pszGroupName, char* pstSoftPath, CWnd* pParent /*=NULL*/)\n\t: CDialog(CPersonOpreateGlg::IDD, pParent)\n{\n\tm_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);\n\n\tm_lLoginID = lLoginHandle;\n\tm_nCurPos = 0;\n\tm_nPersonCount = 0;\n\tm_pstPersonSelectInfo = NULL;\n\tm_pszSoftPath = pstSoftPath;\n\tstrncpy(m_szGroupId, pszGroupId, sizeof(m_szGroupId)-1);\n\tstrncpy(m_szGroupName, pszGroupName, sizeof(m_szGroupName)-1);\n\tmemset(m_szSelectPersonFile, 0, sizeof(m_szSelectPersonFile));\n\tm_lFindPersonHandle = 0;\n\tm_pPersonInfoList = NULL;\n\n\tif (NULL == m_pPersonInfoList)\n\t{\n\t\tm_pPersonInfoList = new NET_PERSON_LIST_INFO[10];\n\t\tif (m_pPersonInfoList)\n\t\t{\n\t\t\tmemset(m_pPersonInfoList, 0, sizeof(NET_PERSON_LIST_INFO)*10);\n\t\t\tfor (int i = 0; i < 10; i++)\n\t\t\t{\n\t\t\t\tNET_PERSON_LIST_INFO *pstPersonListInfo = m_pPersonInfoList + i;\n\t\t\t\tpstPersonListInfo->stuCandidate.stPersonInfo.szFacePicInfo[0].pszFilePath = new char[256];\n\t\t\t\tif (pstPersonListInfo->stuCandidate.stPersonInfo.szFacePicInfo[0].pszFilePath)\n\t\t\t\t{\n\t\t\t\t\tmemset(pstPersonListInfo->stuCandidate.stPersonInfo.szFacePicInfo[0].pszFilePath, 0, 256);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//{{AFX_DATA_INIT(CPersonOpreateGlg)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\nCPersonOpreateGlg::~CPersonOpreateGlg()\n{\n\tDeleteFile(m_szSelectPersonFile);\n\n\tif (m_lFindPersonHandle)\n\t{\n\t\tCLIENT_StopFindFaceRecognition(m_lFindPersonHandle);\n\t\tm_lFindPersonHandle = 0;\n\t}\n\n\tif (m_pPersonInfoList)\n\t{\n\t\tfor (int i = 0; i < 10; i++)\n\t\t{\n\t\t\tNET_PERSON_LIST_INFO *pstPersonListInfo = m_pPersonInfoList + i;\n\t\t\tif (pstPersonListInfo->stuCandidate.stPersonInfo.szFacePicInfo[0].pszFilePath)\n\t\t\t{\n\t\t\t\tdelete[] pstPersonListInfo->stuCandidate.stPersonInfo.szFacePicInfo[0].pszFilePath;\n\t\t\t\tpstPersonListInfo->stuCandidate.stPersonInfo.szFacePicInfo[0].pszFilePath = NULL;\n\t\t\t}\n\t\t}\n\n\t\tdelete[] m_pPersonInfoList;\n\t\tm_pPersonInfoList = NULL;\n\t\tm_pstPersonSelectInfo= NULL;\n\t}\n}\n\nBOOL CPersonOpreateGlg::OnInitDialog()\n{\n\tCDialog::OnInitDialog();\n\n\tg_SetWndStaticText(this);\n\n\tSetDlgItemText(IDC_PersonGroupID, m_szGroupId);\n\tSetDlgItemText(IDC_PersonGroupName, m_szGroupName);\n\n\tm_cbSexType.ResetContent();\n\tm_cbSexType.InsertString(-1, ConvertString(\"Unlimited\"));\n\tm_cbSexType.InsertString(-1, ConvertString(\"Male\"));\n\tm_cbSexType.InsertString(-1, ConvertString(\"Female\"));\n\tm_cbSexType.SetCurSel(0);\n\n\tm_cbCardType.ResetContent();\t\n\tm_cbCardType.InsertString(-1, ConvertString(\"Unlimited\"));\n\tm_cbCardType.InsertString(-1, ConvertString(\"IC\"));\n\tm_cbCardType.InsertString(-1, ConvertString(\"Passport\"));\t\n\tm_cbCardType.SetCurSel(0);\n\n\tGetDlgItem(IDC_BUTTON_PER)->EnableWindow(FALSE);\n\tGetDlgItem(IDC_BUTTON_NEXT)->EnableWindow(FALSE);\n\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tGetDlgItem(IDC_RADIO_PERSON1+i)->EnableWindow(FALSE);\n\t}\n\n\tSetIcon(m_hIcon, TRUE);\t\t\t// Set big icon\n\tSetIcon(m_hIcon, FALSE);\t\t// Set small icon\n\n\tFillCWndWithDefaultColor(GetDlgItem(IDC_SELECT_PersonPicture));\n\t\n\treturn TRUE;  // return TRUE  unless you set the focus to a control\n}\n\n\nvoid CPersonOpreateGlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CPersonOpreateGlg)\n\tDDX_Control(pDX, IDC_COMBO_SEX, m_cbSexType);\n\tDDX_Control(pDX, IDC_COMBO_CARDTYPE, m_cbCardType);\n\t//DDX_DateTimeCtrl(pDX, IDC_PersonBirthDayStart, m_BirthDayStart);\n\t//DDX_DateTimeCtrl(pDX, IDC_PersonBirthDayEnd, m_BirthDayEnd);\n\n\tDDX_Control(pDX, IDC_PersonBirthDayStart, m_BirthDayStart);\n\tDDX_Control(pDX, IDC_PersonBirthDayEnd, m_BirthDayEnd);\n\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n\tDDX_Control(pDX, IDC_SELECT_PersonPicture, m_pPersonPic);\n}\n\n\nBEGIN_MESSAGE_MAP(CPersonOpreateGlg, CDialog)\n\t//{{AFX_MSG_MAP(CPersonOpreateGlg)\n\tON_BN_CLICKED(IDC_BUTTON_NEXT, OnButtonNext)\n\tON_BN_CLICKED(IDC_BUTTON_PER, OnButtonPer)\n\tON_BN_CLICKED(IDC_BUTTON_PERSON_ADD, OnButtonPersonAdd)\n\tON_BN_CLICKED(IDC_BUTTON_PERSON_EDIT, OnButtonPersonEdit)\n\tON_BN_CLICKED(IDC_RADIO_PERSON1, OnSelectPersonInfo)\n\tON_BN_CLICKED(IDC_RADIO_PERSON2, OnSelectPersonInfo)\n\tON_BN_CLICKED(IDC_RADIO_PERSON3, OnSelectPersonInfo)\n\tON_BN_CLICKED(IDC_RADIO_PERSON4, OnSelectPersonInfo)\n\tON_BN_CLICKED(IDC_RADIO_PERSON5, OnSelectPersonInfo)\n\tON_BN_CLICKED(IDC_RADIO_PERSON6, OnSelectPersonInfo)\n\tON_BN_CLICKED(IDC_RADIO_PERSON7, OnSelectPersonInfo)\n\tON_BN_CLICKED(IDC_RADIO_PERSON8, OnSelectPersonInfo)\n\tON_BN_CLICKED(IDC_RADIO_PERSON9, OnSelectPersonInfo)\n\tON_BN_CLICKED(IDC_RADIO_PERSON10, OnSelectPersonInfo)\n\tON_BN_CLICKED(IDC_BUTTON_PERSON_DEL, OnButtonPersonDel)\n\t//}}AFX_MSG_MAP\n\tON_BN_CLICKED(IDOK, &CPersonOpreateGlg::OnBnClickedSearch)\n\tON_WM_PAINT()\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n\n\nvoid CPersonOpreateGlg::ClearShowCandidateInfo()\n{\n\tCString str;\n\tfor(int i = 0; i < 10; i++)\n\t{\n\t\tint nId = IDC_EDIT_NAME1+i;\n\t\tSetDlgItemText(nId, \"\");\n\n\t\tnId = IDC_EDIT_INDEX1+i;\n\t\tSetDlgItemText(nId, \"\");\n\t\t\t\n\t\tnId = IDC_EDIT_SEX1 + i;\n\t\tSetDlgItemText(nId, \"\");\n\t\t\t\n\t\tnId = IDC_EDIT_CITY1 + i;\n\t\tSetDlgItemText(nId, \"\");\n\t\t\t\n\t\tnId = IDC_EDIT_CARDTYPE1 + i;\n\t\tSetDlgItemText(nId, \"\");\n\t\t\t\n\t\tnId = IDC_EDIT_CARDNUMBER1 + i;\n\t\tSetDlgItemText(nId, \"\");\n\n\t\tnId = IDC_BIRTHDAY1 + i;\n\t\tSetDlgItemText(nId, \"\");\n\n\t\tnId = IDC_BIRTHDAY_MONTH1 + i;\n\t\tSetDlgItemText(nId, \"\");\n\n\t\tnId = IDC_BIRTHDAY_DAY1 + i;\n\t\tSetDlgItemText(nId, \"\");\n\n\t\tnId = IDC_RADIO_PERSON1+i;\n\t\t((CButton*)GetDlgItem(nId))->SetCheck(0);\n\t\tGetDlgItem(nId)->EnableWindow(FALSE);\n\n\t\tFillCWndWithDefaultColor(GetDlgItem(IDC_SELECT_PersonPicture));\n\t\tm_pPersonPic.SetImageFile(NULL);\n\t}\t\n}\n\nvoid CPersonOpreateGlg::ShowCandidateInfo(int nCount)\n{\n\tif (m_pPersonInfoList && nCount <= 10)\n\t{\n\t\tCString str;\n\t\tfor (int i = 0; i < nCount; i++)\n\t\t{\n\t\t\tNET_PERSON_LIST_INFO *pstPersonListInfo = m_pPersonInfoList + i;\n\t\t\tCANDIDATE_INFOEX *pstCandidateInfo = &(pstPersonListInfo->stuCandidate);\n\t\t\tFACERECOGNITION_PERSON_INFOEX *pstPersonInfo = &(pstCandidateInfo->stPersonInfo);\n\n\t\t\tint nId = IDC_EDIT_NAME1+i;\n\t\t\tstr.Format(\"%s\", pstPersonInfo->szPersonName);\n\t\t\tSetDlgItemText(nId, str);\n\n\t\t\tnId = IDC_EDIT_INDEX1 + i;\n\t\t\tstr.Format(\"%d\", pstPersonListInfo->nNumber);\n\t\t\tSetDlgItemText(nId, str);\n\n\t\t\tnId = IDC_EDIT_SEX1 + i;\n\t\t\tif (1 == pstPersonInfo->bySex)\n\t\t\t{\n\t\t\t\tSetDlgItemText(nId, ConvertString(\"Male\"));\n\t\t\t}\n\t\t\telse if (2 == pstPersonInfo->bySex)\n\t\t\t{\n\t\t\t\tSetDlgItemText(nId, ConvertString(\"Female\"));\n\t\t\t}\n\n\t\t\tchar szBirthday[11] = {0};\n\t\t\t_snprintf(szBirthday, sizeof(szBirthday)-1, \"%04d-%02d-%02d\", pstPersonInfo->wYear, pstPersonInfo->byMonth, pstPersonInfo->byDay);\n\t\t\tnId = IDC_BIRTHDAY1 + i;\n\t\t\tstr.Format(\"%s\", szBirthday);\n\t\t\tSetDlgItemText(nId, str);\n\n\t\t\tnId = IDC_EDIT_CARDTYPE1 + i;\n\t\t\tif (1 == pstPersonInfo->byIDType)\n\t\t\t{\n\t\t\t\tSetDlgItemText(nId, ConvertString(\"IC\"));\n\t\t\t}\n\t\t\telse if (2 == pstPersonInfo->byIDType)\n\t\t\t{\n\t\t\t\tSetDlgItemText(nId, ConvertString(\"Passport\"));\n\t\t\t}\n\n\t\t\tnId = IDC_EDIT_CARDNUMBER1 + i;\n\t\t\tstr.Format(\"%s\", pstPersonInfo->szID);\n\t\t\tSetDlgItemText(nId, str);\n\n\t\t\tnId = IDC_RADIO_PERSON1+i;\n\t\t\tGetDlgItem(nId)->EnableWindow(TRUE);\n\t\t}\n\t}\n}\n\nvoid CPersonOpreateGlg::SearchPersonInfoFromGroup()\n{\n\tif (0 == m_nPersonCount)\n\t{\n\t\treturn;\n\t}\n\n\tBOOL bRet = FALSE;\n\t\n\tNET_IN_DOFIND_FACERECONGNITION stuInDoFind = {sizeof(stuInDoFind)};\n\tNET_OUT_DOFIND_FACERECONGNITION stuOutDoFind = {sizeof(stuOutDoFind)};\n\tstuOutDoFind.bUseCandidatesEx = TRUE;\n\t\n\tconst int nQueryNum = 10;\n\tconst int nFilePathLen = 256;\n\tfor (int n = 0; n < nQueryNum; n++)\n\t{\n\t\tstuOutDoFind.stuCandidatesEx[n].stPersonInfo.szFacePicInfo[0].pszFilePath = new char[nFilePathLen];\n\t\tstuOutDoFind.stuCandidatesEx[n].stPersonInfo.szFacePicInfo[0].nFilePathLen = nFilePathLen;\n\t}\n\n\tstuInDoFind.lFindHandle = m_lFindPersonHandle;\n\tstuInDoFind.emDataType = EM_NEEDED_PIC_TYPE_HTTP_URL;\n\tstuInDoFind.nCount = nQueryNum;\n\tint nBegin = m_nCurPos;\n\tint nCountIndex = m_nCurPos;\n\t\n\tstuInDoFind.nBeginNum = m_nCurPos;\n\tbRet = CLIENT_DoFindFaceRecognition(&stuInDoFind, &stuOutDoFind, DEFAULT_WAIT_TIME);\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Failed to do find face recognition!\"), \"\");\n\t\tgoto FREE_DATA;\n\t}\n\n\tfor (int i = 0; i < stuOutDoFind.nCadidateExNum; i++)\n\t{\n\t\tNET_PERSON_LIST_INFO *pstPersonListInfo = m_pPersonInfoList+i;\n\t\tchar*  pszFilePath = pstPersonListInfo->stuCandidate.stPersonInfo.szFacePicInfo[0].pszFilePath;\n\n\t\tmemset(pstPersonListInfo, 0, sizeof(*pstPersonListInfo));\n\t\tpstPersonListInfo->nIndex = IDC_RADIO_PERSON1 + nCountIndex;\n\t\tpstPersonListInfo->nNumber = nCountIndex+1;\n\t\tmemcpy(&(pstPersonListInfo->stuCandidate),&(stuOutDoFind.stuCandidatesEx[i]), sizeof(CANDIDATE_INFOEX));\n\t\tpstPersonListInfo->stuCandidate.stPersonInfo.wFacePicNum = 1;\n\t\tpstPersonListInfo->stuCandidate.stPersonInfo.szFacePicInfo[0].pszFilePath = pszFilePath;\n\t\tif (pstPersonListInfo->stuCandidate.stPersonInfo.szFacePicInfo[0].pszFilePath)\n\t\t{\n\t\t\tmemset(pstPersonListInfo->stuCandidate.stPersonInfo.szFacePicInfo[0].pszFilePath, 0, nFilePathLen);\n\t\t\tstrncpy(pstPersonListInfo->stuCandidate.stPersonInfo.szFacePicInfo[0].pszFilePath, stuOutDoFind.stuCandidatesEx[i].stPersonInfo.szFacePicInfo[0].pszFilePath, nFilePathLen - 1);\n\t\t}\n\t\tnCountIndex++;\n\t}\n\n\tif (stuOutDoFind.nCadidateExNum < stuInDoFind.nCount)\n\t{\n\t\tGetDlgItem(IDC_BUTTON_NEXT)->EnableWindow(FALSE);\n\t}\n\n\tShowCandidateInfo(stuOutDoFind.nCadidateExNum);\n\nFREE_DATA:\n\tfor (int n = 0; n < nQueryNum; n++)\n\t{\n\t\tif (stuOutDoFind.stuCandidatesEx[n].stPersonInfo.szFacePicInfo[0].pszFilePath)\n\t\t{\n\t\t\tdelete stuOutDoFind.stuCandidatesEx[n].stPersonInfo.szFacePicInfo[0].pszFilePath;\n\t\t}\n\t\tstuOutDoFind.stuCandidatesEx[n].stPersonInfo.szFacePicInfo[0].pszFilePath = NULL;\n\t}\n\t\n}\n\nvoid CPersonOpreateGlg::StartFindPersonInfo(BOOL bDelete)\n{\n\tif (0 != m_lFindPersonHandle)\n\t{\n\t\tBOOL bRet = CLIENT_StopFindFaceRecognition(m_lFindPersonHandle);\n\t\tif (!bRet)\n\t\t{\n\t\t\tMessageBox(ConvertString(\"Failed to stop find!\"), \"\");\n\t\t}\n\t\tm_lFindPersonHandle = 0;\n\t\tm_nCurPos = 0;\n\t}\n\n\tClearShowCandidateInfo();\n\tGetDlgItem(IDC_BUTTON_NEXT)->EnableWindow(FALSE);\n\tGetDlgItem(IDC_BUTTON_PER)->EnableWindow(FALSE);\n\n\tif (NULL == m_pPersonInfoList)\n\t{\n\t\treturn;\n\t}\n\n\tNET_IN_STARTFIND_FACERECONGNITION stuInParam = {sizeof(stuInParam)};\n\tNET_OUT_STARTFIND_FACERECONGNITION stuOutParam = {sizeof(stuOutParam)};\n\n\tstuInParam.stMatchOptions.dwSize = sizeof(stuInParam.stMatchOptions);\n\tstuInParam.stFilterInfo.dwSize = sizeof(stuInParam.stFilterInfo);\n\tstuInParam.bPersonExEnable = TRUE;\n\n\tstuInParam.stFilterInfo.nRangeNum = 1;\n\tstuInParam.stFilterInfo.szRange[0] = (BYTE)NET_FACE_DB_TYPE_BLACKLIST;\n\n\tCString strName;\n\tGetDlgItemText(IDC_EDIT_NAME, strName);\n\tchar *pcName = (LPSTR)(LPCSTR)strName;\n\tif (strlen(pcName) > 0)\n\t{\n\t\tstrncpy(stuInParam.stPersonInfoEx.szPersonName, pcName, sizeof(stuInParam.stPersonInfoEx.szPersonName)-1);\n\t}\n\tstuInParam.stPersonInfoEx.bySex = m_cbSexType.GetCurSel();\n\n\tSYSTEMTIME DataStart = {0};\n\tCDateTimeCtrl *pCDataStart = (CDateTimeCtrl*)GetDlgItem(IDC_PersonBirthDayStart);\n\tDWORD dwResult = pCDataStart->GetTime(&DataStart);\n\tif (dwResult == GDT_VALID)\n\t{\n\t\tstuInParam.stFilterInfo.stBirthdayRangeStart.dwYear = DataStart.wYear;\n\t\tstuInParam.stFilterInfo.stBirthdayRangeStart.dwMonth = DataStart.wMonth;\n\t\tstuInParam.stFilterInfo.stBirthdayRangeStart.dwDay = DataStart.wDay;\n\t}\n\n\tSYSTEMTIME DataEnd = {0};\n\tdwResult = m_BirthDayEnd.GetTime(&DataEnd);\n\tif (dwResult == GDT_VALID)\n\t{\n\t\tstuInParam.stFilterInfo.stBirthdayRangeEnd.dwYear = DataEnd.wYear;\n\t\tstuInParam.stFilterInfo.stBirthdayRangeEnd.dwMonth = DataEnd.wMonth;\n\t\tstuInParam.stFilterInfo.stBirthdayRangeEnd.dwDay = DataEnd.wDay;\n\t}\n\n\tstuInParam.stPersonInfoEx.byIDType = m_cbCardType.GetCurSel();\n\n\tCString strCard;\n\tGetDlgItemText(IDC_EDIT_CARD_NUM, strCard);\n\tchar *pcCard = (LPSTR)(LPCSTR)strCard;\n\tif (strlen(pcCard) > 0)\n\t{\n\t\tstrncpy(stuInParam.stPersonInfoEx.szID, pcCard, sizeof(stuInParam.stPersonInfoEx.szID)-1);\n\t}\n\tstrncpy(stuInParam.stFilterInfo.szGroupId[0], m_szGroupId, sizeof(m_szGroupId)-1);\n\tstuInParam.stFilterInfo.nGroupIdNum = 1;\n\n\tstrncpy(stuInParam.stPersonInfoEx.szGroupID, m_szGroupId, sizeof(stuInParam.stPersonInfoEx.szGroupID)-1);\n\n\tBOOL bRet = CLIENT_StartFindFaceRecognition(m_lLoginID, &stuInParam, &stuOutParam, DEFAULT_WAIT_TIME);\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Failed to start search face recognition!\"), \"\");\n\t\treturn;\n\t}\n\n\tm_nPersonCount = stuOutParam.nTotalCount;\n\n\tif ((stuOutParam.nTotalCount == 0) && (FALSE == bDelete))\n\t{\n\t\tMessageBox(ConvertString(\"No person!\"), \"\");\n\t\treturn;\n\t}\n\n\tif (stuOutParam.nTotalCount > 10)\n\t{\n\t\tGetDlgItem(IDC_BUTTON_NEXT)->EnableWindow(TRUE);\n\t}\n\n\tm_lFindPersonHandle = stuOutParam.lFindHandle;\n}\n\nvoid CPersonOpreateGlg::OnOK() \n{\t\n\tBOOL bValid = UpdateData(TRUE);\n\tif (!bValid)\n\t{\n\t\treturn;\n\t}\n\n\tStartFindPersonInfo();\n\tSearchPersonInfoFromGroup();\n\n\tFillCWndWithDefaultColor(GetDlgItem(IDC_SELECT_PersonPicture));\n}\n\nvoid CPersonOpreateGlg::OnButtonNext() \n{\n\tm_nCurPos += 10;\n\tClearShowCandidateInfo();\n\n\tSearchPersonInfoFromGroup();\n\n\tGetDlgItem(IDC_BUTTON_PER)->EnableWindow(TRUE);\n}\n\nvoid CPersonOpreateGlg::OnButtonPer() \n{\n\tif (m_nCurPos >= 10)\n\t{\n\t\tm_nCurPos -= 10;\n\t\tClearShowCandidateInfo();\n\t\tSearchPersonInfoFromGroup();\n\t\tGetDlgItem(IDC_BUTTON_NEXT)->EnableWindow(TRUE);\n\t\tif (0 == m_nCurPos)\n\t\t{\n\t\t\tGetDlgItem(IDC_BUTTON_PER)->EnableWindow(FALSE);\n\t\t}\n\t}\n}\n\nvoid CPersonOpreateGlg::OnButtonPersonAdd() \n{\n\tCAddPersonDlg AddPerson(m_lLoginID, m_szGroupId, m_szGroupName, FACE_PERSON_ADD);\n\tint nResponse = AddPerson.DoModal();\n \t//if (nResponse == IDOK)\n \t{\n\t\tStartFindPersonInfo();\n\n\t\tSearchPersonInfoFromGroup();\n \t}\n\tm_pstPersonSelectInfo = NULL;\n}\n\nvoid CPersonOpreateGlg::OnButtonPersonEdit() \n{\n\tif (NULL == m_pstPersonSelectInfo)\n\t{\n\t\tMessageBox(ConvertString(\"Please select a person!\"), \"\");\n\t\treturn;\n\t}\n\t\n\tCANDIDATE_INFOEX *pstCandidateInfo = &(m_pstPersonSelectInfo->stuCandidate);\n\tCAddPersonDlg AddPerson(m_lLoginID, m_szGroupId, m_szGroupName, FACE_PERSON_EDIT, pstCandidateInfo);\n\tint nResponse = AddPerson.DoModal();\n// \tif (nResponse != IDOK)\n// \t{\n// \t\treturn;\n// \t}\n\n\tStartFindPersonInfo();\n\tClearShowCandidateInfo();\n\n\tSearchPersonInfoFromGroup();\n\tm_pstPersonSelectInfo = NULL;\n}\n\nvoid CPersonOpreateGlg::OnSelectPersonInfo()\n{\n\tBOOL bSelect = FALSE;\n\tint nIndex = 0;\n\tint i = 0;\n\n\tfor (nIndex = IDC_RADIO_PERSON1; (nIndex < (nIndex+PERPAGE_INDEX_COUNT)) && (i < 10); nIndex++, i++)\n\t{\n\t\tif (((CButton *)GetDlgItem(nIndex))->GetCheck())\n\t\t{\n\t\t\tm_pstPersonSelectInfo = m_pPersonInfoList + i;\n\t\t\tbSelect = TRUE;\n\t\t\tbreak;\t\t\t\n\t\t}\n\t}\n\n\tif (FALSE == bSelect)\n\t{\n\t\treturn;\n\t}\n\n\tchar szSrcPath[256] = {0};\n\tchar szFileDst[256] = {0};\n\tstrncpy(szSrcPath, m_pstPersonSelectInfo->stuCandidate.stPersonInfo.szFacePicInfo[0].pszFilePath, sizeof(szSrcPath)-1);\n\tstrncpy(szFileDst, \"Face\\\\RemoteFace\\\\SepectPerson.jpg\", sizeof(szFileDst)-1);\n\t\t\t\t\t\t\n\tCString filepath(m_pszSoftPath);\n\tCString filename(szFileDst);\n\tCString strFile = filepath + filename;\n\tchar *pFileDst = strFile.GetBuffer(256);\n\n\tDeleteFile(pFileDst);\n\t\n\tDH_IN_DOWNLOAD_REMOTE_FILE stuInFile = {sizeof(stuInFile)};\n\tDH_OUT_DOWNLOAD_REMOTE_FILE stuOutFile = {sizeof(stuOutFile)};\n\tstuInFile.pszFileName = szSrcPath;\n\tstuInFile.pszFileDst = pFileDst;\n\tBOOL bRet = CLIENT_DownloadRemoteFile(m_lLoginID, &stuInFile, &stuOutFile, DEFAULT_WAIT_TIME);\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Download remote face picture failed!\"), \"\");\n\t\treturn;\n\t}\n\n\tm_pPersonPic.SetImageFile(pFileDst);\n\t\n\tmemset(m_szSelectPersonFile, 0, sizeof(m_szSelectPersonFile));\n\tstrncpy(m_szSelectPersonFile, pFileDst, sizeof(m_szSelectPersonFile)-1);\n}\n\n\nvoid CPersonOpreateGlg::OnButtonPersonDel() \n{\n\tif (NULL == m_pstPersonSelectInfo)\n\t{\n\t\tMessageBox(ConvertString(\"Please select a person!\"), \"\");\n\t\treturn;\n\t}\n\t\n\tCANDIDATE_INFOEX *pstCandidateInfo = &(m_pstPersonSelectInfo->stuCandidate);\n\tNET_IN_OPERATE_FACERECONGNITIONDB stuInParam = {sizeof(stuInParam)};\n\tNET_OUT_OPERATE_FACERECONGNITIONDB stuOutParam = {sizeof(stuOutParam)};\n\tstuInParam.emOperateType = NET_FACERECONGNITIONDB_DELETE;\n\tstuInParam.bUsePersonInfoEx = TRUE;\n\tstrncpy(stuInParam.stPersonInfoEx.szUID, m_pstPersonSelectInfo->stuCandidate.stPersonInfo.szUID, sizeof(stuInParam.stPersonInfoEx.szUID)-1);\n\tstrncpy(stuInParam.stPersonInfoEx.szGroupID, m_szGroupId, sizeof(stuInParam.stPersonInfoEx.szGroupID)-1);\n\tBOOL bRet = CLIENT_OperateFaceRecognitionDB(m_lLoginID, &stuInParam, &stuOutParam, DEFAULT_WAIT_TIME);\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Failed to delete this person info!\"), \"\");\n\t}\n\n\tStartFindPersonInfo(TRUE);\n\tClearShowCandidateInfo();\n\n\tSearchPersonInfoFromGroup();\n\tm_pstPersonSelectInfo = NULL;\n}\n\nvoid CPersonOpreateGlg::OnBnClickedSearch()\n{\n\tOnOK();\n}\n\n\nBOOL CPersonOpreateGlg::PreTranslateMessage(MSG* pMsg)\n{\n\t// Enter key\n\tif(pMsg->message == WM_KEYDOWN &&\n\t\tpMsg->wParam == VK_RETURN)\n\t{\n\t\treturn TRUE;\n\t}\n\treturn CDialog::PreTranslateMessage(pMsg);\n}\n","size_bytes":17294},"bin/DemoSrc/SoundCapture_demo/StdAfx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n//\tSoundCapture_demo.pch will be the pre-compiled header\n//\tstdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n#include \"CharactorTansfer.h\"\n\nCString GetMoudlePath()\n{\n\tTCHAR szAppName[MAX_PATH];\n\tTCHAR szDir[MAX_PATH];\n\tTCHAR szDrive[MAX_PATH];\n\tGetModuleFileName(GetModuleHandle(NULL), szAppName, MAX_PATH);\n\t_tsplitpath(szAppName, szDrive, szDir, NULL, NULL);\n\t\n\tTCHAR szPath[MAX_PATH];\n\t_tmakepath(szPath, szDrive, szDir, NULL, NULL);\n\t\n\treturn szPath;\n}\n\n\n\n","size_bytes":559},"bin/DemoSrc/DecCB_demo/LanguageConvertor.cpp":{"content":"// LanguageConvertor.cpp: implementation of the CLanguageConvertor class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"LanguageConvertor.h\"\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\n//////////////////////////////////////////////////////////////////////\n// Construction/Destruction\n//////////////////////////////////////////////////////////////////////\nTCHAR CLanguageConvertor::m_szIniFile[MAX_PATH] = {0};\n\n\nint CLanguageConvertor::Init()\n{\n\t_stprintf(m_szIniFile, _T(\"%s%s\"), GetMoudlePath(), _T(\"lang.ini\"));\n\treturn 1;\n}\n\nCString CLanguageConvertor::ConvertString(CString strText)\n{\n\tif(strText.GetLength())\n\t{\n\t\tTCHAR val[300];\n\t\tGetPrivateProfileString(_T(\"String\"), strText, strText, val, sizeof(val), m_szIniFile);\n\t\treturn val;\n\t}\n\n\treturn strText;\n}\n\nvoid CLanguageConvertor::SetWndStaticText(CWnd * pWnd)\n{\n\tCString strCaption,strText;\n\n\tpWnd->GetWindowText(strCaption);\n\tif(strCaption.GetLength()>0)\n\t{\n\t\tstrText=ConvertString(strCaption);\n\t\tpWnd->SetWindowText(strText);\n\t}\n\n\tCWnd * pChild=pWnd->GetWindow(GW_CHILD);\n\tCString strClassName;\n\twhile(pChild)\n\t{\n\t\tstrClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n\t\tif(strClassName == \"CEdit\")\n\t\t{\n\t\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t\t\tcontinue;\n\t\t}\n\t\t//////////////////////////////////////////////////////////////////////////\n\t\tpChild->GetWindowText(strCaption);\n\t\tstrText=ConvertString(strCaption);\n\t\tpChild->SetWindowText(strText);\n\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t}\n}\n\nvoid CLanguageConvertor::SetMenuStaticText(CMenu* pMenu)\n{\n\tCString strCaption,strText;\n\t\n\tint MenuItemNum = pMenu->GetMenuItemCount() ;\n\t\n\tfor (int i = 0 ; i < MenuItemNum ; i++)\n\t{\t\t\n\t\tMENUITEMINFO info;\n\t\tmemset(&info, 0 , sizeof(MENUITEMINFO)) ;\n\t\tinfo.cbSize = sizeof (MENUITEMINFO); // must fill up this field\n\t\tinfo.fMask = MIIM_STATE;             // get the state of the menu item\n\t\t\n\t\tpMenu->GetMenuString(i, strCaption, MF_BYPOSITION);\n\t\t\n\t\tstrText=ConvertString(strCaption);\n\t\t\n\t\tUINT ID = pMenu->GetMenuItemID(i) ;\n\t\t\n\t\tif (ID != -1)\n\t\t{\n\t\t\tpMenu->GetMenuItemInfo(ID, &info) ;\n\t\t\tpMenu->ModifyMenu(ID, MF_BYCOMMAND|MF_STRING, ID, strText);\n\t\t\tSetMenuItemInfo(pMenu->m_hMenu, ID, FALSE, &info) ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpMenu->ModifyMenu(i, MF_BYPOSITION| MF_STRING, 0, strText);\n\t\t}\n\t\t\n\t\tCMenu* subMenu = pMenu->GetSubMenu(i) ;\n\t\t\n\t\tif (subMenu != NULL)\n\t\t{\t\t\t\n\t\t\tSetMenuStaticText(subMenu) ;\n\t\t}\n\t}\n}","size_bytes":2495},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/ConfigAlarmDisk.cpp":{"content":"// ConfigAlarmDisk.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"ConfigAlarmDisk.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CConfigAlarmDisk dialog\n\n\nCConfigAlarmDisk::CConfigAlarmDisk(CWnd* pParent /*=NULL*/)\n\t: CDialog(CConfigAlarmDisk::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CConfigAlarmDisk)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CConfigAlarmDisk::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CConfigAlarmDisk)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CConfigAlarmDisk, CDialog)\n\t//{{AFX_MSG_MAP(CConfigAlarmDisk)\n\t\t// NOTE: the ClassWizard will add message map macros here\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CConfigAlarmDisk message handlers\n","size_bytes":1054},"bin/Demo/MfcDemo/22.ThermalCamera/QueryDlg.cpp":{"content":"// QueryDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"ThermalCamera.h\"\n#include \"QueryDlg.h\"\n#include \"ThermalCameraDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CQueryDlg dialog\n\n\nCQueryDlg::CQueryDlg(CWnd* pParent /*=NULL*/, LLONG lLoginId)\n\t: CDialog(CQueryDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CQueryDlg)\n\tm_StartDay = COleDateTime::GetCurrentTime();\n\tm_StartTime = 0;\n\tm_EndDay = COleDateTime::GetCurrentTime();\n\tm_EndTime = 0;\n\tm_nBeginNum = 0;\n\tm_nReallyNum = 0;\n\tm_nCount = 0;\n\tm_strTime = _T(\"unknown\");\n\tm_nPresentID = 0;\n\tm_nRuleID = 0;\n\tm_strName = _T(\"unknown\");\n\tm_nChannel = 0;\n\tm_nX = 0;\n\tm_nY = 0;\n\tm_strMeasuretype = _T(\"unknown\");\n\tm_strUnit = _T(\"unknown\");\n\tm_fAveTemp = 0.0f;\n\tm_fMaxTemp = 0.0f;\n\tm_fMidTemp = 0.0f;\n\tm_fMinTemp = 0.0f;\n\tm_fStdTemp = 0.0f;\n\t//}}AFX_DATA_INIT\n    m_lLoginID = lLoginId;\n    m_nFinderHanle = 0;\n\n\tmemset(&stOutDo, 0, sizeof(stOutDo));\n\tstOutDo.dwSize = sizeof(stOutDo);\n}\n\n\nvoid CQueryDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CQueryDlg)\n\tDDX_Control(pDX, IDC_COMBO_POINTNUM, m_Combo_PointNum);\n\tDDX_Control(pDX, IDC_COMBO_QUERYTYPE, m_Combo_Querytype);\n\tDDX_Control(pDX, IDC_COMBO_CHANNELNUM, m_Combo_ChannelNum);\n\tDDX_DateTimeCtrl(pDX, IDC_STARTDAY, m_StartDay);\n\tDDX_DateTimeCtrl(pDX, IDC_STARTTIME, m_StartTime);\n\tDDX_DateTimeCtrl(pDX, IDC_ENDDAY, m_EndDay);\n\tDDX_DateTimeCtrl(pDX, IDC_ENDTIME, m_EndTime);\n\tDDX_Text(pDX, IDC_EDIT_QUERYBEGINNUM, m_nBeginNum);\n\tDDX_Text(pDX, IDC_EDIT_AMOUNT, m_nReallyNum);\n\tDDX_Text(pDX, IDC_EDIT_COUNT, m_nCount);\n\tDDX_Text(pDX, IDC_EDIT_TIME, m_strTime);\n\tDDX_Text(pDX, IDC_EDIT_PRESETNUM, m_nPresentID);\n\tDDX_Text(pDX, IDC_EDIT_RULENUM, m_nRuleID);\n\tDDX_Text(pDX, IDC_EDIT_MEASURENAME, m_strName);\n\tDDX_Text(pDX, IDC_EDIT_CHANNEL, m_nChannel);\n\tDDX_Text(pDX, IDC_EDIT_Y, m_nX);\n\tDDX_Text(pDX, IDC_EDIT_X, m_nY);\n\tDDX_Text(pDX, IDC_EDIT_MEASURETYPE, m_strMeasuretype);\n\tDDX_Text(pDX, IDC_EDIT_UNIT, m_strUnit);\n\tDDX_Text(pDX, IDC_EDIT_TEMP, m_fAveTemp);\n\tDDX_Text(pDX, IDC_EDIT_MAXTEMP, m_fMaxTemp);\n\tDDX_Text(pDX, IDC_EDIT_MIDTEMP, m_fMidTemp);\n\tDDX_Text(pDX, IDC_EDIT_MINTEMP, m_fMinTemp);\n\tDDX_Text(pDX, IDC_EDIT_STDTEMP, m_fStdTemp);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CQueryDlg, CDialog)\n\t//{{AFX_MSG_MAP(CQueryDlg)\n\tON_BN_CLICKED(IDC_BTN_QUERY, OnBtnQuery)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CQueryDlg message handlers\n\nvoid CQueryDlg::OnBtnQuery() \n{\n\tUpdateData();\n    NET_IN_RADIOMETRY_STARTFIND stInStart = {sizeof(stInStart)};\n    NET_OUT_RADIOMETRY_STARTFIND stOutStart = {sizeof(stOutStart)};\n    stInStart.nChannel = 1/*m_Combo_ChannelNum.GetCurSel()*/;\n    stInStart.nMeterType = m_Combo_Querytype.GetCurSel();\n    stInStart.stStartTime.dwYear = m_StartDay.GetYear();\n    stInStart.stStartTime.dwMonth = m_StartDay.GetMonth();\n    stInStart.stStartTime.dwDay = m_StartDay.GetDay();\n    stInStart.stStartTime.dwHour = m_StartTime.GetHour();\n    stInStart.stStartTime.dwMinute = m_StartTime.GetMinute();\n    stInStart.stStartTime.dwSecond = m_StartTime.GetSecond();\n\n    stInStart.stEndTime.dwYear = m_EndDay.GetYear();\n    stInStart.stEndTime.dwMonth = m_EndDay.GetMonth();\n    stInStart.stEndTime.dwDay = m_EndDay.GetDay();\n    stInStart.stEndTime.dwHour = m_EndTime.GetHour();\n    stInStart.stEndTime.dwMinute = m_EndTime.GetMinute();\n    stInStart.stEndTime.dwSecond = m_EndTime.GetSecond();\n    if (!m_lLoginID)\n    {\n        MessageBox(ConvertString(\"Please login device first\"), ConvertString(\"Prompt\"));\n        return;\n    }\n    BOOL ret = CLIENT_StartFind(m_lLoginID,NET_FIND_RADIOMETRY,&stInStart,&stOutStart,2000);\n    NET_IN_RADIOMETRY_DOFIND stInDo = {sizeof(stInDo)};\n    m_nFinderHanle = stOutStart.nFinderHanle;\n    stInDo.nFinderHanle = m_nFinderHanle;\n    stInDo.nCount = m_nCount;\n    stInDo.nBeginNumber = m_nBeginNum;\n    if ((stInDo.nCount>NET_RADIOMETRY_DOFIND_MAX) || (stInDo.nBeginNumber>stOutStart.nTotalCount))\n    {\n        return;\n    }\n    if (ret != 0)\n    {\n        for (int i=0;i<5;i++)\n        {\n            ret = CLIENT_DoFind(m_lLoginID,NET_FIND_RADIOMETRY,&stInDo,&stOutDo,2000);\n            if (ret)\n            {\n                break;\n            }\n        }\n    }\n    if (ret)\n    {\n        m_nReallyNum = stOutDo.nFound;\n        DWORD dwYear = stOutDo.stInfo[0].stTime.dwYear;\n        DWORD dwMonth = stOutDo.stInfo[0].stTime.dwMonth;\n        DWORD dwDay = stOutDo.stInfo[0].stTime.dwDay;\n        DWORD dwHour = stOutDo.stInfo[0].stTime.dwHour;\n        DWORD dwMinute = stOutDo.stInfo[0].stTime.dwMinute;\n        DWORD dwSecond = stOutDo.stInfo[0].stTime.dwSecond;\n        m_strTime.Format(\"%4d:%2d%:%2d:%2d:%2d:%2d\",dwYear,dwMonth,dwDay,dwHour,dwMinute,dwSecond);\n        m_nPresentID = stOutDo.stInfo[0].nPresetId;\n        m_nRuleID = stOutDo.stInfo[0].nRuleId;\n        m_strName = stOutDo.stInfo[0].szName;\n        m_nChannel = stOutDo.stInfo[0].nChannel;\n        m_nX = stOutDo.stInfo[0].stCoordinate.nx;\n        m_nY = stOutDo.stInfo[0].stCoordinate.ny;\n        if (stOutDo.stInfo[0].stTemperInfo.nMeterType == NET_RADIOMETRY_METERTYPE_UNKNOWN)\n        {\n            m_strMeasuretype = ConvertString(\"unknown\");\n        }\n        else if (stOutDo.stInfo[0].stTemperInfo.nMeterType == NET_RADIOMETRY_METERTYPE_SPOT)\n        {\n            m_strMeasuretype = ConvertString(\"spot\");\n        }\n        else if (stOutDo.stInfo[0].stTemperInfo.nMeterType == NET_RADIOMETRY_METERTYPE_LINE)\n        {\n            m_strMeasuretype = ConvertString(\"line\");\n        }\n        else if (stOutDo.stInfo[0].stTemperInfo.nMeterType == NET_RADIOMETRY_METERTYPE_AREA)\n        {\n            m_strMeasuretype = ConvertString(\"area\");\n        }\n        if (stOutDo.stInfo[0].stTemperInfo.nTemperUnit == TEMPERATURE_UNIT_UNKNOWN)\n        {\n            m_strUnit = ConvertString(\"unknown\");\n        }\n        else if (stOutDo.stInfo[0].stTemperInfo.nTemperUnit == TEMPERATURE_UNIT_CENTIGRADE)\n        {\n            m_strUnit = ConvertString(\"Celsius\");\n        }\n        else if (stOutDo.stInfo[0].stTemperInfo.nTemperUnit == TEMPERATURE_UNIT_FAHRENHEIT)\n        {\n            m_strUnit = ConvertString(\"Fahrenheit\");\n        }\n        m_fAveTemp = stOutDo.stInfo[0].stTemperInfo.fTemperAver;\n        m_fMaxTemp = stOutDo.stInfo[0].stTemperInfo.fTemperMax;\n        m_fMinTemp = stOutDo.stInfo[0].stTemperInfo.fTemperMin;\n        m_fMidTemp = stOutDo.stInfo[0].stTemperInfo.fTemperMin;\n        m_fStdTemp = stOutDo.stInfo[0].stTemperInfo.fTemperStd;\n    }\n    else\n    {\n        MessageBox(ConvertString(\"Query Fail\"),ConvertString(\"Prompt\"));\n    }\n}\n\nBOOL CQueryDlg::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\tm_Combo_Querytype.SetCurSel(0);\n    m_Combo_ChannelNum.SetCurSel(0);\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n","size_bytes":7048},"bin/Demo/MfcDemo/10.AlarmDevice/AlarmDevice.cpp":{"content":"// AlarmDevice.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"AlarmDeviceDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CClientDemoApp\n\nBEGIN_MESSAGE_MAP(CAlarmDeviceApp, CWinApp)\n\t//{{AFX_MSG_MAP(CClientDemoApp)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t\t//    DO NOT EDIT what you see in these blocks of generated code!\n\t//}}AFX_MSG\n\tON_COMMAND(ID_HELP, CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CClientDemoApp construction\n\nCAlarmDeviceApp::CAlarmDeviceApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n\ttheCrashDumper.Enable(_T(\"AlarmDevice\"), true, _T(\"C:\\\\\"));\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The one and only CClientDemoApp object\n\nCAlarmDeviceApp theApp;\n\nCPlayAPI s_PlayAPI;\n\n/////////////////////////////////////////////////////////////////////////////\n// CClientDemoApp initialization\n\nBOOL CAlarmDeviceApp::InitInstance()\n{\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t//  of your final executable, you should remove from the following\n\t//  the specific initialization routines you do not need.\n\n#ifdef _AFXDLL\n\tEnable3dControls();\t\t\t// Call this when using MFC in a shared DLL\n#else\n\tEnable3dControlsStatic();\t// Call this when linking to MFC statically\n#endif\n\n\tCAlarmDeviceDlg dlg;\n\tm_pMainWnd = &dlg;\n\tINT_PTR nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nCString ConvertString(const CString& strText, const char* pszSeg /* = NULL */)\n{\n\tCString strIniPath, strRet;\n\tchar szVal[256] = {0};\n\t\n\tif (!pszSeg)\n\t{\n\t\tpszSeg = DLG_MAIN;\n\t}\n\t\n\tGetPrivateProfileString(pszSeg, strText, \"\", szVal, sizeof(szVal), \"./langchn.ini\");\n\tstrRet = szVal;\n\tif(strRet.GetLength()==0)\n\t{\n\t\t//If there is no corresponding string in ini file then set it to be default value(English).\n\t\tstrRet=strText;\n\t}\n\t\n\treturn strRet;\n}\n\n//Set static text in the dialogue box(English->current language) \nvoid g_SetWndStaticText(CWnd * pWnd, const char* pszSeg /* = NULL */)\n{\n\tCString strCaption,strText;\n\t\n\t//Set main window title \n\tpWnd->GetWindowText(strCaption);\n\tif(strCaption.GetLength()>0)\n\t{\n\t\tstrText=ConvertString(strCaption, pszSeg);\n\t\tpWnd->SetWindowText(strText);\n\t\t\n\t}\n\t\n\t//Set sub-window title \n\tCWnd * pChild=pWnd->GetWindow(GW_CHILD);\n\tCString strClassName;\n\twhile(pChild)\n\t{\n\t\t//////////////////////////////////////////////////////////////////////////\t\t\n\t\t//Added by Jackbin 2005-03-11\n\t\tstrClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n\t\tif(strClassName == \"CEdit\")\n\t\t{\n\t\t\t//The next sub-window \n\t\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t//////////////////////////////////////////////////////////////////////////\t\n\t\t\n\t\t//Set current language text in the sub-window \n\t\tpChild->GetWindowText(strCaption);\n\t\tstrText=ConvertString(strCaption, pszSeg);\n\t\tpChild->SetWindowText(strText);\n\t\t\n\t\t//The next sub-window \n\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t}\n}\n\nvoid SenseTypeToStr(NET_SENSE_METHOD nSenseType, CString& szStr)\n{\n\tif (NET_SENSE_DOOR == nSenseType)\n\t{\n\t\tszStr = \"DoorMagnetism\";\n\t}\n\telse if (NET_SENSE_PASSIVEINFRA == nSenseType)\n\t{\n\t\tszStr = \"PassiveInfrared\";\n\t}\n\telse if (NET_SENSE_GAS == nSenseType)\n\t{\n\t\tszStr = \"GasSensor\";\n\t}\n\telse if (NET_SENSE_SMOKING == nSenseType)\n\t{\n\t\tszStr = \"SmokingSensor\";\n\t}\n\telse if (NET_SENSE_WATER == nSenseType)\n\t{\n\t\tszStr = \"WaterSensor\";\n\t}\n\telse if (NET_SENSE_ACTIVEFRA == nSenseType)\n\t{\n\t\tszStr = \"ActiveInfrared\";\n\t}\n\telse if (NET_SENSE_GLASS == nSenseType)\n\t{\n\t\tszStr = \"GlassSensor\";\n\t}\n\telse if (NET_SENSE_EMERGENCYSWITCH == nSenseType)\n\t{\n\t\tszStr = \"EmergencySwitch\";\n\t}\n\telse if (NET_SENSE_SHOCK == nSenseType)\n\t{\n\t\tszStr = \"ShockSensor\";\n\t}\n\telse if (NET_SENSE_DOUBLEMETHOD == nSenseType)\n\t{\n\t\tszStr = \"DoubleMethod\";\n\t}\n\telse if (NET_SENSE_THREEMETHOD == nSenseType)\n\t{\n\t\tszStr = \"ThreeMethod\";\n\t}\n\telse if (NET_SENSE_TEMP == nSenseType)\n\t{\n\t\tszStr = \"TempSensor\";\n\t}\n\telse if (NET_SENSE_HUMIDITY == nSenseType)\n\t{\n\t\tszStr = \"HumiditySensor\";\n\t}\n    else if (NET_SENSE_WIND == nSenseType)\n    {\n        szStr = \"WindSensor\";\n    }\n\telse if (NET_SENSE_CALLBUTTON == nSenseType)\n\t{\n\t\tszStr = \"CallButton\";\n\t}\n\telse if (NET_SENSE_GASPRESSURE == nSenseType)\n\t{\n\t\tszStr = \"GasPressure\";\n\t}\n\telse if (NET_SENSE_GASCONCENTRATION == nSenseType)\n\t{\n\t\tszStr = \"GasConcentration\";\n\t}\n\telse if (NET_SENSE_GASFLOW == nSenseType)\n\t{\n\t\tszStr = \"GasFlow\";\n\t}\n\telse if (NET_SENSE_OTHER == nSenseType)\n\t{\n\t\tszStr = \"OtherSensor\";\n\t}\n\telse\n\t{\n\t\tszStr = \"UnknownSensor\";\n\t}\n}\n\nCString AnalogAlarmDataStatusToStr(int nStatus)\n{\n    CString csStatus;\n    if (0 == nStatus)\n    {\n        csStatus = \"normal\";\n    }\n    else if (1 == nStatus)\n    {\n        csStatus = \"invalid\";\n    }\n    else if (2 == nStatus)\n    {\n        csStatus = \"upper1\";\n    }\n    else if (3 == nStatus)\n    {\n        csStatus = \"upper2\";\n    }\n    else if (4 == nStatus)\n    {\n        csStatus = \"upper3\";\n    }\n    else if (5 == nStatus)\n    {\n        csStatus = \"upper4\";\n    }\n    else if (6 == nStatus)\n    {\n        csStatus = \"lower1\";\n    }\n    else if (7 == nStatus)\n    {\n        csStatus = \"lower2\";\n    }\n    else if (8 == nStatus)\n    {\n        csStatus = \"lower3\";\n    }\n    else if (9 == nStatus)\n    {\n        csStatus = \"lower4\";\n    }\n    else\n    {\n        csStatus = \"unknown\";\n    }\n    return csStatus;\n}","size_bytes":6134},"bin/Demo/MfcDemo/13.FaceRecognition/SearchByPic.cpp":{"content":"// SearchByPic.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"FaceRecognition.h\"\n#include \"SearchByPic.h\"\n#include <atlconv.h>\n#include <assert.h>\n\n#define WM_UPDATE_BUTTON_UI (WM_USER + 142)\n#define WM_SETCOUNT_UI\t\t(WM_USER + 143)\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n#define MAX_FILE_PATH_LEN 256\n#define FILESEARCH_TIMER_MSEC 62.5\n\nvoid CALLBACK FaceFindState(LLONG lLoginID, LLONG lAttachHandle, NET_CB_FACE_FIND_STATE* pstStates, int nStateNum, LDWORD dwUser)\n{\n\tif (pstStates == NULL || nStateNum == 0 || dwUser == 0)\n\t{\n\t\treturn;\n\t}\n\n\tCSearchByPic *dlg = (CSearchByPic*)dwUser;\n\tdlg->m_nProgress = pstStates->nProgress;\n\tdlg->m_nTotalCount = pstStates->nCurrentCount;\n\tHWND hwnd = dlg->GetSafeHwnd();\n\n\tif (pstStates->nProgress == 100)\n\t{\n\t\t::PostMessage(hwnd, WM_UPDATE_BUTTON_UI, WPARAM(dwUser) , 0);\n\t}\n\treturn;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CSearchByPic dialog\n\n\nCSearchByPic::CSearchByPic(const LLONG lLoginHandle, const int m_nChnCnt, char *pSoftPath /*= NULL*/, CWnd* pParent /*=NULL*/)\n: CDialog(CSearchByPic::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CSearchByPic)\n\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_lLoginId = lLoginHandle;\n\tmemset(m_szFilePath, 0, sizeof(m_szFilePath));\n\tm_nProgress = 0;\n\tm_nChannelCnt = m_nChnCnt;\n\tm_pSoftPath = NULL;\n\tif (pSoftPath)\n\t{\n\t\tm_pSoftPath = pSoftPath;\n\t}\n\n\tm_nTotalCount = 0;\n\tm_dwThreadID = 0;\n\tm_lFindHandle = 0;\n\tm_lAttachHandle = 0;\n\tm_nTimer = 0;\n\tm_lEvent = CreateEvent(NULL, TRUE, FALSE, NULL);\n}\n\nCSearchByPic::~CSearchByPic()\n{\n\tif (m_lEvent)\n\t{\n\t\tCloseHandle(m_lEvent);\n\t\tm_lEvent = 0;\n\t}\n\n\tStopFindHandle();\n\tStopAttchHandle();\n\n\tClearCandidateInfo();\n}\n\nvoid CSearchByPic::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CSearchByPic)\n\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\tDDX_Control(pDX, IDC_SEARCH_CHANNEL, m_comboChannel);\n\t//\tDDX_Control(pDX, IDC_SEARCH_DBTYPE, m_comDbType);\n\tDDX_Control(pDX, IDC_SEARCH_PROGRESS, m_ctlSearchPro);\n\t//}}AFX_DATA_MAP\n\tDDX_Control(pDX, IDC_OPEN_SEARCH_PIC, m_pPicShow);\n\tDDX_Control(pDX, IDC_RESULT_PIC2, m_pResultPic2);\n\tDDX_Control(pDX, IDC_RESULT_PIC, m_pResultPic1);\n}\n\n\nBEGIN_MESSAGE_MAP(CSearchByPic, CDialog)\n\t//{{AFX_MSG_MAP(CSearchByPic)\n\tON_BN_CLICKED(IDC_OPEN_PIC, OnOpenPic)\n\tON_BN_CLICKED(IDC_SEARCH_PIC, OnSearchPic)\n\t//}}AFX_MSG_MAP\n\tON_BN_CLICKED(IDC_BUTTON_SEARCHPIC_STOP, &CSearchByPic::OnBnClickedButtonSearchpicStop)\n\tON_MESSAGE(WM_UPDATE_BUTTON_UI, &CSearchByPic::OnDeviceAttch)\n\tON_WM_TIMER()\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CSearchByPic message handlers\n\nvoid CSearchByPic::ClearCandidateInfo()\n{\n\tFaceLock locker(m_Mutex);\n\tstd::list<CANDIDATE_INFOEX*>::iterator it = m_lstCandidateInfo.begin();\n\twhile(it != m_lstCandidateInfo.end())\n\t{\n\t\tCANDIDATE_INFOEX *pstCandidateInfo = *it;\n\t\tif (pstCandidateInfo)\n\t\t{\n\t\t\tif (pstCandidateInfo->stPersonInfo.szFacePicInfo[0].pszFilePath)\n\t\t\t{\n\t\t\t\tdelete[] pstCandidateInfo->stPersonInfo.szFacePicInfo[0].pszFilePath;\n\t\t\t\tpstCandidateInfo->stPersonInfo.szFacePicInfo[0].pszFilePath = NULL;\n\t\t\t}\n\t\t\tdelete pstCandidateInfo;\n\t\t\tpstCandidateInfo = NULL;\n\t\t}\n\t\tm_lstCandidateInfo.erase(it++);\n\t}\n\tlocker.UnLock();\n}\n\nBOOL CSearchByPic::OnInitDialog()\n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\n\t// TODO: Add extra initialization here\n\tCString str;\n\tint nIndex = 0;\n\tm_comboChannel.ResetContent();\n\tfor(int i=0;i < m_nChannelCnt;i++)\n\t{\n\t\tstr.Format(\"%d\",i + 1);\n\t\tnIndex = m_comboChannel.AddString(str);\n\t\tm_comboChannel.SetItemData(nIndex,i);\n\t}\n\tm_comboChannel.SetCurSel(0);\n\n\tCComboBox *pSimilarity = (CComboBox*)GetDlgItem(IDC_SEARCH_SIMILARITY_COMBOX);\n\tfor (int i = 1; i <= 100; i++)\n\t{\n\t\tstr.Format(\"%d\", i);\n\t\tpSimilarity->AddString(str);\n\t}\n\tpSimilarity->SetCurSel(54);\n\n\tint nYear = 0;\n\tint nMonth = 0;\n\tint nDay = 0;\n\n\tCTime curTime = CTime::GetCurrentTime();\n\tnYear = curTime.GetYear();\n\tnMonth = curTime.GetMonth();\n\tnDay = curTime.GetDay();\n\n\tif (nMonth > 1)\n\t{\n\t\tstr.Format(\"%d\", nYear);\n\t\tSetDlgItemText(IDC_SEARCH_StartYear, str);\n\n\t\tstr.Format(\"%d\", nMonth-1);\n\t\tSetDlgItemText(IDC_SEARCH_StartMonth, str);\n\t}\n\telse\n\t{\n\t\tstr.Format(\"%d\", nYear-1);\n\t\tSetDlgItemText(IDC_SEARCH_StartYear, str);\n\n\t\tstr.Format(\"%d\", 12);\n\t\tSetDlgItemText(IDC_SEARCH_StartMonth, str);\n\t}\n\n\tstr.Format(\"%d\", nDay);\n\tSetDlgItemText(IDC_SEARCH_StartDay, str);\n\n\tstr.Format(\"%d\", nYear);\n\tSetDlgItemText(IDC_SEARCH_EndYear, str);\n\tstr.Format(\"%d\", nMonth);\n\tSetDlgItemText(IDC_SEARCH_EndMonth, str);\n\tstr.Format(\"%d\", nDay);\n\tSetDlgItemText(IDC_SEARCH_EndDay, str);\n\n\tm_ctlSearchPro.SetRange32(0,200);\n\tm_ctlSearchPro.SetPos(0);\n\n\tGetDlgItem(IDC_SEARCH_PIC)->EnableWindow(FALSE);\n\n\tCString filepath(m_pSoftPath);\n\tCString filename(\"BackGround.jpg\");\n\tCString strFile = filepath + filename;\n\tchar *pFileDst = strFile.GetBuffer(256);\n\t\n\tm_pResultPic1.SetImageFile(pFileDst);\n\tm_pResultPic2.SetImageFile(pFileDst);\n\n\tif (0 == m_nTimer)\n\t{\n\t\tm_nTimer = SetTimer(1, FILESEARCH_TIMER_MSEC, NULL);\n\t}\n\n\tGetDlgItem(IDC_BUTTON_SEARCHPIC_STOP)->EnableWindow(FALSE);\n\n\treturn TRUE;  // return TRUE  unless you set the focus to a control\n}\nvoid CSearchByPic::OnOpenPic() \n{\n\tClearShowPersonInfoSearchByPic();\n\n\tUSES_CONVERSION;\n\n\tchar *pFilePath = NULL;\n\tCString PicPath;\n\tCFileDialog dlg(TRUE, NULL, NULL, NULL, \n\t\"JPG files(*.jpg, *.JPG) | *.jpg; *.JPG |\", NULL);\n\tif (dlg.DoModal() == IDOK)\n\t{\n\t\tPicPath = dlg.GetPathName();\n\t\tpFilePath = PicPath.GetBuffer(512);\n\t\tmemcpy(m_szFilePath, pFilePath, sizeof(m_szFilePath));\n\n\t\tm_pPicShow.SetImageFile(PicPath);\n\n\t\tPicPath.ReleaseBuffer();\n\t\tClearShowPersonInfoSearchByPic();\n\t\tGetDlgItem(IDC_SEARCH_PIC)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_BUTTON_SEARCHPIC_STOP)->EnableWindow(FALSE);\n\t}\n}\n\nDWORD WINAPI DoFindFaceRecognition(LPVOID lpParam)\n{\n\tif (lpParam == 0)\n\t{\n\t\treturn 0;\n\t}\n\n\tCSearchByPic *dlg = (CSearchByPic*)lpParam;\n\n\tHWND hwnd = dlg->GetSafeHwnd();\n\t::PostMessage(hwnd, WM_UPDATE_BUTTON_UI, WPARAM(lpParam) , 0);\n\n\treturn 1;\n}\n\nvoid CSearchByPic::ClearShowPersonInfoSearchByPic()\n{\n\tm_ctlSearchPro.SetRange32(0,200);\n\tm_ctlSearchPro.SetPos(0);\n\n\tm_nProgress = 0;\n\n\tSetDlgItemText(IDC_RESULT_NAME, \"\");\n\tSetDlgItemText(IDC_RESULT_SEX, \"\");\n\tSetDlgItemText(IDC_RESULT_YEAR, \"\");\n\tSetDlgItemText(IDC_RESULT_MONTH, \"\");\n\tSetDlgItemText(IDC_RESULT_DAY, \"\");\n\tSetDlgItemText(IDC_RESULT_AGE, \"\");\n\tSetDlgItemText(IDC_RESULT_CARDTYPE, \"\");\n\tSetDlgItemText(IDC_RESULT_CARDID, \"\");\n\tSetDlgItemText(IDC_RESULT_GLASSES, \"\");\n\tSetDlgItemText(IDC_RESULT_RACE, \"\");\n\tSetDlgItemText(IDC_RESULT_EYE, \"\");\n\tSetDlgItemText(IDC_RESULT_Mouth, \"\");\n\tSetDlgItemText(IDC_RESULT_Mask, \"\");\n\tSetDlgItemText(IDC_RESULT_Beard, \"\");\n\tSetDlgItemText(IDC_RESULT_Attractive, \"\");\n\tSetDlgItemText(IDC_EDIT_PIC_SIMILARITY1, \"\");\n\n\tSetDlgItemText(IDC_RESULT_NAME2, \"\");\n\tSetDlgItemText(IDC_RESULT_SEX2, \"\");\n\tSetDlgItemText(IDC_RESULT_YEAR2, \"\");\n\tSetDlgItemText(IDC_RESULT_MONTH2, \"\");\n\tSetDlgItemText(IDC_RESULT_DAY2, \"\");\n\tSetDlgItemText(IDC_RESULT_AGE2, \"\");\n\tSetDlgItemText(IDC_RESULT_CARDTYPE2, \"\");\n\tSetDlgItemText(IDC_RESULT_CARDID2, \"\");\n\tSetDlgItemText(IDC_RESULT_GLASSES2, \"\");\n\tSetDlgItemText(IDC_RESULT_RACE2, \"\");\n\tSetDlgItemText(IDC_RESULT_EYE2, \"\");\n\tSetDlgItemText(IDC_RESULT_Mouth2, \"\");\n\tSetDlgItemText(IDC_RESULT_Mask2, \"\");\n\tSetDlgItemText(IDC_RESULT_Beard2, \"\");\n\tSetDlgItemText(IDC_RESULT_Attractive2, \"\");\n\tSetDlgItemText(IDC_EDIT_PIC_SIMILARITY2, \"\");\n\n\tFillCWndWithDefaultColor(GetDlgItem(IDC_RESULT_PIC));\n\tFillCWndWithDefaultColor(GetDlgItem(IDC_RESULT_PIC2));\n\n\tCString filepath(m_pSoftPath);\n\tCString filename(\"BackGround.jpg\");\n\tCString strFile = filepath + filename;\n\tchar *pFileDst = strFile.GetBuffer(256);\n\tm_pResultPic1.SetImageFile(pFileDst);\n\tm_pResultPic2.SetImageFile(pFileDst);\n\tstrFile.ReleaseBuffer();\n}\n\nvoid CSearchByPic::ShowPersonInfoSearchByPic(FACERECOGNITION_PERSON_INFOEX *pstPersonInfo, int index, int nbySimilarity)\n{\n\tCString str;\n\n\tstr.Format(\"%d\", nbySimilarity);\n\tSetDlgItemText(IDC_EDIT_PIC_SIMILARITY1+(index*300), str);\n\n\tstr.Format(\"%s\", pstPersonInfo->szPersonName);\n\tSetDlgItemText(IDC_RESULT_NAME+(index*300), str);\n\n\tif (1 == pstPersonInfo->bySex)\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Male\"));\n\t}\n\telse if (2 == pstPersonInfo->bySex)\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Female\"));\n\t}\n\telse\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Unknown\"));\n\t}\n\tSetDlgItemText(IDC_RESULT_SEX+(index*300), str);\n\n\tif (pstPersonInfo->wYear != 0  || pstPersonInfo->byMonth != 0 || pstPersonInfo->byDay != 0)\n\t{\n\t\tstr.Format(\"%d\", pstPersonInfo->wYear);\n\t\tSetDlgItemText(IDC_RESULT_YEAR+(index*300), str);\n\n\t\tstr.Format(\"%d\", pstPersonInfo->byMonth);\n\t\tSetDlgItemText(IDC_RESULT_MONTH+(index*300), str);\n\n\t\tstr.Format(\"%d\", pstPersonInfo->byDay);\n\t\tSetDlgItemText(IDC_RESULT_DAY+(index*300), str);\n\t}\n\n\tstr.Format(\"%d\", pstPersonInfo->byAge);\n\tSetDlgItemText(IDC_RESULT_AGE+(index*300), str);\n\n\tif (1 == pstPersonInfo->byIDType)\n\t{\n\t\tSetDlgItemText(IDC_RESULT_CARDTYPE+(index*300), ConvertString(\"IC\"));\n\t}\n\telse if (2 == pstPersonInfo->byIDType)\n\t{\n\t\tSetDlgItemText(IDC_RESULT_CARDTYPE+(index*300), ConvertString(\"Passport\"));\n\t}\n\n\tstr.Format(\"%s\", pstPersonInfo->szID);\n\tSetDlgItemText(IDC_RESULT_CARDID+(index*300), str);\n\n\tif (1 == pstPersonInfo->byGlasses)\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Not Wear\"));\n\t}\n\telse if (2 == pstPersonInfo->byGlasses)\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Wear\"));\n\t}\n\telse\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Unknown\"));\n\t}\n\tSetDlgItemText(IDC_RESULT_GLASSES+(index*300), str);\n\n\tif (EM_RACE_NODISTI == pstPersonInfo->emRace)\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Unidentification\"));\n\t}\n\telse if (EM_RACE_YELLOW == pstPersonInfo->emRace)\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Yellow\"));\n\t}\n\telse if (EM_RACE_BLACK == pstPersonInfo->emRace)\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Black\"));\n\t}\n\telse if (EM_RACE_WHITE == pstPersonInfo->emRace)\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"White\"));\n\t}\n\telse\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Unknown\"));\n\t}\n\tSetDlgItemText(IDC_RESULT_RACE+(index*300), str);\n\n\tif (EM_EYE_STATE_NODISTI == pstPersonInfo->emEye)\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Unidentification\"));\n\t}\n\telse if (EM_EYE_STATE_CLOSE == pstPersonInfo->emEye)\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Close Eyes\"));\n\t}\n\telse if (EM_EYE_STATE_OPEN == pstPersonInfo->emEye)\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Open Eyes\"));\n\t}\n\telse\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Unknown\"));\n\t}\n\tSetDlgItemText(IDC_RESULT_EYE+(index*300), str);\n\n\tif (EM_MOUTH_STATE_NODISTI == pstPersonInfo->emMouth)\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Unidentification\"));\n\t}\n\telse if (EM_MOUTH_STATE_CLOSE == pstPersonInfo->emMouth)\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Close Mouth\"));\n\t}\n\telse if (EM_MOUTH_STATE_OPEN == pstPersonInfo->emMouth)\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Open Mouth\"));\n\t}\n\telse\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Unknown\"));\n\t}\n\tSetDlgItemText(IDC_RESULT_Mouth+(index*300), str);\n\n\tif (EM_MASK_STATE_NODISTI == pstPersonInfo->emMask)\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Unidentification\"));\n\t}\n\telse if (EM_MASK_STATE_NOMASK == pstPersonInfo->emMask)\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Not Wear\"));\n\t}\n\telse if (EM_MASK_STATE_WEAR == pstPersonInfo->emMask)\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Wear\"));\n\t}\n\telse\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Unknown\"));\n\t}\n\tSetDlgItemText(IDC_RESULT_Mask+(index*300), str);\n\n\tif (EM_BEARD_STATE_NODISTI == pstPersonInfo->emBeard)\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Unidentification\"));\n\t}\n\telse if (EM_BEARD_STATE_NOBEARD == pstPersonInfo->emBeard)\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"No Beard\"));\n\t}\n\telse if (EM_BEARD_STATE_HAVEBEARD == pstPersonInfo->emBeard)\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Have Beard\"));\n\t}\n\telse\n\t{\n\t\tstr.Format(\"%s\", ConvertString(\"Unknown\"));\n\t}\n\tSetDlgItemText(IDC_RESULT_Beard+(index*300), str);\n\n\tstr.Format(\"%d\", pstPersonInfo->nAttractive);\n\tSetDlgItemText(IDC_RESULT_Attractive+(index*300), str);\n}\n\nvoid CSearchByPic::AddCandidateInfoToList(CANDIDATE_INFOEX * pstAddInfo)\n{\n\tif (NULL == pstAddInfo)\n\t{\n\t\treturn;\n\t}\n\n\tint i = 0;\n\tBOOL bHasAdd = FALSE;\n\n\tFaceLock locker(m_Mutex);\n\tstd::list<CANDIDATE_INFOEX*>::iterator it = m_lstCandidateInfo.begin();\n\n\tfor (; it != m_lstCandidateInfo.end(); ++it)\n\t{\n\t\tCANDIDATE_INFOEX *pstCandidateInfo = *it;\n\t\tif (pstCandidateInfo)\n\t\t{\n\t\t\tif (pstAddInfo->bySimilarity > pstCandidateInfo->bySimilarity)\n\t\t\t{\n\n\t\t\t\tm_lstCandidateInfo.insert(it, pstAddInfo);\n\t\t\t\tbHasAdd = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tif (FALSE == bHasAdd)\n\t{\n\t\tm_lstCandidateInfo.push_back(pstAddInfo);\n\t}\n\n\tlocker.UnLock();\n}\n\nvoid CSearchByPic::DoFindFaceRecognitionFunc()\n{\n\tint i = 0;\n\tint nToken = 0;\n\tint nTotalCount = 0;\n\tBOOL bRet = FALSE;\n\tCANDIDATE_INFOEX *pstCandidateInfo = NULL;\n\tstd::list<CANDIDATE_INFOEX*>::iterator it;\n\tDH_IN_DOWNLOAD_REMOTE_FILE stuInFile = {sizeof(stuInFile)};\n\tDH_OUT_DOWNLOAD_REMOTE_FILE stuOutFile = {sizeof(stuOutFile)};\n\tNET_IN_DOFIND_FACERECONGNITION stuInDoFind = {sizeof(stuInDoFind)};\n\tNET_OUT_DOFIND_FACERECONGNITION stuOutDoFind = {sizeof(stuOutDoFind)};\n\tconst int nMaxFileLength = 256;\n\n\tfor (int i=0; i<2; ++i)\n\t{\n\t\tstuOutDoFind.stuCandidatesEx[i].stPersonInfo.szFacePicInfo[0].nFilePathLen = nMaxFileLength;\n\t\tstuOutDoFind.stuCandidatesEx[i].stPersonInfo.szFacePicInfo[0].pszFilePath = new char[nMaxFileLength];\n\t\tif (NULL ==  stuOutDoFind.stuCandidatesEx[i].stPersonInfo.szFacePicInfo[0].pszFilePath)\n\t\t{\n\t\t\tgoto ERROR_OUT;\n\t\t}\n\t\tmemset(stuOutDoFind.stuCandidatesEx[i].stPersonInfo.szFacePicInfo[0].pszFilePath, 0, nMaxFileLength);\n\t}\n\n\tstuOutDoFind.bUseCandidatesEx = TRUE;\n\n\tif (m_nProgress == 100) // when device query process is 100 begin to Dofind\n\t{\n\t\tStopAttchHandle();\n\t\tint nBegin = 0;\n\t\tstuInDoFind.nCount = 20; // 20 items per query\n\t\tstuInDoFind.lFindHandle = m_lFindHandle;\n\t\tstuInDoFind.emDataType = EM_NEEDED_PIC_TYPE_HTTP_URL;\n\t\tint nFindCount = 0;\n\t\twhile (1)\n\t\t{\n\t\t\t//stop search button\n\t\t\tDWORD dRet = WaitForSingleObject(m_lEvent, 500);\n\t\t\tif (dRet == WAIT_OBJECT_0)\n\t\t\t{\n\t\t\t\tResetEvent(m_lEvent);\n\t\t\t\tgoto ERROR_OUT;\n\n\t\t\t}\n\n\t\t\tstuInDoFind.nBeginNum = nBegin;\n\t\t\tif (m_lFindHandle)\n\t\t\t{\n\t\t\t\tbRet = CLIENT_DoFindFaceRecognition(&stuInDoFind, &stuOutDoFind, DEFAULT_WAIT_TIME);\n\t\t\t\tif (!bRet)\n\t\t\t\t{\n\t\t\t\t\tMessageBox(ConvertString(\"Failed to do find face recognition!\"), \"\");\n\t\t\t\t\tgoto ERROR_OUT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < stuOutDoFind.nCadidateExNum; i++)\n\t\t\t{\n\t\t\t\tpstCandidateInfo = new CANDIDATE_INFOEX;\n\t\t\t\tif (NULL == pstCandidateInfo)\n\t\t\t\t{\n\t\t\t\t\tAfxMessageBox(ConvertString(\"Memory error\"));\n\t\t\t\t\tgoto ERROR_OUT;\n\t\t\t\t}\n\t\t\t\tmemset(pstCandidateInfo, 0, sizeof(CANDIDATE_INFOEX));\n\t\t\t\tmemcpy(pstCandidateInfo, &(stuOutDoFind.stuCandidatesEx[i]), sizeof(CANDIDATE_INFOEX));\n\t\t\t\tpstCandidateInfo->stPersonInfo.szFacePicInfo[0].pszFilePath = new char[MAX_FILE_PATH_LEN];\n\t\t\t\tif (pstCandidateInfo->stPersonInfo.szFacePicInfo[0].pszFilePath &&\n\t\t\t\t\tstuOutDoFind.stuCandidatesEx[i].stPersonInfo.szFacePicInfo[0].pszFilePath)\n\t\t\t\t{\n\t\t\t\t\tmemset(pstCandidateInfo->stPersonInfo.szFacePicInfo[0].pszFilePath, 0, MAX_FILE_PATH_LEN);\n\t\t\t\t\tstrncpy(pstCandidateInfo->stPersonInfo.szFacePicInfo[0].pszFilePath, stuOutDoFind.stuCandidatesEx[i].stPersonInfo.szFacePicInfo[0].pszFilePath, strlen(stuOutDoFind.stuCandidatesEx[i].stPersonInfo.szFacePicInfo[0].pszFilePath)+1);\n\t\t\t\t}\n\t\t\t\tAddCandidateInfoToList(pstCandidateInfo);\n\t\t\t}\n\n\t\t\tnFindCount += stuOutDoFind.nCadidateExNum;\n\n\t\t\tm_ctlSearchPro.SetRange32(0,200);\n\t\t\tm_nProgress += (((float)nFindCount/(float)m_nTotalCount)*100);\n\n\t\t\tnBegin += 20;\n\n\t\t\tif (stuOutDoFind.nCadidateExNum < 20) // stop query\n\t\t\t{\n\t\t\t\tStopFindHandle();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tDoUpdateCount();\n\n\t\tFaceLock locker(m_Mutex);\n\t\tit = m_lstCandidateInfo.begin();\n\t\tfor (i = 0; (it != m_lstCandidateInfo.end()) && (i < 2); ++it, i++)\n\t\t{\n\t\t\tCANDIDATE_INFOEX *pstCandidateInfo = *it;\n\t\t\tif (pstCandidateInfo)\n\t\t\t{\n\t\t\t\tFACERECOGNITION_PERSON_INFOEX *pstPersonInfo = &(pstCandidateInfo->stPersonInfo);\n\t\t\t\tint nbySimilarity = pstCandidateInfo->bySimilarity;\n\t\t\t\tShowPersonInfoSearchByPic(pstPersonInfo, i, nbySimilarity);\n\t\t\t\tif (strlen(pstCandidateInfo->stPersonInfo.szFacePicInfo[0].pszFilePath) > 0)\n\t\t\t\t{\n\t\t\t\t\tDH_IN_DOWNLOAD_REMOTE_FILE stuInFile = {sizeof(stuInFile)};\n\t\t\t\t\tDH_OUT_DOWNLOAD_REMOTE_FILE stuOutFile = {sizeof(stuOutFile)};\n\n\t\t\t\t\tchar szSrcPath[FACE_MAX_PATH_LEN] = {0};\n\t\t\t\t\tchar szFileDst[FACE_MAX_PATH_LEN] = {0};\n\n\t\t\t\t\tstrncpy(szSrcPath, pstCandidateInfo->stPersonInfo.szFacePicInfo[0].pszFilePath, sizeof(szSrcPath)-1);\n\t\t\t\t\t_snprintf(szFileDst, sizeof(szFileDst) - 1,\"Face\\\\RemoteFace\\\\RemoteFace%d.jpg\", i);\n\n\t\t\t\t\tCString filepath(m_pSoftPath);\n\t\t\t\t\tCString filename(szFileDst);\n\t\t\t\t\tCString strFile = filepath + filename;\n\t\t\t\t\tchar *pFileDst = strFile.GetBuffer(256);\n\n\t\t\t\t\tstuInFile.pszFileName = szSrcPath;\n\t\t\t\t\tstuInFile.pszFileDst = pFileDst;\n\n\t\t\t\t\tbRet = CLIENT_DownloadRemoteFile(m_lLoginId, &stuInFile, &stuOutFile, DEFAULT_WAIT_TIME);\n\t\t\t\t\tif (!bRet)\n\t\t\t\t\t{\n\t\t\t\t\t\tMessageBox(ConvertString(\"Download remote face picture failed!\"), \"\");\n\t\t\t\t\t\tgoto ERROR_OUT;\n\t\t\t\t\t}\n\t\t\t\t\tif (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_pResultPic1.SetImageFile(pFileDst);\n\t\t\t\t\t}\n\t\t\t\t\telse if (i == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_pResultPic2.SetImageFile(pFileDst);\n\t\t\t\t\t}\n\n\t\t\t\t\tstrFile.ReleaseBuffer();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlocker.UnLock();\n\t}\n\nERROR_OUT:\n\tfor (int i=0; i<2; ++i)\n\t{\n\t\tif (stuOutDoFind.stuCandidatesEx[i].stPersonInfo.szFacePicInfo[0].pszFilePath)\n\t\t{\n\t\t\tdelete[] stuOutDoFind.stuCandidatesEx[i].stPersonInfo.szFacePicInfo[0].pszFilePath;\n\t\t\tstuOutDoFind.stuCandidatesEx[i].stPersonInfo.szFacePicInfo[0].pszFilePath = NULL;\n\t\t}\n\t}\n\n\n\tClearCandidateInfo();\n\tStopAttchHandle();\n\tStopFindHandle();\n\tGetDlgItem(IDC_BUTTON_SEARCHPIC_STOP)->EnableWindow(FALSE);\n\tGetDlgItem(IDC_SEARCH_PIC)->EnableWindow(TRUE);\n\tGetDlgItem(IDC_OPEN_PIC)->EnableWindow(TRUE);\n\treturn;\n}\n\nvoid CSearchByPic::OnSearchPic() \n{\n\tStopFindHandle();\n\tStopAttchHandle();\n\tClearShowPersonInfoSearchByPic();\n\tClearCandidateInfo();\n\tGetDlgItem(IDC_OPEN_PIC)->EnableWindow(FALSE);\n\tif (strlen(m_szFilePath) <= 0)\n\t{\n\t\treturn;\n\t}\n\n\tBOOL bRet = FALSE;\n\tLLONG lAttachHandle = 0;\n\tint nToken = 0;\n\n\tNET_THREAD_PARAM stuThreadParam = {0};\n\n\tNET_IN_FACE_FIND_STATE stuInFindState = {sizeof(stuInFindState)};\n\tNET_OUT_FACE_FIND_STATE stuOutFindState = {sizeof(stuOutFindState)};\n\n\tNET_IN_STARTFIND_FACERECONGNITION stuInParam = {sizeof(stuInParam)};\n\tNET_OUT_STARTFIND_FACERECONGNITION stuOutParam = {sizeof(stuOutParam)};\n\tstuInParam.stFilterInfo.dwSize = sizeof(stuInParam.stFilterInfo);\n\tstuInParam.stMatchOptions.dwSize = sizeof(stuInParam.stMatchOptions);\n\n\tstuInParam.bPersonExEnable = TRUE;\n\n\tint id = m_comboChannel.GetCurSel();\n\tif(CB_ERR != id)\n\t{\n\t\tstuInParam.nChannelID = m_comboChannel.GetItemData(id);\n\t}\n\n\tCComboBox *pSimilarity = (CComboBox*)GetDlgItem(IDC_SEARCH_SIMILARITY_COMBOX);\n\tint nSimlilarity = pSimilarity->GetCurSel() + 1;\n\n\tstuInParam.stMatchOptions.nSimilarity = nSimlilarity;\n\n\tCDateTimeCtrl *pCDataStart = (CDateTimeCtrl*)GetDlgItem(IDC_STARTDATE_SEARCHPIC);\n\tCDateTimeCtrl *pCDataEnd = (CDateTimeCtrl*)GetDlgItem(IDC_ENDDATE_SEARCHPIC);\n\n\tSYSTEMTIME DataStart = {0};\n\tSYSTEMTIME DataEnd = {0};\n\n\tpCDataStart->GetTime(&DataStart);\n\tpCDataEnd->GetTime(&DataEnd);\n\n\tstuInParam.stFilterInfo.stStartTime.dwYear = DataStart.wYear;\n\tstuInParam.stFilterInfo.stStartTime.dwMonth = DataStart.wMonth;\n\tstuInParam.stFilterInfo.stStartTime.dwDay = DataStart.wDay;\n\tstuInParam.stFilterInfo.stStartTime.dwHour = 0;\n\tstuInParam.stFilterInfo.stStartTime.dwMinute = 0;\n\tstuInParam.stFilterInfo.stStartTime.dwSecond = 0;\n\n\tstuInParam.stFilterInfo.stEndTime.dwYear = DataEnd.wYear;\n\tstuInParam.stFilterInfo.stEndTime.dwMonth = DataEnd.wMonth;\n\tstuInParam.stFilterInfo.stEndTime.dwDay = DataEnd.wDay;\n\tstuInParam.stFilterInfo.stEndTime.dwHour = 23;\n\tstuInParam.stFilterInfo.stEndTime.dwMinute = 59;\n\tstuInParam.stFilterInfo.stEndTime.dwSecond = 59;\n\n\tBOOL bNeedUpdateButton = TRUE;\n\n\tFILE *fPic = fopen(m_szFilePath, \"rb\");\n\tif (fPic == NULL)\n\t{\n\t\treturn;\n\t}\n\t\n\tfseek(fPic, 0, SEEK_END);\n\tint nLength = ftell(fPic);\n\tif (nLength <= 0)\n\t{\n\t\tbNeedUpdateButton = FALSE;\n\t\tgoto FREE_RETURN;\n\t}\n\trewind(fPic);\n\n\tstuInParam.nBufferLen = nLength;\n\n\tstuInParam.pBuffer = new char[stuInParam.nBufferLen];\n\tif (NULL == stuInParam.pBuffer)\n\t{\n\t\tMessageBox(ConvertString(\"Memory error\"), \"\");\n\t\tbNeedUpdateButton = FALSE;\n\t\tgoto FREE_RETURN;\n\t}\n\n\tmemset(stuInParam.pBuffer, 0, stuInParam.nBufferLen);\n\tint nReadLen = fread(stuInParam.pBuffer, 1, stuInParam.nBufferLen, fPic);\n\tfclose(fPic);\n\tfPic = NULL;\n\tif (nReadLen <= 0)\n\t{\n\t\tbNeedUpdateButton = FALSE;\n\t\tgoto FREE_RETURN;\n\t}\n\n\tstuInParam.stPersonInfoEx.wFacePicNum = 1;\n\tstuInParam.stPersonInfoEx.szFacePicInfo[0].dwOffSet = 0;\n\tstuInParam.stPersonInfoEx.szFacePicInfo[0].dwFileLenth = nLength;\n\n\tbRet = CLIENT_StartFindFaceRecognition(m_lLoginId, &stuInParam, &stuOutParam, DEFAULT_WAIT_TIME);\n\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Failed to start search face recognition!\"), \"\");\n\t\tbNeedUpdateButton = FALSE;\n\t\tgoto FREE_RETURN;\n\t}\n\n\tm_lFindHandle = stuOutParam.lFindHandle;\n\n\tif (-1 == stuOutParam.nTotalCount)\n\t{\n\t\tstuInFindState.nTokenNum = 1;\n\t\tnToken = stuOutParam.nToken;\n\t\tstuInFindState.nTokens = &nToken;\n\t\tstuInFindState.cbFaceFindState = FaceFindState;\n\t\tstuInFindState.dwUser = (LDWORD)this;\n\t\tm_nProgress = 0;\n\n\t\tm_lAttachHandle = CLIENT_AttachFaceFindState(m_lLoginId, &stuInFindState, &stuOutFindState, DEFAULT_WAIT_TIME);\n\n\t\tif (0 == m_lAttachHandle)\n\t\t{\n\t\t\tMessageBox(ConvertString(\"Query By Picture fail\"), \"\");\n\t\t\tStopFindHandle();\n\t\t\tbNeedUpdateButton = FALSE;\n\t\t\tgoto FREE_RETURN;\n\t\t}\n\t}\n\telse\n\t{\n\t\tMessageBox(ConvertString(\"Failed to start search face recognition!\"), \"\");\n\t}\n\nFREE_RETURN:\n\tif (stuInParam.pBuffer)\n\t{\n\t\tdelete[] stuInParam.pBuffer;\n\t\tstuInParam.pBuffer = NULL;\n\t}\n\n\tif (fPic)\n\t{\n\t\tfclose(fPic);\n\t\tfPic = NULL;\n\t}\n\tif (bNeedUpdateButton)\n\t{\n\t\tGetDlgItem(IDC_SEARCH_PIC)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_BUTTON_SEARCHPIC_STOP)->EnableWindow(TRUE);\n\t}\n\telse\n\t{\n\t\tGetDlgItem(IDC_OPEN_PIC)->EnableWindow(TRUE);\n\t}\n}\n\nvoid CSearchByPic::OnBnClickedButtonSearchpicStop()\n{\n\tm_nProgress = 0;\n\tStopFindHandle();\n\tStopAttchHandle();\n\n\tSetEvent(m_lEvent);\n\tGetDlgItem(IDC_BUTTON_SEARCHPIC_STOP)->EnableWindow(FALSE);\n\tGetDlgItem(IDC_SEARCH_PIC)->EnableWindow(TRUE);\n\tGetDlgItem(IDC_OPEN_PIC)->EnableWindow(TRUE);\n}\n\nLRESULT CSearchByPic::OnDeviceAttch(WPARAM wParam, LPARAM lParam)\n{\t\n\tif (wParam == NULL)\n\t{\n\t\treturn 0;\n\t}\n\tCSearchByPic *dlg = (CSearchByPic *)wParam;\n\tdlg->DoFindFaceRecognitionFunc();\n\n\treturn 0;\n}\n\nvoid CSearchByPic::DoUpdateCount()\n{\n\tCString strCount = \"\";\n\tstrCount.Format(\"%d\", m_nTotalCount);\n\tif (m_nTotalCount == 0)\n\t{\n\t\tm_nProgress = 200;\n\t}\n\tSetDlgItemText(IDC_EDIT_SEARCHBUPIC_COUNT, strCount);\n}\n\nBOOL CSearchByPic::PreTranslateMessage(MSG* pMsg)\n{\n\t// Enter key\n\tif(pMsg->message == WM_KEYDOWN &&\n\t\tpMsg->wParam == VK_RETURN)\n\t{\n\t\treturn TRUE;\n\t}\n\n\treturn CDialog::PreTranslateMessage(pMsg);\n}\n\nvoid CSearchByPic::OnTimer(UINT_PTR nIDEvent)\n{\n\tif(nIDEvent == m_nTimer)\n\t{\n\t\tm_ctlSearchPro.SetRange32(0, 200);\n\t\tm_ctlSearchPro.SetPos((int)(m_nProgress) );\n\t}\n\n\tCDialog::OnTimer(nIDEvent);\n}\n\nvoid CSearchByPic::StopAttchHandle()\n{\n\tif (m_lAttachHandle)\n\t{\n\t\tCLIENT_DetachFaceFindState(m_lAttachHandle);\n\t\tm_lAttachHandle = 0;\n\t}\n}\n\nvoid CSearchByPic::StopFindHandle()\n{\n\tif (m_lFindHandle)\n\t{\n\t\tCLIENT_StopFindFaceRecognition(m_lFindHandle);\n\t\tm_lFindHandle = 0;\n\t}\t\n}","size_bytes":23486},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/ConfigAlarmMotionArea.cpp":{"content":"// ConfigAlarmMotionArea.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"ConfigAlarmMotionArea.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CConfigAlarmMotionArea dialog\n\n\nCConfigAlarmMotionArea::CConfigAlarmMotionArea(CWnd* pParent /*=NULL*/)\n\t: CDialog(CConfigAlarmMotionArea::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CConfigAlarmMotionArea)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_bDrawing = FALSE;\n\tm_blckWid = 0;\n\tm_blckHght = 0;\n\tm_stpoint.x = -1;\n\tm_stpoint.y = -1;\n\tm_lastpoint.x = -1;\n\tm_lastpoint.y = -1;\n}\n\n\nvoid CConfigAlarmMotionArea::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CConfigAlarmMotionArea)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CConfigAlarmMotionArea, CDialog)\n\t//{{AFX_MSG_MAP(CConfigAlarmMotionArea)\n\tON_WM_LBUTTONDOWN()\n\tON_WM_LBUTTONUP()\n\tON_WM_CTLCOLOR()\n\tON_BN_CLICKED(IDC_OK, OnOk)\n\tON_BN_CLICKED(IDC_CANCEL, OnCancel)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CConfigAlarmMotionArea message handlers\n\nBOOL CConfigAlarmMotionArea::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\t\n\tCRect m_rect;\n\tGetDlgItem(IDC_AREA_BOARD)->GetClientRect(&m_rect);\n\tGetDlgItem(IDC_AREA_BOARD)->ClientToScreen(&m_rect);\n\tScreenToClient(&m_rect);\n\tint blckWid = (m_rect.Width()-DH_MOTION_COL+1)/DH_MOTION_COL;\n\tm_blckWid = blckWid;\n\tint blckHght = (m_rect.Height()-DH_MOTION_ROW+1)/DH_MOTION_ROW;\n\tm_blckHght = blckHght;\n\tfor (int i = 0; i < DH_MOTION_ROW; i++)\n\t{\n\t\tfor (int j = 0; j < DH_MOTION_COL; j++)\n\t\t{\n\t\t\tm_block[i][j].Create(\n\t\t\tNULL, \n\t\t\tNULL, \n\t\t\tWS_VISIBLE | WS_CHILD,\n\t\t\tCRect(m_rect.left+j*blckWid+j, m_rect.top+i*blckHght+i, m_rect.left+(j+1)*blckWid+j, m_rect.top+(i+1)*blckHght+i),\n\t\t\tthis,\n\t\t\t1979,\n\t\t\tNULL);\n\t\t\tm_block[i][j].PostMessage(MSG_SHOW);\n\t\t\tm_block[i][j].SetPos(i,j);\n\t\t}\n\t}\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CConfigAlarmMotionArea::SetArea(BYTE *area)\n{\n\tif (!area)\n\t{\n\t\treturn;\n\t}\n\tmemcpy(m_myArea, area, DH_MOTION_COL*DH_MOTION_ROW);\n\n\tfor (int i = 0; i < DH_MOTION_ROW; i++)\n\t{\n\t\tfor (int j = 0; j < DH_MOTION_COL; j++)\n\t\t{\n\t\t\tm_block[i][j].SetStatus(m_myArea[i][j]);\n\t\t}\n\t}\n}\n\nvoid CConfigAlarmMotionArea::OnLButtonDown(UINT nFlags, CPoint point) \n{\n\tCDialog::OnLButtonDown(nFlags, point);\n}\n\nvoid CConfigAlarmMotionArea::RecordPoint(BYTE x, BYTE y)\n{\n\tm_stpoint.x = x;\n\tm_stpoint.y = y;\n\tm_lastpoint.x = x;\n\tm_lastpoint.y = y;\n\tm_bDrawing = TRUE;\n\n\tm_block[x][y].PostMessage(MSG_SELETED);\n}\n\nvoid CConfigAlarmMotionArea::ReleasePoint()\n{\n\tm_bDrawing = FALSE;\n}\n\nvoid CConfigAlarmMotionArea::OnLButtonUp(UINT nFlags, CPoint point) \n{\n\tm_bDrawing = FALSE;\n\n\tCDialog::OnLButtonUp(nFlags, point);\n}\n\nBOOL IsBetween(int lft, int mid, int rht)\n{\n\tif (lft >= rht)\n\t{\n\t\treturn (mid >= rht && mid <= lft);\n\t}\n\telse\n\t{\n\t\treturn (mid >= lft && mid <= rht);\n\t}\n}\n\nvoid CConfigAlarmMotionArea::MovePoint(DWORD dwParm, BYTE x, BYTE y)\n{\n\tif (!m_bDrawing || !(dwParm&MK_LBUTTON) || (m_lastpoint.x == x && m_lastpoint.y == y))\n\t{\n\t\treturn;\n\t}\n\n\tfor (int i = 0; i < DH_MOTION_ROW; i++)\n\t{\n\t\tfor (int j = 0; j < DH_MOTION_COL; j++)\n\t\t{\n\t\t\tif(((IsBetween(m_stpoint.x, i, x) && IsBetween(m_stpoint.y, j, y)) &&\n\t\t\t\t!(IsBetween(m_stpoint.x, i, m_lastpoint.x) && IsBetween(m_stpoint.y, j, m_lastpoint.y))) ||\n\t\t\t\t(IsBetween(m_stpoint.x, i, m_lastpoint.x) && IsBetween(m_stpoint.y, j, m_lastpoint.y)) &&\n\t\t\t\t!((IsBetween(m_stpoint.x, i, x) && IsBetween(m_stpoint.y, j, y))))\n\t\t\t{\n\t\t\t\tm_block[i][j].PostMessage(MSG_SELETED);\n\t\t\t}\n\t\t}\n\t}\n\n\tm_lastpoint.x = x;\n\tm_lastpoint.y = y;\n}\n\nHBRUSH CConfigAlarmMotionArea::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) \n{\n\tHBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);\n\t\n\t// TODO: Change any attributes of the DC here\n\t\n\t// TODO: Return a different brush if the default is not desired\n\treturn hbr;\n}\n\nvoid CConfigAlarmMotionArea::OnOk() \n{\n\tfor (int i = 0; i < DH_MOTION_ROW; i++)\n\t{\n\t\tfor (int j = 0; j < DH_MOTION_COL; j++)\n\t\t{\n\t\t\tm_myArea[i][j] = m_block[i][j].IsSeleted()?1:0;\n\t\t}\n\t}\n\tCDialog::OnOK();\n}\n\nvoid CConfigAlarmMotionArea::OnCancel() \n{\n\tCDialog::OnCancel();\n}\n","size_bytes":4480},"bin/Demo/MfcDemo/09.AccessControl/SubDlgCfgDoorOpenTimeSection.cpp":{"content":"// SubDlgCfgDoorOpenTimeSection.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"accesscontrol.h\"\n#include \"SubDlgCfgDoorOpenTimeSection.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CSubDlgCfgDoorOpenTimeSection dialog\n\n\nCSubDlgCfgDoorOpenTimeSection::CSubDlgCfgDoorOpenTimeSection(CWnd* pParent /* = NULL */)\n\t: CDialog(CSubDlgCfgDoorOpenTimeSection::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CSubDlgCfgDoorOpenTimeSection)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tmemset(&m_stuDoorTimeSection, 0, sizeof(m_stuDoorTimeSection));\n}\n\n\nvoid CSubDlgCfgDoorOpenTimeSection::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CSubDlgCfgDoorOpenTimeSection)\n\tDDX_Control(pDX, IDC_DOOROPENTIMESECTION_DTP_ET4, m_dtp4End);\n\tDDX_Control(pDX, IDC_DOOROPENTIMESECTION_DTP_ET3, m_dtp3End);\n\tDDX_Control(pDX, IDC_DOOROPENTIMESECTION_DTP_ET2, m_dtp2End);\n\tDDX_Control(pDX, IDC_DOOROPENTIMESECTION_DTP_ET1, m_dtp1End);\n\tDDX_Control(pDX, IDC_DOOROPENTIMESECTION_DTP_ST4, m_dtp4Start);\n\tDDX_Control(pDX, IDC_DOOROPENTIMESECTION_DTP_ST3, m_dtp3Start);\n\tDDX_Control(pDX, IDC_DOOROPENTIMESECTION_DTP_ST2, m_dtp2Start);\n\tDDX_Control(pDX, IDC_DOOROPENTIMESECTION_DTP_ST1, m_dtp1Start);\n\tDDX_Control(pDX, IDC_DOOROPENTIMESECTION_CMB_WEEKDAY, m_cmbWeekDay);\n\tDDX_Control(pDX, IDC_DOOROPENTIMESECTION_CMB_OPENMETHOD4, m_cmbOpenMethod4);\n\tDDX_Control(pDX, IDC_DOOROPENTIMESECTION_CMB_OPENMETHOD3, m_cmbOpenMethod3);\n\tDDX_Control(pDX, IDC_DOOROPENTIMESECTION_CMB_OPENMETHOD2, m_cmbOpenMethod2);\n\tDDX_Control(pDX, IDC_DOOROPENTIMESECTION_CMB_OPENMETHOD1, m_cmbOpenMethod1);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CSubDlgCfgDoorOpenTimeSection, CDialog)\n\t//{{AFX_MSG_MAP(CSubDlgCfgDoorOpenTimeSection)\n\tON_CBN_SELCHANGE(IDC_DOOROPENTIMESECTION_CMB_WEEKDAY, OnSelchangeDooropentimesectionCmbWeekday)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_DOOROPENTIMESECTION_DTP_ST1, OnDatetimechangeDooropentimesectionDtpSt1)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_DOOROPENTIMESECTION_DTP_ET1, OnDatetimechangeDooropentimesectionDtpEt1)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_DOOROPENTIMESECTION_DTP_ST2, OnDatetimechangeDooropentimesectionDtpSt2)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_DOOROPENTIMESECTION_DTP_ET2, OnDatetimechangeDooropentimesectionDtpEt2)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_DOOROPENTIMESECTION_DTP_ST3, OnDatetimechangeDooropentimesectionDtpSt3)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_DOOROPENTIMESECTION_DTP_ET3, OnDatetimechangeDooropentimesectionDtpEt3)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_DOOROPENTIMESECTION_DTP_ST4, OnDatetimechangeDooropentimesectionDtpSt4)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_DOOROPENTIMESECTION_DTP_ET4, OnDatetimechangeDooropentimesectionDtpEt4)\n\tON_CBN_SELCHANGE(IDC_DOOROPENTIMESECTION_CMB_OPENMETHOD1, OnSelchangeDooropentimesectionCmbOpenmethod1)\n\tON_CBN_SELCHANGE(IDC_DOOROPENTIMESECTION_CMB_OPENMETHOD2, OnSelchangeDooropentimesectionCmbOpenmethod2)\n\tON_CBN_SELCHANGE(IDC_DOOROPENTIMESECTION_CMB_OPENMETHOD3, OnSelchangeDooropentimesectionCmbOpenmethod3)\n\tON_CBN_SELCHANGE(IDC_DOOROPENTIMESECTION_CMB_OPENMETHOD4, OnSelchangeDooropentimesectionCmbOpenmethod4)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CSubDlgCfgDoorOpenTimeSection private method\n\nvoid CSubDlgCfgDoorOpenTimeSection::InitDlg()\n{\n\tunsigned int i = 0;\n\n\t// week day\n\tm_cmbWeekDay.ResetContent();\n\tfor (i = 0; i < sizeof(stuDemoWeekDay) / sizeof(stuDemoWeekDay[0]); i++)\n\t{\n\t\tm_cmbWeekDay.InsertString(-1, ConvertString(stuDemoWeekDay[i].pszName));\n\t}\n\tm_cmbWeekDay.SetCurSel(0);\n\t\n\t// DateTimePickers...\n\tSYSTEMTIME stStart = {2000,1,1,1}, stEnd = {2000,1,1,1,23,59,59,0};\n\tm_dtp1Start.SetTime(&stStart);\n\tm_dtp1End.SetTime(&stEnd);\n\tm_dtp2Start.SetTime(&stStart);\n\tm_dtp2End.SetTime(&stEnd);\n\tm_dtp3Start.SetTime(&stStart);\n\tm_dtp3End.SetTime(&stEnd);\n\tm_dtp4Start.SetTime(&stStart);\n\tm_dtp4End.SetTime(&stEnd);\n\n\t// door open method\n\tm_cmbOpenMethod1.ResetContent();\n\tm_cmbOpenMethod2.ResetContent();\n\tm_cmbOpenMethod3.ResetContent();\n\tm_cmbOpenMethod4.ResetContent();\n\tfor (i = 0; i < sizeof(stuDemoOpenMethod)/sizeof(stuDemoOpenMethod[0]); i++)\n\t{\n\t\tm_cmbOpenMethod1.InsertString(-1, ConvertString(stuDemoOpenMethod[i].szName));\n\t\tm_cmbOpenMethod2.InsertString(-1, ConvertString(stuDemoOpenMethod[i].szName));\n\t\tm_cmbOpenMethod3.InsertString(-1, ConvertString(stuDemoOpenMethod[i].szName));\n\t\tm_cmbOpenMethod4.InsertString(-1, ConvertString(stuDemoOpenMethod[i].szName));\n    }\n    m_cmbOpenMethod1.SetDroppedWidth(160);\n    m_cmbOpenMethod2.SetDroppedWidth(160);\n    m_cmbOpenMethod3.SetDroppedWidth(160);\n    m_cmbOpenMethod4.SetDroppedWidth(160);\n\tm_cmbOpenMethod1.SetCurSel(-1);\n\tm_cmbOpenMethod2.SetCurSel(-1);\n\tm_cmbOpenMethod3.SetCurSel(-1);\n\tm_cmbOpenMethod4.SetCurSel(-1);\t\n}\n\nvoid CSubDlgCfgDoorOpenTimeSection::StuToDlg()\n{\n\tOnSelchangeDooropentimesectionCmbWeekday();\n}\n\nvoid CSubDlgCfgDoorOpenTimeSection::DlgToStu()\n{\n\tGetTimeSectionFromDlg();\n}\n\nvoid CSubDlgCfgDoorOpenTimeSection::GetTimeSectionFromDlg()\n{\n\tint nSel = m_cmbWeekDay.GetCurSel();\n\tSYSTEMTIME stBegin = {0}, stEnd = {0};\n\tfor (int i = 0; i < MAX_DOOR_TIME_SECTION; i++)\n\t{\n\t\tCFG_DOOROPEN_TIMESECTION_INFO& stuTimeSection = m_stuDoorTimeSection[(em_WeekDay)nSel][i];\n\t\tswitch (i)\n\t\t{\n\t\tcase 0:\n\t\t\tstuTimeSection.emDoorOpenMethod = (CFG_DOOR_OPEN_METHOD)m_cmbOpenMethod1.GetCurSel();\n\t\t\tm_dtp1Start.GetTime(&stBegin);\n\t\t\tm_dtp1End.GetTime(&stEnd);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tstuTimeSection.emDoorOpenMethod = (CFG_DOOR_OPEN_METHOD)m_cmbOpenMethod2.GetCurSel();\n\t\t\tm_dtp2Start.GetTime(&stBegin);\n\t\t\tm_dtp2End.GetTime(&stEnd);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstuTimeSection.emDoorOpenMethod = (CFG_DOOR_OPEN_METHOD)m_cmbOpenMethod3.GetCurSel();\n\t\t\tm_dtp3Start.GetTime(&stBegin);\n\t\t\tm_dtp3End.GetTime(&stEnd);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tstuTimeSection.emDoorOpenMethod = (CFG_DOOR_OPEN_METHOD)m_cmbOpenMethod4.GetCurSel();\n\t\t\tm_dtp4Start.GetTime(&stBegin);\n\t\t\tm_dtp4End.GetTime(&stEnd);\n\t\t\tbreak;\n\t\t}\n\t\tDTPToCfgTimePeriod(stBegin, stEnd, stuTimeSection.stuTime);\n\t}\n}\n\nvoid CSubDlgCfgDoorOpenTimeSection::CfgTimePeriodToDTP(const CFG_TIME_PERIOD& stuTimeSection, SYSTEMTIME& stBegin, SYSTEMTIME& stEnd)\n{\n\tstBegin.wHour\t= (WORD)stuTimeSection.stuStartTime.dwHour;\n\tstBegin.wMinute = (WORD)stuTimeSection.stuStartTime.dwMinute;\n\tstBegin.wSecond = (WORD)stuTimeSection.stuStartTime.dwSecond;\n\tstEnd.wHour\t\t= (WORD)stuTimeSection.stuEndTime.dwHour;\n\tstEnd.wMinute\t= (WORD)stuTimeSection.stuEndTime.dwMinute;\n\tstEnd.wSecond\t= (WORD)stuTimeSection.stuEndTime.dwSecond;\n}\n\nvoid CSubDlgCfgDoorOpenTimeSection::DTPToCfgTimePeriod(const SYSTEMTIME& stuStart, const SYSTEMTIME& stuEnd, CFG_TIME_PERIOD& stuPeriod)\n{\n\tstuPeriod.stuStartTime.dwHour = stuStart.wHour;\n\tstuPeriod.stuStartTime.dwMinute = stuStart.wMinute;\n\tstuPeriod.stuStartTime.dwSecond = stuStart.wSecond;\n\tstuPeriod.stuEndTime.dwHour = stuEnd.wHour;\n\tstuPeriod.stuEndTime.dwMinute = stuEnd.wMinute;\n\tstuPeriod.stuEndTime.dwSecond = stuEnd.wSecond;\n}\n\nvoid CSubDlgCfgDoorOpenTimeSection::ShowTimeSection(int nSeg, const CFG_DOOROPEN_TIMESECTION_INFO& stuTimeSection)\n{\n\tSYSTEMTIME stBegin = {2000, 1, 1, 1}, stEnd = {2000, 1, 1, 1};\n\tCfgTimePeriodToDTP(stuTimeSection.stuTime, stBegin, stEnd);\n\t\n\tswitch (nSeg)\n\t{\n\tcase 0:\n\t\tm_dtp1Start.SetTime(&stBegin);\n\t\tm_dtp1End.SetTime(&stEnd);\n\t\tm_cmbOpenMethod1.SetCurSel((int)stuTimeSection.emDoorOpenMethod);\n\t\tbreak;\n\tcase 1:\n\t\tm_dtp2Start.SetTime(&stBegin);\n\t\tm_dtp2End.SetTime(&stEnd);\n\t\tm_cmbOpenMethod2.SetCurSel((int)stuTimeSection.emDoorOpenMethod);\n\t\tbreak;\n\tcase 2:\n\t\tm_dtp3Start.SetTime(&stBegin);\n\t\tm_dtp3End.SetTime(&stEnd);\n\t\tm_cmbOpenMethod3.SetCurSel((int)stuTimeSection.emDoorOpenMethod);\n\t\tbreak;\n\tcase 3:\n\t\tm_dtp4Start.SetTime(&stBegin);\n\t\tm_dtp4End.SetTime(&stEnd);\n\t\tm_cmbOpenMethod4.SetCurSel((int)stuTimeSection.emDoorOpenMethod);\n\t\tbreak;\n\t}\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CSubDlgCfgDoorOpenTimeSection message handlers\n\nBOOL CSubDlgCfgDoorOpenTimeSection::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, SUBDLG_CFG_DOOROPEN_TIMESECTION);\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\tStuToDlg();\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CSubDlgCfgDoorOpenTimeSection::OnSelchangeDooropentimesectionCmbWeekday() \n{\n\t// TODO: Add your control notification handler code here\n\tint nSel = m_cmbWeekDay.GetCurSel();\n\tif (-1 == nSel)\n\t{\n\t\treturn;\n\t}\n\t\n\tfor (int i = 0; i < MAX_DOOR_TIME_SECTION; i++)\n\t{\n\t\tShowTimeSection(i, m_stuDoorTimeSection[nSel][i]);\n\t}\n}\n\nvoid CSubDlgCfgDoorOpenTimeSection::OnDatetimechangeDooropentimesectionDtpSt1(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\t*pResult = 0;\n}\n\nvoid CSubDlgCfgDoorOpenTimeSection::OnDatetimechangeDooropentimesectionDtpEt1(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\t*pResult = 0;\n}\n\nvoid CSubDlgCfgDoorOpenTimeSection::OnDatetimechangeDooropentimesectionDtpSt2(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\t*pResult = 0;\n}\n\nvoid CSubDlgCfgDoorOpenTimeSection::OnDatetimechangeDooropentimesectionDtpEt2(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\t*pResult = 0;\n}\n\nvoid CSubDlgCfgDoorOpenTimeSection::OnDatetimechangeDooropentimesectionDtpSt3(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\t*pResult = 0;\n}\n\nvoid CSubDlgCfgDoorOpenTimeSection::OnDatetimechangeDooropentimesectionDtpEt3(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\t*pResult = 0;\n}\n\nvoid CSubDlgCfgDoorOpenTimeSection::OnDatetimechangeDooropentimesectionDtpSt4(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\t*pResult = 0;\n}\n\nvoid CSubDlgCfgDoorOpenTimeSection::OnDatetimechangeDooropentimesectionDtpEt4(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\t*pResult = 0;\n}\n\nvoid CSubDlgCfgDoorOpenTimeSection::OnSelchangeDooropentimesectionCmbOpenmethod1() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n}\n\nvoid CSubDlgCfgDoorOpenTimeSection::OnSelchangeDooropentimesectionCmbOpenmethod2() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n}\n\nvoid CSubDlgCfgDoorOpenTimeSection::OnSelchangeDooropentimesectionCmbOpenmethod3() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n}\n\nvoid CSubDlgCfgDoorOpenTimeSection::OnSelchangeDooropentimesectionCmbOpenmethod4() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n}\n","size_bytes":11036},"bin/Demo/MfcDemo/17.IntelligentTraffic/StdAfx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n// IntelligentTraffic.pch will be the pre-compiled header\n// stdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n\n\n","size_bytes":211},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/DiskControl.cpp":{"content":"// DiskControl.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"DiskControl.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDiskControl dialog\n\n\nCDiskControl::CDiskControl(CWnd* pParent /*=NULL*/)\n\t: CDialog(CDiskControl::IDD, pParent)\n{\n\tmemset(&m_devWorkState, 0, sizeof(NET_DEV_WORKSTATE));\n\t//{{AFX_DATA_INIT(CDiskControl)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\n\tm_dev = NULL;\n}\n\n\nvoid CDiskControl::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDiskControl)\n\tDDX_Control(pDX, IDC_DISKSEL_COMBO, m_disksel);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDiskControl, CDialog)\n\t//{{AFX_MSG_MAP(CDiskControl)\n\tON_CBN_SELCHANGE(IDC_DISKSEL_COMBO, OnSelchangeDiskselCombo)\t\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDiskControl message handlers\n\nBOOL CDiskControl::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\tBOOL bRet = CLIENT_GetDEVWorkState(m_dev->LoginID, &m_devWorkState);\n\t\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDiskControl::OnSelchangeDiskselCombo() \n{\n}\n\nvoid CDiskControl::SetDeviceId(DeviceNode *dev)\n{\n\tm_dev = dev;\n}","size_bytes":1465},"bin/Demo/MfcDemo/19.MasterSlaveSensor/PlayWnd.cpp":{"content":"#include \"stdafx.h\"\n#include \"MasterSlaverSensor.h\"\n#include \"PlayWnd.h\"\n#include \"PtzScreen.h\"\n#include \"MasterSlaverSensorDlg.h\"\n#include \"Utils.h\"\n\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CPlayWnd dialog\n\n\nCPlayWnd::CPlayWnd()\n\t:m_nWndID(0)\n{\n\t//{{AFX_DATA_INIT(CPlayWnd)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\nBEGIN_MESSAGE_MAP(CPlayWnd, CWnd)\n\t//{{AFX_MSG_MAP(CPlayWnd)\n\tON_WM_ERASEBKGND()\n\tON_WM_CONTEXTMENU()\n\tON_WM_LBUTTONDOWN()\n\tON_WM_MBUTTONUP()\n\tON_WM_MOUSEMOVE()\n\tON_WM_ACTIVATE()\n\tON_WM_CREATE()\n\tON_WM_TIMER()\n\tON_WM_ACTIVATEAPP()\n\t//}}AFX_MSG_MAP\n\tON_COMMAND_RANGE(VIDEO_MENU_BASE, VIDEO_MENU_END, OnVideoMenu)\n\tON_MESSAGE(VIDEO_REPAINT, OnRepaintWnd)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CPlayWnd message handlers\nBOOL CPlayWnd::OnEraseBkgnd(CDC* pDC) \n{\n\t// TODO: Add your message handler code here and/or call default\n\tCRect rt;\n\tGetClientRect(&rt);\n\tCBrush br;\n\tbr.CreateSolidBrush(VIDEO_BACK_COLOR);\n\tpDC->FillRect(&rt,&br);\n\n\treturn TRUE;\n\treturn CWnd::OnEraseBkgnd(pDC);\n}\n\nLRESULT CPlayWnd::DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam) \n{\n\t// TODO: Add your specialized code here and/or call the base class\n\tCPtzScreen *pContainer = (CPtzScreen *)GetParent();\n// \tCClientDemoDlg *pMainWnd = (CClientDemoDlg *)(AfxGetApp()->GetMainWnd());\n// \tCDialogTransmit * pTransWnd = (CDialogTransmit *)pMainWnd->m_pTabTransmit;\n\n\tif(pContainer)\n\t{\n\t\tswitch(message)\n\t\t{\n\t\tcase WM_LBUTTONUP:\n\t\t\t{\n\t\t\t\t\n\t\t\t\tpointEnd.x = LOWORD(lParam);\n\t\t\t\tpointEnd.y = HIWORD(lParam);\n\t\t\t\tif(m_FlagRect == TRUE)\n\t\t\t\t{\n\t\t\t\t\tm_FlagRect =FALSE;\n\t\t\t\t\tKillTimer(2);\n\t\t\t\t\tRECT rt;\n\t\t\t\t\tGetClientRect(&rt);\n\t\t\t\t\tpContainer->m_pRectEventFunc(m_nWndID, rt, pointStart, pointEnd, pContainer->m_dwRectEvent, pContainer->m_nID);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WM_MOUSEMOVE:\n\t\t\t{\n\t\t\t\t\n\t\t\t\tRECT rt;\n\t\t\t\tGetClientRect(&rt);\n\t\t\t\tlong x = LOWORD(lParam);\n\t\t\t\tlong y = HIWORD(lParam);\n\t\t\t\tx = x>rt.right?rt.right:x;\n\t\t\t\tx = x<rt.left?rt.left:x;\n\t\t\t\ty = y>rt.bottom?rt.bottom:y;\n\t\t\t\ty = y<rt.top?rt.top:y;\n\t\t\t\tpointEnd.x = x;\n\t\t\t\tpointEnd.y = y;\n\t\t\t\t\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WM_LBUTTONDOWN:\n\t\t\t{\n\t\t\t\n\t\t\t\tpointStart.x = LOWORD(lParam);\n\t\t\t\tpointStart.y = HIWORD(lParam);\n\t\t\t\tm_FlagRect =TRUE;\n\t\t\t\tSetTimer(2,16,NULL);\n\t\t\t}\n\t\tcase WM_RBUTTONDOWN:\n\t\t\tpContainer->SetActivePage(this);\n\t\t\t{\n\t\t\t\tif (pContainer->m_pMessageProc)\n\t\t\t\t{\n\t\t\t\t\tRECT rt;\n\t\t\t\t\tGetClientRect(&rt);\n\t\t\t\t\tpointEnd.x = LOWORD(lParam);\n\t\t\t\t\tpointEnd.y = HIWORD(lParam);\n\t\t\t\t\t//pContainer->m_pMessageProc(m_nWndID, WM_RBUTTONDOWN, rt, pointStart, pContainer->m_dwMessageUser);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tbreak;\n\t\t\n\t\t\tcase WM_LBUTTONDBLCLK:\n\t\t\t{\n\t\t\t\tBOOL bMulti = pContainer->GetMultiScreen();\n\t\t\t\tpContainer->SetMultiScreen(!bMulti);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn CWnd::DefWindowProc(message, wParam, lParam);\n}\n\nvoid CPlayWnd::OnContextMenu(CWnd* pWnd, CPoint point) \n{\n\tif (m_nWndID == 0)\n\t{\n\t\treturn;\n\t}\n\t// TODO: Add your message handler code here\n\tCPtzScreen *pContainer = (CPtzScreen *)GetParent();\n\tpContainer->SetActivePage(this);\n\n// \tCClientDemoDlg *pMainWnd = (CClientDemoDlg *)(AfxGetApp()->GetMainWnd());\n// \tCDialogTransmit * pTransWnd = (CDialogTransmit *)pMainWnd->m_pTabTransmit;\n\n\tCMenu menu;\n\tmenu.CreatePopupMenu();\n\tmenu.AppendMenu(MF_STRING | pContainer->GetFullScreen()    ? MF_CHECKED : MF_UNCHECKED, VIDEO_MENU_FULLSCREEN, ConvertString(NAME_MENU_FULLSCREEN));\n\tmenu.AppendMenu(MF_STRING | pContainer->GetMultiScreen()    ? MF_CHECKED : MF_UNCHECKED, \tVIDEO_MENU_MULTISCREEN, ConvertString(NAME_MENU_MULTISCREEN));\n\tmenu.AppendMenu(MF_STRING | pContainer->GetAutoAdjustPos() ? MF_CHECKED : MF_UNCHECKED, VIDEO_MENU_AUTOADJUST, ConvertString(NAME_MENU_AUTOADJUST));\n\tmenu.AppendMenu(MF_STRING | pContainer->m_pGetParams(m_nWndID, 0, pContainer->m_dwGetParams) ? MF_CHECKED : MF_UNCHECKED, VIDEO_MENU_EXITDECODE, ConvertString(NAME_MENU_EXITDECODE));\n\tmenu.AppendMenu(MF_STRING | pContainer->m_pGetParams(m_nWndID, 1, pContainer->m_dwGetParams) ? MF_CHECKED : MF_UNCHECKED, VIDEO_MENU_EXITCYCLE, ConvertString(NAME_MENU_EXITCYCLE));\n\n\tTrackPopupMenu( \n\t\tmenu.m_hMenu, \n\t\tTPM_LEFTALIGN, \n\t\tpoint.x, \n\t\tpoint.y,\n\t\t0,\n\t\tm_hWnd,\n\t\tNULL);\n}\n\nvoid CPlayWnd::OnVideoMenu(UINT nID)\n{\n\tCPtzScreen *pContainer = (CPtzScreen *)GetParent();\n// \tCClientDemoDlg *pMainWnd = (CClientDemoDlg *)(AfxGetApp()->GetMainWnd());\n// \tCDialogTransmit * pTransWnd = (CDialogTransmit *)pMainWnd->m_pTabTransmit;\n\n\tswitch(nID)\n\t{\n\tcase VIDEO_MENU_FULLSCREEN:\n\t\tpContainer->SetFullScreen(!pContainer->GetFullScreen());\n\t\tbreak;\n\tcase VIDEO_MENU_MULTISCREEN:\n\t\tpContainer->SetMultiScreen(!pContainer->GetMultiScreen());\n\t\tbreak;\n\tcase VIDEO_MENU_AUTOADJUST:\n\t\tpContainer->SetAutoAdjustPos(!pContainer->GetAutoAdjustPos());\n\t\tbreak;\n\tcase VIDEO_MENU_PRINTSCREEN:\n\t\tbreak;\n\tcase VIDEO_MENU_RECORDVIDEO:\n\t\tbreak;\n\tcase VIDEO_MENU_EXITDECODE:\n\t\tpContainer->m_pSetParams(m_nWndID, 0, pContainer->m_dwSetParams);\n\t\tbreak;\n\tcase VIDEO_MENU_EXITCYCLE:\n\t\tpContainer->m_pSetParams(m_nWndID, 1, pContainer->m_dwSetParams);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nLRESULT CPlayWnd::OnRepaintWnd(WPARAM wParam, LPARAM lParam)\n{\n\tInvalidate();\n\t\n\treturn 0;\n}\n\nBOOL CPlayWnd::DestroyWindow() \n{\n\treturn CWnd::DestroyWindow();\n}\n\nvoid CPlayWnd::OnLButtonDown(UINT nFlags, CPoint point) \n{\n\t// TODO: Add your message handler code here and/or call default\n\tCWnd::OnLButtonDown(nFlags, point);\n}\n\nvoid CPlayWnd::OnMButtonUp(UINT nFlags, CPoint point) \n{\n\t// TODO: Add your message handler code here and/or call default\n\tCWnd::OnMButtonUp(nFlags, point);\n}\n\nvoid CPlayWnd::OnMouseMove(UINT nFlags, CPoint point) \n{\n\t// TODO: Add your message handler code here and/or call default\n\tCWnd::OnMouseMove(nFlags, point);\n}\n\nvoid CPlayWnd::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized) \n{\n\tCWnd::OnActivate(nState, pWndOther, bMinimized);\n\t\n\t// TODO: Add your message handler code here\n\t\n}\n\n#if _MSC_VER >= 1300\nvoid CPlayWnd::OnTimer(UINT_PTR nIDEvent) \n#else\nvoid CPlayWnd::OnTimer(UINT nIDEvent) \n#endif\n{\n\t// TODO: Add your message handler code here and/or call default\n\tif(nIDEvent ==2)\n\t{\n\t\tif(m_FlagRect == TRUE)\n\t\t{\n\t\t\tCDC *pdc = GetDC();\n\t\t\tRECT  rt;\n\t\t\trt.left =  pointStart.x;\n\t\t\trt.top =   pointStart.y;\t\t\n\t\t\trt.right = \tpointEnd.x;\n\t\t\trt.bottom = pointEnd.y;\n\t\t\tpdc->Draw3dRect(&rt,RGB(255,0,0),RGB(255,0,0));\n\t\t\tReleaseDC(pdc);\n\t\t}\n\t}\n\tCWnd::OnTimer(nIDEvent);\n}\n\n#if _MSC_VER >= 1300\nvoid CPlayWnd::OnActivateApp(BOOL bActive, DWORD hTask) \n#else\nvoid CPlayWnd::OnActivateApp(BOOL bActive, HTASK hTask) \n#endif\n{\n\tCWnd::OnActivateApp(bActive, hTask);\n\t\n\t// TODO: Add your message handler code here\n\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":7159},"bin/Demo/MfcDemo/03.Alarm/DlgChn.cpp":{"content":"// DlgChn.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"Alarm.h\"\n#include \"DlgChn.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgChn dialog\n\n\nCDlgChn::CDlgChn(CWnd* pParent /*=NULL*/)\n\t: CDialog(CDlgChn::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgChn)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CDlgChn::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgChn)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgChn, CDialog)\n\t//{{AFX_MSG_MAP(CDlgChn)\n\t\t// NOTE: the ClassWizard will add message map macros here\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgChn message handlers\nBOOL CDlgChn::SetChnState(BYTE* bState, int nLen)\n{\n\tif(nLen > 32 || bState == NULL)\n\t{\n\t\treturn FALSE;\n\t}\n\t\n\tint i = 0;\n\tfor(i = 0; i <= 15; i++)\n\t{\n\t\tGetDlgItem(IDC_ARRAY_00 + i)->ShowWindow(SW_SHOW);\n\t\tGetDlgItem(IDC_ARRAY_90 + i)->ShowWindow(SW_SHOW);\n\t}\n\t\n\tUINT uIDBase = IDC_ARRAY_00;\n\tBOOL bCheck = FALSE;\n\tif (nLen <= 16)\n\t{\n\t\tfor(UINT uID = uIDBase; uID < uIDBase+nLen; uID++)\n\t\t{\n\t    \tbCheck = bState[uID-uIDBase] > 0 ? TRUE : FALSE;\n\t    \t((CButton *)GetDlgItem(uID))->SetCheck(bCheck);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(UINT uID = uIDBase; uID <= uIDBase+15; uID++)\n\t\t{\n\t\t\tbCheck = bState[uID-uIDBase] > 0 ? TRUE : FALSE;\n\t\t\t((CButton *)GetDlgItem(uID))->SetCheck(bCheck);\n\t\t}\n\n\t\tUINT uIDBase1 = IDC_ARRAY_90;\n\t\tfor (UINT uID1 = uIDBase1; uID1 <= uIDBase1+15; uID1++)\n\t\t{\n\t\t\tbCheck = bState[uID1-uIDBase1+16] > 0 ? TRUE : FALSE;\n\t\t\t((CButton *)GetDlgItem(uID1))->SetCheck(bCheck);\n\t\t}\n\t}\n\t\n\tUpdateData(FALSE);\n\treturn TRUE;\n}\n\nBOOL CDlgChn::GetChnState(BYTE* bState, int nLen)\n{\n\tif(nLen > 16 || bState == NULL)\n\t{\n\t\treturn FALSE;\n\t}\n\t\n\tUINT uIDBase = IDC_ARRAY_00;\n\tBOOL bCheck = FALSE;\n\tfor(UINT uID = uIDBase; uID < uIDBase+nLen; uID++)\n\t{\n\t\tbState[uID-uIDBase] = ((CButton *)GetDlgItem(uID))->GetCheck();\n\t}\n\t\n\treturn TRUE;\n}\n\nBOOL CDlgChn::Attach(UINT uID, CDialog* pAttachDlg)\n{\n\t//get attached window rect\n\tRECT rect = {0};\n\tpAttachDlg->GetDlgItem(uID)->GetWindowRect(&rect);\n\tScreenToClient(&rect);\n\t//get self window rect\n\tRECT rectSelf = {0};\n\tthis->GetClientRect(&rectSelf);\n\tScreenToClient(&rectSelf);\n\t//calculte the rect\n\trect.right = rect.left+rectSelf.right-rectSelf.left;\n\trect.bottom = rect.top+rectSelf.bottom-rectSelf.top;\n\t\n\t//hide the attach window\n\tpAttachDlg->GetDlgItem(uID)->ShowWindow(SW_HIDE);\n\t\n\tthis->MoveWindow(&rect, TRUE);\n\tthis->ShowWindow(SW_SHOW);\n\t\n\treturn TRUE;\n}","size_bytes":2743},"bin/DemoSrc/WaterCheck_demo/WaterCheck_demo.cpp":{"content":"// WaterCheck_demo.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"WaterCheck_demo.h\"\n#include \"WaterCheck_demoDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CWaterCheck_demoApp\n\nBEGIN_MESSAGE_MAP(CWaterCheck_demoApp, CWinApp)\n\t//{{AFX_MSG_MAP(CWaterCheck_demoApp)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t\t//    DO NOT EDIT what you see in these blocks of generated code!\n\t//}}AFX_MSG\n\tON_COMMAND(ID_HELP, CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CWaterCheck_demoApp construction\n\nCWaterCheck_demoApp::CWaterCheck_demoApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The one and only CWaterCheck_demoApp object\n\nCWaterCheck_demoApp theApp;\n\n/////////////////////////////////////////////////////////////////////////////\n// CWaterCheck_demoApp initialization\n\nBOOL CWaterCheck_demoApp::InitInstance()\n{\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t//  of your final executable, you should remove from the following\n\t//  the specific initialization routines you do not need.\n\n#ifdef _AFXDLL\n\tEnable3dControls();\t\t\t// Call this when using MFC in a shared DLL\n#else\n\tEnable3dControlsStatic();\t// Call this when linking to MFC statically\n#endif\n\n\tCWaterCheck_demoDlg dlg;\n\tm_pMainWnd = &dlg;\n\tint nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n","size_bytes":2115},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/ExButton.cpp":{"content":"// ExButton.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"ExButton.h\"\n#include \"netsdkdemodlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CExButton\n\nCExButton::CExButton()\n{\n\tm_dwPTZCommand = -1;\n}\n\nCExButton::~CExButton()\n{\n}\n\n\nBEGIN_MESSAGE_MAP(CExButton, CButton)\n\t//{{AFX_MSG_MAP(CExButton)\n\tON_WM_LBUTTONDOWN()\n\tON_WM_LBUTTONUP()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CExButton message handlers\nvoid CExButton::SetButtonCommand(DWORD dwPTZCommand)\n{\n\tm_dwPTZCommand = dwPTZCommand;\n}\n\nvoid CExButton::OnLButtonDown(UINT nFlags, CPoint point) \n{\n\tCButton::OnLButtonDown(nFlags, point);\n\n\tif((int)m_dwPTZCommand < 0)\n\t{\n\t\treturn;\n\t}\n\t((CPTZPannel*)GetParent())->SendPtzControl(m_dwPTZCommand,FALSE);\n\tTRACE(\"START\\n\");\n}\n\nvoid CExButton::OnLButtonUp(UINT nFlags, CPoint point) \n{\n\tCButton::OnLButtonUp(nFlags, point);\n\n\tif((int)m_dwPTZCommand < 0)\n\t{\n\t\treturn;\t\t\n\t}\n\t((CPTZPannel*)GetParent())->SendPtzControl(m_dwPTZCommand,TRUE);\n\tTRACE(\"STOP\\n\");\n}\n","size_bytes":1210},"bin/Demo/MfcDemo/19.MasterSlaveSensor/BSWndContainer.cpp":{"content":"// BSWndContainer.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"BSWndContainer.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CBSWndContainer\n\nCBSWndContainer::CBSWndContainer()\n{\n\t// init active page pointer\n\tm_pActivePage\t= NULL;\n\n\t// init window state\n\tm_bFullScreen\t= FALSE;\t// Full screen sign \n\tm_bMultiScreen\t= TRUE;\t\t// Multiple-window sign \n\tm_bAutoAdjustPos= FALSE;\t// Auto adjust sign \n\n\tSetDrawActivePage(TRUE);\t//\tEnable frame\n\n\tm_nShowPortion=100;\t\t\t//\tDisplay proportion \n}\n\nCBSWndContainer::~CBSWndContainer()\n{\n\t// remove all pages\n\twhile(!m_PageList.IsEmpty())\n\t\tm_PageList.RemoveHead();\n}\n\n\nBEGIN_MESSAGE_MAP(CBSWndContainer, CWnd)\n\t//{{AFX_MSG_MAP(CBSWndContainer)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n\n/////////////////////////////////////////////////////////////////////////////\n// CBSWndContainer member functions\n\n///////////////////////////////////////////////////\n// call this function to create container object.\n// it is override from cwnd class\nBOOL CBSWndContainer::Create( LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext )\n{\n\tdwStyle|=WS_EX_TOOLWINDOW;\n\treturn CWnd::Create(lpszClassName,lpszWindowName,dwStyle,rect,pParentWnd,nID,pContext );\n}\n\n\n///////////////////////////////////////////////////\n// call this function to add a page wnd to \n// container. if success retrun TRUE,else return \n// FALSE.\nBOOL CBSWndContainer::AddPage(CWnd *pWnd, BOOL bRepaint)\n{\n\t// check parameter\n\tif(\t!pWnd || !IsWindow(pWnd->m_hWnd) )\treturn FALSE;\n\n\t// check list \n\tPOSITION pos=m_PageList.Find(pWnd);\n\tif(pos!=NULL) \n\t{\n\t\tTRACE(\"This Window has been added to container, the operation will terminate.\\n\");\n\t\treturn TRUE;\n\t}\n\n\t// added page\n\tm_PageList.AddTail(pWnd);\n\n\tif( m_bDrawActive ) DrawActivePage(FALSE);\n\n\t// reset active page\n\tSetActivePage(pWnd, bRepaint);\n\n\treturn TRUE;\n}\n\n///////////////////////////////////////////////////\n// call this function to remove a page wnd from\n// container. \nCWnd *CBSWndContainer::DelPage(CWnd *pWnd)\n{\n\t// check list\n\tPOSITION pos=m_PageList.Find(pWnd);\n\tif(pos==NULL)\n\t{\n\t\tTRACE(\"This Window is not a member of container, the operation will terminate.\\n\");\n\t\treturn NULL;\n\t}\n\tif(pWnd==m_pActivePage)\n\t\tif(m_pActivePage==GetPrevPage(pWnd))//m_PageList.IsEmpty()?NULL:m_PageList.GetHead();\n\t\t\tm_pActivePage=NULL;\n\t\telse m_pActivePage=GetPrevPage(pWnd);\n\t\n\tm_PageList.RemoveAt(pos);\n\n\tif (pWnd)\n\t{\n\t\tpWnd->ShowWindow(SW_HIDE);\n\t}\n\n//\tInvalidate();\n\n\treturn pWnd;\n}\n\n///////////////////////////////////////////////////\n// call this function to remove active page from\n// container.\nCWnd *CBSWndContainer::DelPage()\n{\n\treturn DelPage(m_pActivePage);\n}\n\n///////////////////////////////////////////////////\n// call this function to set a page to be active\n// page.\nvoid CBSWndContainer::SetActivePage(CWnd *pWnd, BOOL bRepaint)\n{\n\t// check parameter\n\tif(\t!pWnd || !IsWindow(pWnd->m_hWnd) )\treturn;\n\n\t// if pWnd is the Active Page, return \n\tif( m_pActivePage==pWnd ) return;\n\n\t// check list\n\tPOSITION pos=m_PageList.Find(pWnd);\n\tif(pos==NULL)\n\t{\n\t\tTRACE(\"__This Window is not a member of container, the operation will terminate.\\n\");\n\t\treturn;\n\t}\n\n\tif(bRepaint) UpdateWnd();\n\n\tif( m_bDrawActive ) DrawActivePage(FALSE);\n\n\tm_pActivePage=pWnd;\n\n\tif( m_bDrawActive ) DrawActivePage(TRUE);\n}\n\n///////////////////////////////////////////////////\n// call this function to get the active page's\n// pointer. if no active page,return NULL;\nCWnd *CBSWndContainer::GetActivePage()\n{\n\treturn m_pActivePage;\n}\n\nCWnd *CBSWndContainer::GetTailPage()\n{\n\treturn m_PageList.GetTail();\n}\n\n///////////////////////////////////////////////////\n// call this function to get the next page by\n// the page that user defined. if the defined \n// page is not find in container, return NULL.\nCWnd *CBSWndContainer::GetNextPage(CWnd *pWnd)\n{\n\t// check parameter\n\tif(\t!pWnd || !IsWindow(pWnd->m_hWnd) ) return NULL;\n\n\t// check list\n\tPOSITION pos=m_PageList.Find(pWnd);\n\tif(pos==NULL)\n\t{\n\t\tTRACE(\"This Window is not a member of container, the operation will terminate.\\n\");\n\t\treturn NULL;\n\t}\n\t\n\t//\n\tm_PageList.GetNext(pos);\n\tif(pos==NULL)\n\t\treturn m_PageList.GetHead();\n\telse \n\t\treturn m_PageList.GetNext(pos);\n}\n\n///////////////////////////////////////////////////\n// call this function to get the prev page by\n// the page that user defined. if the defined\n// page is not find in container,return NULL.\nCWnd *CBSWndContainer::GetPrevPage(CWnd *pWnd)\n{\n\t// check parameter\n\tif(\t!pWnd || !IsWindow(pWnd->m_hWnd) ) return NULL;\n\n\t// check list\n\tPOSITION pos=m_PageList.Find(pWnd);\n\tif(pos==NULL)\n\t{\n\t\tTRACE(\"This Window is not a member of container, the operation will terminate.\\n\");\n\t\treturn NULL;\n\t}\n\t\n\t//\n\tm_PageList.GetPrev(pos);\n\tif(pos==NULL)\n\t\treturn m_PageList.GetTail();\n\telse \n\t\treturn m_PageList.GetPrev(pos);\n}\n\nCWnd *CBSWndContainer::GetPage(int nIndex)\n{\n\tCWnd *pRet = NULL;\n\tPOSITION pos = m_PageList.FindIndex(nIndex);\n\tif(pos == NULL) return pRet;\n\n\treturn m_PageList.GetAt(pos);\n}\n\nint CBSWndContainer::GetCount() const\n{\n\treturn m_PageList.GetCount();\n}\n\n///////////////////////////////////////////////////\n// call this function to  page wnds,when\n// the window is resized.\nvoid CBSWndContainer::UpdateWnd()\n{\n\tif(!IsWindowVisible()||IsIconic()) return;\n/////////////////////\n//Calculate display total zone \n\n\t//To get current window device coordinates\n\tCRect rtContainer;\n\tGetClientRect(&rtContainer);\n\tGetShowRect(&rtContainer);\n\trtContainer.DeflateRect(1,1);\n\n\t//Adjust Container position \n\tif(m_bAutoAdjustPos)\t\t\n\t\tAdjustRect(&rtContainer);\n\n/////////////////////\n//\n\tif(m_bMultiScreen)\n\t{ //Multiple-window status \n\t\tCRect rt;\n\t\tint nCount=m_PageList.GetCount();\n\t\tint i=0;\n\t\tfor(POSITION pos=m_PageList.GetHeadPosition();pos!=NULL;)\n\t\t{\n\t\t\tCWnd *p=m_PageList.GetNext(pos);\n\n\t\t\trt=rtContainer;\n\t\t\tCalcPageRect(&rt,i,nCount);\n\t\t\trt.DeflateRect(WINDOW_SPACE,WINDOW_SPACE,WINDOW_SPACE,WINDOW_SPACE); \n\t\t\tp->MoveWindow(&rt);\n\t\t\tp->ShowWindow(SW_SHOW);\n\t\t\ti++;\n\t\t}\n\t\tif( m_bDrawActive && m_PageList.GetCount()>1 ) DrawActivePage(TRUE);\n\t}\n\telse\n\t{ //One-window status \n\t\tfor(POSITION pos=m_PageList.GetHeadPosition();pos!=NULL;)\n\t\t{\n\t\t\tCWnd *p=m_PageList.GetNext(pos);\n\t\t\tif(p==m_pActivePage)\n\t\t\t\tp->MoveWindow(&rtContainer);\n\t\t\telse \n\t\t\t{\n\t\t\t\tif(m_bFullScreen)\n\t\t\t\t\tp->MoveWindow(0,0,1,1);\n\t\t\t\telse\n\t\t\t\t\tp->MoveWindow(rtContainer.right+1,rtContainer.bottom+1,1,1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n///////////////////////////////////////////////////\n// full screen\nvoid CBSWndContainer::SetFullScreen(BOOL bFlag)\n{\n\tif(bFlag==m_bFullScreen) return;\n\n\tif( bFlag )\n\t{//Full screen \n\t\t//Get displayer resolution \n\t\tint cx=GetSystemMetrics(SM_CXSCREEN);\n\t\tint cy=GetSystemMetrics(SM_CYSCREEN);\n\n\t\t//Save position information \n\t\tGetWindowPlacement(&_temppl);\n\t\t//Modify style \n\t\tModifyStyle(WS_CHILD,WS_POPUP);\n\t\t//Modify main-window \n\t\t_tempparent=SetParent(NULL);\n\t\t_tempparent->ShowWindow(SW_HIDE);\n\t\t//Move window \n\t\tMoveWindow(0,0,cx,cy);\n\t//\tSetWindowPos(&wndTopMost,0,0,cx,cy,NULL);\n\t}\n\telse\n\t{//Restore\n\t\t//Restore main window \n\t\t_tempparent->ShowWindow(SW_SHOW);\n\t\tSetParent(_tempparent);\n\t\t//Restore style \n\t\tModifyStyle(WS_POPUP,WS_CHILD);\n\t\t//Restore position \n\t\tSetWindowPlacement(&_temppl);\n\t}\n\n\tm_bFullScreen=bFlag;\n\tInvalidate();\n}\nBOOL CBSWndContainer::GetFullScreen()\n{\n\treturn m_bFullScreen;\n}\n\n///////////////////////////////////////////////////\n// multiscreen\nvoid CBSWndContainer::SetMultiScreen(BOOL bFlag)\n{\n\tif(m_bMultiScreen==bFlag) return;\n\tm_bMultiScreen=bFlag;\n\tInvalidate();\n}\nBOOL CBSWndContainer::GetMultiScreen()\n{\n\treturn m_bMultiScreen;\n}\n\n//////////////////////////////////////////////////\n// autoadjustpos\nvoid CBSWndContainer::SetAutoAdjustPos(BOOL bFlag)\n{\n\tif(m_bAutoAdjustPos==bFlag) return;\n\tm_bAutoAdjustPos=bFlag;\n\tInvalidate();\n}\nBOOL CBSWndContainer::GetAutoAdjustPos()\n{\n\treturn m_bAutoAdjustPos;\n}\n\n//////////////////////////////////////////////////\n// draw active page\nvoid CBSWndContainer::SetDrawActivePage(BOOL bFlag,COLORREF clrTopLeft,COLORREF clrBottomRight)\n{\n\tif(m_bDrawActive==bFlag) return;\n\tif(bFlag)\n\t{\n\t\tm_clrTopLeft=clrTopLeft;\n\t\tm_clrBottomRight=clrBottomRight;\n\t}\n\tm_bDrawActive=bFlag;\n\tDrawActivePage(bFlag);\n}\nBOOL CBSWndContainer::GetDrawActivePage()\n{\n\treturn m_bDrawActive;\n}\n\n//////////////////////////////////////////////////\n//\tDisplay percentage \n//\t40 <= nPortion <=100\nvoid CBSWndContainer::SetShowPortion(int nPortion)\n{\n\tif(m_nShowPortion==nPortion) return;\n\tif(m_nShowPortion<40) m_nShowPortion=40;\n\tif(m_nShowPortion>100) m_nShowPortion=100;\n\tm_nShowPortion=nPortion;\n\tInvalidate();\n}\nint  CBSWndContainer::GetShowPortion()\n{\n\treturn m_nShowPortion;\n}\n\n///////////////////////////////////////////////////\n// clean the no useful page in the container,\n// return the page count.\nint CBSWndContainer::UpdateList()\n{\n\tPOSITION posPrev;\n\tfor(POSITION pos=m_PageList.GetHeadPosition();pos!=NULL;)\n\t{\n\t\tposPrev=pos;\n\t\tCWnd *p=m_PageList.GetNext(pos);\n\t\tif(!IsWindow(p->m_hWnd))\n\t\t\tm_PageList.RemoveAt(posPrev);\n\t}\n\treturn m_PageList.GetCount();\n}\n\n///////////////////////////////////////////////////\n// get a rect by the index of a child\nvoid CBSWndContainer::CalcPageRect(LPRECT lpRect,int nIndex,int nPageCount)\n{\n\tif((nPageCount<=0)||(nIndex>=nPageCount))\n\t{\n\t\tlpRect->left=lpRect->right=lpRect->top=lpRect->bottom=0;\n\t\treturn;\n\t}\n//get row count\n\tint nRow=0;\n\twhile((nRow)*(nRow)<nPageCount) nRow++;\n\n//get singledlg width and height\n\tint nWidth=(lpRect->right-lpRect->left)/nRow;\n\tint nHeight=(lpRect->bottom-lpRect->top)/nRow;\n\n//get top-left point\n\tCPoint pt;\n\tpt.x=lpRect->left+nWidth*(nIndex%nRow);\n\tpt.y=lpRect->top+nHeight*(nIndex/nRow);\n\n//set rect return back\n\tlpRect->left=pt.x;\n\tlpRect->top=pt.y;\n\tlpRect->right=lpRect->left+nWidth;\n\tlpRect->bottom=lpRect->top+nHeight;\n}\n\n///////////////////////////////////////////////////\n// adjust a rect by defined proportion \nvoid CBSWndContainer::AdjustRect(LPRECT lpRect)\n{\n\tint nWidth=lpRect->right-lpRect->left;\n\tint nHeight=lpRect->bottom-lpRect->top;\n\tCPoint pt((lpRect->left+lpRect->right)/2,(lpRect->top+lpRect->bottom)/2);\n\n\tint nTemp=nWidth*8/11;\n\tif(nTemp>nHeight)\n\t{\n\t\tnWidth=nHeight*11/8;\n\t}\n\telse if(nTemp<nHeight)\n\t{\n\t\tnHeight=nTemp;\n\t}\n\tlpRect->left=pt.x-nWidth/2;\n\tlpRect->right=pt.x+nWidth/2;\n\tlpRect->top=pt.y-nHeight/2;\n\tlpRect->bottom=pt.y+nHeight/2;\n}\n\n///////////////////////////////////////////////////\n//To get display zone in proportion \nvoid CBSWndContainer::GetShowRect(LPRECT lpRect)\n{\n\tif(m_nShowPortion<40) m_nShowPortion=40;\n\tif(m_nShowPortion>100) m_nShowPortion=100;\n\n\tint nWidth\t= lpRect->right-lpRect->left;\n\tint nHeight\t= lpRect->bottom-lpRect->top;\n\n\tint nNewWidth\t= (int)(nWidth*m_nShowPortion/100);\n\tint nNewHeight\t= (int)(nHeight*m_nShowPortion/100);\n\n\tint ndx\t= ( nWidth-nNewWidth )/2;\n\tint ndy = ( nHeight-nNewHeight )/2;\n\n\tlpRect->left\t= lpRect->left\t+ ndx;\n\tlpRect->top\t\t= lpRect->top\t+ ndy;\n\tlpRect->right\t= lpRect->left\t+ nNewWidth;\n\tlpRect->bottom\t= lpRect->top\t+ nNewHeight;\t\n}\n\n///////////////////////////////////////////////////\n// draw the frame of active page\nvoid CBSWndContainer::DrawActivePage(BOOL bFlag)\n{\n\tif( !m_bMultiScreen || \n\t\t!m_pActivePage\t|| \n\t\tm_PageList.GetCount()<2 \n\t\t) return;\n\n\tCRect rt;\n\tm_pActivePage->GetWindowRect(&rt);\n\tScreenToClient(&rt);\n\trt.InflateRect(1,1);\n\n\tif(bFlag)\n\t{\n\t\tCDC *pDC=GetDC();\n\t\tif(!pDC) return;\n\n//\t\tpDC->Draw3dRect(&rt,m_clrTopLeft, m_clrBottomRight);\t\n\t\tpDC->Draw3dRect(&rt,RGB(255,0,0), RGB(255,0,0));\n\n\t\tReleaseDC(pDC);\n\t}\n\telse\n\t\tInvalidateRect(&rt);\n}\n\n\n","size_bytes":11638},"bin/Demo/MfcDemo/16.HumanTrait/HumanTrait.cpp":{"content":"// HumanTrait.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"HumanTrait.h\"\n#include \"HumanTraitDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\n\n// CHumanTraitApp\n\nBEGIN_MESSAGE_MAP(CHumanTraitApp, CWinApp)\n\tON_COMMAND(ID_HELP, &CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n\n// CHumanTraitApp construction\n\nCHumanTraitApp::CHumanTraitApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n\n// The one and only CHumanTraitApp object\n\nCHumanTraitApp theApp;\n\n\n// CHumanTraitApp initialization\n\nBOOL CHumanTraitApp::InitInstance()\n{\n\t// InitCommonControlsEx() is required on Windows XP if an application\n\t// manifest specifies use of ComCtl32.dll version 6 or later to enable\n\t// visual styles.  Otherwise, any window creation will fail.\n\tINITCOMMONCONTROLSEX InitCtrls;\n\tInitCtrls.dwSize = sizeof(InitCtrls);\n\t// Set this to include all the common control classes you want to use\n\t// in your application.\n\tInitCtrls.dwICC = ICC_WIN95_CLASSES;\n\tInitCommonControlsEx(&InitCtrls);\n\n\tCWinApp::InitInstance();\n\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t// of your final executable, you should remove from the following\n\t// the specific initialization routines you do not need\n\t// Change the registry key under which our settings are stored\n\t// TODO: You should modify this string to be something appropriate\n\t// such as the name of your company or organization\n\tSetRegistryKey(_T(\"Local AppWizard-Generated Applications\"));\n\n\tCHumanTraitDlg dlg;\n\tm_pMainWnd = &dlg;\n\tINT_PTR nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n\nTCHAR* g_GetIniPath(void)\n{\n    static char pszIniPath[512] = {0};\n    if( strlen(pszIniPath) == 0 )\n    {\n        char szDirBuf[512] = {0};\n        GetCurrentDirectory(512, szDirBuf);\n        _snprintf_s(pszIniPath, 512, \"%s\\\\langchn.ini\", szDirBuf);\n    }\n    return pszIniPath;\n}\n\nCString ConvertString(CString strText)\n{\n    char val[200] = {0};\n    CString strIniPath,strRet;\n    GetPrivateProfileString(\"String\",strText,\"\", val,200,g_GetIniPath());\n    strRet = val;\n    if(strRet.GetLength()==0)\n    {\n        //If there is no corresponding string in ini file ,then set it to be default value.\n        strRet=strText;\n    }\n    return strRet;\n}\n//Set static text in dialogue box (English->current language)\nvoid g_SetWndStaticText(CWnd * pWnd)\n{\n    CString strCaption,strText;\n\n    //Set main window title\n    pWnd->GetWindowText(strCaption);\n    if(strCaption.GetLength()>0)\n    {\n        strText=ConvertString(strCaption);\n        pWnd->SetWindowText(strText);\n    }\n\n    //Set small window title \n    CWnd * pChild=pWnd->GetWindow(GW_CHILD);\n    CString strClassName;\n    while(pChild)\n    {\n        //////////////////////////////////////////////////////////////////////////\t\t\n        //Added by Jackbin 2005-03-11\n        strClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n        if(strClassName == \"CEdit\")\n        {\n            //Next small window \n            pChild=pChild->GetWindow(GW_HWNDNEXT);\n            continue;\n        }\n\n        //////////////////////////////////////////////////////////////////////////\t\n\n        //Set small window current language text \n        pChild->GetWindowText(strCaption);\n        strText=ConvertString(strCaption);\n        pChild->SetWindowText(strText);\n\n        //Next small window \n        pChild=pChild->GetWindow(GW_HWNDNEXT);\n    }\n}\n","size_bytes":3879},"bin/Demo/MfcDemo/00.DevInit/LibQREncode/qrencode.c":{"content":"/*\n * qrencode - QR Code encoder\n *\n * Copyright (C) 2006-2012 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#if HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"qrencode.h\"\n#include \"qrspec.h\"\n#include \"mqrspec.h\"\n#include \"bitstream.h\"\n#include \"qrinput.h\"\n#include \"rscode.h\"\n#include \"split.h\"\n#include \"mask.h\"\n#include \"mmask.h\"\n\n/******************************************************************************\n * Raw code\n *****************************************************************************/\n\ntypedef struct {\n\tint dataLength;\n\tunsigned char *data;\n\tint eccLength;\n\tunsigned char *ecc;\n} RSblock;\n\ntypedef struct {\n\tint version;\n\tint dataLength;\n\tint eccLength;\n\tunsigned char *datacode;\n\tunsigned char *ecccode;\n\tint b1;\n\tint blocks;\n\tRSblock *rsblock;\n\tint count;\n} QRRawCode;\n\nstatic void RSblock_initBlock(RSblock *block, int dl, unsigned char *data, int el, unsigned char *ecc, RS *rs)\n{\n\tblock->dataLength = dl;\n\tblock->data = data;\n\tblock->eccLength = el;\n\tblock->ecc = ecc;\n\n\tencode_rs_char(rs, data, ecc);\n}\n\nstatic int RSblock_init(RSblock *blocks, int spec[5], unsigned char *data, unsigned char *ecc)\n{\n\tint i;\n\tRSblock *block;\n\tunsigned char *dp, *ep;\n\tRS *rs;\n\tint el, dl;\n\n\tdl = QRspec_rsDataCodes1(spec);\n\tel = QRspec_rsEccCodes1(spec);\n\trs = init_rs(8, 0x11d, 0, 1, el, 255 - dl - el);\n\tif(rs == NULL) return -1;\n\n\tblock = blocks;\n\tdp = data;\n\tep = ecc;\n\tfor(i=0; i<QRspec_rsBlockNum1(spec); i++) {\n\t\tRSblock_initBlock(block, dl, dp, el, ep, rs);\n\t\tdp += dl;\n\t\tep += el;\n\t\tblock++;\n\t}\n\n\tif(QRspec_rsBlockNum2(spec) == 0) return 0;\n\n\tdl = QRspec_rsDataCodes2(spec);\n\tel = QRspec_rsEccCodes2(spec);\n\trs = init_rs(8, 0x11d, 0, 1, el, 255 - dl - el);\n\tif(rs == NULL) return -1;\n\tfor(i=0; i<QRspec_rsBlockNum2(spec); i++) {\n\t\tRSblock_initBlock(block, dl, dp, el, ep, rs);\n\t\tdp += dl;\n\t\tep += el;\n\t\tblock++;\n\t}\n\n\treturn 0;\n}\n\n__STATIC void QRraw_free(QRRawCode *raw);\n__STATIC QRRawCode *QRraw_new(QRinput *input)\n{\n\tQRRawCode *raw;\n\tint spec[5], ret;\n\n\traw = (QRRawCode *)malloc(sizeof(QRRawCode));\n\tif(raw == NULL) return NULL;\n\n\traw->datacode = QRinput_getByteStream(input);\n\tif(raw->datacode == NULL) {\n\t\tfree(raw);\n\t\treturn NULL;\n\t}\n\n\tQRspec_getEccSpec(input->version, input->level, spec);\n\n\traw->version = input->version;\n\traw->b1 = QRspec_rsBlockNum1(spec);\n\traw->dataLength = QRspec_rsDataLength(spec);\n\traw->eccLength = QRspec_rsEccLength(spec);\n\traw->ecccode = (unsigned char *)malloc(raw->eccLength);\n\tif(raw->ecccode == NULL) {\n\t\tfree(raw->datacode);\n\t\tfree(raw);\n\t\treturn NULL;\n\t}\n\n\traw->blocks = QRspec_rsBlockNum(spec);\n\traw->rsblock = (RSblock *)calloc(raw->blocks, sizeof(RSblock));\n\tif(raw->rsblock == NULL) {\n\t\tQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\tret = RSblock_init(raw->rsblock, spec, raw->datacode, raw->ecccode);\n\tif(ret < 0) {\n\t\tQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\n\traw->count = 0;\n\n\treturn raw;\n}\n\n/**\n * Return a code (byte).\n * This function can be called iteratively.\n * @param raw raw code.\n * @return code\n */\n__STATIC unsigned char QRraw_getCode(QRRawCode *raw)\n{\n\tint col, row;\n\tunsigned char ret;\n\n\tif(raw->count < raw->dataLength) {\n\t\trow = raw->count % raw->blocks;\n\t\tcol = raw->count / raw->blocks;\n\t\tif(col >= raw->rsblock[0].dataLength) {\n\t\t\trow += raw->b1;\n\t\t}\n\t\tret = raw->rsblock[row].data[col];\n\t} else if(raw->count < raw->dataLength + raw->eccLength) {\n\t\trow = (raw->count - raw->dataLength) % raw->blocks;\n\t\tcol = (raw->count - raw->dataLength) / raw->blocks;\n\t\tret = raw->rsblock[row].ecc[col];\n\t} else {\n\t\treturn 0;\n\t}\n\traw->count++;\n\treturn ret;\n}\n\n__STATIC void QRraw_free(QRRawCode *raw)\n{\n\tif(raw != NULL) {\n\t\tfree(raw->datacode);\n\t\tfree(raw->ecccode);\n\t\tfree(raw->rsblock);\n\t\tfree(raw);\n\t}\n}\n\n/******************************************************************************\n * Raw code for Micro QR Code\n *****************************************************************************/\n\ntypedef struct {\n\tint version;\n\tint dataLength;\n\tint eccLength;\n\tunsigned char *datacode;\n\tunsigned char *ecccode;\n\tRSblock *rsblock;\n\tint oddbits;\n\tint count;\n} MQRRawCode;\n\n__STATIC void MQRraw_free(MQRRawCode *raw);\n__STATIC MQRRawCode *MQRraw_new(QRinput *input)\n{\n\tMQRRawCode *raw;\n\tRS *rs;\n\n\traw = (MQRRawCode *)malloc(sizeof(MQRRawCode));\n\tif(raw == NULL) return NULL;\n\n\traw->version = input->version;\n\traw->dataLength = MQRspec_getDataLength(input->version, input->level);\n\traw->eccLength = MQRspec_getECCLength(input->version, input->level);\n\traw->oddbits = raw->dataLength * 8 - MQRspec_getDataLengthBit(input->version, input->level);\n\traw->datacode = QRinput_getByteStream(input);\n\tif(raw->datacode == NULL) {\n\t\tfree(raw);\n\t\treturn NULL;\n\t}\n\traw->ecccode = (unsigned char *)malloc(raw->eccLength);\n\tif(raw->ecccode == NULL) {\n\t\tfree(raw->datacode);\n\t\tfree(raw);\n\t\treturn NULL;\n\t}\n\n\traw->rsblock = (RSblock *)calloc(1, sizeof(RSblock));\n\tif(raw->rsblock == NULL) {\n\t\tMQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\n\trs = init_rs(8, 0x11d, 0, 1, raw->eccLength, 255 - raw->dataLength - raw->eccLength);\n\tif(rs == NULL) {\n\t\tMQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\n\tRSblock_initBlock(raw->rsblock, raw->dataLength, raw->datacode, raw->eccLength, raw->ecccode, rs);\n\n\traw->count = 0;\n\n\treturn raw;\n}\n\n/**\n * Return a code (byte).\n * This function can be called iteratively.\n * @param raw raw code.\n * @return code\n */\n__STATIC unsigned char MQRraw_getCode(MQRRawCode *raw)\n{\n\tunsigned char ret;\n\n\tif(raw->count < raw->dataLength) {\n\t\tret = raw->datacode[raw->count];\n\t} else if(raw->count < raw->dataLength + raw->eccLength) {\n\t\tret = raw->ecccode[raw->count - raw->dataLength];\n\t} else {\n\t\treturn 0;\n\t}\n\traw->count++;\n\treturn ret;\n}\n\n__STATIC void MQRraw_free(MQRRawCode *raw)\n{\n\tif(raw != NULL) {\n\t\tfree(raw->datacode);\n\t\tfree(raw->ecccode);\n\t\tfree(raw->rsblock);\n\t\tfree(raw);\n\t}\n}\n\n\n/******************************************************************************\n * Frame filling\n *****************************************************************************/\n\ntypedef struct {\n\tint width;\n\tunsigned char *frame;\n\tint x, y;\n\tint dir;\n\tint bit;\n\tint mqr;\n} FrameFiller;\n\nstatic FrameFiller *FrameFiller_new(int width, unsigned char *frame, int mqr)\n{\n\tFrameFiller *filler;\n\n\tfiller = (FrameFiller *)malloc(sizeof(FrameFiller));\n\tif(filler == NULL) return NULL;\n\tfiller->width = width;\n\tfiller->frame = frame;\n\tfiller->x = width - 1;\n\tfiller->y = width - 1;\n\tfiller->dir = -1;\n\tfiller->bit = -1;\n\tfiller->mqr = mqr;\n\n\treturn filler;\n}\n\nstatic unsigned char *FrameFiller_next(FrameFiller *filler)\n{\n\tunsigned char *p;\n\tint x, y, w;\n\n\tif(filler->bit == -1) {\n\t\tfiller->bit = 0;\n\t\treturn filler->frame + filler->y * filler->width + filler->x;\n\t}\n\n\tx = filler->x;\n\ty = filler->y;\n\tp = filler->frame;\n\tw = filler->width;\n\n\tif(filler->bit == 0) {\n\t\tx--;\n\t\tfiller->bit++;\n\t} else {\n\t\tx++;\n\t\ty += filler->dir;\n\t\tfiller->bit--;\n\t}\n\n\tif(filler->dir < 0) {\n\t\tif(y < 0) {\n\t\t\ty = 0;\n\t\t\tx -= 2;\n\t\t\tfiller->dir = 1;\n\t\t\tif(!filler->mqr && x == 6) {\n\t\t\t\tx--;\n\t\t\t\ty = 9;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif(y == w) {\n\t\t\ty = w - 1;\n\t\t\tx -= 2;\n\t\t\tfiller->dir = -1;\n\t\t\tif(!filler->mqr && x == 6) {\n\t\t\t\tx--;\n\t\t\t\ty -= 8;\n\t\t\t}\n\t\t}\n\t}\n\tif(x < 0 || y < 0) return NULL;\n\n\tfiller->x = x;\n\tfiller->y = y;\n\n\tif(p[y * w + x] & 0x80) {\n\t\t// This tail recursion could be optimized.\n\t\treturn FrameFiller_next(filler);\n\t}\n\treturn &p[y * w + x];\n}\n\n#ifdef WITH_TESTS\nextern unsigned char *FrameFiller_test(int version)\n{\n\tint width;\n\tunsigned char *frame, *p;\n\tFrameFiller *filler;\n\tint i, length;\n\n\twidth = QRspec_getWidth(version);\n\tframe = QRspec_newFrame(version);\n\tif(frame == NULL) return NULL;\n\tfiller = FrameFiller_new(width, frame, 0);\n\tif(filler == NULL) {\n\t\tfree(frame);\n\t\treturn NULL;\n\t}\n\tlength = QRspec_getDataLength(version, QR_ECLEVEL_L) * 8\n\t       + QRspec_getECCLength(version, QR_ECLEVEL_L) * 8\n\t\t   + QRspec_getRemainder(version);\n\tfor(i=0; i<length; i++) {\n\t\tp = FrameFiller_next(filler);\n\t\tif(p == NULL) {\n\t\t\tfree(filler);\n\t\t\tfree(frame);\n\t\t\treturn NULL;\n\t\t}\n\t\t*p = (unsigned char)(i & 0x7f) | 0x80;\n\t}\n\tfree(filler);\n\treturn frame;\n}\n\nextern unsigned char *FrameFiller_testMQR(int version)\n{\n\tint width;\n\tunsigned char *frame, *p;\n\tFrameFiller *filler;\n\tint i, length;\n\n\twidth = MQRspec_getWidth(version);\n\tframe = MQRspec_newFrame(version);\n\tif(frame == NULL) return NULL;\n\tfiller = FrameFiller_new(width, frame, 1);\n\tif(filler == NULL) {\n\t\tfree(frame);\n\t\treturn NULL;\n\t}\n\tlength = MQRspec_getDataLengthBit(version, QR_ECLEVEL_L)\n\t       + MQRspec_getECCLength(version, QR_ECLEVEL_L) * 8;\n\tfor(i=0; i<length; i++) {\n\t\tp = FrameFiller_next(filler);\n\t\tif(p == NULL) {\n\t\t\tfprintf(stderr, \"Frame filler run over the frame!\\n\");\n\t\t\tfree(filler);\n\t\t\treturn frame;\n\t\t}\n\t\t*p = (unsigned char)(i & 0x7f) | 0x80;\n\t}\n\tfree(filler);\n\treturn frame;\n}\n#endif\n\n\n/******************************************************************************\n * QR-code encoding\n *****************************************************************************/\n\n__STATIC QRcode *QRcode_new(int version, int width, unsigned char *data)\n{\n\tQRcode *qrcode;\n\n\tqrcode = (QRcode *)malloc(sizeof(QRcode));\n\tif(qrcode == NULL) return NULL;\n\n\tqrcode->version = version;\n\tqrcode->width = width;\n\tqrcode->data = data;\n\n\treturn qrcode;\n}\n\nvoid QRcode_free(QRcode *qrcode)\n{\n\tif(qrcode != NULL) {\n\t\tfree(qrcode->data);\n\t\tfree(qrcode);\n\t}\n}\n\n__STATIC QRcode *QRcode_encodeMask(QRinput *input, int mask)\n{\n\tint width, version;\n\tQRRawCode *raw;\n\tunsigned char *frame, *masked, *p, code, bit;\n\tFrameFiller *filler;\n\tint i, j;\n\tQRcode *qrcode = NULL;\n\n\tif(input->mqr) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(input->version < 0 || input->version > QRSPEC_VERSION_MAX) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(input->level > QR_ECLEVEL_H) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\traw = QRraw_new(input);\n\tif(raw == NULL) return NULL;\n\n\tversion = raw->version;\n\twidth = QRspec_getWidth(version);\n\tframe = QRspec_newFrame(version);\n\tif(frame == NULL) {\n\t\tQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\tfiller = FrameFiller_new(width, frame, 0);\n\tif(filler == NULL) {\n\t\tQRraw_free(raw);\n\t\tfree(frame);\n\t\treturn NULL;\n\t}\n\n\t/* inteleaved data and ecc codes */\n\tfor(i=0; i<raw->dataLength + raw->eccLength; i++) {\n\t\tcode = QRraw_getCode(raw);\n\t\tbit = 0x80;\n\t\tfor(j=0; j<8; j++) {\n\t\t\tp = FrameFiller_next(filler);\n\t\t\tif(p == NULL)  goto EXIT;\n\t\t\t*p = 0x02 | ((bit & code) != 0);\n\t\t\tbit = bit >> 1;\n\t\t}\n\t}\n\tQRraw_free(raw);\n\traw = NULL;\n\t/* remainder bits */\n\tj = QRspec_getRemainder(version);\n\tfor(i=0; i<j; i++) {\n\t\tp = FrameFiller_next(filler);\n\t\tif(p == NULL)  goto EXIT;\n\t\t*p = 0x02;\n\t}\n\n\t/* masking */\n\tif(mask == -2) { // just for debug purpose\n\t\tmasked = (unsigned char *)malloc(width * width);\n\t\tmemcpy(masked, frame, width * width);\n\t} else if(mask < 0) {\n\t\tmasked = Mask_mask(width, frame, input->level);\n\t} else {\n\t\tmasked = Mask_makeMask(width, frame, mask, input->level);\n\t}\n\tif(masked == NULL) {\n\t\tgoto EXIT;\n\t}\n\tqrcode = QRcode_new(version, width, masked);\n\nEXIT:\n\tQRraw_free(raw);\n\tfree(filler);\n\tfree(frame);\n\treturn qrcode;\n}\n\n__STATIC QRcode *QRcode_encodeMaskMQR(QRinput *input, int mask)\n{\n\tint width, version;\n\tMQRRawCode *raw;\n\tunsigned char *frame, *masked, *p, code, bit;\n\tFrameFiller *filler;\n\tint i, j;\n\tQRcode *qrcode = NULL;\n\n\tif(!input->mqr) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(input->version <= 0 || input->version > MQRSPEC_VERSION_MAX) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(input->level > QR_ECLEVEL_Q) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\traw = MQRraw_new(input);\n\tif(raw == NULL) return NULL;\n\n\tversion = raw->version;\n\twidth = MQRspec_getWidth(version);\n\tframe = MQRspec_newFrame(version);\n\tif(frame == NULL) {\n\t\tMQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\tfiller = FrameFiller_new(width, frame, 1);\n\tif(filler == NULL) {\n\t\tMQRraw_free(raw);\n\t\tfree(frame);\n\t\treturn NULL;\n\t}\n\n\t/* inteleaved data and ecc codes */\n\tfor(i=0; i<raw->dataLength + raw->eccLength; i++) {\n\t\tcode = MQRraw_getCode(raw);\n\t\tif(raw->oddbits && i == raw->dataLength - 1) {\n\t\t\tbit = 1 << raw->oddbits;\n\t\t\tfor(j=0; j<raw->oddbits; j++) {\n\t\t\t\tp = FrameFiller_next(filler);\n\t\t\t\tif(p == NULL) goto EXIT;\n\t\t\t\t*p = 0x02 | ((bit & code) != 0);\n\t\t\t\tbit = bit >> 1;\n\t\t\t}\n\t\t} else {\n\t\t\tbit = 0x80;\n\t\t\tfor(j=0; j<8; j++) {\n\t\t\t\tp = FrameFiller_next(filler);\n\t\t\t\tif(p == NULL) goto EXIT;\n\t\t\t\t*p = 0x02 | ((bit & code) != 0);\n\t\t\t\tbit = bit >> 1;\n\t\t\t}\n\t\t}\n\t}\n\tMQRraw_free(raw);\n\traw = NULL;\n\n\t/* masking */\n\tif(mask < 0) {\n\t\tmasked = MMask_mask(version, frame, input->level);\n\t} else {\n\t\tmasked = MMask_makeMask(version, frame, mask, input->level);\n\t}\n\tif(masked == NULL) {\n\t\tgoto EXIT;\n\t}\n\n\tqrcode = QRcode_new(version, width, masked);\n\nEXIT:\n\tMQRraw_free(raw);\n\tfree(filler);\n\tfree(frame);\n\treturn qrcode;\n}\n\nQRcode *QRcode_encodeInput(QRinput *input)\n{\n\tif(input->mqr) {\n\t\treturn QRcode_encodeMaskMQR(input, -1);\n\t} else {\n\t\treturn QRcode_encodeMask(input, -1);\n\t}\n}\n\nstatic QRcode *QRcode_encodeStringReal(const char *string, int version, QRecLevel level, int mqr, QRencodeMode hint, int casesensitive)\n{\n\tQRinput *input;\n\tQRcode *code;\n\tint ret;\n\n\tif(string == NULL) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(hint != QR_MODE_8 && hint != QR_MODE_KANJI) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif(mqr) {\n\t\tinput = QRinput_newMQR(version, level);\n\t} else {\n\t\tinput = QRinput_new2(version, level);\n\t}\n\tif(input == NULL) return NULL;\n\n\tret = Split_splitStringToQRinput(string, input, hint, casesensitive);\n\tif(ret < 0) {\n\t\tQRinput_free(input);\n\t\treturn NULL;\n\t}\n\tcode = QRcode_encodeInput(input);\n\tQRinput_free(input);\n\n\treturn code;\n}\n\nQRcode *QRcode_encodeString(const char *string, int version, QRecLevel level, QRencodeMode hint, int casesensitive)\n{\n\treturn QRcode_encodeStringReal(string, version, level, 0, hint, casesensitive);\n}\n\nQRcode *QRcode_encodeStringMQR(const char *string, int version, QRecLevel level, QRencodeMode hint, int casesensitive)\n{\n\treturn QRcode_encodeStringReal(string, version, level, 1, hint, casesensitive);\n}\n\nstatic QRcode *QRcode_encodeDataReal(const unsigned char *data, int length, int version, QRecLevel level, int mqr)\n{\n\tQRinput *input;\n\tQRcode *code;\n\tint ret;\n\n\tif(data == NULL || length == 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif(mqr) {\n\t\tinput = QRinput_newMQR(version, level);\n\t} else {\n\t\tinput = QRinput_new2(version, level);\n\t}\n\tif(input == NULL) return NULL;\n\n\tret = QRinput_append(input, QR_MODE_8, length, data);\n\tif(ret < 0) {\n\t\tQRinput_free(input);\n\t\treturn NULL;\n\t}\n\tcode = QRcode_encodeInput(input);\n\tQRinput_free(input);\n\n\treturn code;\n}\n\nQRcode *QRcode_encodeData(int size, const unsigned char *data, int version, QRecLevel level)\n{\n\treturn QRcode_encodeDataReal(data, size, version, level, 0);\n}\n\nQRcode *QRcode_encodeString8bit(const char *string, int version, QRecLevel level)\n{\n\tif(string == NULL) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\treturn QRcode_encodeDataReal((unsigned char *)string, strlen(string), version, level, 0);\n}\n\nQRcode *QRcode_encodeDataMQR(int size, const unsigned char *data, int version, QRecLevel level)\n{\n\treturn QRcode_encodeDataReal(data, size, version, level, 1);\n}\n\nQRcode *QRcode_encodeString8bitMQR(const char *string, int version, QRecLevel level)\n{\n\tif(string == NULL) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\treturn QRcode_encodeDataReal((unsigned char *)string, strlen(string), version, level, 1);\n}\n\n\n/******************************************************************************\n * Structured QR-code encoding\n *****************************************************************************/\n\nstatic QRcode_List *QRcode_List_newEntry(void)\n{\n\tQRcode_List *entry;\n\n\tentry = (QRcode_List *)malloc(sizeof(QRcode_List));\n\tif(entry == NULL) return NULL;\n\n\tentry->next = NULL;\n\tentry->code = NULL;\n\n\treturn entry;\n}\n\nstatic void QRcode_List_freeEntry(QRcode_List *entry)\n{\n\tif(entry != NULL) {\n\t\tQRcode_free(entry->code);\n\t\tfree(entry);\n\t}\n}\n\nvoid QRcode_List_free(QRcode_List *qrlist)\n{\n\tQRcode_List *list = qrlist, *next;\n\n\twhile(list != NULL) {\n\t\tnext = list->next;\n\t\tQRcode_List_freeEntry(list);\n\t\tlist = next;\n\t}\n}\n\nint QRcode_List_size(QRcode_List *qrlist)\n{\n\tQRcode_List *list = qrlist;\n\tint size = 0;\n\n\twhile(list != NULL) {\n\t\tsize++;\n\t\tlist = list->next;\n\t}\n\n\treturn size;\n}\n\n#if 0\nstatic unsigned char QRcode_parity(const char *str, int size)\n{\n\tunsigned char parity = 0;\n\tint i;\n\n\tfor(i=0; i<size; i++) {\n\t\tparity ^= str[i];\n\t}\n\n\treturn parity;\n}\n#endif\n\nQRcode_List *QRcode_encodeInputStructured(QRinput_Struct *s)\n{\n\tQRcode_List *head = NULL;\n\tQRcode_List *tail = NULL;\n\tQRcode_List *entry;\n\tQRinput_InputList *list = s->head;\n\n\twhile(list != NULL) {\n\t\tif(head == NULL) {\n\t\t\tentry = QRcode_List_newEntry();\n\t\t\tif(entry == NULL) goto ABORT;\n\t\t\thead = entry;\n\t\t\ttail = head;\n\t\t} else {\n\t\t\tentry = QRcode_List_newEntry();\n\t\t\tif(entry == NULL) goto ABORT;\n\t\t\ttail->next = entry;\n\t\t\ttail = tail->next;\n\t\t}\n\t\ttail->code = QRcode_encodeInput(list->input);\n\t\tif(tail->code == NULL) {\n\t\t\tgoto ABORT;\n\t\t}\n\t\tlist = list->next;\n\t}\n\n\treturn head;\nABORT:\n\tQRcode_List_free(head);\n\treturn NULL;\n}\n\nstatic QRcode_List *QRcode_encodeInputToStructured(QRinput *input)\n{\n\tQRinput_Struct *s;\n\tQRcode_List *codes;\n\n\ts = QRinput_splitQRinputToStruct(input);\n\tif(s == NULL) return NULL;\n\n\tcodes = QRcode_encodeInputStructured(s);\n\tQRinput_Struct_free(s);\n\n\treturn codes;\n}\n\nstatic QRcode_List *QRcode_encodeDataStructuredReal(\n\tint size, const unsigned char *data,\n\tint version, QRecLevel level,\n\tint eightbit, QRencodeMode hint, int casesensitive)\n{\n\tQRinput *input;\n\tQRcode_List *codes;\n\tint ret;\n\n\tif(version <= 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(!eightbit && (hint != QR_MODE_8 && hint != QR_MODE_KANJI)) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tinput = QRinput_new2(version, level);\n\tif(input == NULL) return NULL;\n\n\tif(eightbit) {\n\t\tret = QRinput_append(input, QR_MODE_8, size, data);\n\t} else {\n\t\tret = Split_splitStringToQRinput((char *)data, input, hint, casesensitive);\n\t}\n\tif(ret < 0) {\n\t\tQRinput_free(input);\n\t\treturn NULL;\n\t}\n\tcodes = QRcode_encodeInputToStructured(input);\n\tQRinput_free(input);\n\n\treturn codes;\n}\n\nQRcode_List *QRcode_encodeDataStructured(int size, const unsigned char *data, int version, QRecLevel level) {\n\treturn QRcode_encodeDataStructuredReal(size, data, version, level, 1, QR_MODE_NUL, 0);\n}\n\nQRcode_List *QRcode_encodeString8bitStructured(const char *string, int version, QRecLevel level) {\n\tif(string == NULL) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\treturn QRcode_encodeDataStructured(strlen(string), (unsigned char *)string, version, level);\n}\n\nQRcode_List *QRcode_encodeStringStructured(const char *string, int version, QRecLevel level, QRencodeMode hint, int casesensitive)\n{\n\tif(string == NULL) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\treturn QRcode_encodeDataStructuredReal(strlen(string), (unsigned char *)string, version, level, 0, hint, casesensitive);\n}\n\n/******************************************************************************\n * System utilities\n *****************************************************************************/\n\nvoid QRcode_APIVersion(int *major_version, int *minor_version, int *micro_version)\n{\n\tif(major_version != NULL) {\n\t\t*major_version = MAJOR_VERSION;\n\t}\n\tif(minor_version != NULL) {\n\t\t*minor_version = MINOR_VERSION;\n\t}\n\tif(micro_version != NULL) {\n\t\t*micro_version = MICRO_VERSION;\n\t}\n}\n\nchar *QRcode_APIVersionString(void)\n{\n\treturn VERSION;\n}\n\nvoid QRcode_clearCache(void)\n{\n\tQRspec_clearCache();\n\tMQRspec_clearCache();\n\tfree_rs_cache();\n}\n","size_bytes":20071},"bin/Demo/MfcDemo/23.VehicleGPS/VehicleGPS.cpp":{"content":"// VehicleGPS.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"VehicleGPS.h\"\n#include \"VehicleGPSDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\n\n// CVehicleGPSApp\n\nBEGIN_MESSAGE_MAP(CVehicleGPSApp, CWinApp)\n\tON_COMMAND(ID_HELP, &CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n\n// CVehicleGPSApp construction\n\nCVehicleGPSApp::CVehicleGPSApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n\n// The one and only CVehicleGPSApp object\n\nCVehicleGPSApp theApp;\n\n\n// CVehicleGPSApp initialization\n\nBOOL CVehicleGPSApp::InitInstance()\n{\n\t// InitCommonControlsEx() is required on Windows XP if an application\n\t// manifest specifies use of ComCtl32.dll version 6 or later to enable\n\t// visual styles.  Otherwise, any window creation will fail.\n\tINITCOMMONCONTROLSEX InitCtrls;\n\tInitCtrls.dwSize = sizeof(InitCtrls);\n\t// Set this to include all the common control classes you want to use\n\t// in your application.\n\tInitCtrls.dwICC = ICC_WIN95_CLASSES;\n\tInitCommonControlsEx(&InitCtrls);\n\n\tCWinApp::InitInstance();\n\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t// of your final executable, you should remove from the following\n\t// the specific initialization routines you do not need\n\t// Change the registry key under which our settings are stored\n\t// TODO: You should modify this string to be something appropriate\n\t// such as the name of your company or organization\n\tSetRegistryKey(_T(\"Local AppWizard-Generated Applications\"));\n\n\tCVehicleGPSDlg dlg;\n\tm_pMainWnd = &dlg;\n\tINT_PTR nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n","size_bytes":2058},"bin/Demo/MfcDemo/22.ThermalCamera/Property.cpp":{"content":"// Property.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"ThermalCamera.h\"\n#include \"Property.h\"\n#include \"GlobalDlg.h\"\n#include \"ThermalCameraDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CProperty dialog\n\n\nCProperty::CProperty(CWnd* pParent /*=NULL*/,LLONG lLoginId)\n\t: CDialog(CProperty::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CProperty)\n\tm_nZoom = 0;\n\tm_nGamma = 0;\n\tm_nOptIndicator = 0;\n\tm_nAmount = 0;\n\tm_nAgc = 0;\n\tm_nAgcMaxGain = 0;\n\tm_nAgcPlateau = 0;\n\tm_nHighValue = 0;\n\tm_nLHRoi = 0;\n\tm_nHLRoi = 0;\n\tm_nLowValue = 0;\n\tm_nBottom = 0;\n\tm_nLeft = 0;\n\tm_nRight = 0;\n\tm_nTop = 0;\n\t//}}AFX_DATA_INIT\n    m_iLoginID = lLoginId;\n}\n\n\nvoid CProperty::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CProperty)\n\tDDX_Control(pDX, IDC_COMBO_GAINMODE, m_Combo_GainMode);\n\tDDX_Control(pDX, IDC_COMBO_NUM, m_Combo_Num);\n\tDDX_Control(pDX, IDC_COMBO_ROITYPE, m_Combo_RoiType);\n\tDDX_Control(pDX, IDC_COMBO_OPTREGION, m_Combo_OptRegion);\n\tDDX_Control(pDX, IDC_COMBO_PSEUDOCOLOR, m_Combo_Pseudocolor);\n\tDDX_Text(pDX, IDC_EDIT_ZOOM, m_nZoom);\n\tDDX_Text(pDX, IDC_EDIT_GAMMA, m_nGamma);\n\tDDX_Text(pDX, IDC_EDIT_OPTINDICATOR, m_nOptIndicator);\n\tDDX_Text(pDX, IDC_EDIT_AMOUNT, m_nAmount);\n\tDDX_Text(pDX, IDC_EDIT_GAINCTL, m_nAgc);\n\tDDX_Text(pDX, IDC_EDIT_MAXGAIN, m_nAgcMaxGain);\n\tDDX_Text(pDX, IDC_EDIT_GAINBALANCE, m_nAgcPlateau);\n\tDDX_Text(pDX, IDC_EDIT_HIGHVALUE, m_nHighValue);\n\tDDX_Text(pDX, IDC_EDIT_LHROI, m_nLHRoi);\n\tDDX_Text(pDX, IDC_EDIT_HLROI, m_nHLRoi);\n\tDDX_Text(pDX, IDC_EDIT_LOWVALUE, m_nLowValue);\n\tDDX_Text(pDX, IDC_EDIT_BOTTOM, m_nBottom);\n\tDDX_Text(pDX, IDC_EDIT_LEFT, m_nLeft);\n\tDDX_Text(pDX, IDC_EDIT_RIGHT, m_nRight);\n\tDDX_Text(pDX, IDC_EDIT_TOP, m_nTop);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CProperty, CDialog)\n\t//{{AFX_MSG_MAP(CProperty)\n\tON_BN_CLICKED(IDC_BTN_GET, OnBtnGet)\n\tON_CBN_SELCHANGE(IDC_COMBO_NUM, OnSelchangeComboNum)\n\tON_BN_CLICKED(IDC_BTN_SET, OnBtnSet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CProperty message handlers\n\nBOOL CProperty::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n    char szJsonBuf[1024 * 40] = {0};\n    int nerror = 0;\n    int nChannel = 1;\n    CString str;\n    int index = 0;\n    BOOL ret = CLIENT_GetNewDevConfig(m_iLoginID,CFG_CMD_THERMO_GRAPHY,nChannel,szJsonBuf,1024*40,&nerror,3000);\n    if (0 != ret)\n    {\n        CFG_THERMOGRAPHY_INFO stuInfo = {0};\n        DWORD dwRetLen = 0;\n        ret = CLIENT_ParseData(CFG_CMD_THERMO_GRAPHY,szJsonBuf,(void*)&stuInfo,sizeof(stuInfo),&dwRetLen);\n        if (!ret)\n        {\n            MessageBox(ConvertString(\"getconfig error\"), ConvertString(\"Prompt\"));\n            return FALSE;\n        }\n        else\n        {\n            m_nZoom = stuInfo.stOptions[0].nEZoom;\n            m_nGamma = stuInfo.stOptions[0].nThermographyGamma;\n            m_Combo_Pseudocolor.SetCurSel(stuInfo.stOptions[0].nColorization);\n            m_nOptIndicator = stuInfo.stOptions[0].nSmartOptimizer;\n            m_Combo_OptRegion.SetCurSel(stuInfo.stOptions[0].bOptimizedRegion);\n            m_Combo_RoiType.SetCurSel(stuInfo.stOptions[0].nOptimizedROIType);\n            m_nAmount = stuInfo.stOptions[0].nCustomRegion;\n            if (stuInfo.stOptions[0].nOptimizedROIType == NET_THERMO_ROI_CUSTOM)\n            {\n                for (int i = 0;i<m_nAmount;++i)\n                {\n                    m_Combo_Num.ResetContent();\n                    for (int i = 0;i<m_nAmount;++i)\n                    {\n                        index = 0;\n                        str.Format(\"%d\",i);\n                        index = m_Combo_Num.AddString(str);\n                        m_Combo_Num.SetItemData(index,i);\n                    }\n                }\n                m_Combo_Num.SetCurSel(0);\n                m_nLeft = stuInfo.stOptions[0].stCustomRegions[0].nLeft;\n                m_nRight = stuInfo.stOptions[0].stCustomRegions[0].nRight;\n                m_nTop = stuInfo.stOptions[0].stCustomRegions[0].nTop;\n                m_nBottom = stuInfo.stOptions[0].stCustomRegions[0].nBottom;\n            }\n            m_nAgc = stuInfo.stOptions[0].nAgc;\n            m_nAgcMaxGain = stuInfo.stOptions[0].nAgcMaxGain;\n            m_nAgcPlateau = stuInfo.stOptions[0].nAgcPlateau;\n            m_Combo_GainMode.SetCurSel(stuInfo.stOptions[0].nGainMode);\n            if (stuInfo.stOptions[0].nGainMode == CFG_THERMO_GAIN_MODE_AUTO)\n            {\n                m_nHighValue = stuInfo.stOptions[0].stAutoGain.nHighToLow;\n                m_nHLRoi = stuInfo.stOptions[0].stAutoGain.nHLROI;\n                m_nLHRoi = stuInfo.stOptions[0].stAutoGain.nLHROI;\n                m_nLowValue = stuInfo.stOptions[0].stAutoGain.nLowToHigh;\n            }\n            else\n            {\n                m_nHighValue = 0;\n                m_nHLRoi = 0;\n                m_nLHRoi = 0;\n                m_nLowValue = 0;\n            }\n        }\n    }\n    else\n    {\n        MessageBox(ConvertString(\"getconfig error\"), ConvertString(\"Prompt\"));\n    }\n\tUpdateData(FALSE);\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CProperty::OnOK() \n{\n\t\n\t\n\tCDialog::OnOK();\n}\n\nvoid CProperty::OnBtnGet() \n{\n    char szJsonBuf[1024 * 40] = {0};\n    int nerror = 0;\n    int nChannel = 1;\n    CString str;\n    int index = 0;\n    BOOL ret = CLIENT_GetNewDevConfig(m_iLoginID,CFG_CMD_THERMO_GRAPHY,nChannel,szJsonBuf,1024*40,&nerror,3000);\n    if (0 != ret)\n    {\n        CFG_THERMOGRAPHY_INFO stuInfo = {0};\n        DWORD dwRetLen = 0;\n        ret = CLIENT_ParseData(CFG_CMD_THERMO_GRAPHY,szJsonBuf,(void*)&stuInfo,sizeof(stuInfo),&dwRetLen);\n        if (!ret)\n        {\n            return ;\n        }\n        else\n        {\n            m_nZoom = stuInfo.stOptions[0].nEZoom;\n            m_nGamma = stuInfo.stOptions[0].nThermographyGamma;\n            m_Combo_Pseudocolor.SetCurSel(stuInfo.stOptions[0].nColorization);\n            m_nOptIndicator = stuInfo.stOptions[0].nSmartOptimizer;\n            m_Combo_OptRegion.SetCurSel(stuInfo.stOptions[0].bOptimizedRegion);\n            m_Combo_RoiType.SetCurSel(stuInfo.stOptions[0].nOptimizedROIType);\n            m_nAmount = stuInfo.stOptions[0].nCustomRegion;\n            if (stuInfo.stOptions[0].nOptimizedROIType == NET_THERMO_ROI_CUSTOM)\n            {\n                m_Combo_Num.ResetContent();\n                for (int i = 0;i<m_nAmount;++i)\n                {\n                    index = 0;\n                    str.Format(\"%d\",i);\n                    index = m_Combo_Num.AddString(str);\n                    m_Combo_Num.SetItemData(index,i);\n                }\n                m_Combo_Num.SetCurSel(0);\n                m_nLeft = stuInfo.stOptions[0].stCustomRegions[0].nLeft;\n                m_nRight = stuInfo.stOptions[0].stCustomRegions[0].nRight;\n                m_nTop = stuInfo.stOptions[0].stCustomRegions[0].nTop;\n                m_nBottom = stuInfo.stOptions[0].stCustomRegions[0].nBottom;\n            }\n            m_nAgc = stuInfo.stOptions[0].nAgc;\n            m_nAgcMaxGain = stuInfo.stOptions[0].nAgcMaxGain;\n            m_nAgcPlateau = stuInfo.stOptions[0].nAgcPlateau;\n            m_Combo_GainMode.SetCurSel(stuInfo.stOptions[0].nGainMode);\n            if (stuInfo.stOptions[0].nGainMode == CFG_THERMO_GAIN_MODE_AUTO)\n            {\n                m_nHighValue = stuInfo.stOptions[0].stAutoGain.nHighToLow;\n                m_nHLRoi = stuInfo.stOptions[0].stAutoGain.nHLROI;\n                m_nLHRoi = stuInfo.stOptions[0].stAutoGain.nLHROI;\n                m_nLowValue = stuInfo.stOptions[0].stAutoGain.nLowToHigh;\n            }\n            else\n            {\n                m_nHighValue = 0;\n                m_nHLRoi = 0;\n                m_nLHRoi = 0;\n                m_nLowValue = 0;\n            }\n        }\n    }\n\tUpdateData(FALSE);\n}\n\nvoid CProperty::OnSelchangeComboNum() \n{\n    UpdateData();\n\tint i = m_Combo_Num.GetCurSel();\n    char szJsonBuf[1024 * 40] = {0};\n    int nerror = 0;\n    int nChannel = 1;\n    CString str;\n    int index = 0;\n    BOOL ret = CLIENT_GetNewDevConfig(m_iLoginID,CFG_CMD_THERMO_GRAPHY,nChannel,szJsonBuf,1024*40,&nerror,3000);\n    if (0 != ret)\n    {\n        CFG_THERMOGRAPHY_INFO stuInfo = {0};\n        DWORD dwRetLen = 0;\n        ret = CLIENT_ParseData(CFG_CMD_THERMO_GRAPHY,szJsonBuf,(void*)&stuInfo,sizeof(stuInfo),&dwRetLen);\n        if (!ret)\n        {\n            return ;\n        }\n        else\n        {\n            m_nLeft = stuInfo.stOptions[0].stCustomRegions[i].nLeft;\n            m_nRight = stuInfo.stOptions[0].stCustomRegions[i].nRight;\n            m_nTop = stuInfo.stOptions[0].stCustomRegions[i].nTop;\n            m_nBottom = stuInfo.stOptions[0].stCustomRegions[i].nBottom;\n        }\n    }\n\tUpdateData(FALSE);\n}\n\nvoid CProperty::OnBtnSet() \n{\n    UpdateData();\n\tCFG_THERMOGRAPHY_INFO stuInfo = {sizeof(stuInfo)};\n    stuInfo.stOptions[0].nEZoom = m_nZoom;\n    stuInfo.stOptions[0].nThermographyGamma = m_nGamma;\n    stuInfo.stOptions[0].nColorization = m_Combo_Pseudocolor.GetCurSel();\n    stuInfo.stOptions[0].nSmartOptimizer = m_nOptIndicator;\n    stuInfo.stOptions[0].bOptimizedRegion = m_Combo_OptRegion.GetCurSel();\n    stuInfo.stOptions[0].nOptimizedROIType = m_Combo_RoiType.GetCurSel();\n    stuInfo.stOptions[0].nCustomRegion = m_nAmount;\n    int i = m_Combo_Num.GetCurSel();\n    stuInfo.stOptions[0].stCustomRegions[i].nLeft = m_nLeft;\n    stuInfo.stOptions[0].stCustomRegions[i].nRight = m_nRight;\n    stuInfo.stOptions[0].stCustomRegions[i].nTop = m_nTop;\n    stuInfo.stOptions[0].stCustomRegions[i].nBottom = m_nBottom;\n    stuInfo.stOptions[0].nAgc = m_nAgc;\n    stuInfo.stOptions[0].nAgcMaxGain = m_nAgcMaxGain;\n    stuInfo.stOptions[0].nAgcPlateau = m_nAgcPlateau;\n    stuInfo.stOptions[0].nGainMode = m_Combo_GainMode.GetCurSel();\n    if (stuInfo.stOptions[0].nGainMode == CFG_THERMO_GAIN_MODE_AUTO)\n    {\n        stuInfo.stOptions[0].stAutoGain.nHighToLow = m_nHighValue;\n        stuInfo.stOptions[0].stAutoGain.nHLROI = m_nHLRoi;\n        stuInfo.stOptions[0].stAutoGain.nLHROI = m_nLHRoi;\n        stuInfo.stOptions[0].stAutoGain.nLowToHigh = m_nLowValue;\n    }\n    char szJsonBuf[512 * 40] = {0};\n    BOOL bRet = CLIENT_PacketData(CFG_CMD_THERMOMETRY,(LPVOID)&stuInfo, sizeof(stuInfo), szJsonBuf, sizeof(szJsonBuf));\n    if (!bRet)\n    {\n        \n    } \n    else\n    {\n        int nerror = 0;\n        int nrestart = 0;\n        int nChannelID = -1;\n        bRet = CLIENT_SetNewDevConfig(m_iLoginID, CFG_CMD_THERMOMETRY, nChannelID, szJsonBuf, 512*40, &nerror, &nrestart, 3000);\n        if (!bRet)\n        {\n            \n        }\n    }\n    UpdateData(FALSE);\n}\n","size_bytes":10777},"bin/Demo/MfcDemo/13.FaceRecognition/StdAfx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n//\tFaceRecognition.pch will be the pre-compiled header\n//\tstdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n\n\n\n","size_bytes":209},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgNetAbort.cpp":{"content":"// DlgCfgNetAbort.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"alarmdevice.h\"\n#include \"DlgCfgNetAbort.h\"\n#include \"SubDlgCfgEventHandler.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgNetAbort dialog\n\n\nCDlgCfgNetAbort::CDlgCfgNetAbort(CWnd* pParent /* = NULL */, LLONG lLoginID /* = 0 */)\n\t: CDialog(CDlgCfgNetAbort::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgNetAbort)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n    m_lLoginId = lLoginID;\n\tmemset(&m_stuInfo, 0, sizeof(CFG_NETABORT_INFO));\n}\n\n\nvoid CDlgCfgNetAbort::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgNetAbort)\n\tDDX_Control(pDX, IDC_CFGNETABORT_CHK_ENABLE, m_ckEnable);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgNetAbort, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgNetAbort)\n\tON_BN_CLICKED(IDC_CFGNETABORT_BTN_EVENTHANDLER, OnCfgnetabortBtnEventhandler)\n\tON_BN_CLICKED(IDC_CFGNETABORT_BTN_GET, OnCfgnetabortBtnGet)\n\tON_BN_CLICKED(IDC_CFGNETABORT_BTN_SET, OnCfgnetabortBtnSet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgNetAbort private method\n\nBOOL CDlgCfgNetAbort::GetConfigFromDevice()\n{\n    char szJsonBuf[1024 * 40] = {0};\n    int nerror = 0;\n    int nSelChn = -1;\n    BOOL bRet = CLIENT_GetNewDevConfig(m_lLoginId, CFG_CMD_NETABORT, nSelChn, szJsonBuf, sizeof(szJsonBuf), &nerror, SDK_API_WAIT);\n    \n    if (bRet)\n    {\n        DWORD dwRetLen = 0;\n        bRet = CLIENT_ParseData(CFG_CMD_NETABORT, szJsonBuf, (void*)&m_stuInfo, sizeof(m_stuInfo), &dwRetLen);\n        if (!bRet)\n        {\n            MessageBox(ConvertString(CString(\"parse NetAbort error...\"), DLG_CFG_NETABORT), ConvertString(\"Prompt\"));\n            return FALSE;\n        }\n    }\n    else\n    {\t\t\t\n        CString csErr;\n        csErr.Format(\"%s 0x%08x\",ConvertString(\"QueryConfig NetAbort error:\", DLG_CFG_NETABORT), CLIENT_GetLastError());\n        MessageBox(csErr, ConvertString(\"Prompt\"));\n        return FALSE;\n    }\n    return TRUE;\n}\n\nBOOL CDlgCfgNetAbort::SetConfigToDevice()\n{\n    char szJsonBuf[1024 * 40] = {0};    \n    BOOL bRet = CLIENT_PacketData(CFG_CMD_NETABORT, &m_stuInfo, sizeof(m_stuInfo), szJsonBuf, sizeof(szJsonBuf));\n    if (!bRet)\n    {\n        MessageBox(ConvertString(CString(\"packet NetAbort error...\"), DLG_CFG_NETABORT), ConvertString(\"Prompt\"));\n        return FALSE;\n    } \n    else\n    {\n        int nerror = 0;\n        int nrestart = 0;\n        bRet = CLIENT_SetNewDevConfig(m_lLoginId, CFG_CMD_NETABORT, -1, szJsonBuf, sizeof(szJsonBuf), &nerror, &nrestart, SDK_API_WAIT);\n        if (!bRet)\n        {\n            CString csErr;\n            csErr.Format(\"%s 0x%08x\", ConvertString(\"SetupConfig NetAbort failed:\", DLG_CFG_NETABORT), CLIENT_GetLastError());\n            MessageBox(csErr, ConvertString(\"Prompt\"));\n            return FALSE;\n        }\n        else\n        {\n            MessageBox(ConvertString(CString(\"SetConfig NetAbort ok!\"), DLG_CFG_NETABORT), ConvertString(\"Prompt\"));\n        }\n    }\n    return TRUE;\n}\n\nBOOL CDlgCfgNetAbort::showInfo()\n{\n    m_ckEnable.SetCheck(m_stuInfo.bEnable ? BST_CHECKED : BST_UNCHECKED);\n    return TRUE;\n}\n\nBOOL CDlgCfgNetAbort::getInfo()\n{\n    m_stuInfo.bEnable = m_ckEnable.GetCheck() ? TRUE : FALSE;\n    return TRUE;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgNetAbort message handlers\n\nBOOL CDlgCfgNetAbort::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_NETABORT);\n\t// TODO: Add extra initialization here\n    \n    if (GetConfigFromDevice())\n    {\n        showInfo();\n\t}\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgNetAbort::OnCfgnetabortBtnEventhandler() \n{\n\t// TODO: Add your control notification handler code here\n    CSubDlgCfgEventHandler* pdlgEventHandler = new CSubDlgCfgEventHandler;\n    if (pdlgEventHandler != NULL)\n    {\n        pdlgEventHandler->SetEventHandler(m_stuInfo.stuEventHandler);\n        \n        if (IDOK == pdlgEventHandler->DoModal())\n        {\n            const CFG_ALARM_MSG_HANDLE& stuEventHandler = pdlgEventHandler->GetEventHandler();\n            memcpy(&m_stuInfo.stuEventHandler, &stuEventHandler, sizeof(CFG_ALARM_MSG_HANDLE));\n        }\n        \n        delete pdlgEventHandler;\n        pdlgEventHandler = NULL;\n    }\n    else\n    {\n        MessageBox(ConvertString(\"new handler dialog error!\", DLG_CFG_NETABORT), ConvertString(\"Prompt\"));\n\t}\n}\n\nvoid CDlgCfgNetAbort::OnCfgnetabortBtnGet() \n{\n\t// TODO: Add your control notification handler code here    \n    if (GetConfigFromDevice())\n    {\n        showInfo();\n\t}\n}\n\nvoid CDlgCfgNetAbort::OnCfgnetabortBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n    getInfo();\n    SetConfigToDevice();\n}\n","size_bytes":5026},"bin/DemoSrc/AviConvert_Demo/LanguageConvertor.cpp":{"content":"// LanguageConvertor.cpp: implementation of the CLanguageConvertor class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"LanguageConvertor.h\"\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\n//////////////////////////////////////////////////////////////////////\n// Construction/Destruction\n//////////////////////////////////////////////////////////////////////\nTCHAR CLanguageConvertor::m_szIniFile[MAX_PATH] = {0};\n\n\nint CLanguageConvertor::Init()\n{\n\t_stprintf(m_szIniFile, _T(\"%s%s\"), GetMoudlePath(), _T(\"lang.ini\"));\n\treturn 1;\n}\n\nCString CLanguageConvertor::ConvertString(CString strText)\n{\n\tif(strText.GetLength())\n\t{\n\t\tTCHAR val[300];\n\t\tGetPrivateProfileString(_T(\"String\"), strText, strText, val, sizeof(val), m_szIniFile);\n\t\treturn val;\n\t}\n\n\treturn strText;\n}\n\nvoid CLanguageConvertor::SetWndStaticText(CWnd * pWnd)\n{\n\tCString strCaption,strText;\n\n\tpWnd->GetWindowText(strCaption);\n\tif(strCaption.GetLength()>0)\n\t{\n\t\tstrText=ConvertString(strCaption);\n\t\tpWnd->SetWindowText(strText);\n\t}\n\n\tCWnd * pChild=pWnd->GetWindow(GW_CHILD);\n\tCString strClassName;\n\twhile(pChild)\n\t{\n\t\tstrClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n\t\tif(strClassName == \"CEdit\")\n\t\t{\n\t\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t\t\tcontinue;\n\t\t}\n\t\t//////////////////////////////////////////////////////////////////////////\n\t\tpChild->GetWindowText(strCaption);\n\t\tstrText=ConvertString(strCaption);\n\t\tpChild->SetWindowText(strText);\n\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t}\n}\n\nvoid CLanguageConvertor::SetMenuStaticText(CMenu* pMenu)\n{\n\tCString strCaption,strText;\n\t\n\tint MenuItemNum = pMenu->GetMenuItemCount() ;\n\t\n\tfor (int i = 0 ; i < MenuItemNum ; i++)\n\t{\t\t\n\t\tMENUITEMINFO info;\n\t\tmemset(&info, 0 , sizeof(MENUITEMINFO)) ;\n\t\tinfo.cbSize = sizeof (MENUITEMINFO); // must fill up this field\n\t\tinfo.fMask = MIIM_STATE;             // get the state of the menu item\n\t\t\n\t\tpMenu->GetMenuString(i, strCaption, MF_BYPOSITION);\n\t\t\n\t\tstrText=ConvertString(strCaption);\n\t\t\n\t\tUINT ID = pMenu->GetMenuItemID(i) ;\n\t\t\n\t\tif (ID != -1)\n\t\t{\n\t\t\tpMenu->GetMenuItemInfo(ID, &info) ;\n\t\t\tpMenu->ModifyMenu(ID, MF_BYCOMMAND|MF_STRING, ID, strText);\n\t\t\tSetMenuItemInfo(pMenu->m_hMenu, ID, FALSE, &info) ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpMenu->ModifyMenu(i, MF_BYPOSITION| MF_STRING, 0, strText);\n\t\t}\n\t\t\n\t\tCMenu* subMenu = pMenu->GetSubMenu(i) ;\n\t\t\n\t\tif (subMenu != NULL)\n\t\t{\t\t\t\n\t\t\tSetMenuStaticText(subMenu) ;\n\t\t}\n\t}\n}","size_bytes":2495},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgSensorSampling.cpp":{"content":"// DlgCfgSensorSampling.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgCfgSensorSampling.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgSensorSampling dialog\n\n\nCDlgCfgSensorSampling::CDlgCfgSensorSampling(CWnd* pParent /*=NULL*/, LLONG lLoginId)\n\t: CDialog(CDlgCfgSensorSampling::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgSensorSampling)\n\tm_edtDetectionPeriod = 0;\n\tm_edtStorageitem = 0;\n\t//}}AFX_DATA_INIT\n\tm_lLoginId = lLoginId;\n\tmemset(&m_stuInfo, 0, sizeof(m_stuInfo));\n}\n\n\nvoid CDlgCfgSensorSampling::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgSensorSampling)\n\tDDX_Text(pDX, IDC_SENSORSAMPLING_EDT_DETECTIONPERIOD, m_edtDetectionPeriod);\n\tDDX_Text(pDX, IDC_SENSORSAMPLING_EDT_STORAGEITEM, m_edtStorageitem);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgSensorSampling, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgSensorSampling)\n\tON_BN_CLICKED(IDC_SENSORSAMPLING_BTN_GET, OnSensorsamplingBtnGet)\n\tON_BN_CLICKED(IDC_SENSORSAMPLING_BTN_SET, OnSensorsamplingBtnSet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgSensorSampling message handlers\n\nBOOL CDlgCfgSensorSampling::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\tg_SetWndStaticText(this, DLG_CFG_SENSORSANMPLING);\n\t// TODO: Add extra initialization here\n\tif (m_lLoginId == 0)\n\t{\n\t\tMessageBox(ConvertString(\"Please login first!\", DLG_CFG_SENSORSANMPLING), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\t\n\tif (getCfgFromDevice())\n\t{\n\t\tStuToDlg();\n\t}\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgSensorSampling::OnSensorsamplingBtnGet() \n{\n\t// TODO: Add your control notification handler code here\n\tif (getCfgFromDevice())\n\t{\n\t\tStuToDlg();\n\t}\n}\n\nvoid CDlgCfgSensorSampling::OnSensorsamplingBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\tsetCfgToDevice();\n}\n\nvoid CDlgCfgSensorSampling::DlgToStu()\n{\n\tUpdateData(TRUE);\n\tm_stuInfo.nDetectionPeriod = m_edtDetectionPeriod;\n\tm_stuInfo.nStorageItem = m_edtStorageitem;\n}\n\nvoid CDlgCfgSensorSampling::StuToDlg()\n{\n\tm_edtDetectionPeriod = m_stuInfo.nDetectionPeriod;\n\tm_edtStorageitem = m_stuInfo.nStorageItem;\n\tUpdateData(FALSE);\n}\n\nBOOL CDlgCfgSensorSampling::getCfgFromDevice()\n{\n\tif (m_lLoginId == 0)\n\t{\n\t\tMessageBox(ConvertString(\"Please login first!\", DLG_CFG_SENSORSANMPLING), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\t\n\tchar szOutBuffer[1024] = {0};\n\tint nerror = 0;\n\n\tBOOL bRet = CLIENT_GetNewDevConfig(m_lLoginId, CFG_CMD_SENSORSAMPLING, -1, szOutBuffer, 1024, &nerror, SDK_API_WAIT);\n\tif (bRet)\n\t{\n\t\tDWORD dwRetLen = 0;\t\t\n\t\tbRet = CLIENT_ParseData(CFG_CMD_SENSORSAMPLING, szOutBuffer, (void*)&m_stuInfo, sizeof(m_stuInfo), &dwRetLen);\n\t\tif (!bRet)\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"parse SensorSampling error...\"), DLG_CFG_SENSORSANMPLING), ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\t\t\t\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"get config SensorSampling error:\", DLG_CFG_SENSORSANMPLING),CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nBOOL CDlgCfgSensorSampling::setCfgToDevice()\n{\n\tif (m_lLoginId == 0)\n\t{\n\t\tMessageBox(ConvertString(\"Please login first!\", DLG_CFG_SENSORSANMPLING), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\t\n\tchar szJsonBuf[1024] = {0};\n\tBOOL bRet = CLIENT_PacketData(CFG_CMD_SENSORSAMPLING, (void*)&m_stuInfo, sizeof(m_stuInfo), szJsonBuf, sizeof(szJsonBuf));\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(CString(\"packet SensorSampling error...\"), DLG_CFG_SENSORSANMPLING), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t} \n\telse\n\t{\n\t\tint nerror = 0;\n\t\tint nrestart = 0;\n\t\tbRet = CLIENT_SetNewDevConfig(m_lLoginId, CFG_CMD_SENSORSAMPLING, -1, szJsonBuf, sizeof(szJsonBuf), &nerror, &nrestart, SDK_API_WAIT);\n\t\tif (!bRet)\n\t\t{\n\t\t\tCString csErr;\n\t\t\tcsErr.Format(\"%s %08x\", ConvertString(\"SetupConfig SensorSampling failed:\", DLG_CFG_SENSORSANMPLING), CLIENT_GetLastError());\n\t\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n        else\n        {    \n\t\t\tMessageBox(ConvertString(CString(\"SetConfig SensorSampling ok!\"), DLG_CFG_SENSORSANMPLING), ConvertString(\"Prompt\"));\n        }\n\t}\n\treturn TRUE;\n}","size_bytes":4490},"bin/Demo/MfcDemo/22.ThermalCamera/ThermalCamera.cpp":{"content":"// ThermalCamera.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"ThermalCamera.h\"\n#include \"ThermalCameraDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CThermalCameraApp\n\nBEGIN_MESSAGE_MAP(CThermalCameraApp, CWinApp)\n\t//{{AFX_MSG_MAP(CThermalCameraApp)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t\t//    DO NOT EDIT what you see in these blocks of generated code!\n\t//}}AFX_MSG\n\tON_COMMAND(ID_HELP, CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CThermalCameraApp construction\n\nCThermalCameraApp::CThermalCameraApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The one and only CThermalCameraApp object\n\nCThermalCameraApp theApp;\n\n/////////////////////////////////////////////////////////////////////////////\n// CThermalCameraApp initialization\n\nBOOL CThermalCameraApp::InitInstance()\n{\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t//  of your final executable, you should remove from the following\n\t//  the specific initialization routines you do not need.\n\n#ifdef _AFXDLL\n\tEnable3dControls();\t\t\t// Call this when using MFC in a shared DLL\n#else\n\tEnable3dControlsStatic();\t// Call this when linking to MFC statically\n#endif\n\n\tCThermalCameraDlg dlg;\n\tm_pMainWnd = &dlg;\n\tINT_PTR nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n","size_bytes":2091},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgNetwork.cpp":{"content":"// DlgCfgNetwork.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgCfgNetwork.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgNetwork dialog\n\n\nCDlgCfgNetwork::CDlgCfgNetwork(CWnd* pParent /*=NULL*/, LLONG lLoginID)\n\t: CDialog(CDlgCfgNetwork::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgNetwork)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\tm_lLoginID = lLoginID;\n\t//}}AFX_DATA_INIT\n\tmemset(&m_stuNetwork, 0, sizeof(m_stuNetwork));\n}\n\n\nvoid CDlgCfgNetwork::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgNetwork)\n\tDDX_Control(pDX, IDC_NETWORK_MASK, m_ctlMask);\n\tDDX_Control(pDX, IDC_NETWORK_IP, m_ctlIp);\n\tDDX_Control(pDX, IDC_NETWORK_GATEWAY, m_ctlGateway);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgNetwork, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgNetwork)\n\tON_BN_CLICKED(IDC_NETWORK_BTN_CANCEL, OnBtnCancel)\n\tON_BN_CLICKED(IDC_NETWORK_BTN_SET, OnBtnSet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgNetwork message handlers\n\nBOOL CDlgCfgNetwork::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_NETWORK);\n\t\n\t// TODO: Add extra initialization here\n\tm_ctlIp.SetAddress(0, 0, 0, 0);\n\tm_ctlMask.SetAddress(0, 0, 0, 0);\n\tm_ctlGateway.SetAddress(0, 0, 0, 0);\n\n\tGetNetworkPara();\n\tUpdateData(FALSE);\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgNetwork::OnBtnCancel() \n{\n\t// TODO: Add your control notification handler code here\n\tCDialog::OnCancel();\n}\n\nvoid CDlgCfgNetwork::OnBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n\tUpdateData(TRUE);\n\n\tif (0 == m_lLoginID)\n\t{\n\t\tMessageBox(ConvertString(\"we haven't login a device yet!\", DLG_CFG_NETWORK), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tCString csIp, csMask, csGateway;\n\tm_ctlIp.GetWindowText(csIp);\n\tm_ctlMask.GetWindowText(csMask);\n\tm_ctlGateway.GetWindowText(csGateway);\n\n//\tCFG_NETWORK_INFO stuNetworkPara = {0};\n\tCFG_NETWORK_INFO& stuNetworkPara = m_stuNetwork;\n\tstuNetworkPara.nInterfaceNum = 1;\n\tstrncpy(stuNetworkPara.stuInterfaces[0].szIP, csIp, MAX_ADDRESS_LEN-1);\n\tstrncpy(stuNetworkPara.stuInterfaces[0].szSubnetMask, csMask, MAX_ADDRESS_LEN-1);\n\tstrncpy(stuNetworkPara.stuInterfaces[0].szDefGateway, csGateway, MAX_ADDRESS_LEN-1);\n\n\tchar szJsonBuf[1024] = {0};\n\tBOOL nRet = CLIENT_PacketData(CFG_CMD_NETWORK, &stuNetworkPara, sizeof(CFG_NETWORK_INFO), szJsonBuf, sizeof(szJsonBuf));\n\tif (!nRet)\n\t{\n\t\tMessageBox(ConvertString(\"Packet network json buffer failed.\", DLG_CFG_NETWORK), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tint nErr = 0, nRestart = 0;\n\tnRet = CLIENT_SetNewDevConfig(m_lLoginID, CFG_CMD_NETWORK,\n\t\t-1, szJsonBuf, strlen(szJsonBuf), &nErr, &nRestart, SDK_API_WAIT);\n\tif (!nRet)\n\t{\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"SetupConfig network failed:\", DLG_CFG_NETWORK), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn ;\n\t}\n\n \tMessageBox(ConvertString(\"send network parameters successfully.\", DLG_CFG_NETWORK), ConvertString(\"Prompt\"));\n\n\treturn;\n}\n\nvoid CDlgCfgNetwork::GetNetworkPara()\n{\n\tif (0 == m_lLoginID)\n\t{\n\t\tMessageBox(ConvertString(\"we haven't login a device yet!\", DLG_CFG_NETWORK), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\tchar szJsonBuf[1024] = {0};\n\tint nErr = 0;\n\tBOOL bRet = CLIENT_GetNewDevConfig(m_lLoginID, CFG_CMD_NETWORK,\n\t\t-1, szJsonBuf, sizeof(szJsonBuf), &nErr, SDK_API_WAIT);\n\tif (!bRet)\n\t{\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"GetConfig network failed:\", DLG_CFG_NETWORK), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tCFG_NETWORK_INFO stNetworkInfo = {0};\n\tDWORD dwRetLen = 0;\n\tbRet = CLIENT_ParseData(CFG_CMD_NETWORK, szJsonBuf, &stNetworkInfo, sizeof(stNetworkInfo), &dwRetLen);\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Parse network jason failed.\", DLG_CFG_NETWORK), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tif (0 == stNetworkInfo.stuInterfaces[0].szIP[0] \n\t\t|| 0 == stNetworkInfo.stuInterfaces[0].szSubnetMask[0]\n\t\t|| 0 == stNetworkInfo.stuInterfaces[0].szDefGateway[0])\n\t{\n\t\tMessageBox(ConvertString(\"Invalidate ip parameters.\", DLG_CFG_NETWORK), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tmemcpy(&m_stuNetwork, &stNetworkInfo, sizeof(CFG_NETWORK_INFO));\n\n\tm_ctlIp.SetWindowText(stNetworkInfo.stuInterfaces[0].szIP);\n\tm_ctlMask.SetWindowText(stNetworkInfo.stuInterfaces[0].szSubnetMask);\n\tm_ctlGateway.SetWindowText(stNetworkInfo.stuInterfaces[0].szDefGateway);\n\n#if 0\n\tDWORD dwIp = ntohl(inet_addr(stNetworkInfo.stuInterfaces[0].szIP));\n\tm_ctlIp.SetAddress(dwIp);\n\n\tDWORD dwMask = ntohl(inet_addr(stNetworkInfo.stuInterfaces[0].szSubnetMask));\n\tm_ctlMask.SetAddress(dwMask);\n\n\tDWORD dwGateway = ntohl(inet_addr(stNetworkInfo.stuInterfaces[0].szDefGateway));\n\tm_ctlGateway.SetAddress(dwGateway);\n#endif\n}\n","size_bytes":5093},"bin/Demo/MfcDemo/17.IntelligentTraffic/BWListDlg.cpp":{"content":"// BWListDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"IntelligentTraffic.h\"\n#include \"BWListDlg.h\"\n#include \"AddAndModifyBWDlg.h\"\n#include <cmath>\n\n\n// CBWListDlg Dialog\n\nIMPLEMENT_DYNAMIC(CBWListDlg, CDialog)\n\nCBWListDlg::CBWListDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CBWListDlg::IDD, pParent)\n{\n\n    m_nCurPage = 0;\n    m_nTotalPage = 0;\n    m_nIndexOfTrafficList = 0;\n    m_nTotalCountOfTrafficList = 0;\n    \n    m_lLoginHandle = 0;\n    m_LFindeHandle = 0;\n}\n\nCBWListDlg::~CBWListDlg()\n{\n}\n\nvoid CBWListDlg::DoDataExchange(CDataExchange* pDX)\n{\n    CDialog::DoDataExchange(pDX);\n    DDX_Control(pDX, IDC_BTTN_QUERY, m_btnQuery);\n    DDX_Control(pDX, IDC_BTN_ADD, m_btnAdd);\n    DDX_Control(pDX, IDC_BTN_MODIFY, m_btnModify);\n    DDX_Control(pDX, IDC_BTN_DELETE, m_btnDelete);\n    DDX_Control(pDX, IDC_COMBO_CHANNEL, m_cmbChannel);\n    DDX_Control(pDX, IDC_LIST_BW, m_ctrTrafficList);\n    DDX_Control(pDX, IDC_BTN_PREVIOUS_PAGE, m_btnPreviousPage);\n    DDX_Control(pDX, IDC_BTN_NEXT_PAGE, m_btnNextPage);\n    DDX_Control(pDX, IDC_COMBO_CHANNEL2, m_cmbType);\n}\n\n\nBEGIN_MESSAGE_MAP(CBWListDlg, CDialog)\n    ON_BN_CLICKED(IDC_BTTN_QUERY, &CBWListDlg::OnBnClickedBtnQuery)\n    ON_BN_CLICKED(IDC_BTN_MODIFY, &CBWListDlg::OnBnClickedBtnModify)\n    ON_BN_CLICKED(IDC_BTN_ADD, &CBWListDlg::OnBnClickedBtnAdd)\n    ON_BN_CLICKED(IDC_BTN_DELETE, &CBWListDlg::OnBnClickedBtnDelete)\n    ON_BN_CLICKED(IDC_BTN_PREVIOUS_PAGE, &CBWListDlg::OnBnClickedBtnPreviousPage)\n    ON_BN_CLICKED(IDC_BTN_NEXT_PAGE, &CBWListDlg::OnBnClickedBtnNextPage)\n    ON_CBN_SELCHANGE(IDC_COMBO_CHANNEL2, &CBWListDlg::OnCbnSelchangeComboChannelTrafficList)\nEND_MESSAGE_MAP()\n\n\n// CBWListDlg message handlers\n\nBOOL CBWListDlg::PreTranslateMessage(MSG* pMsg)\n{\n    // Enter key\n    if(pMsg->message == WM_KEYDOWN &&\n        pMsg->wParam == VK_RETURN)\n    {\n        return TRUE;\n    }\n\n    // Escape key\n    if(pMsg->message == WM_KEYDOWN &&\n        pMsg->wParam == VK_ESCAPE)\n    {\n        return TRUE;\n    }\n    return CDialog::PreTranslateMessage(pMsg);\n}\n\n\nBOOL CBWListDlg::OnInitDialog()\n{\n    CDialog::OnInitDialog();\n    g_SetWndStaticText(this);\n\n    m_btnQuery.EnableWindow(FALSE);\n    m_btnAdd.EnableWindow(FALSE);\n    m_btnModify.EnableWindow(FALSE);\n    m_btnDelete.EnableWindow(FALSE);\n    m_btnPreviousPage.EnableWindow(FALSE);\n    m_btnNextPage.EnableWindow(FALSE);\n\n    m_ctrTrafficList.SetExtendedStyle(m_ctrTrafficList.GetExtendedStyle() | LVS_EX_HEADERDRAGDROP | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);\n    m_ctrTrafficList.InsertColumn(0, ConvertString(\"Index\"), LVCFMT_LEFT, 60);\n    m_ctrTrafficList.InsertColumn(1, ConvertString(\"Plate Number\"), LVCFMT_LEFT, 120);\n    m_ctrTrafficList.InsertColumn(2, ConvertString(\"Master of Car\"), LVCFMT_LEFT, 120);\n    m_ctrTrafficList.InsertColumn(3, ConvertString(\"Start Time\"), LVCFMT_LEFT, 130);\n    m_ctrTrafficList.InsertColumn(4, ConvertString(\"End Time\"), LVCFMT_LEFT, 130);\n    return TRUE;  // return TRUE unless you set the focus to a control\n}\n\n\nvoid CBWListDlg::Init(unsigned int nChannel, LLONG lLoginHandle)\n{\n    if (0 == nChannel || 0 == lLoginHandle)\n    {\n        return;\n    }\n\n    for (unsigned int i = 0 ;i < nChannel; i++)\n    {\n        CString csChannel;\n        csChannel.Format(\"%d\", i+1);\n        m_cmbChannel.InsertString(i, csChannel);\n    }\n    m_cmbChannel.SetCurSel(0);\n\n    m_cmbType.InsertString(0, ConvertString(\"White List\"));\n    m_cmbType.InsertString(1, ConvertString(\"Black List\"));\n    m_cmbType.SetCurSel(0);\n\n    m_btnQuery.EnableWindow(TRUE);\n    m_btnAdd.EnableWindow(TRUE);\n    m_btnModify.EnableWindow(TRUE);\n    m_btnDelete.EnableWindow(TRUE);\n    m_lLoginHandle = lLoginHandle;\n}\n\nvoid CBWListDlg::CleanUp()\n{\n    if (0 != m_LFindeHandle)\n    {\n        // stop querying\n        CLIENT_FindRecordClose(m_LFindeHandle);\n    }\n\n    m_btnQuery.EnableWindow(FALSE);\n    m_btnAdd.EnableWindow(FALSE);\n    m_btnModify.EnableWindow(FALSE);\n    m_btnDelete.EnableWindow(FALSE);\n    m_btnPreviousPage.EnableWindow(FALSE);\n    m_btnNextPage.EnableWindow(FALSE);\n\n    m_cmbType.ResetContent();\n    m_cmbChannel.ResetContent();\n    m_cmbChannel.ResetContent();\n    m_ctrTrafficList.DeleteAllItems();\n\n    SetDlgItemText(IDC_EDIT_RECORD_COUNT, \"\");\n    SetDlgItemText(IDC_EDIT_RECORD_CURRENT_PAGE, \"\");\n\n    // Delete vector \n    for (unsigned int i =0; i < m_vecTrafficListInfo.size(); i++)\n    {\n        NET_TRAFFIC_LIST_RECORD* pTraffic = m_vecTrafficListInfo[i];\n        if (pTraffic)\n        {\n            delete pTraffic;\n            pTraffic = NULL;\n        }\n    }\n    m_vecTrafficListInfo.clear();\n}\n\nvoid CBWListDlg::OnBnClickedBtnAdd()\n{\n    CAddAndModifyBWDlg dlg;\n    int nType = m_cmbType.GetCurSel();\n    \n    if (0 == nType)  // Add whilte list\n    {\n        dlg.SetTrafficOperatorType(EM_ADD_WHITELIST);\n    }\n    else   // Add black list\n    {\n        dlg.SetTrafficOperatorType(EM_ADD_BACKLIST);\n    }\n    dlg.SetLoginHandle(m_lLoginHandle);\n    \n    if (IDOK == dlg.DoModal())\n    {\n        OnBnClickedBtnQuery();\n    }\n}\n\nvoid CBWListDlg::OnBnClickedBtnModify()\n{\n    int nSelect = m_ctrTrafficList.GetNextItem(-1,LVNI_SELECTED);\n    if (-1 == nSelect)\n    {\n        MessageBox(ConvertString(\"Please select a traffic list!\"), ConvertString(\"Prompt\"));\n        return;\n    }\n    int nCurrentIndex = (m_nCurPage-1)*SINGLE_QUERY_COUNT+nSelect;\n\n    CAddAndModifyBWDlg dlg;\n    int nType = m_cmbType.GetCurSel();\n    if (0 == nType)  // Modify white list\n    {\n        dlg.SetTrafficOperatorType(EM_MODIFY_WHITELIST);\n    }\n    else  // Modify black list\n    {\n        dlg.SetTrafficOperatorType(EM_MODIFY_BACKLIST);\n    }\n    dlg.SetLoginHandle(m_lLoginHandle);\n    dlg.SetTrafficListInfo(m_vecTrafficListInfo[nCurrentIndex]);\n\n    if ( IDOK == dlg.DoModal())\n    {\n        OnBnClickedBtnQuery();\n    }\n}\n\n\nvoid CBWListDlg::OnBnClickedBtnDelete()\n{\n    int nSelect = m_ctrTrafficList.GetNextItem(-1,LVNI_SELECTED);\n    if (-1 == nSelect)\n    {\n        MessageBox(ConvertString(\"Please select a traffic list!\"), ConvertString(\"Prompt\"));\n        return;\n    }\n\n    int nCurrentIndex = (m_nCurPage-1)*SINGLE_QUERY_COUNT+nSelect;\n\n    NET_IN_OPERATE_TRAFFIC_LIST_RECORD stInParam = { sizeof(NET_IN_OPERATE_TRAFFIC_LIST_RECORD) };\n    NET_OUT_OPERATE_TRAFFIC_LIST_RECORD stOutParam = { sizeof(NET_OUT_OPERATE_TRAFFIC_LIST_RECORD) };\n    stInParam.emOperateType = NET_TRAFFIC_LIST_REMOVE;\n    if (0 == m_cmbType.GetCurSel())\n    {\n        stInParam.emRecordType = NET_RECORD_TRAFFICREDLIST;\n    }\n    else\n    {\n        stInParam.emRecordType = NET_RECORD_TRAFFICBLACKLIST;\n    }\n    NET_REMOVE_RECORD_INFO stRemoveRecord = { sizeof(NET_REMOVE_RECORD_INFO) };\n    stRemoveRecord.nRecordNo = m_vecTrafficListInfo[nCurrentIndex]->nRecordNo;\n    stInParam.pstOpreateInfo = &stRemoveRecord;\n    \n    BOOL bRet = CLIENT_OperateTrafficList(m_lLoginHandle, &stInParam, &stOutParam, MAX_TIMEOUT);\n    if (!bRet)\n    {\n        MessageBox(ConvertString(\"Delete Traffic list failed!\"), ConvertString(\"Prompt\"));\n        return;\n    }\n    OnBnClickedBtnQuery();\n}\n\nvoid CBWListDlg::OnBnClickedBtnQuery()\n{  \n    CleanUpResultOfLastTimeQuery();\n\n    // Start query records\n    m_LFindeHandle = StartFindTrafficList();\n    if (0 ==  m_LFindeHandle)\n    {\n        return;\n    }\n\n    // Get the total count\n    m_nTotalCountOfTrafficList = GetTotalCountOfTrafficList(m_LFindeHandle);\n    if (m_nTotalCountOfTrafficList <= 0)\n    {\n        return;\n    }\n    \n    m_nCurPage = 1;\n    SetDlgItemInt(IDC_EDIT_RECORD_COUNT, m_nTotalCountOfTrafficList);\n    SetDlgItemInt(IDC_EDIT_RECORD_CURRENT_PAGE, m_nCurPage);\n\n    int nQueryCount = SINGLE_QUERY_COUNT;\n    if (m_nTotalCountOfTrafficList <= SINGLE_QUERY_COUNT)\n    {\n        nQueryCount = m_nTotalCountOfTrafficList ;\n        m_nTotalPage = 1;\n    }\n    else\n    {\n        m_btnNextPage.EnableWindow(TRUE);\n        m_nTotalPage = (int)ceil(m_nTotalCountOfTrafficList / (float)nQueryCount);\n    }\n    \n    // Do find N number of traffic list\n    if (!DoFindTrafficList(nQueryCount))\n    {\n        m_btnNextPage.EnableWindow(FALSE);\n        return;\n    }\n}\n\nvoid CBWListDlg::CleanUpResultOfLastTimeQuery()\n{\n    m_ctrTrafficList.DeleteAllItems();\n    m_nCurPage = 0;\n    m_nTotalPage = 0;\n    m_nIndexOfTrafficList = 0;\n    m_nTotalCountOfTrafficList = 0;\n    m_btnPreviousPage.EnableWindow(FALSE);\n    m_btnNextPage.EnableWindow(FALSE);\n\n    SetDlgItemText(IDC_EDIT_RECORD_COUNT, \"\");\n    SetDlgItemText(IDC_EDIT_RECORD_CURRENT_PAGE, \"\");\n\n    for (unsigned int i =0; i < m_vecTrafficListInfo.size(); i++)\n    {\n        NET_TRAFFIC_LIST_RECORD* pTraffic = m_vecTrafficListInfo[i];\n        if (pTraffic)\n        {\n            delete pTraffic;\n            pTraffic = NULL;\n        }\n    }\n    m_vecTrafficListInfo.clear();\n\n    if (0 != m_LFindeHandle)\n    {\n        // stop querying\n        CLIENT_FindRecordClose(m_LFindeHandle);\n        m_LFindeHandle = 0;\n    }\n}\n\nLLONG CBWListDlg::StartFindTrafficList()\n{\n    NET_IN_FIND_RECORD_PARAM stuFindInParam = {sizeof(NET_IN_FIND_RECORD_PARAM)};\n    NET_OUT_FIND_RECORD_PARAM stuFindOutParam = {sizeof(NET_OUT_FIND_RECORD_PARAM)};\n    if (0 == m_cmbType.GetCurSel())\n    {\n        stuFindInParam.emType = NET_RECORD_TRAFFICREDLIST;\n    }\n    else\n    {\n        stuFindInParam.emType = NET_RECORD_TRAFFICBLACKLIST;\n    }\n    FIND_RECORD_TRAFFICREDLIST_CONDITION stuRedListCondition = {sizeof(FIND_RECORD_TRAFFICREDLIST_CONDITION)};\n    CString strPlateNumber;\n    GetDlgItemText(IDC_EDIT_PLATE_NUMBER, strPlateNumber);\n    memcpy(stuRedListCondition.szPlateNumberVague, strPlateNumber.GetBuffer(), DH_MAX_PLATE_NUMBER_LEN);\n    stuFindInParam.pQueryCondition = &stuRedListCondition;\n\n    BOOL bRet = CLIENT_FindRecord(m_lLoginHandle, &stuFindInParam, &stuFindOutParam, MAX_TIMEOUT);\n    if (!bRet)\n    {\n        MessageBox(ConvertString(\"Start query record failed!\"), ConvertString(\"Prompt\"));\n        return 0;\n    }\n    return stuFindOutParam.lFindeHandle;\n}\n\nint CBWListDlg::GetTotalCountOfTrafficList(LLONG lFindeHandle)\n{\n    NET_IN_QUEYT_RECORD_COUNT_PARAM inQueryCountParam = { sizeof(NET_IN_QUEYT_RECORD_COUNT_PARAM)};\n    NET_OUT_QUEYT_RECORD_COUNT_PARAM outQueryCountParam  = { sizeof(NET_OUT_QUEYT_RECORD_COUNT_PARAM) };\n    inQueryCountParam.lFindeHandle =  lFindeHandle;\n\n    BOOL bRet = CLIENT_QueryRecordCount(&inQueryCountParam, &outQueryCountParam , MAX_TIMEOUT);\n    if (!bRet)\n    {\n        MessageBox(ConvertString(\"Query record count failed!\"), ConvertString(\"Prompt\"));\n        return -1;\n    }\n    if (outQueryCountParam.nRecordCount == 0)\n    {\n        MessageBox(ConvertString(\"Query zero!\"), ConvertString(\"Prompt\"));\n        return -1;\n    }\n    return outQueryCountParam.nRecordCount;\n}\n\nbool CBWListDlg::DoFindTrafficList( int nQueryCount )\n{\n    NET_TRAFFIC_LIST_RECORD* pRecordList = new NET_TRAFFIC_LIST_RECORD[nQueryCount];\n    memset(pRecordList, 0, sizeof(NET_TRAFFIC_LIST_RECORD) * nQueryCount);\n    for (int unIndex = 0; unIndex < nQueryCount; ++unIndex)\n    {\n        pRecordList[unIndex].dwSize = sizeof(NET_TRAFFIC_LIST_RECORD);\n        for (unsigned int unIndex2 = 0; unIndex2 < DH_MAX_AUTHORITY_LIST_NUM; ++unIndex2)\n        {\n            pRecordList[unIndex].stAuthrityTypes[unIndex2].dwSize = sizeof(NET_AUTHORITY_TYPE);\n        }\n    }\n\n    NET_IN_FIND_NEXT_RECORD_PARAM stuFindNextInParam =  {sizeof(NET_IN_FIND_NEXT_RECORD_PARAM)};\n    stuFindNextInParam.lFindeHandle = m_LFindeHandle;\n    stuFindNextInParam.nFileCount = nQueryCount;\n\n    NET_OUT_FIND_NEXT_RECORD_PARAM stuFindNextOutParam = {sizeof(NET_OUT_FIND_NEXT_RECORD_PARAM)};\n    stuFindNextOutParam.pRecordList = pRecordList;\n    stuFindNextOutParam.nMaxRecordNum = nQueryCount;\n    BOOL bRet = CLIENT_FindNextRecord(&stuFindNextInParam, &stuFindNextOutParam, MAX_TIMEOUT);\n    if (!bRet)\n    {\n        MessageBox(ConvertString(\"Query record count failed!\"), ConvertString(\"Prompt\"));\n        delete[] pRecordList;\n        return false;\n    }\n    if (0 == stuFindNextOutParam.nRetRecordNum)\n    {\n        MessageBox(ConvertString(\"Query record over!\"), ConvertString(\"Prompt\"));\n        delete[] pRecordList;\n        return false;\n    }\n\n    for (int i = 0; i < stuFindNextOutParam.nRetRecordNum; i++)\n    { \n        m_nIndexOfTrafficList++;\n        ShowTrafficList(pRecordList+i, m_nIndexOfTrafficList);\n\n        NET_TRAFFIC_LIST_RECORD* pTrafficListInfo = new NET_TRAFFIC_LIST_RECORD;\n        memcpy(pTrafficListInfo, pRecordList+i, sizeof(NET_TRAFFIC_LIST_RECORD));        \n        m_vecTrafficListInfo.push_back(pTrafficListInfo);\n    }\n    delete[] pRecordList;\n    return true;\n}\n\nvoid CBWListDlg::ShowTrafficList(NET_TRAFFIC_LIST_RECORD* pRecordList, int nCurrentIndex)\n{\n    if (NULL == pRecordList)\n    {\n        return;\n    }\n    CString strStartTime;\n    CString strEndTime;\n    CString strIndex;\n    strIndex.Format(\"%d\", nCurrentIndex);\n    strStartTime.Format(\"%04d-%02d-%02d %02d:%02d:%02d\",\n        pRecordList->stBeginTime.dwYear, pRecordList->stBeginTime.dwMonth, \n        pRecordList->stBeginTime.dwDay, pRecordList->stBeginTime.dwHour, \n        pRecordList->stBeginTime.dwMinute, pRecordList->stBeginTime.dwSecond);\n    strEndTime.Format(\"%04d-%02d-%02d %02d:%02d:%02d\",\n        pRecordList->stCancelTime.dwYear, pRecordList->stCancelTime.dwMonth, \n        pRecordList->stCancelTime.dwDay, pRecordList->stCancelTime.dwHour, \n        pRecordList->stCancelTime.dwMinute, pRecordList->stCancelTime.dwSecond);\n\n    int nCount =  m_ctrTrafficList.GetItemCount();\n    m_ctrTrafficList.InsertItem(LVIF_TEXT|LVIF_STATE,nCount,strIndex,0,LVIS_SELECTED,0,0);\n    m_ctrTrafficList.SetItemText(nCount,0, strIndex);\n    m_ctrTrafficList.SetItemText(nCount,1, pRecordList->szPlateNumber);\n    m_ctrTrafficList.SetItemText(nCount,2, pRecordList->szMasterOfCar);\n    m_ctrTrafficList.SetItemText(nCount,3, strStartTime);\n    m_ctrTrafficList.SetItemText(nCount,4, strEndTime);\n}\n\nvoid CBWListDlg::OnBnClickedBtnPreviousPage()\n{\n    if(1 >= m_nCurPage )\n    {\n        return;\n    }\n    m_ctrTrafficList.DeleteAllItems();\n    for (int i = 0; i < SINGLE_QUERY_COUNT; i++)\n    {\n        ShowTrafficList(m_vecTrafficListInfo[(m_nCurPage-2)*SINGLE_QUERY_COUNT+i], (m_nCurPage-2)*SINGLE_QUERY_COUNT+i+1);\n    }\n    m_nCurPage--;\n    SetDlgItemInt(IDC_EDIT_RECORD_CURRENT_PAGE, m_nCurPage);\n    if (m_nCurPage <= 1)\n    {\n        m_btnPreviousPage.EnableWindow(FALSE);\n    }\n    m_btnNextPage.EnableWindow(TRUE);\n}\n\nvoid CBWListDlg::OnBnClickedBtnNextPage()\n{\n    if(0 >= m_nCurPage || m_nCurPage >= m_nTotalPage)\n    {\n        return;\n    }\n    m_ctrTrafficList.DeleteAllItems();\n    if (m_vecTrafficListInfo.size() > m_nCurPage*SINGLE_QUERY_COUNT)\n    {\n        int nRemainCount = m_vecTrafficListInfo.size() - m_nCurPage*SINGLE_QUERY_COUNT;\n        int nQueryCount = nRemainCount > SINGLE_QUERY_COUNT?SINGLE_QUERY_COUNT:nRemainCount;\n        for (int i = 0; i < nQueryCount; i++)\n        {\n            ShowTrafficList(m_vecTrafficListInfo[m_nCurPage*SINGLE_QUERY_COUNT+i], m_nCurPage*SINGLE_QUERY_COUNT+i+1);\n        }\n    }\n    else\n    {\n        int nRemainCount = m_nTotalCountOfTrafficList - m_nCurPage*SINGLE_QUERY_COUNT;\n        int nQueryCount = nRemainCount > SINGLE_QUERY_COUNT?SINGLE_QUERY_COUNT:nRemainCount;\n        if (!DoFindTrafficList(nQueryCount))\n        {\n            return;\n        }\n    } \n    m_nCurPage++;\n    SetDlgItemInt(IDC_EDIT_RECORD_CURRENT_PAGE, m_nCurPage);\n    if (m_nCurPage >= m_nTotalPage)\n    {\n        m_btnNextPage.EnableWindow(FALSE);\n    }\n\n    m_btnPreviousPage.EnableWindow(TRUE);\n}\n\n\nvoid CBWListDlg::OnCbnSelchangeComboChannelTrafficList()\n{\n    CleanUpResultOfLastTimeQuery();\n}\n\n\n","size_bytes":15603},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgPSTNBreakLine.cpp":{"content":"// DlgCfgPSTNBreakLine.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"alarmdevice.h\"\n#include \"DlgCfgPSTNBreakLine.h\"\n#include \"SubDlgCfgEventHandler.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgPSTNBreakLine dialog\n\n\nCDlgCfgPSTNBreakLine::CDlgCfgPSTNBreakLine(CWnd* pParent /* = NULL */, LLONG lLoginID /* = 0 */)\n\t: CDialog(CDlgCfgPSTNBreakLine::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgPSTNBreakLine)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n    m_lLoginId = lLoginID;\n\tmemset(&m_stuInfo, 0, sizeof(CFG_PSTN_BREAK_LINE_INFO));\n}\n\n\nvoid CDlgCfgPSTNBreakLine::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgPSTNBreakLine)\n\tDDX_Control(pDX, IDC_CFGPSTNBREAKLINE_CHK_ENABLE, m_ckEnable);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgPSTNBreakLine, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgPSTNBreakLine)\n\tON_BN_CLICKED(IDC_CFGPSTNBREAKLINE_BTN_HANDLER, OnCfgPSTNBreakLineBtnHandler)\n\tON_BN_CLICKED(IDC_CFGPSTNBREAKLINE_BTN_GET, OnCfgPSTNBreakLineBtnGet)\n\tON_BN_CLICKED(IDC_CFGPSTNBREAKLINE_BTN_SET, OnCfgPSTNBreakLineBtnSet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgPSTNBreakLine private method\n\nBOOL CDlgCfgPSTNBreakLine::GetConfigFromDevice()\n{\n    char szJsonBuf[1024 * 40] = {0};\n    int nerror = 0;\n    int nSelChn = -1;\n    BOOL bRet = CLIENT_GetNewDevConfig(m_lLoginId, CFG_CMD_PSTN_BREAK_LINE, nSelChn, szJsonBuf, sizeof(szJsonBuf), &nerror, SDK_API_WAIT);\n    \n    if (bRet)\n    {\n        DWORD dwRetLen = 0;\n        bRet = CLIENT_ParseData(CFG_CMD_PSTN_BREAK_LINE, szJsonBuf, (void*)&m_stuInfo, sizeof(m_stuInfo), &dwRetLen);\n        if (!bRet)\n        {\n            MessageBox(ConvertString(CString(\"parse PSTNBreakLine error...\"), DLG_CFG_PSTNBREAKLINE), ConvertString(\"Prompt\"));\n            return FALSE;\n        }\n    }\n    else\n    {\t\t\t\n        CString csErr;\n        csErr.Format(\"%s 0x%08x\",ConvertString(\"QueryConfig PSTNBreakLine error:\", DLG_CFG_PSTNBREAKLINE), CLIENT_GetLastError());\n        MessageBox(csErr, ConvertString(\"Prompt\"));\n        return FALSE;\n    }\n    return TRUE;\n}\n\nBOOL CDlgCfgPSTNBreakLine::SetConfigToDevice()\n{\n    char szJsonBuf[1024 * 40] = {0};    \n    BOOL bRet = CLIENT_PacketData(CFG_CMD_PSTN_BREAK_LINE, &m_stuInfo, sizeof(m_stuInfo), szJsonBuf, sizeof(szJsonBuf));\n    if (!bRet)\n    {\n        MessageBox(ConvertString(CString(\"packet PSTNBreakLine error...\"), DLG_CFG_PSTNBREAKLINE), ConvertString(\"Prompt\"));\n        return FALSE;\n    } \n    else\n    {\n        int nerror = 0;\n        int nrestart = 0;\n        bRet = CLIENT_SetNewDevConfig(m_lLoginId, CFG_CMD_PSTN_BREAK_LINE, -1, szJsonBuf, sizeof(szJsonBuf), &nerror, &nrestart, SDK_API_WAIT);\n        if (!bRet)\n        {\n            CString csErr;\n            csErr.Format(\"%s 0x%08x\", ConvertString(\"SetupConfig PSTNBreakLine failed:\", DLG_CFG_PSTNBREAKLINE), CLIENT_GetLastError());\n            MessageBox(csErr, ConvertString(\"Prompt\"));\n            return FALSE;\n        }\n        else\n        {\n            MessageBox(ConvertString(CString(\"SetConfig PSTNBreakLine ok!\"), DLG_CFG_PSTNBREAKLINE), ConvertString(\"Prompt\"));\n        }\n    }\n    return TRUE;\n}\n\nBOOL CDlgCfgPSTNBreakLine::showInfo()\n{\n    m_ckEnable.SetCheck(m_stuInfo.bEnable ? BST_CHECKED : BST_UNCHECKED);\n    return TRUE;\n}\n\nBOOL CDlgCfgPSTNBreakLine::getInfo()\n{\n    m_stuInfo.bEnable = m_ckEnable.GetCheck() ? TRUE : FALSE;\n    return TRUE;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgPSTNBreakLine message handlers\n\nBOOL CDlgCfgPSTNBreakLine::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_PSTNBREAKLINE);\n    // TODO: Add extra initialization here\n    \n    if (GetConfigFromDevice())\n    {\n        showInfo();\n\t}\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgPSTNBreakLine::OnCfgPSTNBreakLineBtnHandler() \n{\n    // TODO: Add your control notification handler code here\n    CSubDlgCfgEventHandler* pdlgEventHandler = new CSubDlgCfgEventHandler;\n    if (pdlgEventHandler != NULL)\n    {\n        pdlgEventHandler->SetEventHandler(m_stuInfo.stuEventHandler);\n        \n        if (IDOK == pdlgEventHandler->DoModal())\n        {\n            const CFG_ALARM_MSG_HANDLE& stuEventHandler = pdlgEventHandler->GetEventHandler();\n            memcpy(&m_stuInfo.stuEventHandler, &stuEventHandler, sizeof(CFG_ALARM_MSG_HANDLE));\n        }\n        \n        delete pdlgEventHandler;\n        pdlgEventHandler = NULL;\n    }\n    else\n    {\n        MessageBox(ConvertString(\"new handler dialog error!\", DLG_CFG_NETABORT), ConvertString(\"Prompt\"));\n\t}\t\n}\n\nvoid CDlgCfgPSTNBreakLine::OnCfgPSTNBreakLineBtnGet() \n{\n\t// TODO: Add your control notification handler code here\n    if (GetConfigFromDevice())\n    {\n        showInfo();\n    }\n}\n\nvoid CDlgCfgPSTNBreakLine::OnCfgPSTNBreakLineBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n    getInfo();\n    SetConfigToDevice();\n}\n","size_bytes":5262},"bin/Demo/MfcDemo/22.ThermalCamera/StdAfx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n//\tThermalCamera.pch will be the pre-compiled header\n//\tstdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n\n\n\n","size_bytes":207},"bin/Demo/MfcDemo/09.AccessControl/AccessControlDlg.cpp":{"content":"// AccessControlDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AccessControl.h\"\n#include \"AccessControlDlg.h\"\n\n#include \"DlgCapability.h\"\n#include \"AlarmSubscribe.h\"\n#include \"DlgVersion.h\"\n#include \"DlgQueryLog.h\"\n#include \"DlgDeviceTime.h\"\n#include \"DlgUpgrade.h\"\n#include \"DlgDoorControl.h\"\n#include \"DlgUserManage.h\"\n#include \"DlgRecordSetControl.h\"\n#include \"RecordSetFinder.h\"\n\n#include \"DlgCfgNetwork.h\"\n#include \"DlgCfgAccessControlGeneral.h\"\n#include \"DlgCfgAccessControl.h\"\n#include \"DlgCfgTimeSchedule.h\"\n#include \"DlgCfgNTP.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n#define WM_DEVICE_DISCONNECT\t(WM_USER+200)\n#define WM_DEVICE_RECONNECT\t\t(WM_USER+201)\n\n/////////////////////////////////////////////////////////////////////////////\n// CAboutDlg dialog used for App About\n\nclass CAboutDlg : public CDialog\n{\npublic:\n\tCAboutDlg();\n\n// Dialog Data\n\t//{{AFX_DATA(CAboutDlg)\n\tenum { IDD = IDD_ABOUTBOX };\n\t//}}AFX_DATA\n\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CAboutDlg)\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n\t//}}AFX_VIRTUAL\n\n// Implementation\nprotected:\n\t//{{AFX_MSG(CAboutDlg)\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\n};\n\nCAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)\n{\n\t//{{AFX_DATA_INIT(CAboutDlg)\n\t//}}AFX_DATA_INIT\n}\n\nvoid CAboutDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CAboutDlg)\n\t//}}AFX_DATA_MAP\n}\n\nBEGIN_MESSAGE_MAP(CAboutDlg, CDialog)\n\t//{{AFX_MSG_MAP(CAboutDlg)\n\t\t// No message handlers\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CAccessControlDlg dialog\n\nCAccessControlDlg::CAccessControlDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CAccessControlDlg::IDD, pParent)\n\t, m_lLoginID(0)\n\t, m_emType(NET_PRODUCT_NONE)\n\t, m_nVideoInput(0)\n\t, m_nAlarmIn(0)\n\t, m_nAlarmOut(0)\n\t, m_nAccessGroup(0)\t\n{\n\t//{{AFX_DATA_INIT(CAccessControlDlg)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\t// Note that LoadIcon does not require a subsequent DestroyIcon in Win32\n\tm_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);\n}\n\nvoid CAccessControlDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CAccessControlDlg)\n\tDDX_Control(pDX, IDC_LIST_INFOPRINT, m_lstPrint);\n\tDDX_Control(pDX, IDC_CMB_CONTROLQUERY, m_cmbControlQueryType);\n\tDDX_Control(pDX, IDC_CMB_CONFIG, m_cmbConfig);\n\tDDX_Control(pDX, IDC_IPADDRESS, m_DvrIPAddr);\n\t//}}AFX_DATA_MAP\n}\n\nBEGIN_MESSAGE_MAP(CAccessControlDlg, CDialog)\n\t//{{AFX_MSG_MAP(CAccessControlDlg)\n\tON_WM_SYSCOMMAND()\n\tON_WM_PAINT()\n\tON_WM_QUERYDRAGICON()\n\tON_MESSAGE(WM_DEVICE_DISCONNECT, OnDisConnect)\n\tON_MESSAGE(WM_DEVICE_RECONNECT, OnReConnect)\n\tON_WM_DESTROY()\n\tON_BN_CLICKED(IDC_BTN_LOGIN, OnBtnLogin)\n\tON_BN_CLICKED(IDC_BTN_LOGOUT, OnBtnLogout)\n\tON_BN_CLICKED(IDC_BTN_CAPABILITY, OnBtnCapability)\n\tON_BN_CLICKED(IDC_BTN_SUBSCIBE, OnBtnSubscibe)\n\tON_BN_CLICKED(IDC_BTN_RECORDSET_CONTROL, OnBtnRecordsetControl)\n\tON_BN_CLICKED(IDC_BTN_RECORDSET_FIND, OnBtnRecordsetFind)\n\tON_BN_CLICKED(IDC_BTN_CONTROLQUERY, OnBtnControlQuery)\n\tON_BN_CLICKED(IDC_BTN_CONFIG, OnBtnConfig)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// private method handlers\n\nvoid CALLBACK DisConnectFunc(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser)\n{\n\tif (0 == dwUser)\n\t{\n\t\treturn;\n\t}\n\t\n\tCAccessControlDlg *pThis = (CAccessControlDlg *)dwUser;\n\tHWND hWnd = pThis->GetSafeHwnd();\n\tif (NULL == hWnd)\n\t{\n\t\treturn;\n\t}\n\tPostMessage(hWnd, WM_DEVICE_DISCONNECT, NULL, NULL);\t\n}\n\nvoid CALLBACK ReConnectFunc(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser)\n{\n\tif (0 == dwUser)\n\t{\n\t\treturn;\n\t}\n\n\tCAccessControlDlg *pThis = (CAccessControlDlg *)dwUser;\n\tHWND hWnd = pThis->GetSafeHwnd();\n\tif (NULL == hWnd)\n\t{\n\t\treturn;\n\t}\n\tPostMessage(hWnd, WM_DEVICE_RECONNECT, NULL, NULL);\t\n}\n\n\nLRESULT CAccessControlDlg::OnDisConnect(WPARAM wParam, LPARAM lParam)\n{\n\t//Add process code when device disconnected\n\tSetWindowText(ConvertString(\"Network disconnected\"));\n\treturn 0;\t\n}\n\n\nLRESULT CAccessControlDlg::OnReConnect(WPARAM wParam, LPARAM lParam)\n{\n\t//Add process code when device Reconnect\n\tSetWindowText(ConvertString(\"AccessControl\"));\n\treturn 0;\n}\n\n\nvoid CAccessControlDlg::InitDlg()\n{\n\t//Set initial IP address, port, user name, password\n\t{\n\t\tCString csIp = ConvertString(\"ip\", DEVICE_PARAM);\n\t\tif (csIp == CString(\"ip\"))\n\t\t{\n\t\t\tm_DvrIPAddr.SetWindowText(\"172.23.2.72\");\n\t\t} \n\t\telse\n\t\t{\n\t\t\tm_DvrIPAddr.SetWindowText(csIp);\n\t\t}\n\t\t\n\t\tCString csPort = ConvertString(\"port\", DEVICE_PARAM);\n\t\tif (csPort == CString(\"port\"))\n\t\t{\n\t\t\tSetDlgItemInt(IDC_EDT_PORT, 37777);\n\t\t} \n\t\telse\n\t\t{\n\t\t\tGetDlgItem(IDC_EDT_PORT)->SetWindowText(csPort);\n\t\t}\n\t\t\n\t\tCString csName = ConvertString(\"username\", DEVICE_PARAM);\n\t\tif (csName == CString(\"username\"))\n\t\t{\n\t\t\tGetDlgItem(IDC_EDT_NAME)->SetWindowText(\"system\");\n\t\t} \n\t\telse\n\t\t{\n\t\t\tGetDlgItem(IDC_EDT_NAME)->SetWindowText(csName);\n\t\t}\n\t\t\n\t\tCString csPsw = ConvertString(\"password\", DEVICE_PARAM);\n\t\tif (csPsw == CString(\"password\"))\n\t\t{\n\t\t\tGetDlgItem(IDC_EDT_PWD)->SetWindowText(\"123456\");\n\t\t} \n\t\telse\n\t\t{\n\t\t\tGetDlgItem(IDC_EDT_PWD)->SetWindowText(csPsw);\n\t\t}\n\t}\n\n\t{\n\t\tm_cmbConfig.ResetContent();\n\t\tfor (int i = 0; i < sizeof(stuDemoEmConfigType) / sizeof(stuDemoEmConfigType[0]); i++)\n\t\t{\n\t\t\tm_cmbConfig.InsertString(-1, ConvertString(stuDemoEmConfigType[i].szName, DLG_MAIN));\n\t\t}\n\t\tm_cmbConfig.SetCurSel(-1);\n\t\t\n\t\tm_cmbControlQueryType.ResetContent();\n\t\tfor (int j = 0; j < sizeof(stuDemoEmControlQueryType) / sizeof(stuDemoEmControlQueryType[0]); j++)\n\t\t{\n\t\t\tm_cmbControlQueryType.InsertString(-1, ConvertString(stuDemoEmControlQueryType[j].szName, DLG_MAIN));\n\t\t}\n\t\tm_cmbControlQueryType.SetCurSel(-1);\n\t}\n\n\tGetDlgItem(IDC_BTN_LOGOUT)->EnableWindow(FALSE);\n}\n\nBOOL CAccessControlDlg::InitNetSDK()\n{\n\tNET_PARAM stuParam = {0};\n\t\n\tCString csConnectBufSize = ConvertString(\"ConnectBufSize\", SDK_PARAM);\n\tif (csConnectBufSize == CString(\"ConnectBufSize\"))\n\t{\n\t\tstuParam.nConnectBufSize = 250 * 1024;\n\t}\n\telse\n\t{\n\t\tstuParam.nConnectBufSize = atoi(csConnectBufSize.GetBuffer(0));\n\t}\n\t\n\tCString csConnectTime = ConvertString(\"ConnectTime\", SDK_PARAM);\n\tif (csConnectTime == CString(\"ConnectTime\"))\n\t{\n\t\tstuParam.nConnectTime = 1500;\n\t} \n\telse\n\t{\n\t\tstuParam.nConnectTime = atoi(csConnectTime.GetBuffer(0));\n\t}\n\t\n\tCString csConnectTryNum = ConvertString(\"ConnetTryNum\", SDK_PARAM);\n\tif (csConnectTryNum == CString(\"ConnetTryNum\"))\n\t{\n\t\tstuParam.nConnectTryNum = 1;\n\t} \n\telse\n\t{\n\t\tstuParam.nConnectTryNum = atoi(csConnectTryNum.GetBuffer(0));\n\t}\n\t\n\tCString csGetDevInfoTime = ConvertString(\"GetDevInfoTime\", SDK_PARAM);\n\tif (csGetDevInfoTime == CString(\"GetDevInfoTime\"))\n\t{\n\t\tstuParam.nGetDevInfoTime = 5000;\n\t} \n\telse\n\t{\n\t\tstuParam.nGetDevInfoTime = atoi(csGetDevInfoTime.GetBuffer(0));\n\t}\n\t\n\tCString csWaitTime = ConvertString(\"WaitTime\", SDK_PARAM);\n\tif (csWaitTime == CString(\"WaitTime\"))\n\t{\n\t\tstuParam.nWaittime = 5000;\n\t} \n\telse\n\t{\n\t\tstuParam.nWaittime = atoi(csWaitTime.GetBuffer(0));\n\t}\n\t\n\tCLIENT_SetNetworkParam(&stuParam);\n\n\tCLIENT_Init(DisConnectFunc, (LDWORD)this);\n\tCLIENT_SetAutoReconnect(ReConnectFunc, (LDWORD)this);\n\n\treturn TRUE;\n}\n\n//Display log in failure reason \nvoid CAccessControlDlg::ShowLoginErrorReason(int nError)\n{\n\tif(1 == nError)\t\tMessageBox(ConvertString(\"Invalid password!\"), ConvertString(\"Prompt\"));\n\telse if(2 == nError)\tMessageBox(ConvertString(\"Invalid account!\"), ConvertString(\"Prompt\"));\n\telse if(3 == nError)\tMessageBox(ConvertString(\"Timeout!\"), ConvertString(\"Prompt\"));\n\telse if(4 == nError)\tMessageBox(ConvertString(\"The user has logged in!\"), ConvertString(\"Prompt\"));\n\telse if(5 == nError)\tMessageBox(ConvertString(\"The user has been locked!\"), ConvertString(\"Prompt\"));\n\telse if(6 == nError)\tMessageBox(ConvertString(\"The user has listed into illegal!\"), ConvertString(\"Prompt\"));\n\telse if(7 == nError)\tMessageBox(ConvertString(\"The system is busy!\"), ConvertString(\"Prompt\"));\n\telse if(9 == nError)\tMessageBox(ConvertString(\"You Can't find the network server!\"), ConvertString(\"Prompt\"));\n\telse\tMessageBox(ConvertString(\"Login failed!\"), ConvertString(\"Prompt\"));\n}\n\nvoid CAccessControlDlg::PrintInfo(const CString& csInfo)\n{\n\n}\n\nBOOL CAccessControlDlg::GetAccessCount(int& nCount)\n{\n    char szBuf[1024] = {0};\n    int nError = 0;\n    BOOL bRet = CLIENT_QueryNewSystemInfo(m_lLoginID, CFG_CAP_CMD_ACCESSCONTROLMANAGER, -1, szBuf, sizeof(szBuf), &nError, 3000);\n    if (bRet)\n    {\n        CFG_CAP_ACCESSCONTROL stuCap = {0};\n        DWORD dwRet = 0;\n        bRet = CLIENT_ParseData(CFG_CAP_CMD_ACCESSCONTROLMANAGER, szBuf, &stuCap, sizeof(stuCap), &dwRet);\n        if (bRet && dwRet == sizeof(CFG_CAP_ACCESSCONTROL))\n        {\n            nCount = stuCap.nAccessControlGroups;\n        }\n        else\n        {\n            return FALSE;\n        }\n    }\n    else\n    {\n        return FALSE;\n\t}\n    return TRUE;\n}\n\nvoid CAccessControlDlg::CQofVersion()\n{\n\tCDlgVersion dlg(this, m_lLoginID);\n\tdlg.DoModal();\n}\n\nvoid CAccessControlDlg::CQofReboot()\n{\n\tif (MessageBox(ConvertString(\"Are you sure to reboot?\"), ConvertString(\"Prompt\"), MB_YESNO) == IDYES)\n\t{\n\t\tBOOL bRet = CLIENT_ControlDevice(m_lLoginID, DH_CTRL_REBOOT, NULL, 3000);\n\t\tif (!bRet)\n\t\t{\n\t\t\tCString csInfo;\n\t\t\tcsInfo.Format(\"%s0x%08x\", ConvertString(\"Reboot failed:\"), CLIENT_GetLastError());\n\t\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\t}\n\t}\n}\n\nvoid CAccessControlDlg::CQofRestoreAll()\n{\n\tif (MessageBox(ConvertString(\"Are you sure to restore all?\"), ConvertString(\"Prompt\"), MB_YESNO) == IDYES)\n\t{\n\t\tBOOL bRet = CLIENT_ControlDevice(m_lLoginID, DH_CTRL_RESTOREDEFAULT, NULL, 3000);\n\t\tif (!bRet)\n\t\t{\n\t\t\tCString csInfo;\n\t\t\tcsInfo.Format(\"%s0x%08x\", ConvertString(\"Restore all failed:\"), CLIENT_GetLastError());\n\t\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\t}\n\t}\n}\n\nvoid CAccessControlDlg::CQofDoor()\n{\n\tCDlgDoorControl dlg(this, m_lLoginID);\n\tdlg.DoModal();\n}\n\nvoid CAccessControlDlg::CQofLog()\n{\n\tCDlgQueryLog dlg(this, m_lLoginID);\n\tdlg.DoModal();\n}\n\nvoid CAccessControlDlg::CQofMac()\n{\t\n\tDHDEV_NETINTERFACE_INFO stuInfo[DH_MAX_NETINTERFACE_NUM] = {0};\n\tfor (int i = 0; i < DH_MAX_NETINTERFACE_NUM; i++)\n\t{\n\t\tstuInfo[i].dwSize = sizeof(DHDEV_NETINTERFACE_INFO);\n\t}\n\tint nRet = 0;\n\tBOOL bRet = CLIENT_QueryDevState(m_lLoginID, DH_DEVSTATE_NETINTERFACE, (char*)&stuInfo, sizeof(stuInfo) * DH_MAX_NETINTERFACE_NUM, &nRet, 3000);\n\tif (bRet)\n\t{\n\t\tMessageBox(stuInfo[0].szMAC, ConvertString(\"Prompt\"));\n\t}\n\telse\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%s0x%08x\", ConvertString(\"Get Mac failed:\"), CLIENT_GetLastError());\n\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t}\n}\n\nvoid CAccessControlDlg::CQofTime()\n{\n\tCDlgDeviceTime dlg(this, m_lLoginID);\n\tdlg.DoModal();\n}\n\nvoid CAccessControlDlg::CQofUpgrade()\n{\n\tCDlgUpgrade dlg(this, m_lLoginID);\n\tdlg.DoModal();\n}\n\nvoid CAccessControlDlg::CQofModifyPwd()\n{\n\tCDlgUserManage dlg(this, m_lLoginID);\n\tdlg.DoModal();\n}\n\nvoid CAccessControlDlg::CFGofNetwork()\n{\n\tCDlgCfgNetwork dlg(this, m_lLoginID);\n\tdlg.DoModal();\n}\n\nvoid CAccessControlDlg::CFGofAccessControlGeneral()\n{\n\tCDlgCfgAccessControlGeneral dlg(this, m_lLoginID);\n\tdlg.DoModal();\n}\n\nvoid CAccessControlDlg::CFGofAccessControl()\n{\n\tCDlgCfgAccessControl dlg(this, m_lLoginID);\n\tdlg.DoModal();\n}\n\nvoid CAccessControlDlg::CFGofAccessTimeSechdule()\n{\n\tCDlgCfgTimeSchedule dlg(this, m_lLoginID);\n\tdlg.DoModal();\n}\n\nvoid CAccessControlDlg::CFGofNTP()\n{\n\tCDlgCfgNTP dlg(this, m_lLoginID);\n\tdlg.DoModal();\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CAccessControlDlg message handlers\n\nBOOL CAccessControlDlg::OnInitDialog()\n{\n\tCDialog::OnInitDialog();\n    g_SetWndStaticText(this, DLG_MAIN);\n\t// Add \"About...\" menu item to system menu.\n\n\t// IDM_ABOUTBOX must be in the system command range.\n\tASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);\n\tASSERT(IDM_ABOUTBOX < 0xF000);\n\n\tCMenu* pSysMenu = GetSystemMenu(FALSE);\n\tif (pSysMenu != NULL)\n\t{\n\t\tCString strAboutMenu;\n\t\tstrAboutMenu.LoadString(IDS_ABOUTBOX);\n\t\tif (!strAboutMenu.IsEmpty())\n\t\t{\n\t\t\tpSysMenu->AppendMenu(MF_SEPARATOR);\n\t\t\tpSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);\n\t\t}\n\t}\n\n\t// Set the icon for this dialog.  The framework does this automatically\n\t//  when the application's main window is not a dialog\n\tSetIcon(m_hIcon, TRUE);\t\t\t// Set big icon\n\tSetIcon(m_hIcon, FALSE);\t\t// Set small icon\n\t\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\tInitNetSDK();\n\t\n\treturn TRUE;  // return TRUE  unless you set the focus to a control\n}\n\nvoid CAccessControlDlg::OnSysCommand(UINT nID, LPARAM lParam)\n{\n\tif ((nID & 0xFFF0) == IDM_ABOUTBOX)\n\t{\n\t\tCAboutDlg dlgAbout;\n\t\tdlgAbout.DoModal();\n\t}\n\telse\n\t{\n\t\tCDialog::OnSysCommand(nID, lParam);\n\t}\n}\n\n// If you add a minimize button to your dialog, you will need the code below\n//  to draw the icon.  For MFC applications using the document/view model,\n//  this is automatically done for you by the framework.\n\nvoid CAccessControlDlg::OnPaint() \n{\n\tif (IsIconic())\n\t{\n\t\tCPaintDC dc(this); // device context for painting\n\n\t\tSendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);\n\n\t\t// Center icon in client rectangle\n\t\tint cxIcon = GetSystemMetrics(SM_CXICON);\n\t\tint cyIcon = GetSystemMetrics(SM_CYICON);\n\t\tCRect rect;\n\t\tGetClientRect(&rect);\n\t\tint x = (rect.Width() - cxIcon + 1) / 2;\n\t\tint y = (rect.Height() - cyIcon + 1) / 2;\n\n\t\t// Draw the icon\n\t\tdc.DrawIcon(x, y, m_hIcon);\n\t}\n\telse\n\t{\n\t\tCDialog::OnPaint();\n\t}\n}\n\n// The system calls this to obtain the cursor to display while the user drags\n//  the minimized window.\nHCURSOR CAccessControlDlg::OnQueryDragIcon()\n{\n\treturn (HCURSOR) m_hIcon;\n}\n\nBOOL CAccessControlDlg::PreTranslateMessage(MSG* pMsg) \n{\n\t// TODO: Add your specialized code here and/or call the base class\n    if (pMsg->message == WM_KEYDOWN || pMsg->message == WM_KEYUP)\n    {\n        if (VK_ESCAPE == pMsg->wParam)\n        {\n            if (MessageBox(ConvertString(\"Exit?\"), ConvertString(\"Prompt\"), MB_YESNO) != IDYES)\n            {\n                return TRUE;\n            }\n        }\n        else if (VK_RETURN == pMsg->wParam)\n        {\n            return TRUE;\n        }\n    }\n\treturn CDialog::PreTranslateMessage(pMsg);\n}\n\nvoid CAccessControlDlg::OnDestroy() \n{\n\tCDialog::OnDestroy();\n\t\n\t// TODO: Add your message handler code here\n\tOnBtnLogout();\n\tCLIENT_Cleanup();\n}\n\nvoid CAccessControlDlg::OnBtnLogin() \n{\n\t// TODO: Add your control notification handler code here\n\tCString csIp;\n\tm_DvrIPAddr.GetWindowText(csIp);\n\n\tunsigned short sPort = GetDlgItemInt(IDC_EDT_PORT, NULL, FALSE);\n\n\tCString csName;\n\tGetDlgItemText(IDC_EDT_NAME, csName);\n\n\tCString csPwd;\n\tGetDlgItemText(IDC_EDT_PWD, csPwd);\n\n\tint nErr = 0;\n    NET_DEVICEINFO_Ex stuDeviceInfo = {0};\n\n    LLONG lLoginID = CLIENT_LoginEx2(csIp.GetBuffer(0), sPort, csName.GetBuffer(0), \n                                     csPwd.GetBuffer(0), EM_LOGIN_SPEC_CAP_TCP, NULL,\n                                     &stuDeviceInfo, &nErr);\n\tif (lLoginID != NULL)\n\t{\n\t\tm_lLoginID\t= lLoginID;\n\t\tm_emType\t= (NET_DEVICE_TYPE)stuDeviceInfo.nDVRType;\n\t\tm_nAlarmIn\t= stuDeviceInfo.nAlarmInPortNum;\n\t\tm_nAlarmOut = stuDeviceInfo.nAlarmOutPortNum;\n\t\t\n\t\tGetDlgItem(IDC_IPADDRESS)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_EDT_PORT)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_EDT_NAME)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_EDT_PWD)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_BTN_LOGIN)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_BTN_LOGOUT)->EnableWindow();\n\n        GetAccessCount(m_nAccessGroup);\n\t}\n\telse\n\t{\n\t\tShowLoginErrorReason(nErr);\n\t}\n\tSetWindowText(ConvertString(\"AccessControl\"));\n}\n\nvoid CAccessControlDlg::OnBtnLogout() \n{\n\t// TODO: Add your control notification handler code here\n\tif (m_lLoginID != NULL)\n\t{\n\t\tCLIENT_Logout(m_lLoginID);\n\t\tm_lLoginID = NULL;\n\n\t\tGetDlgItem(IDC_IPADDRESS)->EnableWindow();\n\t\tGetDlgItem(IDC_EDT_PORT)->EnableWindow();\n\t\tGetDlgItem(IDC_EDT_NAME)->EnableWindow();\n\t\tGetDlgItem(IDC_EDT_PWD)->EnableWindow();\n\t\tGetDlgItem(IDC_BTN_LOGIN)->EnableWindow();\n\t\tGetDlgItem(IDC_BTN_LOGOUT)->EnableWindow(FALSE);\n\t}\n\tSetWindowText(ConvertString(\"AccessControl\"));\n}\n\nvoid CAccessControlDlg::OnBtnCapability() \n{\n\t// TODO: Add your control notification handler code here\n\tCDlgCapability dlg(this, m_lLoginID, m_nAlarmIn, m_nAlarmOut);\n\tdlg.DoModal();\n}\n\nvoid CAccessControlDlg::OnBtnSubscibe() \n{\n\t// TODO: Add your control notification handler code here\n\tAlarmSubscribe dlg(this, m_lLoginID, m_nAlarmIn, m_nAccessGroup);\n\tdlg.DoModal();\n}\n\nvoid CAccessControlDlg::OnBtnRecordsetControl() \n{\n\t// TODO: Add your control notification handler code here\n\tCDlgRecordSetControl dlg(this, m_lLoginID, m_nAccessGroup);\n\tdlg.DoModal();\n}\n\nvoid CAccessControlDlg::OnBtnRecordsetFind() \n{\n\t// TODO: Add your control notification handler code here\n\tCRecordSetFinder dlg(this, m_lLoginID, m_nAccessGroup);\n\tdlg.DoModal();\n}\n\nvoid CAccessControlDlg::OnBtnControlQuery() \n{\n\t// TODO: Add your control notification handler code here\n\tint nCurSel = m_cmbControlQueryType.GetCurSel();\n\tswitch (nCurSel)\n\t{\n\tcase EM_CONTROL_QUERY_VERSION:\n\t\tCQofVersion();\n\t\tbreak;\n\tcase EM_CONTROL_QUERY_REBOOT:\n\t\tCQofReboot();\n\t\tbreak;\n\tcase EM_CONTROL_QUERY_RESTOREALL:\n\t\tCQofRestoreAll();\n\t\tbreak;\n\tcase EM_CONTROL_QUERY_DOOR_CONTROL:\n\t\tCQofDoor();\n\t\tbreak;\n\tcase EM_CONTROL_QUERY_LOG:\n\t\tCQofLog();\n\t\tbreak;\n\tcase EM_CONTROL_QUERY_MAC:\n\t\tCQofMac();\n\t\tbreak;\n\tcase EM_CONTROL_QUERY_TIME:\n\t\tCQofTime();\n\t\tbreak;\n\tcase EM_CONTROL_QUERY_UPGRADE:\n\t\tCQofUpgrade();\n\t\tbreak;\n\tcase EM_CONTROL_QUERY_MODIFY_PWD:\n\t\tCQofModifyPwd();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid CAccessControlDlg::OnBtnConfig() \n{\n\t// TODO: Add your control notification handler code here\n\tint nCurSel = m_cmbConfig.GetCurSel();\n\tswitch (nCurSel)\n\t{\n\tcase EM_CONFIG_NETWORK:\n\t\tCFGofNetwork();\n\t\tbreak;\n\tcase EM_CONFIG_ACCESSCONTROL_GENERAL:\n\t\tCFGofAccessControlGeneral();\n\t\tbreak;\n\tcase EM_CONFIG_ACCESSCONTROL:\n\t\tCFGofAccessControl();\n\t\tbreak;\n\tcase EM_CONFIG_ACCESS_TIMESECHDULE:\n\t\tCFGofAccessTimeSechdule();\n\t\tbreak;\n\tcase EM_CONFIG_NTP:\n\t\tCFGofNTP();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n","size_bytes":18130},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgSnapLinkage.cpp":{"content":"// DlgCfgSnapLinkage.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgCfgSnapLinkage.h\"\n#include \"SubDlgSensorInfoDescription.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgSnapLinkage dialog\n\n\nCDlgCfgSnapLinkage::CDlgCfgSnapLinkage(CWnd* pParent /* = NULL */, LLONG lLoginID /* = NULL */, UINT32 uiVideoIn /* = 0 */, UINT32 uiAnalogAlarmIn /* = 72 */)\n\t: CDialog(CDlgCfgSnapLinkage::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgSnapLinkage)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n    m_lLoginID = lLoginID;\n    m_uiVideoIn = uiVideoIn;\n    m_uiAnalogAlarmIn = uiAnalogAlarmIn;\n    memset(&m_stuInfo, 0, sizeof(m_stuInfo));\n}\n\n\nvoid CDlgCfgSnapLinkage::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgSnapLinkage)\n\tDDX_Control(pDX, IDC_CFG_SNAPLINKAGE_CMB_CHN, m_cmbChn);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgSnapLinkage, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgSnapLinkage)\n\tON_CBN_SELCHANGE(IDC_CFG_SNAPLINKAGE_CMB_CHN, OnSelchangeCfgSnaplinkageCmbChn)\n\tON_BN_CLICKED(IDC_CFG_SNAPLINKAGE_BTN_CHNS, OnCfgSnaplinkageBtnChns)\n\tON_BN_CLICKED(IDC_CFG_SNAPLINKAGE_BTN_GET, OnCfgSnaplinkageBtnGet)\n\tON_BN_CLICKED(IDC_CFG_SNAPLINKAGE_BTN_SET, OnCfgSnaplinkageBtnSet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n//////////////////////////////////////////////////////////////////////////\n// Private method\n\nvoid CDlgCfgSnapLinkage::InitDlg()\n{\n    m_uiVideoIn = m_uiVideoIn <= 0 ? 4 : m_uiVideoIn;\n\n\t// channel\n\tm_cmbChn.ResetContent();\n\tfor (int i = 0; i < m_uiVideoIn; i++)\n    {\n        CString csItem;\n        csItem.Format(\"%s %02d\", ConvertString(\"Channel\"), i + 1);\n        m_cmbChn.InsertString(-1, csItem);\n    }\n\tm_cmbChn.SetCurSel(0);\n}\n\nBOOL CDlgCfgSnapLinkage::SetConfigToDevice()\n{\t\n\tint nSel = m_cmbChn.GetCurSel();\n\tif (-1 == nSel)\n\t{\n\t\treturn FALSE;\n\t}\n\tchar szJsonBuf[1024 * 40] = {0};\n\tBOOL bRet = CLIENT_PacketData(CFG_CMD_SNAPLIKAGE, &m_stuInfo, sizeof(m_stuInfo), szJsonBuf, sizeof(szJsonBuf));\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(\"packet SnapLinkage error...\", DLG_CFG_SNAPLINKAGE), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t} \n\telse\n\t{\n\t\tint nerror = 0;\n\t\tint nrestart = 0;\n\t\t\n\t\tbRet = CLIENT_SetNewDevConfig(m_lLoginID, CFG_CMD_SNAPLIKAGE, nSel, szJsonBuf, strlen(szJsonBuf), &nerror, &nrestart, SDK_API_WAIT);\n\t\tif (!bRet)\n\t\t{\n\t\t\tCString csErr;\n\t\t\tcsErr.Format(\"%s %08x\", ConvertString(\"SetupConfig SnapLinkage failed:\", DLG_CFG_SNAPLINKAGE), CLIENT_GetLastError());\n\t\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMessageBox(ConvertString(\"SetConfig SnapLinkage ok!\", DLG_CFG_SNAPLINKAGE), ConvertString(\"Prompt\"));\n\t\t}\n\t}\n\treturn TRUE;\n}\n\nBOOL CDlgCfgSnapLinkage::GetConfigFromDevice()\n{\n\tchar szJsonBuf[1024 * 40] = {0};\n\tint nerror = 0;\n\tint nSelChn = m_cmbChn.GetCurSel() == -1 ? 0 : m_cmbChn.GetCurSel();\n\tBOOL bRet = CLIENT_GetNewDevConfig(m_lLoginID, CFG_CMD_SNAPLIKAGE, nSelChn, szJsonBuf, \n\t\tsizeof(szJsonBuf), &nerror, SDK_API_WAIT);\n\t\n\tif (bRet)\n\t{\n\t\tDWORD dwRetLen = 0;\n\t\tbRet = CLIENT_ParseData(CFG_CMD_SNAPLIKAGE, szJsonBuf, (void*)&m_stuInfo, sizeof(m_stuInfo), &dwRetLen);\n\t\tif (!bRet)\n\t\t{\n\t\t\tMessageBox(ConvertString(\"parse SnapLinkage error...\", DLG_CFG_SNAPLINKAGE), ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\t\t\t\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", \n\t\t\tConvertString(\"QueryConfig SnapLinkage error:\", DLG_CFG_SNAPLINKAGE), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nvoid CDlgCfgSnapLinkage::DlgToStu()\n{\n}\n\nvoid CDlgCfgSnapLinkage::StuToDlg()\n{\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgSnapLinkage message handlers\n\nBOOL CDlgCfgSnapLinkage::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_SNAPLINKAGE);\n\t// TODO: Add extra initialization here\n\tInitDlg();\n    OnCfgSnaplinkageBtnGet();\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgSnapLinkage::OnSelchangeCfgSnaplinkageCmbChn() \n{\n    // TODO: Add your control notification handler code here\n    int nSel = m_cmbChn.GetCurSel();\n    if (-1 == nSel)\n    {\n        return;\n    }\n    if (GetConfigFromDevice())\n    {\n        StuToDlg();\n\t}\t\n}\n\nvoid CDlgCfgSnapLinkage::OnCfgSnaplinkageBtnChns() \n{\n\t// TODO: Add your control notification handler code here\n    std::vector<int> vecChn;\n    int i = 0;\n    for (; i < m_stuInfo.nChannelNum; i++)\n    {\n        vecChn.push_back(m_stuInfo.anAnalogAlarm[i]);\n    }\n    \n    CSubDlgSensorInfoDescription dlg(this, m_uiAnalogAlarmIn);\n    dlg.SetID(vecChn);\n    if (IDOK == dlg.DoModal())\n    {\n        vecChn.clear();\n        vecChn = dlg.GetID();\n        std::vector<int>::iterator it = vecChn.begin();\n        for (i = 0; i < __min(vecChn.size(), DH_MAX_ZONE_NUM) && it != vecChn.end(); i++, it++)\n        {\n            m_stuInfo.anAnalogAlarm[i] = *it;\n        }\n        m_stuInfo.nChannelNum = __min(vecChn.size(), DH_MAX_ZONE_NUM);\n\t}\n}\n\nvoid CDlgCfgSnapLinkage::OnCfgSnaplinkageBtnGet() \n{\n    // TODO: Add your control notification handler code here\n    if (GetConfigFromDevice())\n    {\n        StuToDlg();\n\t}\t\n}\n\nvoid CDlgCfgSnapLinkage::OnCfgSnaplinkageBtnSet() \n{\n    // TODO: Add your control notification handler code here\n    DlgToStu();\n\tSetConfigToDevice();\t\t\n}\n","size_bytes":5578},"bin/Demo/MfcDemo/18.IntelligentDevice/IntelligentDevice.cpp":{"content":"// IntelligentDevice.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"IntelligentDevice.h\"\n#include \"IntelligentDeviceDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\n\n// CIntelligentDeviceApp\n\nBEGIN_MESSAGE_MAP(CIntelligentDeviceApp, CWinApp)\n\tON_COMMAND(ID_HELP, &CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n\n// CIntelligentDeviceApp construction\n\nCIntelligentDeviceApp::CIntelligentDeviceApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n\n// The one and only CIntelligentDeviceApp object\n\nCIntelligentDeviceApp theApp;\n\n\n// CIntelligentDeviceApp initialization\n\nBOOL CIntelligentDeviceApp::InitInstance()\n{\n\t// InitCommonControlsEx() is required on Windows XP if an application\n\t// manifest specifies use of ComCtl32.dll version 6 or later to enable\n\t// visual styles.  Otherwise, any window creation will fail.\n\tINITCOMMONCONTROLSEX InitCtrls;\n\tInitCtrls.dwSize = sizeof(InitCtrls);\n\t// Set this to include all the common control classes you want to use\n\t// in your application.\n\tInitCtrls.dwICC = ICC_WIN95_CLASSES;\n\tInitCommonControlsEx(&InitCtrls);\n\n\tCWinApp::InitInstance();\n\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t// of your final executable, you should remove from the following\n\t// the specific initialization routines you do not need\n\t// Change the registry key under which our settings are stored\n\t// TODO: You should modify this string to be something appropriate\n\t// such as the name of your company or organization\n\tSetRegistryKey(_T(\"Local AppWizard-Generated Applications\"));\n\n\tCIntelligentDeviceDlg dlg;\n\tm_pMainWnd = &dlg;\n\tINT_PTR nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n","size_bytes":2149},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/ExceptionConfig.cpp":{"content":"// ExceptionConfig.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"ExceptionConfig.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CExceptionConfig dialog\n\n\nCExceptionConfig::CExceptionConfig(CWnd* pParent /*=NULL*/)\n\t: CDialog(CExceptionConfig::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CExceptionConfig)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CExceptionConfig::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CExceptionConfig)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CExceptionConfig, CDialog)\n\t//{{AFX_MSG_MAP(CExceptionConfig)\n\t\t// NOTE: the ClassWizard will add message map macros here\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CExceptionConfig message handlers\n","size_bytes":1054},"bin/DemoSrc/playsdkdemo/GetDllVersion.cpp":{"content":"// GetDllVersion.cpp: implementation of the CGetDllVersion class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"PlayDemo.h\"\n#include \"GetDllVersion.h\"\n#include <MEMORY>\n\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\n//////////////////////////////////////////////////////////////////////\n// Construction/Destruction\n//////////////////////////////////////////////////////////////////////\n\nBOOL GetDllVersion(TCHAR *pszDllName, CString& strVer)\n{\n\tDWORD dwInfoSize = GetFileVersionInfoSize(pszDllName, NULL);\n\tif(!dwInfoSize)\n\t\treturn FALSE;\n\t\n\t/* auto_ptr prevents multiple calls at time of return */\n\tstd::auto_ptr<BYTE> lpData(new BYTE[dwInfoSize]);\n\tif( !GetFileVersionInfo(pszDllName, NULL, dwInfoSize, (void*)lpData.get()) )\n\t\treturn FALSE;\n\t\n\tLPVOID\tlpInfo;\n\tUINT nInfoLen;\n\tif( !VerQueryValue(lpData.get(), _T(\"\\\\\"), &lpInfo, &nInfoLen) )\n\t\treturn FALSE;\n\t\n\tVS_FIXEDFILEINFO fileInfo = {0};\n\tif(nInfoLen!=sizeof(fileInfo))\n\t\treturn FALSE;\n\t\n\tmemcpy(&fileInfo, lpInfo, nInfoLen);\n\t\n\tstrVer.Format(_T(\"%d.%d.%d.%d\"), \n\t\t(fileInfo.dwFileVersionMS & 0xFFFF0000) >> 16,\n\t\tfileInfo.dwFileVersionMS & 0x0000FFFF,\n\t\t(fileInfo.dwFileVersionLS & 0xFFFF0000) >> 16,\n\t\tfileInfo.dwFileVersionLS & 0x0000FFFF);\n\t\n\treturn TRUE;\n}\n","size_bytes":1328},"bin/Demo/MfcDemo/00.DevInit/LibQREncode/bitstream.c":{"content":"/*\n * qrencode - QR Code encoder\n *\n * Binary sequence class.\n * Copyright (C) 2006-2011 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#if HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"bitstream.h\"\n\nBitStream *BitStream_new(void)\n{\n\tBitStream *bstream;\n\n\tbstream = (BitStream *)malloc(sizeof(BitStream));\n\tif(bstream == NULL) return NULL;\n\n\tbstream->length = 0;\n\tbstream->data = NULL;\n\n\treturn bstream;\n}\n\nstatic int BitStream_allocate(BitStream *bstream, int length)\n{\n\tunsigned char *data;\n\n\tif(bstream == NULL) {\n\t\treturn -1;\n\t}\n\n\tdata = (unsigned char *)malloc(length);\n\tif(data == NULL) {\n\t\treturn -1;\n\t}\n\n\tif(bstream->data) {\n\t\tfree(bstream->data);\n\t}\n\tbstream->length = length;\n\tbstream->data = data;\n\n\treturn 0;\n}\n\nstatic BitStream *BitStream_newFromNum(int bits, unsigned int num)\n{\n\tunsigned int mask;\n\tint i;\n\tunsigned char *p;\n\tBitStream *bstream;\n\n\tbstream = BitStream_new();\n\tif(bstream == NULL) return NULL;\n\n\tif(BitStream_allocate(bstream, bits)) {\n\t\tBitStream_free(bstream);\n\t\treturn NULL;\n\t}\n\n\tp = bstream->data;\n\tmask = 1 << (bits - 1);\n\tfor(i=0; i<bits; i++) {\n\t\tif(num & mask) {\n\t\t\t*p = 1;\n\t\t} else {\n\t\t\t*p = 0;\n\t\t}\n\t\tp++;\n\t\tmask = mask >> 1;\n\t}\n\n\treturn bstream;\n}\n\nstatic BitStream *BitStream_newFromBytes(int size, unsigned char *data)\n{\n\tunsigned char mask;\n\tint i, j;\n\tunsigned char *p;\n\tBitStream *bstream;\n\n\tbstream = BitStream_new();\n\tif(bstream == NULL) return NULL;\n\n\tif(BitStream_allocate(bstream, size * 8)) {\n\t\tBitStream_free(bstream);\n\t\treturn NULL;\n\t}\n\n\tp = bstream->data;\n\tfor(i=0; i<size; i++) {\n\t\tmask = 0x80;\n\t\tfor(j=0; j<8; j++) {\n\t\t\tif(data[i] & mask) {\n\t\t\t\t*p = 1;\n\t\t\t} else {\n\t\t\t\t*p = 0;\n\t\t\t}\n\t\t\tp++;\n\t\t\tmask = mask >> 1;\n\t\t}\n\t}\n\n\treturn bstream;\n}\n\nint BitStream_append(BitStream *bstream, BitStream *arg)\n{\n\tunsigned char *data;\n\n\tif(arg == NULL) {\n\t\treturn -1;\n\t}\n\tif(arg->length == 0) {\n\t\treturn 0;\n\t}\n\tif(bstream->length == 0) {\n\t\tif(BitStream_allocate(bstream, arg->length)) {\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(bstream->data, arg->data, arg->length);\n\t\treturn 0;\n\t}\n\n\tdata = (unsigned char *)malloc(bstream->length + arg->length);\n\tif(data == NULL) {\n\t\treturn -1;\n\t}\n\tmemcpy(data, bstream->data, bstream->length);\n\tmemcpy(data + bstream->length, arg->data, arg->length);\n\n\tfree(bstream->data);\n\tbstream->length += arg->length;\n\tbstream->data = data;\n\n\treturn 0;\n}\n\nint BitStream_appendNum(BitStream *bstream, int bits, unsigned int num)\n{\n\tBitStream *b;\n\tint ret;\n\n\tif(bits == 0) return 0;\n\n\tb = BitStream_newFromNum(bits, num);\n\tif(b == NULL) return -1;\n\n\tret = BitStream_append(bstream, b);\n\tBitStream_free(b);\n\n\treturn ret;\n}\n\nint BitStream_appendBytes(BitStream *bstream, int size, unsigned char *data)\n{\n\tBitStream *b;\n\tint ret;\n\n\tif(size == 0) return 0;\n\n\tb = BitStream_newFromBytes(size, data);\n\tif(b == NULL) return -1;\n\n\tret = BitStream_append(bstream, b);\n\tBitStream_free(b);\n\n\treturn ret;\n}\n\nunsigned char *BitStream_toByte(BitStream *bstream)\n{\n\tint i, j, size, bytes;\n\tunsigned char *data, v;\n\tunsigned char *p;\n\n\tsize = BitStream_size(bstream);\n\tif(size == 0) {\n\t\treturn NULL;\n\t}\n\tdata = (unsigned char *)malloc((size + 7) / 8);\n\tif(data == NULL) {\n\t\treturn NULL;\n\t}\n\n\tbytes = size  / 8;\n\n\tp = bstream->data;\n\tfor(i=0; i<bytes; i++) {\n\t\tv = 0;\n\t\tfor(j=0; j<8; j++) {\n\t\t\tv = v << 1;\n\t\t\tv |= *p;\n\t\t\tp++;\n\t\t}\n\t\tdata[i] = v;\n\t}\n\tif(size & 7) {\n\t\tv = 0;\n\t\tfor(j=0; j<(size & 7); j++) {\n\t\t\tv = v << 1;\n\t\t\tv |= *p;\n\t\t\tp++;\n\t\t}\n\t\tdata[bytes] = v;\n\t}\n\n\treturn data;\n}\n\nvoid BitStream_free(BitStream *bstream)\n{\n\tif(bstream != NULL) {\n\t\tfree(bstream->data);\n\t\tfree(bstream);\n\t}\n}\n","size_bytes":4310},"bin/Demo/MfcDemo/00.DevInit/SearchDevice.cpp":{"content":"// SearchDevice.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"SearchDevice.h\"\n#include \"SearchDeviceDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CSearchDeviceApp\n\nBEGIN_MESSAGE_MAP(CSearchDeviceApp, CWinApp)\n\t//{{AFX_MSG_MAP(CSearchDeviceApp)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t\t//    DO NOT EDIT what you see in these blocks of generated code!\n\t//}}AFX_MSG\n\tON_COMMAND(ID_HELP, CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CSearchDeviceApp construction\nTCHAR* g_GetIniPath(void)\n{\n\tstatic char pszIniPath[512] = {0};\n\tif( strlen(pszIniPath) == 0 )\n\t{\n\t\tchar szDirBuf[512] = {0};\n\t\tGetCurrentDirectory(512, szDirBuf);\n\t\tsprintf(pszIniPath, \"%s\\\\langchn.ini\", szDirBuf);\n\t}\n\treturn pszIniPath;\n}\n\nCString ConvertString(CString strText)\n{\n\tchar *val = new char[200];\n\tCString strIniPath,strRet;\n\t\n\tmemset(val,0,200);\n\tGetPrivateProfileString(\"String\",strText,\"\",\n\t\tval,200,g_GetIniPath());\n\tstrRet = val;\n\tif(strRet.GetLength()==0)\n\t{\n\t\t//If there is no corresponding string in ini file ,then set it to be default value.\n\t\tstrRet=strText;\n\t}\n\tdelete val;\n\treturn strRet;\n}\n//Set static text in dialogue box (English->current language)\nvoid g_SetWndStaticText(CWnd * pWnd)\n{\n\tCString strCaption,strText;\n\t\n\t//Set main window title\n\tpWnd->GetWindowText(strCaption);\n\tif(strCaption.GetLength()>0)\n\t{\n\t\tstrText=ConvertString(strCaption);\n\t\tpWnd->SetWindowText(strText);\n\t}\n\t\n\t//Set small window title \n\tCWnd * pChild=pWnd->GetWindow(GW_CHILD);\n\tCString strClassName;\n\twhile(pChild)\n\t{\n\t\t//////////////////////////////////////////////////////////////////////////\t\t\n\t\t//Added by Jackbin 2005-03-11\n\t\tstrClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n\t\tif(strClassName == \"CEdit\")\n\t\t{\n\t\t\t//Next small window \n\t\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t//////////////////////////////////////////////////////////////////////////\t\n\t\t\n\t\t//Set small window current language text \n\t\tpChild->GetWindowText(strCaption);\n\t\tstrText=ConvertString(strCaption);\n\t\tpChild->SetWindowText(strText);\n\t\t\n\t\t//Next small window \n\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t}\n}\n\nCSearchDeviceApp::CSearchDeviceApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The one and only CSearchDeviceApp object\n\nCSearchDeviceApp theApp;\n\n/////////////////////////////////////////////////////////////////////////////\n// CSearchDeviceApp initialization\n\nBOOL CSearchDeviceApp::InitInstance()\n{\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t//  of your final executable, you should remove from the following\n\t//  the specific initialization routines you do not need.\n\n#ifdef _AFXDLL\n\tEnable3dControls();\t\t\t// Call this when using MFC in a shared DLL\n#else\n\tEnable3dControlsStatic();\t// Call this when linking to MFC statically\n#endif\n\n\tCSearchDeviceDlg dlg;\n\tm_pMainWnd = &dlg;\n\tint nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n","size_bytes":3713},"bin/Demo/MfcDemo/10.AlarmDevice/DlgOptAccess.cpp":{"content":"// DlgOptAccess.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgOptAccess.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgOptAccess dialog\n\n\nCDlgOptAccess::CDlgOptAccess(CWnd* pParent /* = NULL */, LLONG hLoginID /* = 0 */)\n\t: CDialog(CDlgOptAccess::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgOptAccess)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\tm_hLoginID = hLoginID;\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CDlgOptAccess::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgOptAccess)\n\tDDX_Control(pDX, IDC_CMB_CHANNEL, m_cbChannelId);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgOptAccess, CDialog)\n\t//{{AFX_MSG_MAP(CDlgOptAccess)\n\tON_BN_CLICKED(IDC_BTN_CANCEL, OnBtnCancel)\n\tON_BN_CLICKED(IDC_BTN_OPEN, OnBtnOpen)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgOptAccess message handlers\n\nvoid CDlgOptAccess::OnBtnCancel() \n{\n\t// TODO: Add your control notification handler code here\n\tCDialog::OnCancel();\n}\n\nvoid CDlgOptAccess::OnBtnOpen() \n{\n\t// TODO: Add your control notification handler code here\n\tNET_CTRL_ACCESS_OPEN stuAccessPara = {sizeof(stuAccessPara)};\n\tstuAccessPara.nChannelID = m_cbChannelId.GetCurSel();\n\n\tBOOL bRet = CLIENT_ControlDevice(m_hLoginID, DH_CTRL_ACCESS_OPEN, &stuAccessPara, SDK_API_WAIT);\n\tif (!bRet)\n\t{\n\t\tCString csOut;\n\t\tcsOut.Format(\"%s %08x\", ConvertString(\"Open access failed.\", DLG_OPT_ACCESS), CLIENT_GetLastError());\n\t\tMessageBox(csOut, ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tMessageBox(ConvertString(\"Open access successfully.\", DLG_OPT_ACCESS), ConvertString(\"Prompt\"));\n}\n\nBOOL CDlgOptAccess::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_OPT_ACCESS);\n\t\n\tif (!m_hLoginID)\n\t{\n\t\tMessageBox(ConvertString(\"we haven't login a device yet!\", DLG_OPT_ACCESS), ConvertString(\"Prompt\"));\n\t\treturn TRUE;\n\t}\n\n\t// TODO: Add extra initialization here\n\tm_cbChannelId.InsertString(0, ConvertString(\"channel 0\", DLG_OPT_ACCESS));\n\tm_cbChannelId.InsertString(1, ConvertString(\"channel 1\", DLG_OPT_ACCESS));\n\tm_cbChannelId.InsertString(2, ConvertString(\"channel 2\", DLG_OPT_ACCESS));\n\tm_cbChannelId.InsertString(3, ConvertString(\"channel 3\", DLG_OPT_ACCESS));\n\tm_cbChannelId.InsertString(4, ConvertString(\"channel 4\", DLG_OPT_ACCESS));\n\n\tm_cbChannelId.SetCurSel(0);\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n","size_bytes":2658},"bin/Demo/MfcDemo/15.HeatMap/stdafx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n// HeatMap.pch will be the pre-compiled header\n// stdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n\n\n","size_bytes":200},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgAlarmUrgency.cpp":{"content":"// DlgCfgAlarmUrgency.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgCfgAlarmUrgency.h\"\n#include \"SubDlgCfgEventHandler.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgAlarmUrgency dialog\n\n\nCDlgCfgAlarmUrgency::CDlgCfgAlarmUrgency(CWnd* pParent /* = NULL */, LLONG lLoginId /* = 0 */)\n\t: CDialog(CDlgCfgAlarmUrgency::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgAlarmUrgency)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\tm_lLoginId = lLoginId;\n\t//}}AFX_DATA_INIT\n\tmemset(&m_stuUrgency, 0, sizeof(CFG_URGENCY_INFO));\n}\n\n\nvoid CDlgCfgAlarmUrgency::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgAlarmUrgency)\n\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\tDDX_Control(pDX, IDC_URGENCY_CHECK_ENABLE, m_ckEnable);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgAlarmUrgency, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgAlarmUrgency)\n\tON_BN_CLICKED(IDC_URGENCY_BUTTON_GET, OnUrgencyButtonGet)\n\tON_BN_CLICKED(IDC_URGENCY_BUTTON_SET, OnUrgencyButtonSet)\n\tON_BN_CLICKED(IDC_URGENCY_BUTTON_EVENTHANDLER, OnUrgencyButtonEventhandler)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgAlarmUrgency message handlers\n\nBOOL CDlgCfgAlarmUrgency::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\tg_SetWndStaticText(this, DLG_CFG_URGENCY);\n\t// TODO: Add extra initialization here\n\tif (m_lLoginId == 0)\n\t{\n\t\tMessageBox(ConvertString(CString(\"We haven't login yet!\"), DLG_CFG_URGENCY), ConvertString(\"Prompt\"));\n\t}\n\t\n\tif (GetConfigFromDevice())\n\t{\n\t\tshowInfo();\n\t\treturn TRUE;\n\t}\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nBOOL CDlgCfgAlarmUrgency::GetConfigFromDevice()\n{\n\tchar szJsonBuf[1024 * 40] = {0};\n\tint nerror = 0;\n\tint nSelChn = -1;\n\tBOOL bRet = CLIENT_GetNewDevConfig(m_lLoginId, CFG_CMD_URGENCY, nSelChn, szJsonBuf, sizeof(szJsonBuf), &nerror, SDK_API_WAIT);\n\t\n\tif (bRet)\n\t{\n\t\tDWORD dwRetLen = 0;\n\t\tbRet = CLIENT_ParseData(CFG_CMD_URGENCY, szJsonBuf, (void*)&m_stuUrgency, sizeof(m_stuUrgency), &dwRetLen);\n\t\tif (!bRet)\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"parse Urgency error...\"), DLG_CFG_URGENCY), ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\t\t\t\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"QueryConfig Urgency error:\", DLG_CFG_URGENCY), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nBOOL CDlgCfgAlarmUrgency::SetConfigToDevice()\n{\n\tchar szJsonBuf[1024 * 40] = {0};\t\n\tBOOL bRet = CLIENT_PacketData(CFG_CMD_URGENCY, &m_stuUrgency, sizeof(m_stuUrgency), szJsonBuf, sizeof(szJsonBuf));\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(CString(\"packet Urgency error...\"), DLG_CFG_URGENCY), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t} \n\telse\n\t{\n\t\tint nerror = 0;\n\t\tint nrestart = 0;\n\t\tbRet = CLIENT_SetNewDevConfig(m_lLoginId, CFG_CMD_URGENCY, -1, szJsonBuf, sizeof(szJsonBuf), &nerror, &nrestart, SDK_API_WAIT);\n\t\tif (!bRet)\n\t\t{\n\t\t\tCString csErr;\n\t\t\tcsErr.Format(\"%s %08x\", ConvertString(\"SetupConfig Urgency failed:\", DLG_CFG_URGENCY), CLIENT_GetLastError());\n\t\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"SetConfig Urgency ok!\"), DLG_CFG_URGENCY), ConvertString(\"Prompt\"));\n\t\t}\n\t}\n\treturn TRUE;\n}\n\nBOOL CDlgCfgAlarmUrgency::showInfo()\n{\n\tm_ckEnable.SetCheck(m_stuUrgency.bEnable ? BST_CHECKED : BST_UNCHECKED);\n\treturn TRUE;\n}\n\nBOOL CDlgCfgAlarmUrgency::getInfo()\n{\n\tm_stuUrgency.bEnable = m_ckEnable.GetCheck() ? TRUE : FALSE;\n\treturn TRUE;\n}\n\nvoid CDlgCfgAlarmUrgency::OnUrgencyButtonGet() \n{\n\t// TODO: Add your control notification handler code here\n\tif (GetConfigFromDevice())\n\t{\n\t\tshowInfo();\n\t}\t\n}\n\nvoid CDlgCfgAlarmUrgency::OnUrgencyButtonSet() \n{\n\t// TODO: Add your control notification handler code here\n\tgetInfo();\n\tSetConfigToDevice();\t\n}\n\nvoid CDlgCfgAlarmUrgency::OnUrgencyButtonEventhandler() \n{\n\t// TODO: Add your control notification handler code here\n\tCSubDlgCfgEventHandler* pdlgEventHandler = new CSubDlgCfgEventHandler;\n\tif (pdlgEventHandler != NULL)\n\t{\n\t\tpdlgEventHandler->SetEventHandler(m_stuUrgency.stuEventHandler);\n\t\tpdlgEventHandler->SetConfigType(emConfigType_AlarmChassisIntrusion);\n\t\t\n\t\tif (IDOK == pdlgEventHandler->DoModal())\n\t\t{\n\t\t\tconst CFG_ALARM_MSG_HANDLE& stuEventHandler = pdlgEventHandler->GetEventHandler();\n\t\t\tmemcpy(&m_stuUrgency.stuEventHandler, &stuEventHandler, sizeof(CFG_ALARM_MSG_HANDLE));\n\t\t}\n\t\t\n\t\tdelete pdlgEventHandler;\n\t\tpdlgEventHandler = NULL;\n\t}\n\telse\n\t{\n\t\tMessageBox(ConvertString(\"new handler dialog error!\", DLG_CFG_URGENCY), ConvertString(\"Prompt\"));\n\t}\n}\n","size_bytes":4880},"bin/Demo/MfcDemo/13.FaceRecognition/AddGroupDlg.cpp":{"content":"// AddGroupDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"FaceRecognition.h\"\n#include \"AddGroupDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CAddGroupDlg dialog\n\n\nCAddGroupDlg::CAddGroupDlg(const LLONG lLoginHandle, const int nOpreateType, const NET_FACERECONGNITION_GROUP_INFO *pstGroupInfo, CWnd* pParent /*=NULL*/)\n\t: CDialog(CAddGroupDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CAddGroupDlg)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\n\tm_lLoginID = lLoginHandle;\n\t//memset(m_szGroupId, 0, sizeof(m_szGroupId));\n\tm_nOpreateType = nOpreateType;\n\tmemset(&m_stuGroupInfo, 0, sizeof(m_stuGroupInfo));\n\tm_stuGroupInfo.dwSize = sizeof(m_stuGroupInfo);\n\tif (pstGroupInfo)\n\t{\n\t\tstrncpy(m_szGroupName, pstGroupInfo->szGroupName, sizeof(m_szGroupName) - 1);\n\t\tmemcpy(&m_stuGroupInfo, pstGroupInfo, sizeof(m_stuGroupInfo));\n\t}\n}\n\nBOOL CAddGroupDlg::OnInitDialog()\n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\tif (1 == m_nOpreateType) // add\n\t{\n\t\tSetWindowText(ConvertString(\"Add Face Group\"));\n\t}\n\telse if (2 == m_nOpreateType) // edit\n\t{\n\t\tSetWindowText(ConvertString(\"Modify Face Group\"));\n\t}\n\tSetDlgItemText(IDC_EDIT_ADD_GROUP_NAME,m_stuGroupInfo.szGroupName);\n\treturn TRUE;  // return TRUE  unless you set the focus to a control\n}\n\nvoid CAddGroupDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CAddGroupDlg)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CAddGroupDlg, CDialog)\n\t//{{AFX_MSG_MAP(CAddGroupDlg)\n\t//}}AFX_MSG_MAP\n\tON_BN_CLICKED(IDOK, &CAddGroupDlg::OnBnClickedOk)\nEND_MESSAGE_MAP()\n\nvoid CAddGroupDlg::OnCancel() \n{\n\tCDialog::OnCancel();\n}\n\nvoid CAddGroupDlg::OnBnClickedOk()\n{\n\tNET_IN_OPERATE_FACERECONGNITION_GROUP stuInParam = {sizeof(stuInParam)};\n\tNET_OUT_OPERATE_FACERECONGNITION_GROUP stuOutParam = {sizeof(stuOutParam)};\n\n\tNET_ADD_FACERECONGNITION_GROUP_INFO stuAddGroupInfo = {sizeof(stuAddGroupInfo)};\n\tNET_MODIFY_FACERECONGNITION_GROUP_INFO stuEditGroupInfo = {sizeof(stuEditGroupInfo)};\n\n\tCString strGroupName;\n\tGetDlgItemText(IDC_EDIT_ADD_GROUP_NAME, strGroupName);\n\tchar *pcGroupName = (LPSTR)(LPCSTR)strGroupName;\n\n\tif (m_nOpreateType == 1) // add a group\n\t{\n\t\tstuInParam.emOperateType = NET_FACERECONGNITION_GROUP_ADD;\n\t\tstuAddGroupInfo.stuGroupInfo.dwSize = sizeof(stuAddGroupInfo.stuGroupInfo);\n\t\tstuAddGroupInfo.stuGroupInfo.emFaceDBType = NET_FACE_DB_TYPE_BLACKLIST;\n\t\tstrncpy(stuAddGroupInfo.stuGroupInfo.szGroupName, pcGroupName, sizeof(stuAddGroupInfo.stuGroupInfo.szGroupName)-1);\n\t\tstuInParam.pOPerateInfo = &stuAddGroupInfo;\n\t}\n\telse if (m_nOpreateType == 2) // modify a group\n\t{\n\t\tstuInParam.emOperateType = NET_FACERECONGNITION_GROUP_MODIFY;\n\t\tstuEditGroupInfo.stuGroupInfo.dwSize = sizeof(stuEditGroupInfo.stuGroupInfo);\n\t\tstuEditGroupInfo.stuGroupInfo.emFaceDBType = NET_FACE_DB_TYPE_BLACKLIST;\n\t\tstrncpy(stuEditGroupInfo.stuGroupInfo.szGroupName, pcGroupName, sizeof(stuEditGroupInfo.stuGroupInfo.szGroupName)-1);\n\t\tstrncpy(stuEditGroupInfo.stuGroupInfo.szGroupId, m_stuGroupInfo.szGroupId, sizeof(stuEditGroupInfo.stuGroupInfo.szGroupId)-1);\n\t\tstuInParam.pOPerateInfo = &stuEditGroupInfo;\n\t}\n\n\tBOOL bRet = CLIENT_OperateFaceRecognitionGroup(m_lLoginID, &stuInParam, &stuOutParam, DEFAULT_WAIT_TIME);\n\tif (!bRet)\n\t{\n\t\tif (1 == m_nOpreateType)\n\t\t{\n\t\t\tMessageBox(ConvertString(\"Failed to add group!\"), \"\");\n\t\t}\n\t\telse if (2 == m_nOpreateType)\n\t\t{\n\t\t\tMessageBox(ConvertString(\"Failed to modify this group!\"), \"\");\n\t\t}\n\t\treturn;\n\t}\n\n\tstrncpy(m_szGroupName, stuEditGroupInfo.stuGroupInfo.szGroupName, sizeof(m_szGroupName)-1);\n\tCDialog::OnOK();\n}\n\nBOOL CAddGroupDlg::PreTranslateMessage(MSG* pMsg)\n{\n\tif(pMsg->message == WM_KEYDOWN &&\n\t\tpMsg->wParam == VK_RETURN)\n\t{\n\t\treturn TRUE;\n\t}\n\treturn CDialog::PreTranslateMessage(pMsg);\n}\n","size_bytes":3965},"bin/Demo/MfcDemo/09.AccessControl/DlgCfgAccessControlGeneral.cpp":{"content":"// DlgCfgAccessControlGeneral.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AccessControl.h\"\n#include \"DlgCfgAccessControlGeneral.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgAccessControlGeneral dialog\n\n\nCDlgCfgAccessControlGeneral::CDlgCfgAccessControlGeneral(CWnd* pParent /* = NULL */, LLONG lLoginID /* = 0 */)\n\t: CDialog(CDlgCfgAccessControlGeneral::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgAccessControlGeneral)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_lLoginID = lLoginID;\n\tmemset(&m_stuInfo, 0, sizeof(m_stuInfo));\n}\n\n\nvoid CDlgCfgAccessControlGeneral::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgAccessControlGeneral)\n\tDDX_Control(pDX, IDC_ACCESSCONTROL_GENERAL_CMB_PROPERTY, m_cmbAccessProperty);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgAccessControlGeneral, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgAccessControlGeneral)\n\tON_BN_CLICKED(IDC_ACCESSCONTROL_GENERAL_BTN_GET, OnAccesscontrolGeneralBtnGet)\n\tON_BN_CLICKED(IDC_ACCESSCONTROL_GENERAL_BTN_SET, OnAccesscontrolGeneralBtnSet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgAccessControlGeneral private method\n\nvoid CDlgCfgAccessControlGeneral::InitDlg()\n{\n    m_cmbAccessProperty.ResetContent();\n    for (int i = 0; i < sizeof(stuDemoAccessProperty)/sizeof(stuDemoAccessProperty[0]); i++)\n    {\n        m_cmbAccessProperty.InsertString(-1, ConvertString(stuDemoAccessProperty[i].szInfo, DLG_CFG_ACCESS_GENERAL));\n    }\n    m_cmbAccessProperty.SetCurSel(0);\n}\n\nBOOL CDlgCfgAccessControlGeneral::SetConfigToDevice()\n{\t\n\tchar szJsonBuf[1024 * 40] = {0};\n\tBOOL bRet = CLIENT_PacketData(CFG_CMD_ACCESS_GENERAL, &m_stuInfo, sizeof(m_stuInfo), szJsonBuf, sizeof(szJsonBuf));\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(CString(\"packet AccessControlGeneral error...\"), DLG_CFG_ACCESS_GENERAL), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t} \n\telse\n\t{\t\t\n\t\tint nerror = 0;\n\t\tint nrestart = 0;\n\t\t\n\t\tbRet = CLIENT_SetNewDevConfig((LLONG)m_lLoginID, CFG_CMD_ACCESS_GENERAL, -1, szJsonBuf, 1024*40, &nerror, &nrestart, 5000);\n\t\tif (!bRet)\n\t\t{\n\t\t\tCString csErr;\n\t\t\tcsErr.Format(\"%s %08x...\", ConvertString(\"SetupConfig AccessControlGeneral failed:\", DLG_CFG_ACCESS_GENERAL), CLIENT_GetLastError());\n\t\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"SetConfig AccessControlGeneral ok!\"), DLG_CFG_ACCESS_GENERAL), ConvertString(\"Prompt\"));\n\t\t}\n\t}\n\treturn TRUE;\n}\n\nBOOL CDlgCfgAccessControlGeneral::GetConfigFromDevice()\n{\n\tchar szJsonBuf[1024 * 40] = {0};\n\tint nerror = 0;\n\tBOOL bRet = CLIENT_GetNewDevConfig((LLONG)m_lLoginID, CFG_CMD_ACCESS_GENERAL, -1, szJsonBuf, 1024*40, &nerror, 5000);\n\t\n\tif (bRet)\n\t{\n\t\tDWORD dwRetLen = 0;\n\t\tbRet = CLIENT_ParseData(CFG_CMD_ACCESS_GENERAL, szJsonBuf, (void*)&m_stuInfo, sizeof(m_stuInfo), &dwRetLen);\n\t\tif (!bRet)\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"parse AccessControlGeneral error...\"), DLG_CFG_ACCESS_GENERAL), ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\t\t\t\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x...\\r\\n\\r\\n%s\", ConvertString(\"QueryConfig AccessControlGeneral error:\", DLG_CFG_ACCESS_GENERAL),\n\t\t\tCLIENT_GetLastError(), szJsonBuf);\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nvoid CDlgCfgAccessControlGeneral::DlgToStu()\n{\n\t// project password\n\tm_stuInfo.abProjectPassword = true;\n\tGetDlgItemText(IDC_ACCESSCONTROL_GENERAL_EDT_PROJECTPWD, m_stuInfo.szProjectPassword, sizeof(m_stuInfo.szProjectPassword) - 1);\n\n\t// access property\n\tm_stuInfo.abAccessProperty = true;\n\tm_stuInfo.emAccessProperty = (CFG_ACCESS_PROPERTY_TYPE)m_cmbAccessProperty.GetCurSel();\n}\n\nvoid CDlgCfgAccessControlGeneral::StuToDlg()\n{\n\t// project password\n\tSetDlgItemText(IDC_ACCESSCONTROL_GENERAL_EDT_PROJECTPWD, m_stuInfo.szProjectPassword);\n\n\t// access property\n\tm_cmbAccessProperty.SetCurSel((int)m_stuInfo.emAccessProperty);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgAccessControlGeneral message handlers\n\nvoid CDlgCfgAccessControlGeneral::OnAccesscontrolGeneralBtnGet() \n{\n\t// TODO: Add your control notification handler code here\n\tif (GetConfigFromDevice())\n\t{\n\t\tStuToDlg();\n\t}\n}\n\nvoid CDlgCfgAccessControlGeneral::OnAccesscontrolGeneralBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\tSetConfigToDevice();\n}\n\nBOOL CDlgCfgAccessControlGeneral::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_ACCESS_GENERAL);\n\t// TODO: Add extra initialization here\n    InitDlg();\n\tOnAccesscontrolGeneralBtnGet();\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n","size_bytes":4970},"bin/Demo/MfcDemo/14.GateDemo/Utils.cpp":{"content":"#include \"StdAfx.h\"\n#include \"Utils.h\"\n\nTCHAR* g_GetIniPath(void)\n{\n\tstatic char pszIniPath[512] = {0};\n\tif( strlen(pszIniPath) == 0 )\n\t{\n\t\tchar szDirBuf[512] = {0};\n\t\tGetCurrentDirectory(512, szDirBuf);\n\t\t_snprintf(pszIniPath, sizeof(pszIniPath), \"%s\\\\langchn.ini\", szDirBuf);\n\t}\n\treturn pszIniPath;\n}\n\nCString ConvertString(CString strText)\n{\n\tchar szVal[200] = {0};\n\tCString strIniPath,strRet;\n\n\tGetPrivateProfileString(\"String\",strText,\"\",\n\t\tszVal,200,g_GetIniPath());\n\tstrRet = szVal;\n\tif(strRet.GetLength()==0)\n\t{\n\t\t//If there is no corresponding string in ini file ,then set it to be default value.\n\t\tstrRet=strText;\n\t}\n\treturn strRet;\n}\n\nvoid g_SetWndStaticText(CWnd * pWnd)\n{\n\tCString strCaption,strText;\n\n\t//Set main widnow title \n\tpWnd->GetWindowText(strCaption);\n\tif(strCaption.GetLength()>0)\n\t{\n\t\tstrText=ConvertString(strCaption);\n\t\tpWnd->SetWindowText(strText);\n\t}\n\n\t//Set small window title \n\tCWnd * pChild=pWnd->GetWindow(GW_CHILD);\n\tCString strClassName;\n\twhile(pChild)\n\t{\n\t\t//////////////////////////////////////////////////////////////////////////\t\t\n\t\t//Added by Jackbin 2005-03-11\n\t\tstrClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n\t\tif(strClassName == \"CEdit\")\n\t\t{\n\t\t\t//The next small window \n\t\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t\t\tcontinue;\n\t\t}\n\n\t\t//////////////////////////////////////////////////////////////////////////\t\n\n\t\t//Set current language text in small window\n\t\tpChild->GetWindowText(strCaption);\n\t\tstrText=ConvertString(strCaption);\n\t\tpChild->SetWindowText(strText);\n\n\t\t//The next small window \n\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t}\n}\n\nvoid FillCWndWithDefaultColor(CWnd* cwnd) \n{\n\tif (NULL == cwnd)\n\t{\n\t\treturn;\n\t}\n\n\tCDC* cdc = cwnd->GetDC();\n\tif (NULL == cdc)\n\t{\n\t\treturn;\n\t}\n\n\tRECT rect;\n\tcwnd->GetClientRect(&rect);\n\tCBrush brush(RGB(105,105,105));\n\tcdc->FillRect(&rect, &brush);\n\tcwnd->ReleaseDC(cdc);\n}\n","size_bytes":1884},"bin/Demo/MfcDemo/10.AlarmDevice/DlgExAlarmHandler.cpp":{"content":"// DlgExAlarmHandler.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgExAlarmHandler.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgExAlarmHandler dialog\n\n\nCDlgExAlarmHandler::CDlgExAlarmHandler(CWnd* pParent /*=NULL*/)\n\t: CDialog(CDlgExAlarmHandler::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgExAlarmHandler)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tZeroMemory(m_dwExAlarmOutMask, sizeof(m_dwExAlarmOutMask));\n}\n\n\nvoid CDlgExAlarmHandler::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgExAlarmHandler)\n\tDDX_Control(pDX, IDOK, m_btnOk);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgExAlarmHandler, CDialog)\n\t//{{AFX_MSG_MAP(CDlgExAlarmHandler)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgExAlarmHandler message handlers\n\nBOOL CDlgExAlarmHandler::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\t// TODO: Add extra initialization here\n\tint i = 0, j = 0, k = 0;\n\tfor (i = 0; i < MAX_CHANNEL_COUNT*sizeof(DWORD)*8; ++i)\n\t{\n\t\tif (i%20 == 0)\n\t\t{\n\t\t\tk = 0;\n\t\t\t++j;\n\t\t}\n\t\tchar szIndex[32] = {0};\n\t\t_itoa(i + 1, szIndex, 10);\n\t\tcBtnExAlarmOut[i].Create(szIndex, WS_CHILD|WS_VISIBLE|BS_AUTOCHECKBOX|BS_DEFPUSHBUTTON, CRect(10+50*k, 30*j, 60+50*k, 30+30*j), this, 100+i);\n\t\t++k;\n\t}\n\tMoveWindow(0, 0, 1050, 130+30*j);\n\tCenterWindow();\n\tCRect cRectTemp;\n\tGetDlgItem(IDOK)->GetClientRect(cRectTemp);\n\tGetDlgItem(IDOK)->MoveWindow(350, 50+30*j, cRectTemp.Width(), cRectTemp.Height());\n\tGetDlgItem(IDCANCEL)->GetClientRect(cRectTemp);\n\tGetDlgItem(IDCANCEL)->MoveWindow(470, 50+30*j, cRectTemp.Width(), cRectTemp.Height());\n\t\n\tStuToDlg();\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t// EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgExAlarmHandler::OnOK() \n{\n\t// TODO: Add extra validation here\n\tDlgToStu();\n\tCDialog::OnOK();\n}\n\nvoid CDlgExAlarmHandler::StuToDlg()\n{\n\tfor (int i = 0; i < MAX_CHANNEL_COUNT*sizeof(DWORD)*8; i++)\n\t{\n\t\tint nRow = i / (sizeof(DWORD)*8);\n\t\tint nCol = i % (sizeof(DWORD)*8);\n\t\tif (m_dwExAlarmOutMask[nRow] & (0x1 << nCol))\n\t\t{\n\t\t\tcBtnExAlarmOut[i].SetCheck(BST_CHECKED);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcBtnExAlarmOut[i].SetCheck(BST_UNCHECKED);\n\t\t}\n\t}\n}\n\nvoid CDlgExAlarmHandler::DlgToStu()\n{\n\tZeroMemory(m_dwExAlarmOutMask, sizeof(m_dwExAlarmOutMask));\n\tfor (int i = 0; i < MAX_CHANNEL_COUNT*sizeof(DWORD)*8; i++)\n\t{\n\t\tint nRow = i / (sizeof(DWORD)*8);\n\t\tint nCol = i % (sizeof(DWORD)*8);\n\t\t\n\t\tif (BST_CHECKED == cBtnExAlarmOut[i].GetCheck())\n\t\t{\n\t\t\tm_dwExAlarmOutMask[nRow] |= 0x1 << nCol;\n\t\t}\t\n\t}\n}","size_bytes":2800},"bin/Demo/MfcDemo/00.DevInit/LibQREncode/qrinput.c":{"content":"/*\n * qrencode - QR Code encoder\n *\n * Input data chunk class\n * Copyright (C) 2006-2011 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#if HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"qrencode.h\"\n#include \"qrspec.h\"\n#include \"mqrspec.h\"\n#include \"bitstream.h\"\n#include \"qrinput.h\"\n\n/******************************************************************************\n * Utilities\n *****************************************************************************/\nint QRinput_isSplittableMode(QRencodeMode mode)\n{\n\treturn (mode >= QR_MODE_NUM && mode <= QR_MODE_KANJI);\n}\n\n/******************************************************************************\n * Entry of input data\n *****************************************************************************/\n\nstatic QRinput_List *QRinput_List_newEntry(QRencodeMode mode, int size, const unsigned char *data)\n{\n\tQRinput_List *entry;\n\n\tif(QRinput_check(mode, size, data)) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tentry = (QRinput_List *)malloc(sizeof(QRinput_List));\n\tif(entry == NULL) return NULL;\n\n\tentry->mode = mode;\n\tentry->size = size;\n\tif(size > 0) {\n\t\tentry->data = (unsigned char *)malloc(size);\n\t\tif(entry->data == NULL) {\n\t\t\tfree(entry);\n\t\t\treturn NULL;\n\t\t}\n\t\tmemcpy(entry->data, data, size);\n\t}\n\tentry->bstream = NULL;\n\tentry->next = NULL;\n\n\treturn entry;\n}\n\nstatic void QRinput_List_freeEntry(QRinput_List *entry)\n{\n\tif(entry != NULL) {\n\t\tfree(entry->data);\n\t\tBitStream_free(entry->bstream);\n\t\tfree(entry);\n\t}\n}\n\nstatic QRinput_List *QRinput_List_dup(QRinput_List *entry)\n{\n\tQRinput_List *n;\n\n\tn = (QRinput_List *)malloc(sizeof(QRinput_List));\n\tif(n == NULL) return NULL;\n\n\tn->mode = entry->mode;\n\tn->size = entry->size;\n\tn->data = (unsigned char *)malloc(n->size);\n\tif(n->data == NULL) {\n\t\tfree(n);\n\t\treturn NULL;\n\t}\n\tmemcpy(n->data, entry->data, entry->size);\n\tn->bstream = NULL;\n\tn->next = NULL;\n\n\treturn n;\n}\n\n/******************************************************************************\n * Input Data\n *****************************************************************************/\n\nQRinput *QRinput_new(void)\n{\n\treturn QRinput_new2(0, QR_ECLEVEL_L);\n}\n\nQRinput *QRinput_new2(int version, QRecLevel level)\n{\n\tQRinput *input;\n\n\tif(version < 0 || version > QRSPEC_VERSION_MAX || level > QR_ECLEVEL_H) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tinput = (QRinput *)malloc(sizeof(QRinput));\n\tif(input == NULL) return NULL;\n\n\tinput->head = NULL;\n\tinput->tail = NULL;\n\tinput->version = version;\n\tinput->level = level;\n\tinput->mqr = 0;\n\tinput->fnc1 = 0;\n\n\treturn input;\n}\n\nQRinput *QRinput_newMQR(int version, QRecLevel level)\n{\n\tQRinput *input;\n\n\tif(version <= 0 || version > MQRSPEC_VERSION_MAX) goto INVALID;\n\tif((MQRspec_getECCLength(version, level) == 0)) goto INVALID;\n\n\tinput = QRinput_new2(version, level);\n\tif(input == NULL) return NULL;\n\n\tinput->mqr = 1;\n\n\treturn input;\n\nINVALID:\n\terrno = EINVAL;\n\treturn NULL;\n}\n\nint QRinput_getVersion(QRinput *input)\n{\n\treturn input->version;\n}\n\nint QRinput_setVersion(QRinput *input, int version)\n{\n\tif(input->mqr || version < 0 || version > QRSPEC_VERSION_MAX) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tinput->version = version;\n\n\treturn 0;\n}\n\nQRecLevel QRinput_getErrorCorrectionLevel(QRinput *input)\n{\n\treturn input->level;\n}\n\nint QRinput_setErrorCorrectionLevel(QRinput *input, QRecLevel level)\n{\n\tif(input->mqr || level > QR_ECLEVEL_H) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tinput->level = level;\n\n\treturn 0;\n}\n\nint QRinput_setVersionAndErrorCorrectionLevel(QRinput *input, int version, QRecLevel level)\n{\n\tif(input->mqr) {\n\t\tif(version <= 0 || version > MQRSPEC_VERSION_MAX) goto INVALID;\n\t\tif((MQRspec_getECCLength(version, level) == 0)) goto INVALID;\n\t} else {\n\t\tif(version < 0 || version > QRSPEC_VERSION_MAX) goto INVALID;\n\t\tif(level > QR_ECLEVEL_H) goto INVALID;\n\t}\n\n\tinput->version = version;\n\tinput->level = level;\n\n\treturn 0;\n\nINVALID:\n\terrno = EINVAL;\n\treturn -1;\n}\n\nstatic void QRinput_appendEntry(QRinput *input, QRinput_List *entry)\n{\n\tif(input->tail == NULL) {\n\t\tinput->head = entry;\n\t\tinput->tail = entry;\n\t} else {\n\t\tinput->tail->next = entry;\n\t\tinput->tail = entry;\n\t}\n\tentry->next = NULL;\n}\n\nint QRinput_append(QRinput *input, QRencodeMode mode, int size, const unsigned char *data)\n{\n\tQRinput_List *entry;\n\n\tentry = QRinput_List_newEntry(mode, size, data);\n\tif(entry == NULL) {\n\t\treturn -1;\n\t}\n\n\tQRinput_appendEntry(input, entry);\n\n\treturn 0;\n}\n\n/**\n * Insert a structured-append header to the head of the input data.\n * @param input input data.\n * @param size number of structured symbols.\n * @param index index number of the symbol. (1 <= index <= size)\n * @param parity parity among input data. (NOTE: each symbol of a set of structured symbols has the same parity data)\n * @retval 0 success.\n * @retval -1 error occurred and errno is set to indeicate the error. See Execptions for the details.\n * @throw EINVAL invalid parameter.\n * @throw ENOMEM unable to allocate memory.\n */\n__STATIC int QRinput_insertStructuredAppendHeader(QRinput *input, int size, int index, unsigned char parity)\n{\n\tQRinput_List *entry;\n\tunsigned char buf[3];\n\n\tif(size > MAX_STRUCTURED_SYMBOLS) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tif(index <= 0 || index > MAX_STRUCTURED_SYMBOLS) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tbuf[0] = (unsigned char)size;\n\tbuf[1] = (unsigned char)index;\n\tbuf[2] = parity;\n\tentry = QRinput_List_newEntry(QR_MODE_STRUCTURE, 3, buf);\n\tif(entry == NULL) {\n\t\treturn -1;\n\t}\n\n\tentry->next = input->head;\n\tinput->head = entry;\n\n\treturn 0;\n}\n\nint QRinput_appendECIheader(QRinput *input, unsigned int ecinum)\n{\n\tunsigned char data[4];\n\n\tif(ecinum > 999999) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/* We manually create byte array of ecinum because\n\t (unsigned char *)&ecinum may cause bus error on some architectures, */\n\tdata[0] = ecinum & 0xff;\n\tdata[1] = (ecinum >>  8) & 0xff;\n\tdata[2] = (ecinum >> 16) & 0xff;\n\tdata[3] = (ecinum >> 24) & 0xff;\n\treturn QRinput_append(input, QR_MODE_ECI, 4, data);\n}\n\nvoid QRinput_free(QRinput *input)\n{\n\tQRinput_List *list, *next;\n\n\tif(input != NULL) {\n\t\tlist = input->head;\n\t\twhile(list != NULL) {\n\t\t\tnext = list->next;\n\t\t\tQRinput_List_freeEntry(list);\n\t\t\tlist = next;\n\t\t}\n\t\tfree(input);\n\t}\n}\n\nstatic unsigned char QRinput_calcParity(QRinput *input)\n{\n\tunsigned char parity = 0;\n\tQRinput_List *list;\n\tint i;\n\n\tlist = input->head;\n\twhile(list != NULL) {\n\t\tif(list->mode != QR_MODE_STRUCTURE) {\n\t\t\tfor(i=list->size-1; i>=0; i--) {\n\t\t\t\tparity ^= list->data[i];\n\t\t\t}\n\t\t}\n\t\tlist = list->next;\n\t}\n\n\treturn parity;\n}\n\nQRinput *QRinput_dup(QRinput *input)\n{\n\tQRinput *n;\n\tQRinput_List *list, *e;\n\n\tif(input->mqr) {\n\t\tn = QRinput_newMQR(input->version, input->level);\n\t} else {\n\t\tn = QRinput_new2(input->version, input->level);\n\t}\n\tif(n == NULL) return NULL;\n\n\tlist = input->head;\n\twhile(list != NULL) {\n\t\te = QRinput_List_dup(list);\n\t\tif(e == NULL) {\n\t\t\tQRinput_free(n);\n\t\t\treturn NULL;\n\t\t}\n\t\tQRinput_appendEntry(n, e);\n\t\tlist = list->next;\n\t}\n\n\treturn n;\n}\n\n/******************************************************************************\n * Numeric data\n *****************************************************************************/\n\n/**\n * Check the input data.\n * @param size\n * @param data\n * @return result\n */\nstatic int QRinput_checkModeNum(int size, const char *data)\n{\n\tint i;\n\n\tfor(i=0; i<size; i++) {\n\t\tif(data[i] < '0' || data[i] > '9')\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * Estimates the length of the encoded bit stream of numeric data.\n * @param size\n * @return number of bits\n */\nint QRinput_estimateBitsModeNum(int size)\n{\n\tint w;\n\tint bits;\n\n\tw = size / 3;\n\tbits = w * 10;\n\tswitch(size - w * 3) {\n\t\tcase 1:\n\t\t\tbits += 4;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbits += 7;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn bits;\n}\n\n/**\n * Convert the number data to a bit stream.\n * @param entry\n * @param mqr\n * @retval 0 success\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ENOMEM unable to allocate memory.\n */\nstatic int QRinput_encodeModeNum(QRinput_List *entry, int version, int mqr)\n{\n\tint words, i, ret;\n\tunsigned int val;\n\n\tentry->bstream = BitStream_new();\n\tif(entry->bstream == NULL) return -1;\n\n\tif(mqr) {\n\t\tif(version > 1) {\n\t\t\tret = BitStream_appendNum(entry->bstream, version - 1, MQRSPEC_MODEID_NUM);\n\t\t\tif(ret < 0) goto ABORT;\n\t\t}\n\t\tret = BitStream_appendNum(entry->bstream, MQRspec_lengthIndicator(QR_MODE_NUM, version), entry->size);\n\t\tif(ret < 0) goto ABORT;\n\t} else {\n\t\tret = BitStream_appendNum(entry->bstream, 4, QRSPEC_MODEID_NUM);\n\t\tif(ret < 0) goto ABORT;\n\t\n\t\tret = BitStream_appendNum(entry->bstream, QRspec_lengthIndicator(QR_MODE_NUM, version), entry->size);\n\t\tif(ret < 0) goto ABORT;\n\t}\n\n\twords = entry->size / 3;\n\tfor(i=0; i<words; i++) {\n\t\tval  = (entry->data[i*3  ] - '0') * 100;\n\t\tval += (entry->data[i*3+1] - '0') * 10;\n\t\tval += (entry->data[i*3+2] - '0');\n\n\t\tret = BitStream_appendNum(entry->bstream, 10, val);\n\t\tif(ret < 0) goto ABORT;\n\t}\n\n\tif(entry->size - words * 3 == 1) {\n\t\tval = entry->data[words*3] - '0';\n\t\tret = BitStream_appendNum(entry->bstream, 4, val);\n\t\tif(ret < 0) goto ABORT;\n\t} else if(entry->size - words * 3 == 2) {\n\t\tval  = (entry->data[words*3  ] - '0') * 10;\n\t\tval += (entry->data[words*3+1] - '0');\n\t\tret = BitStream_appendNum(entry->bstream, 7, val);\n\t\tif(ret < 0) goto ABORT;\n\t}\n\n\treturn 0;\nABORT:\n\tBitStream_free(entry->bstream);\n\tentry->bstream = NULL;\n\treturn -1;\n}\n\n/******************************************************************************\n * Alphabet-numeric data\n *****************************************************************************/\n\nconst signed char QRinput_anTable[128] = {\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41, 42, 43,\n\t 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 44, -1, -1, -1, -1, -1,\n\t-1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n\t25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n};\n\n/**\n * Check the input data.\n * @param size\n * @param data\n * @return result\n */\nstatic int QRinput_checkModeAn(int size, const char *data)\n{\n\tint i;\n\n\tfor(i=0; i<size; i++) {\n\t\tif(QRinput_lookAnTable(data[i]) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * Estimates the length of the encoded bit stream of alphabet-numeric data.\n * @param size\n * @return number of bits\n */\nint QRinput_estimateBitsModeAn(int size)\n{\n\tint w;\n\tint bits;\n\n\tw = size / 2;\n\tbits = w * 11;\n\tif(size & 1) {\n\t\tbits += 6;\n\t}\n\n\treturn bits;\n}\n\n/**\n * Convert the alphabet-numeric data to a bit stream.\n * @param entry\n * @param mqr\n * @retval 0 success\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ENOMEM unable to allocate memory.\n * @throw EINVAL invalid version.\n */\nstatic int QRinput_encodeModeAn(QRinput_List *entry, int version, int mqr)\n{\n\tint words, i, ret;\n\tunsigned int val;\n\n\tentry->bstream = BitStream_new();\n\tif(entry->bstream == NULL) return -1;\n\n\tif(mqr) {\n\t\tif(version < 2) {\n\t\t\terrno = EINVAL;\n\t\t\tgoto ABORT;\n\t\t}\n\t\tret = BitStream_appendNum(entry->bstream, version - 1, MQRSPEC_MODEID_AN);\n\t\tif(ret < 0) goto ABORT;\n\t\tret = BitStream_appendNum(entry->bstream, MQRspec_lengthIndicator(QR_MODE_AN, version), entry->size);\n\t\tif(ret < 0) goto ABORT;\n\t} else {\n\t\tret = BitStream_appendNum(entry->bstream, 4, QRSPEC_MODEID_AN);\n\t\tif(ret < 0) goto ABORT;\n\t\tret = BitStream_appendNum(entry->bstream, QRspec_lengthIndicator(QR_MODE_AN, version), entry->size);\n\t\tif(ret < 0) goto ABORT;\n\t}\n\n\twords = entry->size / 2;\n\tfor(i=0; i<words; i++) {\n\t\tval  = (unsigned int)QRinput_lookAnTable(entry->data[i*2  ]) * 45;\n\t\tval += (unsigned int)QRinput_lookAnTable(entry->data[i*2+1]);\n\n\t\tret = BitStream_appendNum(entry->bstream, 11, val);\n\t\tif(ret < 0) goto ABORT;\n\t}\n\n\tif(entry->size & 1) {\n\t\tval = (unsigned int)QRinput_lookAnTable(entry->data[words * 2]);\n\n\t\tret = BitStream_appendNum(entry->bstream, 6, val);\n\t\tif(ret < 0) goto ABORT;\n\t}\n\n\treturn 0;\nABORT:\n\tBitStream_free(entry->bstream);\n\tentry->bstream = NULL;\n\treturn -1;\n}\n\n/******************************************************************************\n * 8 bit data\n *****************************************************************************/\n\n/**\n * Estimates the length of the encoded bit stream of 8 bit data.\n * @param size\n * @return number of bits\n */\nint QRinput_estimateBitsMode8(int size)\n{\n\treturn size * 8;\n}\n\n/**\n * Convert the 8bits data to a bit stream.\n * @param entry\n * @param mqr\n * @retval 0 success\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ENOMEM unable to allocate memory.\n */\nstatic int QRinput_encodeMode8(QRinput_List *entry, int version, int mqr)\n{\n\tint ret;\n\n\tentry->bstream = BitStream_new();\n\tif(entry->bstream == NULL) return -1;\n\n\tif(mqr) {\n\t\tif(version < 3) {\n\t\t\terrno = EINVAL;\n\t\t\tgoto ABORT;\n\t\t}\n\t\tret = BitStream_appendNum(entry->bstream, version - 1, MQRSPEC_MODEID_8);\n\t\tif(ret < 0) goto ABORT;\n\t\tret = BitStream_appendNum(entry->bstream, MQRspec_lengthIndicator(QR_MODE_8, version), entry->size);\n\t\tif(ret < 0) goto ABORT;\n\t} else {\n\t\tret = BitStream_appendNum(entry->bstream, 4, QRSPEC_MODEID_8);\n\t\tif(ret < 0) goto ABORT;\n\t\tret = BitStream_appendNum(entry->bstream, QRspec_lengthIndicator(QR_MODE_8, version), entry->size);\n\t\tif(ret < 0) goto ABORT;\n\t}\n\n\tret = BitStream_appendBytes(entry->bstream, entry->size, entry->data);\n\tif(ret < 0) goto ABORT;\n\n\treturn 0;\nABORT:\n\tBitStream_free(entry->bstream);\n\tentry->bstream = NULL;\n\treturn -1;\n}\n\n\n/******************************************************************************\n * Kanji data\n *****************************************************************************/\n\n/**\n * Estimates the length of the encoded bit stream of kanji data.\n * @param size\n * @return number of bits\n */\nint QRinput_estimateBitsModeKanji(int size)\n{\n\treturn (size / 2) * 13;\n}\n\n/**\n * Check the input data.\n * @param size\n * @param data\n * @return result\n */\nstatic int QRinput_checkModeKanji(int size, const unsigned char *data)\n{\n\tint i;\n\tunsigned int val;\n\n\tif(size & 1)\n\t\treturn -1;\n\n\tfor(i=0; i<size; i+=2) {\n\t\tval = ((unsigned int)data[i] << 8) | data[i+1];\n\t\tif(val < 0x8140 || (val > 0x9ffc && val < 0xe040) || val > 0xebbf) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * Convert the kanji data to a bit stream.\n * @param entry\n * @param mqr\n * @retval 0 success\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ENOMEM unable to allocate memory.\n * @throw EINVAL invalid version.\n */\nstatic int QRinput_encodeModeKanji(QRinput_List *entry, int version, int mqr)\n{\n\tint ret, i;\n\tunsigned int val, h;\n\n\tentry->bstream = BitStream_new();\n\tif(entry->bstream == NULL) return -1;\n\n\tif(mqr) {\n\t\tif(version < 2) {\n\t\t\terrno = EINVAL;\n\t\t\tgoto ABORT;\n\t\t}\n\t\tret = BitStream_appendNum(entry->bstream, version - 1, MQRSPEC_MODEID_KANJI);\n\t\tif(ret < 0) goto ABORT;\n\t\tret = BitStream_appendNum(entry->bstream, MQRspec_lengthIndicator(QR_MODE_KANJI, version), entry->size/2);\n\t\tif(ret < 0) goto ABORT;\n\t} else {\n\t\tret = BitStream_appendNum(entry->bstream, 4, QRSPEC_MODEID_KANJI);\n\t\tif(ret < 0) goto ABORT;\n\t\tret = BitStream_appendNum(entry->bstream, QRspec_lengthIndicator(QR_MODE_KANJI, version), entry->size/2);\n\t\tif(ret < 0) goto ABORT;\n\t}\n\n\tfor(i=0; i<entry->size; i+=2) {\n\t\tval = ((unsigned int)entry->data[i] << 8) | entry->data[i+1];\n\t\tif(val <= 0x9ffc) {\n\t\t\tval -= 0x8140;\n\t\t} else {\n\t\t\tval -= 0xc140;\n\t\t}\n\t\th = (val >> 8) * 0xc0;\n\t\tval = (val & 0xff) + h;\n\n\t\tret = BitStream_appendNum(entry->bstream, 13, val);\n\t\tif(ret < 0) goto ABORT;\n\t}\n\n\treturn 0;\nABORT:\n\tBitStream_free(entry->bstream);\n\tentry->bstream = NULL;\n\treturn -1;\n}\n\n/******************************************************************************\n * Structured Symbol\n *****************************************************************************/\n\n/**\n * Convert a structure symbol code to a bit stream.\n * @param entry\n * @param mqr\n * @retval 0 success\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ENOMEM unable to allocate memory.\n * @throw EINVAL invalid entry.\n */\nstatic int QRinput_encodeModeStructure(QRinput_List *entry, int mqr)\n{\n\tint ret;\n\n\tif(mqr) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tentry->bstream = BitStream_new();\n\tif(entry->bstream == NULL) return -1;\n\n\tret = BitStream_appendNum(entry->bstream, 4, QRSPEC_MODEID_STRUCTURE);\n\tif(ret < 0) goto ABORT;\n\tret = BitStream_appendNum(entry->bstream, 4, entry->data[1] - 1);\n\tif(ret < 0) goto ABORT;\n\tret = BitStream_appendNum(entry->bstream, 4, entry->data[0] - 1);\n\tif(ret < 0) goto ABORT;\n\tret = BitStream_appendNum(entry->bstream, 8, entry->data[2]);\n\tif(ret < 0) goto ABORT;\n\n\treturn 0;\nABORT:\n\tBitStream_free(entry->bstream);\n\tentry->bstream = NULL;\n\treturn -1;\n}\n\n/******************************************************************************\n * FNC1\n *****************************************************************************/\n\nstatic int QRinput_checkModeFNC1Second(int size, const unsigned char *data)\n{\n\tif(size != 1) return -1;\n\n\treturn 0;\n}\n\nstatic int QRinput_encodeModeFNC1Second(QRinput_List *entry, int version)\n{\n\tint ret;\n\n\tentry->bstream = BitStream_new();\n\tif(entry->bstream == NULL) return -1;\n\n\tret = BitStream_appendNum(entry->bstream, 4, QRSPEC_MODEID_FNC1SECOND);\n\tif(ret < 0) goto ABORT;\n\t\n\tret = BitStream_appendBytes(entry->bstream, 1, entry->data);\n\tif(ret < 0) goto ABORT;\n\n\treturn 0;\nABORT:\n\tBitStream_free(entry->bstream);\n\tentry->bstream = NULL;\n\treturn -1;\n}\n\n/******************************************************************************\n * ECI header\n *****************************************************************************/\nstatic unsigned int QRinput_decodeECIfromByteArray(unsigned char *data)\n{\n\tint i;\n\tunsigned int ecinum;\n\n\tecinum = 0;\n\tfor(i=0; i<4; i++) {\n\t\tecinum = ecinum << 8;\n\t\tecinum |= data[3-i];\n\t}\n\n\treturn ecinum;\n}\n\nint QRinput_estimateBitsModeECI(unsigned char *data)\n{\n\tunsigned int ecinum;\n\n\tecinum = QRinput_decodeECIfromByteArray(data);;\n\n\t/* See Table 4 of JISX 0510:2004 pp.17. */\n\tif(ecinum < 128) {\n\t\treturn MODE_INDICATOR_SIZE + 8;\n\t} else if(ecinum < 16384) {\n\t\treturn MODE_INDICATOR_SIZE + 16;\n\t} else {\n\t\treturn MODE_INDICATOR_SIZE + 24;\n\t}\n}\n\nstatic int QRinput_encodeModeECI(QRinput_List *entry, int version)\n{\n\tint ret, words;\n\tunsigned int ecinum, code;\n\n\tentry->bstream = BitStream_new();\n\tif(entry->bstream == NULL) return -1;\n\n\tecinum = QRinput_decodeECIfromByteArray(entry->data);;\n\n\t/* See Table 4 of JISX 0510:2004 pp.17. */\n\tif(ecinum < 128) {\n\t\twords = 1;\n\t\tcode = ecinum;\n\t} else if(ecinum < 16384) {\n\t\twords = 2;\n\t\tcode = 0x8000 + ecinum;\n\t} else {\n\t\twords = 3;\n\t\tcode = 0xc0000 + ecinum;\n\t}\n\n\tret = BitStream_appendNum(entry->bstream, 4, QRSPEC_MODEID_ECI);\n\tif(ret < 0) goto ABORT;\n\t\n\tret = BitStream_appendNum(entry->bstream, words * 8, code);\n\tif(ret < 0) goto ABORT;\n\n\treturn 0;\nABORT:\n\tBitStream_free(entry->bstream);\n\tentry->bstream = NULL;\n\treturn -1;\n}\n\n/******************************************************************************\n * Validation\n *****************************************************************************/\n\nint QRinput_check(QRencodeMode mode, int size, const unsigned char *data)\n{\n\tif((mode == QR_MODE_FNC1FIRST && size < 0) || size <= 0) return -1;\n\n\tswitch(mode) {\n\t\tcase QR_MODE_NUM:\n\t\t\treturn QRinput_checkModeNum(size, (const char *)data);\n\t\tcase QR_MODE_AN:\n\t\t\treturn QRinput_checkModeAn(size, (const char *)data);\n\t\tcase QR_MODE_KANJI:\n\t\t\treturn QRinput_checkModeKanji(size, data);\n\t\tcase QR_MODE_8:\n\t\t\treturn 0;\n\t\tcase QR_MODE_STRUCTURE:\n\t\t\treturn 0;\n\t\tcase QR_MODE_ECI:\n\t\t\treturn 0;\n\t\tcase QR_MODE_FNC1FIRST:\n\t\t\treturn 0;\n\t\tcase QR_MODE_FNC1SECOND:\n\t\t\treturn QRinput_checkModeFNC1Second(size, data);\n\t\tcase QR_MODE_NUL:\n\t\t\tbreak;\n\t}\n\n\treturn -1;\n}\n\n/******************************************************************************\n * Estimation of the bit length\n *****************************************************************************/\n\n/**\n * Estimates the length of the encoded bit stream on the current version.\n * @param entry\n * @param version version of the symbol\n * @param mqr\n * @return number of bits\n */\nstatic int QRinput_estimateBitStreamSizeOfEntry(QRinput_List *entry, int version, int mqr)\n{\n\tint bits = 0;\n\tint l, m;\n\tint num;\n\n\tif(version == 0) version = 1;\n\n\tswitch(entry->mode) {\n\t\tcase QR_MODE_NUM:\n\t\t\tbits = QRinput_estimateBitsModeNum(entry->size);\n\t\t\tbreak;\n\t\tcase QR_MODE_AN:\n\t\t\tbits = QRinput_estimateBitsModeAn(entry->size);\n\t\t\tbreak;\n\t\tcase QR_MODE_8:\n\t\t\tbits = QRinput_estimateBitsMode8(entry->size);\n\t\t\tbreak;\n\t\tcase QR_MODE_KANJI:\n\t\t\tbits = QRinput_estimateBitsModeKanji(entry->size);\n\t\t\tbreak;\n\t\tcase QR_MODE_STRUCTURE:\n\t\t\treturn STRUCTURE_HEADER_SIZE;\n\t\tcase QR_MODE_ECI:\n\t\t\tbits = QRinput_estimateBitsModeECI(entry->data);\n\t\t\tbreak;\n\t\tcase QR_MODE_FNC1FIRST:\n\t\t\treturn MODE_INDICATOR_SIZE;\n\t\t\tbreak;\n\t\tcase QR_MODE_FNC1SECOND:\n\t\t\treturn MODE_INDICATOR_SIZE + 8;\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n\n\tif(mqr) {\n\t\tl = QRspec_lengthIndicator(entry->mode, version);\n\t\tm = version - 1;\n\t\tbits += l + m;\n\t} else {\n\t\tl = QRspec_lengthIndicator(entry->mode, version);\n\t\tm = 1 << l;\n\t\tnum = (entry->size + m - 1) / m;\n\n\t\tbits += num * (MODE_INDICATOR_SIZE + l);\n\t}\n\n\treturn bits;\n}\n\n/**\n * Estimates the length of the encoded bit stream of the data.\n * @param input input data\n * @param version version of the symbol\n * @return number of bits\n */\n__STATIC int QRinput_estimateBitStreamSize(QRinput *input, int version)\n{\n\tQRinput_List *list;\n\tint bits = 0;\n\n\tlist = input->head;\n\twhile(list != NULL) {\n\t\tbits += QRinput_estimateBitStreamSizeOfEntry(list, version, input->mqr);\n\t\tlist = list->next;\n\t}\n\n\treturn bits;\n}\n\n/**\n * Estimates the required version number of the symbol.\n * @param input input data\n * @return required version number\n */\nstatic int QRinput_estimateVersion(QRinput *input)\n{\n\tint bits;\n\tint version, prev;\n\n\tversion = 0;\n\tdo {\n\t\tprev = version;\n\t\tbits = QRinput_estimateBitStreamSize(input, prev);\n\t\tversion = QRspec_getMinimumVersion((bits + 7) / 8, input->level);\n\t\tif (version < 0) {\n\t\t\treturn -1;\n\t\t}\n\t} while (version > prev);\n\n\treturn version;\n}\n\n/**\n * Returns required length in bytes for specified mode, version and bits.\n * @param mode\n * @param version\n * @param bits\n * @return required length of code words in bytes.\n */\n__STATIC int QRinput_lengthOfCode(QRencodeMode mode, int version, int bits)\n{\n\tint payload, size, chunks, remain, maxsize;\n\n\tpayload = bits - 4 - QRspec_lengthIndicator(mode, version);\n\tswitch(mode) {\n\t\tcase QR_MODE_NUM:\n\t\t\tchunks = payload / 10;\n\t\t\tremain = payload - chunks * 10;\n\t\t\tsize = chunks * 3;\n\t\t\tif(remain >= 7) {\n\t\t\t\tsize += 2;\n\t\t\t} else if(remain >= 4) {\n\t\t\t\tsize += 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QR_MODE_AN:\n\t\t\tchunks = payload / 11;\n\t\t\tremain = payload - chunks * 11;\n\t\t\tsize = chunks * 2;\n\t\t\tif(remain >= 6) size++;\n\t\t\tbreak;\n\t\tcase QR_MODE_8:\n\t\t\tsize = payload / 8;\n\t\t\tbreak;\n\t\tcase QR_MODE_KANJI:\n\t\t\tsize = (payload / 13) * 2;\n\t\t\tbreak;\n\t\tcase QR_MODE_STRUCTURE:\n\t\t\tsize = payload / 8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t}\n\tmaxsize = QRspec_maximumWords(mode, version);\n\tif(size < 0) size = 0;\n\tif(maxsize > 0 && size > maxsize) size = maxsize;\n\n\treturn size;\n}\n\n/******************************************************************************\n * Data conversion\n *****************************************************************************/\n\n/**\n * Convert the input data in the data chunk to a bit stream.\n * @param entry\n * @return number of bits (>0) or -1 for failure.\n */\nstatic int QRinput_encodeBitStream(QRinput_List *entry, int version, int mqr)\n{\n\tint words, ret;\n\tQRinput_List *st1 = NULL, *st2 = NULL;\n\n\tif(entry->bstream != NULL) {\n\t\tBitStream_free(entry->bstream);\n\t\tentry->bstream = NULL;\n\t}\n\n\twords = QRspec_maximumWords(entry->mode, version);\n\tif(words != 0 && entry->size > words) {\n\t\tst1 = QRinput_List_newEntry(entry->mode, words, entry->data);\n\t\tif(st1 == NULL) goto ABORT;\n\t\tst2 = QRinput_List_newEntry(entry->mode, entry->size - words, &entry->data[words]);\n\t\tif(st2 == NULL) goto ABORT;\n\n\t\tret = QRinput_encodeBitStream(st1, version, mqr);\n\t\tif(ret < 0) goto ABORT;\n\t\tret = QRinput_encodeBitStream(st2, version, mqr);\n\t\tif(ret < 0) goto ABORT;\n\t\tentry->bstream = BitStream_new();\n\t\tif(entry->bstream == NULL) goto ABORT;\n\t\tret = BitStream_append(entry->bstream, st1->bstream);\n\t\tif(ret < 0) goto ABORT;\n\t\tret = BitStream_append(entry->bstream, st2->bstream);\n\t\tif(ret < 0) goto ABORT;\n\t\tQRinput_List_freeEntry(st1);\n\t\tQRinput_List_freeEntry(st2);\n\t} else {\n\t\tret = 0;\n\t\tswitch(entry->mode) {\n\t\t\tcase QR_MODE_NUM:\n\t\t\t\tret = QRinput_encodeModeNum(entry, version, mqr);\n\t\t\t\tbreak;\n\t\t\tcase QR_MODE_AN:\n\t\t\t\tret = QRinput_encodeModeAn(entry, version, mqr);\n\t\t\t\tbreak;\n\t\t\tcase QR_MODE_8:\n\t\t\t\tret = QRinput_encodeMode8(entry, version, mqr);\n\t\t\t\tbreak;\n\t\t\tcase QR_MODE_KANJI:\n\t\t\t\tret = QRinput_encodeModeKanji(entry, version, mqr);\n\t\t\t\tbreak;\n\t\t\tcase QR_MODE_STRUCTURE:\n\t\t\t\tret = QRinput_encodeModeStructure(entry, mqr);\n\t\t\t\tbreak;\n\t\t\tcase QR_MODE_ECI:\n\t\t\t\tret = QRinput_encodeModeECI(entry, version);\n\t\t\t\tbreak;\n\t\t\tcase QR_MODE_FNC1SECOND:\n\t\t\t\tret = QRinput_encodeModeFNC1Second(entry, version);\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\tif(ret < 0) return -1;\n\t}\n    if (entry->bstream)\n    {\n        return BitStream_size(entry->bstream);\n    }\n    else\n    {\n        return -1;\n    }\n\t\nABORT:\n\tQRinput_List_freeEntry(st1);\n\tQRinput_List_freeEntry(st2);\n\treturn -1;\n}\n\n/**\n * Convert the input data to a bit stream.\n * @param input input data.\n * @retval 0 success\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ENOMEM unable to allocate memory.\n */\nstatic int QRinput_createBitStream(QRinput *input)\n{\n\tQRinput_List *list;\n\tint bits, total = 0;\n\n\tlist = input->head;\n\twhile(list != NULL) {\n\t\tbits = QRinput_encodeBitStream(list, input->version, input->mqr);\n\t\tif(bits < 0) return -1;\n\t\ttotal += bits;\n\t\tlist = list->next;\n\t}\n\n\treturn total;\n}\n\n/**\n * Convert the input data to a bit stream.\n * When the version number is given and that is not sufficient, it is increased\n * automatically.\n * @param input input data.\n * @retval 0 success\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ENOMEM unable to allocate memory.\n * @throw ERANGE input is too large.\n */\nstatic int QRinput_convertData(QRinput *input)\n{\n\tint bits;\n\tint ver;\n\n\tver = QRinput_estimateVersion(input);\n\tif(ver > QRinput_getVersion(input)) {\n\t\tQRinput_setVersion(input, ver);\n\t}\n\n\tfor(;;) {\n\t\tbits = QRinput_createBitStream(input);\n\t\tif(bits < 0) return -1;\n\t\tver = QRspec_getMinimumVersion((bits + 7) / 8, input->level);\n\t\tif(ver < 0) {\n\t\t\terrno = ERANGE;\n\t\t\treturn -1;\n\t\t} else if(ver > QRinput_getVersion(input)) {\n\t\t\tQRinput_setVersion(input, ver);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * Append padding bits for the input data.\n * @param bstream Bitstream to be appended.\n * @param input input data.\n * @retval 0 success\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ERANGE input data is too large.\n * @throw ENOMEM unable to allocate memory.\n */\nstatic int QRinput_appendPaddingBit(BitStream *bstream, QRinput *input)\n{\n\tint bits, maxbits, words, maxwords, i, ret;\n\tBitStream *padding = NULL;\n\tunsigned char *padbuf;\n\tint padlen;\n\n\tbits = BitStream_size(bstream);\n\tmaxwords = QRspec_getDataLength(input->version, input->level);\n\tmaxbits = maxwords * 8;\n\n\tif(maxbits < bits) {\n\t\terrno = ERANGE;\n\t\treturn -1;\n\t}\n\tif(maxbits == bits) {\n\t\treturn 0;\n\t}\n\n\tif(maxbits - bits <= 4) {\n\t\tret = BitStream_appendNum(bstream, maxbits - bits, 0);\n\t\tgoto DONE;\n\t}\n\n\twords = (bits + 4 + 7) / 8;\n\n\tpadding = BitStream_new();\n\tif(padding == NULL) return -1;\n\tret = BitStream_appendNum(padding, words * 8 - bits, 0);\n\tif(ret < 0) goto DONE;\n\n\tpadlen = maxwords - words;\n\tif(padlen > 0) {\n\t\tpadbuf = (unsigned char *)malloc(padlen);\n\t\tif(padbuf == NULL) {\n\t\t\tret = -1;\n\t\t\tgoto DONE;\n\t\t}\n\t\tfor(i=0; i<padlen; i++) {\n\t\t\tpadbuf[i] = (i&1)?0x11:0xec;\n\t\t}\n\t\tret = BitStream_appendBytes(padding, padlen, padbuf);\n\t\tfree(padbuf);\n\t\tif(ret < 0) {\n\t\t\tgoto DONE;\n\t\t}\n\t}\n\n\tret = BitStream_append(bstream, padding);\n\nDONE:\n\tBitStream_free(padding);\n\treturn ret;\n}\n\n/**\n * Append padding bits for the input data - Micro QR Code version.\n * @param bstream Bitstream to be appended.\n * @param input input data.\n * @retval 0 success\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ERANGE input data is too large.\n * @throw ENOMEM unable to allocate memory.\n */\nstatic int QRinput_appendPaddingBitMQR(BitStream *bstream, QRinput *input)\n{\n\tint bits, maxbits, words, maxwords, i, ret, termbits;\n\tBitStream *padding = NULL;\n\tunsigned char *padbuf;\n\tint padlen;\n\n\tbits = BitStream_size(bstream);\n\tmaxbits = MQRspec_getDataLengthBit(input->version, input->level);\n\tmaxwords = maxbits / 8;\n\n\tif(maxbits < bits) {\n\t\terrno = ERANGE;\n\t\treturn -1;\n\t}\n\tif(maxbits == bits) {\n\t\treturn 0;\n\t}\n\n\ttermbits = input->version * 2 + 1;\n\n\tif(maxbits - bits <= termbits) {\n\t\tret = BitStream_appendNum(bstream, maxbits - bits, 0);\n\t\tgoto DONE;\n\t}\n\n\tbits += termbits;\n\n\twords = (bits + 7) / 8;\n\tif(maxbits - words * 8 > 0) {\n\t\ttermbits += words * 8 - bits;\n\t\tif(words == maxwords) termbits += maxbits - words * 8;\n\t} else {\n\t\ttermbits += words * 8 - bits;\n\t}\n\tpadding = BitStream_new();\n\tif(padding == NULL) return -1;\n\tret = BitStream_appendNum(padding, termbits, 0);\n\tif(ret < 0) goto DONE;\n\n\tpadlen = maxwords - words;\n\tif(padlen > 0) {\n\t\tpadbuf = (unsigned char *)malloc(padlen);\n\t\tif(padbuf == NULL) {\n\t\t\tret = -1;\n\t\t\tgoto DONE;\n\t\t}\n\t\tfor(i=0; i<padlen; i++) {\n\t\t\tpadbuf[i] = (i&1)?0x11:0xec;\n\t\t}\n\t\tret = BitStream_appendBytes(padding, padlen, padbuf);\n\t\tfree(padbuf);\n\t\tif(ret < 0) {\n\t\t\tgoto DONE;\n\t\t}\n\t\ttermbits = maxbits - maxwords * 8;\n\t\tif(termbits > 0) {\n\t\t\tret = BitStream_appendNum(padding, termbits, 0);\n\t\t\tif(ret < 0) goto DONE;\n\t\t}\n\t}\n\n\tret = BitStream_append(bstream, padding);\n\nDONE:\n\tBitStream_free(padding);\n\treturn ret;\n}\n\nstatic int QRinput_insertFNC1Header(QRinput *input)\n{\n\tQRinput_List *entry = NULL;\n\n\tif(input->fnc1 == 1) {\n\t\tentry = QRinput_List_newEntry(QR_MODE_FNC1FIRST, 0, NULL);\n\t} else if(input->fnc1 == 2) {\n\t\tentry = QRinput_List_newEntry(QR_MODE_FNC1SECOND, 1, &(input->appid));\n\t}\n\tif(entry == NULL) {\n\t\treturn -1;\n\t}\n\n\tif(input->head->mode != QR_MODE_STRUCTURE && input->head->mode != QR_MODE_ECI) {\n\t\tentry->next = input->head;\n\t\tinput->head = entry;\n\t} else {\n\t\tentry->next = input->head->next;\n\t\tinput->head->next = entry;\n\t}\n\n\treturn 0;\n}\n\n/**\n * Merge all bit streams in the input data.\n * @param input input data.\n * @return merged bit stream\n */\n\n__STATIC BitStream *QRinput_mergeBitStream(QRinput *input)\n{\n\tBitStream *bstream;\n\tQRinput_List *list;\n\tint ret;\n\n\tif(input->mqr) {\n\t\tif(QRinput_createBitStream(input) < 0) {\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tif(input->fnc1) {\n\t\t\tif(QRinput_insertFNC1Header(input) < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tif(QRinput_convertData(input) < 0) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tbstream = BitStream_new();\n\tif(bstream == NULL) return NULL;\n\n\tlist = input->head;\n\twhile(list != NULL) {\n\t\tret = BitStream_append(bstream, list->bstream);\n\t\tif(ret < 0) {\n\t\t\tBitStream_free(bstream);\n\t\t\treturn NULL;\n\t\t}\n\t\tlist = list->next;\n\t}\n\n\treturn bstream;\n}\n\n/**\n * Merge all bit streams in the input data and append padding bits\n * @param input input data.\n * @return padded merged bit stream\n */\n\n__STATIC BitStream *QRinput_getBitStream(QRinput *input)\n{\n\tBitStream *bstream;\n\tint ret;\n\n\tbstream = QRinput_mergeBitStream(input);\n\tif(bstream == NULL) {\n\t\treturn NULL;\n\t}\n\tif(input->mqr) {\n\t\tret = QRinput_appendPaddingBitMQR(bstream, input);\n\t} else {\n\t\tret = QRinput_appendPaddingBit(bstream, input);\n\t}\n\tif(ret < 0) {\n\t\tBitStream_free(bstream);\n\t\treturn NULL;\n\t}\n\n\treturn bstream;\n}\n\n/**\n * Pack all bit streams padding bits into a byte array.\n * @param input input data.\n * @return padded merged byte stream\n */\n\nunsigned char *QRinput_getByteStream(QRinput *input)\n{\n\tBitStream *bstream;\n\tunsigned char *array;\n\n\tbstream = QRinput_getBitStream(input);\n\tif(bstream == NULL) {\n\t\treturn NULL;\n\t}\n\tarray = BitStream_toByte(bstream);\n\tBitStream_free(bstream);\n\n\treturn array;\n}\n\n/******************************************************************************\n * Structured input data\n *****************************************************************************/\n\nstatic QRinput_InputList *QRinput_InputList_newEntry(QRinput *input)\n{\n\tQRinput_InputList *entry;\n\n\tentry = (QRinput_InputList *)malloc(sizeof(QRinput_InputList));\n\tif(entry == NULL) return NULL;\n\n\tentry->input = input;\n\tentry->next = NULL;\n\n\treturn entry;\n}\n\nstatic void QRinput_InputList_freeEntry(QRinput_InputList *entry)\n{\n\tif(entry != NULL) {\n\t\tQRinput_free(entry->input);\n\t\tfree(entry);\n\t}\n}\n\nQRinput_Struct *QRinput_Struct_new(void)\n{\n\tQRinput_Struct *s;\n\n\ts = (QRinput_Struct *)malloc(sizeof(QRinput_Struct));\n\tif(s == NULL) return NULL;\n\n\ts->size = 0;\n\ts->parity = -1;\n\ts->head = NULL;\n\ts->tail = NULL;\n\n\treturn s;\n}\n\nvoid QRinput_Struct_setParity(QRinput_Struct *s, unsigned char parity)\n{\n\ts->parity = (int)parity;\n}\n\nint QRinput_Struct_appendInput(QRinput_Struct *s, QRinput *input)\n{\n\tQRinput_InputList *e;\n\n\tif(input->mqr) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\te = QRinput_InputList_newEntry(input);\n\tif(e == NULL) return -1;\n\n\ts->size++;\n\tif(s->tail == NULL) {\n\t\ts->head = e;\n\t\ts->tail = e;\n\t} else {\n\t\ts->tail->next = e;\n\t\ts->tail = e;\n\t}\n\n\treturn s->size;\n}\n\nvoid QRinput_Struct_free(QRinput_Struct *s)\n{\n\tQRinput_InputList *list, *next;\n\t\n\tif(s != NULL) {\n\t\tlist = s->head;\n\t\twhile(list != NULL) {\n\t\t\tnext = list->next;\n\t\t\tQRinput_InputList_freeEntry(list);\n\t\t\tlist = next;\n\t\t}\n\t\tfree(s);\n\t}\n}\n\nstatic unsigned char QRinput_Struct_calcParity(QRinput_Struct *s)\n{\n\tQRinput_InputList *list;\n\tunsigned char parity = 0;\n\n\tlist = s->head;\n\twhile(list != NULL) {\n\t\tparity ^= QRinput_calcParity(list->input);\n\t\tlist = list->next;\n\t}\n\n\tQRinput_Struct_setParity(s, parity);\n\n\treturn parity;\n}\n\nstatic int QRinput_List_shrinkEntry(QRinput_List *entry, int bytes)\n{\n\tunsigned char *data;\n\n\tdata = (unsigned char *)malloc(bytes);\n\tif(data == NULL) return -1;\n\n\tmemcpy(data, entry->data, bytes);\n\tfree(entry->data);\n\tentry->data = data;\n\tentry->size = bytes;\n\n\treturn 0;\n}\n\n__STATIC int QRinput_splitEntry(QRinput_List *entry, int bytes)\n{\n\tQRinput_List *e;\n\tint ret;\n\n\te = QRinput_List_newEntry(entry->mode, entry->size - bytes, entry->data + bytes);\n\tif(e == NULL) {\n\t\treturn -1;\n\t}\n\n\tret = QRinput_List_shrinkEntry(entry, bytes);\n\tif(ret < 0) {\n\t\tQRinput_List_freeEntry(e);\n\t\treturn -1;\n\t}\n\n\te->next = entry->next;\n\tentry->next = e;\n\n\treturn 0;\n}\n\nQRinput_Struct *QRinput_splitQRinputToStruct(QRinput *input)\n{\n\tQRinput *p = NULL;\n\tQRinput_Struct *s;\n\tint bits, maxbits, nextbits, bytes, ret;\n\tQRinput_List *list, *next, *prev;\n\n\tif(input->mqr) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\ts = QRinput_Struct_new();\n\tif(s == NULL) \n\t\treturn NULL;\n\n\tinput = QRinput_dup(input);\n\tif(input == NULL) {\n\t\tQRinput_Struct_free(s);\n\t\treturn NULL;\n\t}\n\n\tQRinput_Struct_setParity(s, QRinput_calcParity(input));\n\tmaxbits = QRspec_getDataLength(input->version, input->level) * 8 - STRUCTURE_HEADER_SIZE;\n\n\tif(maxbits <= 0) {\n\t\tQRinput_Struct_free(s);\n\t\tQRinput_free(input);\n\t\treturn NULL;\n\t}\n\n\tbits = 0;\n\tlist = input->head;\n\tprev = NULL;\n\twhile(list != NULL)\n    {\n\t\tnextbits = QRinput_estimateBitStreamSizeOfEntry(list, input->version, input->mqr);\n\t\tif(bits + nextbits <= maxbits)\n        {\n\t\t\tret = QRinput_encodeBitStream(list, input->version, input->mqr);\n\t\t\tif(ret < 0) goto ABORT;\n\t\t\tbits += ret;\n\t\t\tprev = list;\n\t\t\tlist = list->next;\n\t\t} \n        else\n        {\n\t\t\tbytes = QRinput_lengthOfCode(list->mode, input->version, maxbits - bits);\n\t\t\tif(bytes > 0) \n            {\n\t\t\t\t/* Splits this entry into 2 entries. */\n\t\t\t\tret = QRinput_splitEntry(list, bytes);\n\t\t\t\tif(ret < 0) goto ABORT;\n\t\t\t\t/* First half is the tail of the current input. */\n\t\t\t\tnext = list->next;\n\t\t\t\tlist->next = NULL;\n\t\t\t\t/* Second half is the head of the next input, p.*/\n\t\t\t\tp = QRinput_new2(input->version, input->level);\n\t\t\t\tif(p == NULL) goto ABORT;\n\t\t\t\tp->head = next;\n\t\t\t\t/* Renew QRinput.tail. */\n\t\t\t\tp->tail = input->tail;\n\t\t\t\tinput->tail = list;\n\t\t\t\t/* Point to the next entry. */\n\t\t\t\tprev = list;\n\t\t\t\tlist = next;\n\t\t\t}\n            else\n            {\n\t\t\t\t/* Current entry will go to the next input. */\n                if (prev)\n\t\t\t\t    prev->next = NULL;\n\t\t\t\tp = QRinput_new2(input->version, input->level);\n\t\t\t\tif(p == NULL) \n                    goto ABORT;\n\t\t\t\tp->head = list;\n\t\t\t\tp->tail = input->tail;\n\t\t\t\tinput->tail = prev;\n\t\t\t}\n\t\t\tret = QRinput_Struct_appendInput(s, input);\n\t\t\tif(ret < 0) \n\t\t\t{\n\t\t\t\tQRinput_free(p); \n\t\t\t\tgoto ABORT;\n\t\t\t}\n\t\t\t\t\n\t\t\tinput = p;\n\t\t\tbits = 0;\n\t\t}\n\t}\n\tQRinput_Struct_appendInput(s, input);\n\tif(s->size > MAX_STRUCTURED_SYMBOLS) {\n\t\tQRinput_Struct_free(s);\n\t\terrno = ERANGE;\n\t\treturn NULL;\n\t}\n\tret = QRinput_Struct_insertStructuredAppendHeaders(s);\n\tif(ret < 0) {\n\t\tQRinput_Struct_free(s);\n\t\treturn NULL;\n\t}\n\n\treturn s;\n\nABORT:\n\tQRinput_free(input);\n\tQRinput_Struct_free(s);\n\t\n\treturn NULL;\n}\n\nint QRinput_Struct_insertStructuredAppendHeaders(QRinput_Struct *s)\n{\n\tint num, i;\n\tQRinput_InputList *list;\n\n\tif(s->parity < 0) {\n\t\tQRinput_Struct_calcParity(s);\n\t}\n\tnum = 0;\n\tlist = s->head;\n\twhile(list != NULL) {\n\t\tnum++;\n\t\tlist = list->next;\n\t}\n\ti = 1;\n\tlist = s->head;\n\twhile(list != NULL) {\n\t\tif(QRinput_insertStructuredAppendHeader(list->input, num, i, s->parity))\n\t\t\treturn -1;\n\t\ti++;\n\t\tlist = list->next;\n\t}\n\n\treturn 0;\n}\n\n/******************************************************************************\n * Extended encoding mode (FNC1 and ECI)\n *****************************************************************************/\n\nint QRinput_setFNC1First(QRinput *input)\n{\n\tif(input->mqr) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tinput->fnc1 = 1;\n\n\treturn 0;\n}\n\nint QRinput_setFNC1Second(QRinput *input, unsigned char appid)\n{\n\tif(input->mqr) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tinput->fnc1 = 2;\n\tinput->appid = appid;\n\n\treturn 0;\n}\n","size_bytes":39225},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/setdeviceconfig.cpp":{"content":"// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++\n\n// NOTE: Do not modify the contents of this file.  If this class is regenerated by\n//  Microsoft Visual C++, your modifications will be overwritten.\n\n\n#include \"StdAfx.h\"\n#include \"setdeviceconfig.h\"\n\n// Dispatch interfaces referenced by this interface\n#include \"font.h\"\n\n/////////////////////////////////////////////////////////////////////////////\n// CSetDeviceConfig\n\nIMPLEMENT_DYNCREATE(CSetDeviceConfig, CWnd)\n\n/////////////////////////////////////////////////////////////////////////////\n// CSetDeviceConfig properties\n\n/////////////////////////////////////////////////////////////////////////////\n// CSetDeviceConfig operations\n\nBOOL CSetDeviceConfig::GetAutoScroll()\n{\n\tBOOL result;\n\tInvokeHelper(0x2, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);\n\treturn result;\n}\n\nvoid CSetDeviceConfig::SetAutoScroll(BOOL bNewValue)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_BOOL;\n\tInvokeHelper(0x2, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,\n\t\t bNewValue);\n}\n\nBOOL CSetDeviceConfig::GetAutoSize()\n{\n\tBOOL result;\n\tInvokeHelper(0x3, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);\n\treturn result;\n}\n\nvoid CSetDeviceConfig::SetAutoSize(BOOL bNewValue)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_BOOL;\n\tInvokeHelper(0x3, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,\n\t\t bNewValue);\n}\n\nlong CSetDeviceConfig::GetAxBorderStyle()\n{\n\tlong result;\n\tInvokeHelper(0x4, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);\n\treturn result;\n}\n\nvoid CSetDeviceConfig::SetAxBorderStyle(long nNewValue)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_I4;\n\tInvokeHelper(0x4, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,\n\t\t nNewValue);\n}\n\nlong CSetDeviceConfig::GetBorderWidth()\n{\n\tlong result;\n\tInvokeHelper(0x5, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);\n\treturn result;\n}\n\nvoid CSetDeviceConfig::SetBorderWidth(long nNewValue)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_I4;\n\tInvokeHelper(0x5, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,\n\t\t nNewValue);\n}\n\nCString CSetDeviceConfig::GetCaption()\n{\n\tCString result;\n\tInvokeHelper(DISPID_CAPTION, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);\n\treturn result;\n}\n\nvoid CSetDeviceConfig::SetCaption(LPCTSTR lpszNewValue)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_BSTR;\n\tInvokeHelper(DISPID_CAPTION, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,\n\t\t lpszNewValue);\n}\n\nunsigned long CSetDeviceConfig::GetColor()\n{\n\tunsigned long result;\n\tInvokeHelper(DISPID_BACKCOLOR, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);\n\treturn result;\n}\n\nvoid CSetDeviceConfig::SetColor(unsigned long newValue)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_I4;\n\tInvokeHelper(DISPID_BACKCOLOR, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,\n\t\t newValue);\n}\n\nCOleFont CSetDeviceConfig::GetFont()\n{\n\tLPDISPATCH pDispatch;\n\tInvokeHelper(DISPID_FONT, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&pDispatch, NULL);\n\treturn COleFont(pDispatch);\n}\n\nvoid CSetDeviceConfig::SetFont(LPDISPATCH newValue)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_DISPATCH;\n\tInvokeHelper(DISPID_FONT, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,\n\t\t newValue);\n}\n\nvoid CSetDeviceConfig::SetRefFont(LPDISPATCH* newValue)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_PDISPATCH;\n\tInvokeHelper(DISPID_FONT, DISPATCH_PROPERTYPUTREF, VT_EMPTY, NULL, parms,\n\t\t newValue);\n}\n\nBOOL CSetDeviceConfig::GetKeyPreview()\n{\n\tBOOL result;\n\tInvokeHelper(0x6, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);\n\treturn result;\n}\n\nvoid CSetDeviceConfig::SetKeyPreview(BOOL bNewValue)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_BOOL;\n\tInvokeHelper(0x6, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,\n\t\t bNewValue);\n}\n\nlong CSetDeviceConfig::GetPixelsPerInch()\n{\n\tlong result;\n\tInvokeHelper(0x7, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);\n\treturn result;\n}\n\nvoid CSetDeviceConfig::SetPixelsPerInch(long nNewValue)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_I4;\n\tInvokeHelper(0x7, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,\n\t\t nNewValue);\n}\n\nlong CSetDeviceConfig::GetPrintScale()\n{\n\tlong result;\n\tInvokeHelper(0x8, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);\n\treturn result;\n}\n\nvoid CSetDeviceConfig::SetPrintScale(long nNewValue)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_I4;\n\tInvokeHelper(0x8, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,\n\t\t nNewValue);\n}\n\nBOOL CSetDeviceConfig::GetScaled()\n{\n\tBOOL result;\n\tInvokeHelper(0x9, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);\n\treturn result;\n}\n\nvoid CSetDeviceConfig::SetScaled(BOOL bNewValue)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_BOOL;\n\tInvokeHelper(0x9, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,\n\t\t bNewValue);\n}\n\nvoid CSetDeviceConfig::SetDeviceShowType(long* lpDeviceInfo)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_PI4;\n\tInvokeHelper(0x11, DISPATCH_METHOD, VT_EMPTY, NULL, parms,\n\t\t lpDeviceInfo);\n}\n\nvoid CSetDeviceConfig::SetDetectWinRGB(unsigned long unRed, unsigned long unGreen, unsigned long unBlue, unsigned long unType)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_I4 VTS_I4 VTS_I4 VTS_I4;\n\tInvokeHelper(0x14, DISPATCH_METHOD, VT_EMPTY, NULL, parms,\n\t\t unRed, unGreen, unBlue, unType);\n}\n\nvoid CSetDeviceConfig::SendDeviceInfoData(long DeviceID, long lConfigType, long* lpReData, unsigned long ReDataLength)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_I4 VTS_I4 VTS_PI4 VTS_I4;\n\tInvokeHelper(0x15, DISPATCH_METHOD, VT_EMPTY, NULL, parms,\n\t\t DeviceID, lConfigType, lpReData, ReDataLength);\n}\n\nvoid CSetDeviceConfig::CreateDeviceFram(unsigned long unLagType)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_I4;\n\tInvokeHelper(0x13, DISPATCH_METHOD, VT_EMPTY, NULL, parms,\n\t\t unLagType);\n}\n\nvoid CSetDeviceConfig::SetDetectAreaHandle(long SetDetectAreaHandle, unsigned long unDetectType)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_I4 VTS_I4;\n\tInvokeHelper(0x10, DISPATCH_METHOD, VT_EMPTY, NULL, parms,\n\t\t SetDetectAreaHandle, unDetectType);\n}\n\nvoid CSetDeviceConfig::SetConfigPageHide(long lPageIndex)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_I4;\n\tInvokeHelper(0x12, DISPATCH_METHOD, VT_EMPTY, NULL, parms,\n\t\t lPageIndex);\n}\n","size_bytes":5856},"bin/DemoSrc/playsdkdemo/MediaInfoDlg.cpp":{"content":"// MediaInfoDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"PlayDemo.h\"\n#include \"MediaInfoDlg.h\"\n#include \"dhplay.h\"\n#include \"LanguageConvertor.h\"\n#include \"Player.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CMediaInfoDlg dialog\n\n\nCMediaInfoDlg::CMediaInfoDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CMediaInfoDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CMediaInfoDlg)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CMediaInfoDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CMediaInfoDlg)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CMediaInfoDlg, CDialog)\n\t//{{AFX_MSG_MAP(CMediaInfoDlg)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CMediaInfoDlg message handlers\n\nBOOL CMediaInfoDlg::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\t// TODO: Add extra initialization here\n\tint len = 0;\n\tMEDIA_INFO tMediaInfo;\n\tmemset(&tMediaInfo, 0, sizeof(MEDIA_INFO));\n\tCPlayer::Instance()->GetQueryInfo(PLAY_CMD_GetMediaInfo, (char *)&tMediaInfo, sizeof(MEDIA_INFO), &len);\n\n\tCString csMediaInfo = \"\";\n\n\tif (tMediaInfo.lFrameRate != 0)\n\t{\n\t\tCString csTemp;\n\t\tcsTemp.Format(_T(\"%s\\t%d\\n\"),LANG_CS(\"Video Frame Rate\"), tMediaInfo.lFrameRate);\n\t\tcsMediaInfo += csTemp;\n\n\t\tcsTemp.Format(_T(\"%s\\t%d * %d\\n\"),LANG_CS(\"Video resolution\"), tMediaInfo.lWidth, tMediaInfo.lHeight);\n\t\tcsMediaInfo += csTemp;\n\t\tcsMediaInfo += \"---------------------------------------------\\n\";\n\t}\n\n\tif (tMediaInfo.lChannel != 0)\n\t{\n\t\tCString csTemp;\n\t\tcsTemp.Format(_T(\"%s\\t%d\\n\"),LANG_CS(\"Audio Channel\"), tMediaInfo.lChannel);\n\t\tcsMediaInfo += csTemp;\n\n\t\tcsTemp.Format(_T(\"%s\\t%d\\n\"),LANG_CS(\"Audio BitPerSample\"), tMediaInfo.lBitPerSample);\n\t\tcsMediaInfo += csTemp;\n\n\t\tcsTemp.Format(_T(\"%s\\t%d\\n\"),LANG_CS(\"Audio SamplesPerSec\"), tMediaInfo.lSamplesPerSec);\n\t\tcsMediaInfo += csTemp;\n\t\tcsMediaInfo += \"---------------------------------------------\\n\";\n\t}\n\n\tGetDlgItem(IDC_STATIC_MEDIAINFO)->SetWindowText(csMediaInfo);\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nBOOL CMediaInfoDlg::PreTranslateMessage(MSG* pMsg) \n{\n\t// TODO: Add your specialized code here and/or call the base class\n\tif (pMsg->wParam == VK_RETURN && pMsg->message == WM_KEYDOWN)\n\t\treturn 1;\n\telse if(pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_ESCAPE)\n\t\treturn 1;\n\treturn CDialog::PreTranslateMessage(pMsg);\n}\n","size_bytes":2703},"bin/Demo/MfcDemo/10.AlarmDevice/StdAfx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n//\tAlarmDevice.pch will be the pre-compiled header\n//\tstdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":545},"bin/DemoSrc/playsdkdemo/DlgMultPlay.cpp":{"content":"// DlgMultPlay.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"PlayDemo.h\"\n#include \"DlgMultPlay.h\"\n#include \"Player.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgMultPlay dialog\n\n\nCDlgMultPlay::CDlgMultPlay(CWnd* pParent /*=NULL*/)\n\t: CDialog(CDlgMultPlay::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgMultPlay)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CDlgMultPlay::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgMultPlay)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgMultPlay, CDialog)\n\t//{{AFX_MSG_MAP(CDlgMultPlay)\n\tON_WM_CLOSE()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgMultPlay message handlers\n\nvoid CDlgMultPlay::OnClose() \n{\n\t// TODO: Add your message handler code here and/or call default\n\tCPlayer::Instance()->SetDisplayRegion(1, NULL, m_hWnd, FALSE);\n\tCDialog::OnClose();\n}\n","size_bytes":1164},"bin/Demo/MfcDemo/04.CapturePicture/CapturePicture.cpp":{"content":"// CapturePicture.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"CapturePicture.h\"\n#include \"CapturePictureDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CCapturePictureApp\n\nBEGIN_MESSAGE_MAP(CCapturePictureApp, CWinApp)\n\t//{{AFX_MSG_MAP(CCapturePictureApp)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t\t//    DO NOT EDIT what you see in these blocks of generated code!\n\t//}}AFX_MSG\n\tON_COMMAND(ID_HELP, CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CCapturePictureApp construction\nCString ConvertString(CString strText)\n{\n\tchar *val = new char[200];\n\tCString strIniPath,strRet;\n\t\n\tmemset(val,0,200);\n\tGetPrivateProfileString(\"String\",strText,\"\",\n\t\tval,200,\"./langchn.ini\");\n\tstrRet = val;\n\tif(strRet.GetLength()==0)\n\t{\n\t\t//If there is no corresponding string in ini file then set it to be deafault value(English).\n\t\tstrRet=strText;\n\t}\n\tdelete[] val;\n\treturn strRet;\n}\n//Set static text for dialogue box(English->current language)\nvoid g_SetWndStaticText(CWnd * pWnd)\n{\n\tCString strCaption,strText;\n\t\n\t//Set main window title \n\tpWnd->GetWindowText(strCaption);\n\tif(strCaption.GetLength()>0)\n\t{\n\t\tstrText=ConvertString(strCaption);\n\t\tpWnd->SetWindowText(strText);\n\t}\n\t\n\t//Set small window title\n\tCWnd * pChild=pWnd->GetWindow(GW_CHILD);\n\tCString strClassName;\n\twhile(pChild)\n\t{\n\t\t//////////////////////////////////////////////////////////////////////////\t\t\n\t\t//Added by Jackbin 2005-03-11\n\t\tstrClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n\t\tif(strClassName == \"CEdit\")\n\t\t{\n\t\t\t//The next small window \n\t\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t//////////////////////////////////////////////////////////////////////////\t\n\t\t\n\t\t//Set current language text for small window. \n\t\tpChild->GetWindowText(strCaption);\n\t\tstrText=ConvertString(strCaption);\n\t\tpChild->SetWindowText(strText);\n\t\t\n\t\t//Next small window \n\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\t\t\n\t}\n}\n\nCCapturePictureApp::CCapturePictureApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The one and only CCapturePictureApp object\n\nCCapturePictureApp theApp;\n\n/////////////////////////////////////////////////////////////////////////////\n// CCapturePictureApp initialization\n\nBOOL CCapturePictureApp::InitInstance()\n{\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t//  of your final executable, you should remove from the following\n\t//  the specific initialization routines you do not need.\n\n#ifdef _AFXDLL\n\tEnable3dControls();\t\t\t// Call this when using MFC in a shared DLL\n#else\n\tEnable3dControlsStatic();\t// Call this when linking to MFC statically\n#endif\n\n\tCCapturePictureDlg dlg;\n\tm_pMainWnd = &dlg;\n\tINT_PTR nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":3569},"bin/Demo/MfcDemo/10.AlarmDevice/SubDlgCfgTimeSection.cpp":{"content":"// SubDlgCfgTimeSection.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"SubDlgCfgTimeSection.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CSubDlgCfgTimeSection dialog\n\n\nCSubDlgCfgTimeSection::CSubDlgCfgTimeSection(CWnd* pParent /*=NULL*/)\n\t: CDialog(CSubDlgCfgTimeSection::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CSubDlgCfgTimeSection)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tmemset(&m_stuTimeSection, 0, sizeof(m_stuTimeSection));\n}\n\n\nvoid CSubDlgCfgTimeSection::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CSubDlgCfgTimeSection)\n\tDDX_Control(pDX, IDC_TIMESECTION_CMB_WEEKDAY, m_cmbWeekDay);\n\tDDX_Control(pDX, IDC_TIMESECTION_CHK_SEG1_ENABLE, m_chkSeg1);\n\tDDX_Control(pDX, IDC_TIMESECTION_CHK_SEG2_ENABLE, m_chkSeg2);\n\tDDX_Control(pDX, IDC_TIMESECTION_CHK_SEG3_ENABLE, m_chkSeg3);\n\tDDX_Control(pDX, IDC_TIMESECTION_CHK_SEG4_ENABLE, m_chkSeg4);\n\tDDX_Control(pDX, IDC_TIMESECTION_CHK_SEG5_ENABLE, m_chkSeg5);\n\tDDX_Control(pDX, IDC_TIMESECTION_CHK_SEG6_ENABLE, m_chkSeg6);\n\tDDX_Control(pDX, IDC_TIMESECTION_DTP1_END, m_dtp1End);\n\tDDX_Control(pDX, IDC_TIMESECTION_DTP1_START, m_dtp1Start);\n\tDDX_Control(pDX, IDC_TIMESECTION_DTP2_END, m_dtp2End);\n\tDDX_Control(pDX, IDC_TIMESECTION_DTP2_START, m_dtp2Start);\n\tDDX_Control(pDX, IDC_TIMESECTION_DTP3_END, m_dtp3End);\n\tDDX_Control(pDX, IDC_TIMESECTION_DTP3_START, m_dtp3Start);\n\tDDX_Control(pDX, IDC_TIMESECTION_DTP4_END, m_dtp4End);\n\tDDX_Control(pDX, IDC_TIMESECTION_DTP4_START, m_dtp4Start);\n\tDDX_Control(pDX, IDC_TIMESECTION_DTP5_END, m_dtp5End);\n\tDDX_Control(pDX, IDC_TIMESECTION_DTP5_START, m_dtp5Start);\n\tDDX_Control(pDX, IDC_TIMESECTION_DTP6_END, m_dtp6End);\n\tDDX_Control(pDX, IDC_TIMESECTION_DTP6_START, m_dtp6Start);\n\t//}}AFX_DATA_MAP\n}\n\nBEGIN_MESSAGE_MAP(CSubDlgCfgTimeSection, CDialog)\n\t//{{AFX_MSG_MAP(CSubDlgCfgTimeSection)\n\tON_CBN_SELCHANGE(IDC_TIMESECTION_CMB_WEEKDAY, OnSelchangeTimesectionCmbWeekday)\n\tON_BN_CLICKED(IDC_TIMESECTION_CHK_SEG1_ENABLE, OnEventhandlerChkSeg1Enable)\n\tON_BN_CLICKED(IDC_TIMESECTION_CHK_SEG2_ENABLE, OnEventhandlerChkSeg2Enable)\n\tON_BN_CLICKED(IDC_TIMESECTION_CHK_SEG3_ENABLE, OnEventhandlerChkSeg3Enable)\n\tON_BN_CLICKED(IDC_TIMESECTION_CHK_SEG4_ENABLE, OnEventhandlerChkSeg4Enable)\n\tON_BN_CLICKED(IDC_TIMESECTION_CHK_SEG5_ENABLE, OnEventhandlerChkSeg5Enable)\n\tON_BN_CLICKED(IDC_TIMESECTION_CHK_SEG6_ENABLE, OnEventhandlerChkSeg6Enable)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_TIMESECTION_DTP1_START, OnDatetimechangeEventhandlerDtp1Start)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_TIMESECTION_DTP1_END, OnDatetimechangeEventhandlerDtp1End)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_TIMESECTION_DTP2_START, OnDatetimechangeEventhandlerDtp2Start)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_TIMESECTION_DTP2_END, OnDatetimechangeEventhandlerDtp2End)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_TIMESECTION_DTP3_START, OnDatetimechangeEventhandlerDtp3Start)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_TIMESECTION_DTP3_END, OnDatetimechangeEventhandlerDtp3End)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_TIMESECTION_DTP4_START, OnDatetimechangeEventhandlerDtp4Start)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_TIMESECTION_DTP4_END, OnDatetimechangeEventhandlerDtp4End)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_TIMESECTION_DTP5_START, OnDatetimechangeEventhandlerDtp5Start)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_TIMESECTION_DTP5_END, OnDatetimechangeEventhandlerDtp5End)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_TIMESECTION_DTP6_START, OnDatetimechangeEventhandlerDtp6Start)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_TIMESECTION_DTP6_END, OnDatetimechangeEventhandlerDtp6End)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CSubDlgCfgTimeSection private method\n\nvoid CSubDlgCfgTimeSection::InitDlg()\n{\n\tunsigned int i = 0;\n\t\n\t// WeekDay\n\tm_cmbWeekDay.ResetContent();\n\tfor (i = 0; i < sizeof(stuDemoWeekDay) / sizeof(stuDemoWeekDay[0]); i++)\n\t{\n\t\tm_cmbWeekDay.InsertString(-1, ConvertString(stuDemoWeekDay[i].pszName, DLG_EVENTHANDLER));\n\t}\n\tm_cmbWeekDay.SetCurSel(0);\n\t\n\t// DateTimePickers...\n\tSYSTEMTIME stStart = {2000,1,1,1}, stEnd = {2000,1,1,1,23,59,59,0};\n\tm_dtp1Start.SetTime(&stStart);\n\tm_dtp1End.SetTime(&stEnd);\n\tm_dtp2Start.SetTime(&stStart);\n\tm_dtp2End.SetTime(&stEnd);\n\tm_dtp3Start.SetTime(&stStart);\n\tm_dtp3End.SetTime(&stEnd);\n\tm_dtp4Start.SetTime(&stStart);\n\tm_dtp4End.SetTime(&stEnd);\n\tm_dtp5Start.SetTime(&stStart);\n\tm_dtp5End.SetTime(&stEnd);\n\tm_dtp6Start.SetTime(&stStart);\n\tm_dtp6End.SetTime(&stEnd);\n\tm_chkSeg1.SetCheck(BST_UNCHECKED);\n\tm_chkSeg2.SetCheck(BST_UNCHECKED);\n\tm_chkSeg3.SetCheck(BST_UNCHECKED);\n\tm_chkSeg4.SetCheck(BST_UNCHECKED);\n\tm_chkSeg5.SetCheck(BST_UNCHECKED);\n\tm_chkSeg6.SetCheck(BST_UNCHECKED);\n}\n\nvoid CSubDlgCfgTimeSection::StuToDlg()\n{\n\tOnSelchangeTimesectionCmbWeekday();\n}\n\nvoid CSubDlgCfgTimeSection::DlgToStu()\n{\n\tGetTimeSectionFromDlg();\n}\n\nvoid CSubDlgCfgTimeSection::ShowTimeSection(int nSeg, const CFG_TIME_SECTION& stuTimeSection)\n{\n\tSYSTEMTIME stBegin = {2000, 1, 1, 1}, stEnd = {2000, 1, 1, 1};\n\tCfgTimeSectionToDTP(stuTimeSection, stBegin, stEnd);\n\t\n\tswitch (nSeg)\n\t{\n\tcase 0:\n\t\tm_dtp1Start.SetTime(&stBegin);\n\t\tm_dtp1End.SetTime(&stEnd);\n\t\tm_chkSeg1.SetCheck(stuTimeSection.dwRecordMask ? BST_CHECKED : BST_UNCHECKED);\n\t\tbreak;\n\tcase 1:\n\t\tm_dtp2Start.SetTime(&stBegin);\n\t\tm_dtp2End.SetTime(&stEnd);\n\t\tm_chkSeg2.SetCheck(stuTimeSection.dwRecordMask ? BST_CHECKED : BST_UNCHECKED);\n\t\tbreak;\n\tcase 2:\n\t\tm_dtp3Start.SetTime(&stBegin);\n\t\tm_dtp3End.SetTime(&stEnd);\n\t\tm_chkSeg3.SetCheck(stuTimeSection.dwRecordMask ? BST_CHECKED : BST_UNCHECKED);\n\t\tbreak;\n\tcase 3:\n\t\tm_dtp4Start.SetTime(&stBegin);\n\t\tm_dtp4End.SetTime(&stEnd);\n\t\tm_chkSeg4.SetCheck(stuTimeSection.dwRecordMask ? BST_CHECKED : BST_UNCHECKED);\n\t\tbreak;\n\tcase 4:\n\t\tm_dtp5Start.SetTime(&stBegin);\n\t\tm_dtp5End.SetTime(&stEnd);\n\t\tm_chkSeg5.SetCheck(stuTimeSection.dwRecordMask ? BST_CHECKED : BST_UNCHECKED);\n\t\tbreak;\n\tcase 5:\n\t\tm_dtp6Start.SetTime(&stBegin);\n\t\tm_dtp6End.SetTime(&stEnd);\n\t\tm_chkSeg6.SetCheck(stuTimeSection.dwRecordMask ? BST_CHECKED : BST_UNCHECKED);\n\t\tbreak;\n\t}\n}\n\nvoid CSubDlgCfgTimeSection::GetTimeSectionFromDlg()\n{\n\tint nSel = m_cmbWeekDay.GetCurSel();\n\tSYSTEMTIME stBegin = {0}, stEnd = {0};\n\tfor (int i = 0; i < MAX_REC_TSECT; i++)\n\t{\n\t\tCFG_TIME_SECTION& stuTimeSection = m_stuTimeSection[(em_WeekDay)nSel][i];\n\t\tswitch (i)\n\t\t{\n\t\tcase 0:\n\t\t\tstuTimeSection.dwRecordMask = m_chkSeg1.GetCheck();\n\t\t\tm_dtp1Start.GetTime(&stBegin);\n\t\t\tm_dtp1End.GetTime(&stEnd);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tstuTimeSection.dwRecordMask = m_chkSeg2.GetCheck();\n\t\t\tm_dtp2Start.GetTime(&stBegin);\n\t\t\tm_dtp2End.GetTime(&stEnd);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstuTimeSection.dwRecordMask = m_chkSeg3.GetCheck();\n\t\t\tm_dtp3Start.GetTime(&stBegin);\n\t\t\tm_dtp3End.GetTime(&stEnd);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tstuTimeSection.dwRecordMask = m_chkSeg4.GetCheck();\n\t\t\tm_dtp4Start.GetTime(&stBegin);\n\t\t\tm_dtp4End.GetTime(&stEnd);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tstuTimeSection.dwRecordMask = m_chkSeg5.GetCheck();\n\t\t\tm_dtp5Start.GetTime(&stBegin);\n\t\t\tm_dtp5End.GetTime(&stEnd);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tstuTimeSection.dwRecordMask = m_chkSeg6.GetCheck();\n\t\t\tm_dtp6Start.GetTime(&stBegin);\n\t\t\tm_dtp6End.GetTime(&stEnd);\n\t\t\tbreak;\n\t\t}\n\t\tDTPToCfgTimeSection(stBegin, stEnd, stuTimeSection);\n\t}\n}\n\nvoid CSubDlgCfgTimeSection::CfgTimeSectionToDTP(const CFG_TIME_SECTION& stuTimeSection, SYSTEMTIME& stBegin, SYSTEMTIME& stEnd)\n{\n\tstBegin.wHour = stuTimeSection.nBeginHour;\n\tstBegin.wMinute = stuTimeSection.nBeginMin;\n\tstBegin.wSecond = stuTimeSection.nBeginSec;\n\tstEnd.wHour = stuTimeSection.nEndHour;\n\tstEnd.wMinute = stuTimeSection.nEndMin;\n\tstEnd.wSecond = stuTimeSection.nEndSec;\n}\n\nvoid CSubDlgCfgTimeSection::DTPToCfgTimeSection(const SYSTEMTIME& stBegin, const SYSTEMTIME& stEnd, CFG_TIME_SECTION& stuTimeSection)\n{\n\tstuTimeSection.nBeginHour = stBegin.wHour;\n\tstuTimeSection.nBeginMin = stBegin.wMinute;\n\tstuTimeSection.nBeginSec = stBegin.wSecond;\n\tstuTimeSection.nEndHour = stEnd.wHour;\n\tstuTimeSection.nEndMin = stEnd.wMinute;\n\tstuTimeSection.nEndSec = stEnd.wSecond;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CSubDlgCfgTimeSection message handlers\n\nBOOL CSubDlgCfgTimeSection::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\tStuToDlg();\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CSubDlgCfgTimeSection::OnSelchangeTimesectionCmbWeekday() \n{\n\t// TODO: Add your control notification handler code here\n\tint nSel = m_cmbWeekDay.GetCurSel();\n\tif (-1 == nSel)\n\t{\n\t\treturn;\n\t}\n\t\n\tfor (int i = 0; i < MAX_REC_TSECT; i++)\n\t{\n\t\tShowTimeSection(i, m_stuTimeSection[nSel][i]);\n\t}\n}\n\nvoid CSubDlgCfgTimeSection::OnOK() \n{\n\t// TODO: Add extra validation here\n\tStuToDlg();\n\n\tCDialog::OnOK();\n}\n\nvoid CSubDlgCfgTimeSection::OnEventhandlerChkSeg1Enable() \n{\n\t// TODO: Add your control notification handler code here\n\tGetTimeSectionFromDlg();\n}\n\nvoid CSubDlgCfgTimeSection::OnEventhandlerChkSeg2Enable() \n{\n\t// TODO: Add your control notification handler code here\n\tGetTimeSectionFromDlg();\n}\n\nvoid CSubDlgCfgTimeSection::OnEventhandlerChkSeg3Enable() \n{\n\t// TODO: Add your control notification handler code here\n\tGetTimeSectionFromDlg();\n}\n\nvoid CSubDlgCfgTimeSection::OnEventhandlerChkSeg4Enable() \n{\n\t// TODO: Add your control notification handler code here\n\tGetTimeSectionFromDlg();\n}\n\nvoid CSubDlgCfgTimeSection::OnEventhandlerChkSeg5Enable() \n{\n\t// TODO: Add your control notification handler code here\n\tGetTimeSectionFromDlg();\n}\n\nvoid CSubDlgCfgTimeSection::OnEventhandlerChkSeg6Enable() \n{\n\t// TODO: Add your control notification handler code here\n\tGetTimeSectionFromDlg();\n}\n\nvoid CSubDlgCfgTimeSection::OnDatetimechangeEventhandlerDtp1Start(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tGetTimeSectionFromDlg();\n\t*pResult = 0;\n}\n\nvoid CSubDlgCfgTimeSection::OnDatetimechangeEventhandlerDtp1End(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tGetTimeSectionFromDlg();\n\t*pResult = 0;\n}\n\nvoid CSubDlgCfgTimeSection::OnDatetimechangeEventhandlerDtp2Start(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tGetTimeSectionFromDlg();\n\t*pResult = 0;\n}\n\nvoid CSubDlgCfgTimeSection::OnDatetimechangeEventhandlerDtp2End(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tGetTimeSectionFromDlg();\n\t*pResult = 0;\n}\n\nvoid CSubDlgCfgTimeSection::OnDatetimechangeEventhandlerDtp3Start(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tGetTimeSectionFromDlg();\n\t*pResult = 0;\n}\n\nvoid CSubDlgCfgTimeSection::OnDatetimechangeEventhandlerDtp3End(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tGetTimeSectionFromDlg();\n\t*pResult = 0;\n}\n\nvoid CSubDlgCfgTimeSection::OnDatetimechangeEventhandlerDtp4Start(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tGetTimeSectionFromDlg();\n\t*pResult = 0;\n}\n\nvoid CSubDlgCfgTimeSection::OnDatetimechangeEventhandlerDtp4End(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tGetTimeSectionFromDlg();\n\t*pResult = 0;\n}\n\nvoid CSubDlgCfgTimeSection::OnDatetimechangeEventhandlerDtp5Start(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tGetTimeSectionFromDlg();\n\t*pResult = 0;\n}\n\nvoid CSubDlgCfgTimeSection::OnDatetimechangeEventhandlerDtp5End(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tGetTimeSectionFromDlg();\n\t*pResult = 0;\n}\n\nvoid CSubDlgCfgTimeSection::OnDatetimechangeEventhandlerDtp6Start(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tGetTimeSectionFromDlg();\n\t*pResult = 0;\n}\n\nvoid CSubDlgCfgTimeSection::OnDatetimechangeEventhandlerDtp6End(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tGetTimeSectionFromDlg();\n\t*pResult = 0;\n}\n","size_bytes":12297},"bin/DemoSrc/SoundCapture_demo/LanguageConvertor.cpp":{"content":"// LanguageConvertor.cpp: implementation of the CLanguageConvertor class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"LanguageConvertor.h\"\n\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\n//////////////////////////////////////////////////////////////////////\n// Construction/Destruction\n//////////////////////////////////////////////////////////////////////\nTCHAR CLanguageConvertor::m_szIniFile[MAX_PATH] = {0};\n\n\nint CLanguageConvertor::Init()\n{\n\t_stprintf(m_szIniFile, _T(\"%s%s\"), GetMoudlePath(), \"lang.ini\");\n\treturn 1;\n}\n\nCString CLanguageConvertor::ConvertString(CString strText)\n{\n\tif(strText.GetLength())\n\t{\n\t\tTCHAR val[300];\n\t\tGetPrivateProfileString(_T(\"String\"), strText, strText, val, sizeof(val), m_szIniFile);\n\t\treturn val;\n\t}\n\n\treturn strText;\n}\n\nvoid CLanguageConvertor::SetWndStaticText(CWnd * pWnd)\n{\n\tCString strCaption,strText;\n\n\tpWnd->GetWindowText(strCaption);\n\tif(strCaption.GetLength()>0)\n\t{\n\t\tstrText=ConvertString(strCaption);\n\t\tpWnd->SetWindowText(strText);\n\t}\n\n\tCWnd * pChild=pWnd->GetWindow(GW_CHILD);\n\tCString strClassName;\n\twhile(pChild)\n\t{\n\t\tstrClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n\t\tif(strClassName == \"CEdit\")\n\t\t{\n\t\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t\t\tcontinue;\n\t\t}\n\t\t//////////////////////////////////////////////////////////////////////////\n\t\tpChild->GetWindowText(strCaption);\n\t\tstrText=ConvertString(strCaption);\n\t\tpChild->SetWindowText(strText);\n\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t}\n}\n\nvoid CLanguageConvertor::SetMenuStaticText(CMenu* pMenu)\n{\n\tCString strCaption,strText;\n\t\n\tint MenuItemNum = pMenu->GetMenuItemCount() ;\n\t\n\tfor (int i = 0 ; i < MenuItemNum ; i++)\n\t{\t\t\n\t\tMENUITEMINFO info;\n\t\tmemset(&info, 0 , sizeof(MENUITEMINFO)) ;\n\t\tinfo.cbSize = sizeof (MENUITEMINFO); // must fill up this field\n\t\tinfo.fMask = MIIM_STATE;             // get the state of the menu item\n\t\t\n\t\tpMenu->GetMenuString(i, strCaption, MF_BYPOSITION);\n\t\t\n\t\tstrText=ConvertString(strCaption);\n\t\t\n\t\tUINT ID = pMenu->GetMenuItemID(i) ;\n\t\t\n\t\tif (ID != -1)\n\t\t{\n\t\t\tpMenu->GetMenuItemInfo(ID, &info) ;\n\t\t\tpMenu->ModifyMenu(ID, MF_BYCOMMAND|MF_STRING, ID, strText);\n\t\t\tSetMenuItemInfo(pMenu->m_hMenu, ID, FALSE, &info) ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpMenu->ModifyMenu(i, MF_BYPOSITION| MF_STRING, 0, strText);\n\t\t}\n\t\t\n\t\tCMenu* subMenu = pMenu->GetSubMenu(i) ;\n\t\t\n\t\tif (subMenu != NULL)\n\t\t{\t\t\t\n\t\t\tSetMenuStaticText(subMenu) ;\n\t\t}\n\t}\n}","size_bytes":2492},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/ConfigRecord.cpp":{"content":"// ConfigRecord.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"ConfigRecord.h\"\n#include \"NetSDKDemoDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CConfigRecord dialog\n\n\nCConfigRecord::CConfigRecord(CWnd* pParent /*=NULL*/)\n\t: CDialog(CConfigRecord::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CConfigRecord)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_pDev = 0;;\n\tmemset(m_recCFG, 0, 16*sizeof(DHDEV_RECORD_CFG));\n\tm_bInited = FALSE;\n\tm_chnIdx = -1;\n\tm_weekIdx = -1;\n}\n\n\nvoid CConfigRecord::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CConfigRecord)\n\tDDX_Control(pDX, IDC_CHECK_REDUNDANCY, m_redundancychk);\n\tDDX_Control(pDX, IDC_COMBO_RECORDWEEK, m_weeksel);\n\tDDX_Control(pDX, IDC_COMBO_CHANNO, m_channelsel);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CConfigRecord, CDialog)\n\t//{{AFX_MSG_MAP(CConfigRecord)\n\tON_WM_SHOWWINDOW()\n\tON_BN_CLICKED(IDC_UNDO_ALL, OnUndoAll)\n\tON_BN_CLICKED(IDC_APPLY, OnApply)\n\tON_CBN_SELCHANGE(IDC_COMBO_RECORDWEEK, OnSelchangeComboRecordweek)\n\tON_CBN_SELCHANGE(IDC_COMBO_CHANNO, OnSelchangeComboChanno)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CConfigRecord message handlers\n\nvoid CConfigRecord::GetConfig()\n{\n\tif (!m_pDev || m_bInited)\n\t{\n\t\treturn;\n\t}\n\t\n\tBOOL bRet = FALSE;\n\tDWORD retlen = 0;\n\tbRet = CLIENT_GetDevConfig(m_pDev->LoginID, DH_DEV_RECORDCFG, -1/*all channel*/,\n\t\t&m_recCFG, 16*sizeof(DHDEV_RECORD_CFG), &retlen, CONFIG_WAITTIME);\n\tif (!bRet || retlen != m_pDev->Info.byChanNum*sizeof(DHDEV_RECORD_CFG))\n\t{\n\t\t((CNetSDKDemoDlg*)AfxGetMainWnd())->LastError();\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tm_bInited = TRUE;\n\t}\n\t\n\t//show config information\n\tif (m_channelsel.GetCount() > 0)\n\t{\n\t\tm_channelsel.SetCurSel(0);\n\t\tOnSelchangeComboChanno();\n\t}\n}\n\nvoid CConfigRecord::SetDevice(DeviceNode *pDev)\n{\n\tm_pDev = pDev;\n}\n\nBOOL CConfigRecord::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\tg_SetWndStaticText(this);\n\tif (!m_pDev)\n\t{\n\t\treturn TRUE;\n\t}\n\t\n\tCString strChn;\n\tfor (int i = 0; i < m_pDev->Info.byChanNum; i++)\n\t{\n\t\tstrChn.Format(ConvertString(\"Channel_%d\"), i+1);\n\t\tm_channelsel.InsertString(i, strChn);\n\t}\n\t\n\tm_weeksel.InsertString(0, ConvertString(\"Sunday\"));\n\tm_weeksel.InsertString(1, ConvertString(\"Monday\"));\n\tm_weeksel.InsertString(2, ConvertString(\"Tuesday\"));\n\tm_weeksel.InsertString(3, ConvertString(\"Wedensday\"));\n\tm_weeksel.InsertString(4, ConvertString(\"Thursday\"));\n\tm_weeksel.InsertString(5, ConvertString(\"Friday\"));\n\tm_weeksel.InsertString(6, ConvertString(\"Saturday\"));\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CConfigRecord::OnShowWindow(BOOL bShow, UINT nStatus) \n{\n\tCDialog::OnShowWindow(bShow, nStatus);\n\t\n\tif (bShow)\n\t{\n\t\tGetConfig();\n\t}\n}\n\n\nvoid CConfigRecord::OnSelchangeComboChanno() \n{\n\tif (!m_bInited)\n\t{\n\t\treturn;\n\t}\n\t\n\tint weekIdx;\n\tint secIdx = 0;\n\tint i;\n\t//store current config\n\tif (m_chnIdx < 0)\n\t{\n\t\tgoto skipsave;\n\t}\n\tm_recCFG[m_chnIdx].byPreRecordLen = GetDlgItemInt(IDC_EDIT_PRERECLEN);\n\tm_recCFG[m_chnIdx].byRedundancyEn = m_redundancychk.GetCheck();\n\t\n\tweekIdx = m_weeksel.GetCurSel();\n\tif (weekIdx < 0)\n\t{\n\t\tgoto skipsave;\n\t}\n\t\n\tfor (i = 0; i < 6; i++)\n\t{\n\t\tm_recCFG[m_chnIdx].stSect[weekIdx][i].iBeginHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\tsecIdx++;\n\t\tm_recCFG[m_chnIdx].stSect[weekIdx][i].iBeginMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\tsecIdx++;\n\t\tm_recCFG[m_chnIdx].stSect[weekIdx][i].iBeginSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\tsecIdx++;\n\t\t\n\t\tm_recCFG[m_chnIdx].stSect[weekIdx][i].iEndHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\tsecIdx++;\n\t\tm_recCFG[m_chnIdx].stSect[weekIdx][i].iEndMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\tsecIdx++;\n\t\tm_recCFG[m_chnIdx].stSect[weekIdx][i].iEndSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\tsecIdx++;\n\t}\n\t\n\t//show new config\nskipsave:\n\tint chnIdx = m_channelsel.GetCurSel();\n\tif (chnIdx < 0)\n\t{\n\t\treturn;\n\t}\n\tm_chnIdx = chnIdx;\n\t\n\tSetDlgItemInt(IDC_EDIT_PRERECLEN, m_recCFG[chnIdx].byPreRecordLen);\n\tm_redundancychk.SetCheck((m_recCFG[chnIdx].byRedundancyEn)?1:0);\n\tif (m_weeksel.GetCount())\n\t{\n\t\tm_weeksel.SetCurSel(0);\n\t}\n\tm_weekIdx = -1; //prevent from unwanted saving\n\tOnSelchangeComboRecordweek();\n}\n\nvoid CConfigRecord::OnSelchangeComboRecordweek() \n{\n\tif (!m_bInited || m_chnIdx < 0)\n\t{\n\t\treturn;\n\t}\n\t\n\t//store current time sectors\n\tif (m_weekIdx >= 0)\n\t{\n\t\tint secIdx = 0;\n\t\tfor (int i = 0; i < 6; i++)\n\t\t{\n\t\t\tm_recCFG[m_chnIdx].stSect[m_weekIdx][i].iBeginHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_recCFG[m_chnIdx].stSect[m_weekIdx][i].iBeginMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_recCFG[m_chnIdx].stSect[m_weekIdx][i].iBeginSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\t\n\t\t\tm_recCFG[m_chnIdx].stSect[m_weekIdx][i].iEndHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_recCFG[m_chnIdx].stSect[m_weekIdx][i].iEndMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_recCFG[m_chnIdx].stSect[m_weekIdx][i].iEndSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t}\n\t}\n\t\n\t//show new time sectors\n\tint weekIdx = m_weeksel.GetCurSel();\n\tif (weekIdx < 0)\n\t{\n\t\treturn;\n\t}\n\tm_weekIdx = weekIdx;\n\t\n\tint timeCtrlIdx = 0;\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_recCFG[m_chnIdx].stSect[weekIdx][i].iBeginHour);\n\t\ttimeCtrlIdx++;\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_recCFG[m_chnIdx].stSect[weekIdx][i].iBeginMin);\n\t\ttimeCtrlIdx++;\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_recCFG[m_chnIdx].stSect[weekIdx][i].iBeginSec);\n\t\ttimeCtrlIdx++;\n\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_recCFG[m_chnIdx].stSect[weekIdx][i].iEndHour);\n\t\ttimeCtrlIdx++;\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_recCFG[m_chnIdx].stSect[weekIdx][i].iEndMin);\n\t\ttimeCtrlIdx++;\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_recCFG[m_chnIdx].stSect[weekIdx][i].iEndSec);\n\t\ttimeCtrlIdx++;\n\t}\n}\n\nvoid CConfigRecord::OnUndoAll() \n{\n\tm_bInited = FALSE;\n\tm_chnIdx = -1;\n\tm_weekIdx = -1;\n\n\tGetConfig();\n}\n\nvoid CConfigRecord::OnApply() \n{\n\tif (!m_bInited || m_chnIdx < 0)\n\t{\n\t\treturn;\n\t}\n\t\n\tint weekIdx = m_weeksel.GetCurSel();\n\tif (weekIdx < 0)\n\t{\n\t\treturn;\n\t}\n\t\n\tm_recCFG[m_chnIdx].byPreRecordLen = GetDlgItemInt(IDC_EDIT_PRERECLEN);\n\tm_recCFG[m_chnIdx].byRedundancyEn = m_redundancychk.GetCheck();\n\n\tif (m_weekIdx >= 0)\n\t{\n\t\tint secIdx = 0;\n\t\tfor (int i = 0; i < 6; i++)\n\t\t{\n\t\t\tm_recCFG[m_chnIdx].stSect[m_weekIdx][i].iBeginHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_recCFG[m_chnIdx].stSect[m_weekIdx][i].iBeginMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_recCFG[m_chnIdx].stSect[m_weekIdx][i].iBeginSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\t\n\t\t\tm_recCFG[m_chnIdx].stSect[m_weekIdx][i].iEndHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_recCFG[m_chnIdx].stSect[m_weekIdx][i].iEndMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_recCFG[m_chnIdx].stSect[m_weekIdx][i].iEndSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t}\n\t}\n\t\n\tBOOL bRet = CLIENT_SetDevConfig(m_pDev->LoginID, DH_DEV_RECORDCFG, -1/*all channel*/,\n\t\t\t\t\t\t\t\t&m_recCFG, 16*sizeof(DHDEV_RECORD_CFG), CONFIG_WAITTIME);\n\tif (!bRet)\n\t{\n\t\t((CNetSDKDemoDlg*)AfxGetMainWnd())->LastError();\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tMessageBox(ConvertString(MSG_CONFIG_SUCCESS), \"OK\");\n\t}\n}\n\n","size_bytes":7524},"bin/DemoSrc/playsdkdemo/Player.cpp":{"content":"// Player.cpp: implementation of the CPlayer class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"PlayDemo.h\"\n#include \"Player.h\"\n\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\n#include \"FilePlayer.h\"\n#include \"FileStreamPlayer.h\"\n\n//////////////////////////////////////////////////////////////////////\n// Construction/Destruction\n//////////////////////////////////////////////////////////////////////\nCPlayer::CPlayer()\n{\t\n\tmemset(m_lpState, 0, sizeof(m_lpState));\n\tm_lpPlay = NULL;\n\n\tm_playParam.nPort = 0;\n\tm_playParam.hWnd = 0;\n\tm_playParam.bOverlayMode = FALSE;\n\tm_playParam.OverlayColor = RGB(0, 0, 0);\n\tm_playParam.bOpenAudio = 0;\n\n\tmemset(stateTable, 0, sizeof(stateTable));\n\tmemset(openTable, 0, sizeof(openTable));\n\tmemset(closeTable, 0, sizeof(closeTable));\n\t\n\tm_bStartFishEye = false;\n\n\tmemset(&m_feOptParams, 0x00, sizeof(m_feOptParams));\n\tm_feOptParams.mainStreamSize.h = 4000;\n\tm_feOptParams.mainStreamSize.w = 3000;\n\tm_feOptParams.originX = 4096;\n\tm_feOptParams.originY = 4096;\n\tm_feOptParams.radius = 4096;\n\tm_feOptParams.mainMountMode = FISHEYEMOUNT_MODE_CEIL;\n\n\tFISHEYE_OUTPUTFORMAT* pFormat = new FISHEYE_OUTPUTFORMAT;\n\tmemset(pFormat, 0x00, sizeof(FISHEYE_OUTPUTFORMAT));\n\n\tFISHEYE_SUBMODE* pSubMode = new FISHEYE_SUBMODE[9];\n\tmemset(pSubMode, 0x00, sizeof(FISHEYE_SUBMODE)*9);\n\t//get screen resolution\n\tpFormat->mainShowSize.w = GetSystemMetrics(SM_CXSCREEN);\n\tpFormat->mainShowSize.h = GetSystemMetrics(SM_CYSCREEN);\n\tpFormat->subMode = pSubMode;\n\tm_feOptParams.outputFormat = pFormat;\n\n\tm_bNeedDrawFishEyeLines = false;\n\t\n}\n\nCPlayer::~CPlayer()\n{\n\tmemset(m_lpState, 0, sizeof(m_lpState));\n\tm_lpPlay = NULL;\n\n\tdelete [] m_feOptParams.outputFormat->subMode;\n\tdelete m_feOptParams.outputFormat;\n}\n\nCPlayer* CPlayer::Instance()\n{\n\tstatic CPlayer splayer;\n\treturn &splayer;\n}\n\n\nint CPlayer::Open(TYPE eType, TCHAR* lpszFile, HWND playWnd, HWND MainDlgWnd)\n{\n\tif(eType == FILE)\n\t\tCreateFile();\n\telse if(eType == FILESTREAM)\n\t\tCreateFileStream();\n\telse\n\t\treturn -1;\n\t\n\tm_playParam.bIndexCreated = FALSE;\n\tm_playParam.hWnd = playWnd;\n\tm_playParam.pMainWnd = MainDlgWnd;\n\treturn m_lpPlay->Open(lpszFile, &m_playParam);\n}\n\nint CPlayer::Close()\n{\n\tif(m_bStartFishEye)\n\t{\n\t\tm_bStartFishEye = false;\n\t\tm_bNeedDrawFishEyeLines = false;\n\t\tRegistDrawCallback(0, 0);\n\t\tm_lpPlay->StopFisheye(&m_playParam);\n\t}\n\n\tif(m_lpPlay)\n\t\tm_lpPlay->Close(&m_playParam);\n\tDestroy();\n\n\treturn 1;\n}\n\nint CPlayer::GetProcess()\n{\n\tif(!m_lpPlay)\n\t\treturn -1;\n\n\treturn m_lpPlay->GetProcess(&m_playParam);\n}\n\nint CPlayer::Seek(int nPos)\n{\n\tif(!m_lpPlay)\n\t\treturn -1;\n\n\treturn m_lpPlay->Seek(&m_playParam, nPos);\n}\n\nint CPlayer::SetColor(int nSaturation, int nBrightness, int nContrast, int nHue)\n{\n\tif(!m_lpPlay)\n\t\treturn -1;\n\t\n\treturn m_lpPlay->SetColor(&m_playParam, nSaturation, nBrightness, nContrast, nHue);\n}\n\nint CPlayer::GetColor(int* nSaturation, int* nBrightness, int* nContrast, int* nHue)\n{\n\tif(!m_lpPlay)\n\t\treturn -1;\n\t\n\treturn m_lpPlay->GetColor(&m_playParam, nSaturation, nBrightness, nContrast, nHue);\n}\n\nint CPlayer::GetPlayedTime()\n{\n\tif(!m_lpPlay)\n\t\treturn -1;\n\t\n\treturn m_lpPlay->GetPlayedTime(&m_playParam);\n}\n\nint CPlayer::GetTotalTime()\n{\n\tif(!m_lpPlay)\n\t\treturn -1;\n\n\treturn m_lpPlay->GetTotalTime(&m_playParam);\n}\n\nint CPlayer::GetPlayedFrame()\n{\n\tif(!m_lpPlay)\n\t\treturn -1;\n\n\treturn m_lpPlay->GetPlayedFrame(&m_playParam);\n}\n\nint CPlayer::GetTotalFrame()\n{\n\tif(!m_lpPlay)\n\t\treturn -1;\n\n\treturn m_lpPlay->GetTotalFrame(&m_playParam);\n}\n\nint CPlayer::GetPicture(int* nWidth, int* nHeight)\n{\n\tif(!m_lpPlay)\n\t\treturn -1;\n\n\treturn m_lpPlay->GetPicSize(&m_playParam, (long *)nWidth, (long *)nHeight);\n}\n\nint CPlayer::GetRate(int* nRate)\n{\n\tif(!m_lpPlay)\n\t\treturn -1;\n\n\treturn m_lpPlay->GetRate(&m_playParam, nRate);\n}\n\nint CPlayer::GetBitrate(double* dbBitrate)\n{\n\tif(!m_lpPlay)\n\t\treturn -1;\n\n\treturn m_lpPlay->GetBitrate(&m_playParam, dbBitrate);\n}\n\nint CPlayer::SnapPicture(char* szFileName, int nType)\n{\n\tif(!m_lpPlay)\n\t\treturn -1;\n\n\treturn m_lpPlay->SnapPicture(&m_playParam, szFileName, nType);\n}\n\nBOOL CPlayer::GetPicSize(long *width, long *height)\n{\n\tif (m_lpPlay == NULL)\n\t\treturn FALSE;\n\treturn m_lpPlay->GetPicSize(&m_playParam, width, height);\n}\n\nBOOL CPlayer::SetCurrentFrameNum(int frameNum)\n{\n\treturn m_lpPlay->SetCurrentFrameNum(&m_playParam, frameNum);\n}\n\nBOOL CPlayer::SetPlayedTiemEx(int time)\n{\n\treturn m_lpPlay->SetPlayedTimeEx(&m_playParam, time);\n}\n\nint CPlayer::SetDisplayRegion(DWORD nRegionNum, RECT *pSrcRect, HWND hDestWnd, BOOL bEnable)\n{\n\tif(!m_lpPlay)\n\t\treturn -1;\n\n\treturn m_lpPlay->SetDisplayRegion(&m_playParam, nRegionNum, (DISPLAYRECT*)pSrcRect, hDestWnd, bEnable);\n}\n\nBOOL CPlayer::GetNextKeyFramePos(DWORD nValue, int nType, PFRAME_POS pFramePos) \n{\n\treturn m_lpPlay->GetNextKeyFramePos(&m_playParam, nValue, nType, pFramePos);\n}\n\nBOOL CPlayer::GetKeyFramePos(DWORD nValue, int nType, PFRAME_POS pFramePos) \n{\n\treturn m_lpPlay->GetKeyFramePos(&m_playParam, nValue, nType, pFramePos);\n}\n\nBOOL CPlayer::SetVerticalSync(bool bVerticalSync)\n{\n\treturn m_lpPlay->SetVerticalSync(&m_playParam, bVerticalSync);\n}\n\nBOOL CPlayer::SetAntiAliasing(bool bAntiAliasing)\n{\n\treturn m_lpPlay->SetAntiAliasing(&m_playParam, bAntiAliasing);\n}\n\nBOOL CPlayer::GetQueryInfo(int cmdType, char* buf, int buflen, int* returnlen)\n{\n\treturn m_lpPlay->GetQueryInfo(&m_playParam, cmdType, buf, buflen, returnlen);\n}\n\nBOOL CPlayer::IsIndexCreated()\n{\n\treturn m_playParam.bIndexCreated;\n}\n\nint CPlayer::CreateFile()\n{\n\tm_lpState[Play] = new FileState::CPlay;\n\tm_lpState[Pause] = new FileState::CPause;\n\tm_lpState[Stop] = new FileState::CStop;\n\tm_lpState[ToBegin] = new FileState::CToBegin;\n\tm_lpState[ToEnd] = new FileState::CToEnd;\n\tm_lpState[BackOne] = new FileState::CBackOne;\n\tm_lpState[OneByOne] = new FileState::COneByeOne;\n\tm_lpState[Slow] = new FileState::CSlow;\n\tm_lpState[Fast] = new FileState::CFast;\n\n\tmemcpy(stateTable, FileState::stateTable, sizeof(stateTable));\n\tmemcpy(openTable, FileState::openTable, sizeof(openTable));\n\tmemcpy(closeTable, FileState::closeTable, sizeof(closeTable));\n\n\tm_lpPlay = new CFilePlayer;\n\n\treturn 1;\n}\n\nint CPlayer::CreateFileStream()\n{\n\tm_lpState[Play] = new FileStreamState::CPlay;\n\tm_lpState[Pause] = new FileStreamState::CPause;\n\tm_lpState[Stop] = new FileStreamState::CStop;\n\tm_lpState[ToBegin] = new FileStreamState::CToBegin;\n\tm_lpState[ToEnd] = new FileStreamState::CToEnd;\n\tm_lpState[BackOne] = new FileStreamState::CBackOne;\n\tm_lpState[OneByOne] = new FileStreamState::COneByeOne;\n\tm_lpState[Slow] = new FileStreamState::CSlow;\n\tm_lpState[Fast] = new FileStreamState::CFast;\n\n\tmemcpy(stateTable, FileStreamState::stateTable, sizeof(stateTable));\n\tmemcpy(openTable, FileStreamState::openTable, sizeof(openTable));\n\tmemcpy(closeTable, FileStreamState::closeTable, sizeof(closeTable));\n\n\tm_lpPlay = new CFileStreamPlayer;\n\t\n\treturn 1;\n}\n\nint CPlayer::Destroy()\n{\n\tfor(int i = 0 ; i < STATE_SIZE; i++)\n\t{\n\t\tif(m_lpState[i]) \n\t\t\tdelete m_lpState[i];\n\t}\n\n\tif(m_lpPlay)\n\t\tdelete m_lpPlay;\n\n\tmemset(m_lpState, 0, sizeof(m_lpState));\n\tm_lpPlay = NULL;\n\n\treturn 1;\n}\n\nint CPlayer::ChangeState(PLAY_STATE nState)\n{\n\tif(!m_lpPlay)\n\t\treturn -1;\n\n\tif (Play == nState)\n\t{\n\t\tm_lpPlay->SetFishEyeInfoCallBack(&m_playParam, OnFisheyeInfo, this);\n\t}\n\telse if(Stop == nState && m_bStartFishEye)\n\t{\n\t\tm_bStartFishEye = false;\n\t\tm_bNeedDrawFishEyeLines = false;\n\t\tRegistDrawCallback(0, 0);\n\t\tm_lpPlay->StopFisheye(&m_playParam);\n\t}\n\n\treturn m_lpPlay->ChangeState(m_lpState[nState]);\n}\n\nint CPlayer::Do()\n{\n\tif(!m_lpPlay)\n\t\treturn -1;\n\n\treturn m_lpPlay->Do(&m_playParam);\n}\n\nTCHAR* CPlayer::Description()\n{\n\tif(!m_lpPlay)\n\t\treturn NULL;\n\n\treturn m_lpPlay->Description(&m_playParam);\n}\n\nint CPlayer::OpenSound(BOOL bOpen)\n{\n\tif(!m_lpPlay)\n\t\treturn -1;\n\n\treturn m_lpPlay->OpenSound(&m_playParam, bOpen);\n}\n\nint CPlayer::SetAudioVolume(int nVolume)\n{\n\tif(!m_lpPlay)\n\t\treturn -1;\n\n\treturn m_lpPlay->SetAudioVolume(&m_playParam, nVolume);\n}\n\nint CPlayer::GetAudioVolume()\n{\n\tif(!m_lpPlay)\n\t\treturn -1;\n\n\treturn m_lpPlay->GetAudioVolume(&m_playParam);\n}\n\nint CPlayer::SetAudioWave(int nWave)\n{\n\tif(!m_lpPlay)\n\t\treturn -1;\n\n\treturn m_lpPlay->SetAudioWave(&m_playParam, nWave);\n}\n\nBOOL CPlayer::RegistDrawCallback(fDrawCBFun cbDrawCBFun,void* nUser)\n{\n\tif (!m_lpPlay)\n\t\treturn -1;\n\n\treturn m_lpPlay->RegistDrawCallback(&m_playParam, cbDrawCBFun, nUser);\n}\n\nBOOL CPlayer::SetPlayDirection(DWORD emDirection)\n{\n\tif (!m_lpPlay)\n\t\treturn -1;\n\n\treturn m_lpPlay->SetPlayDirection(&m_playParam, emDirection);\n}\n\nBOOL CPlayer::RenderPrivateData(BOOL bTrue)\n{\n\tif (!m_lpPlay)\n\t\treturn -1;\n\t\n\treturn m_lpPlay->RenderPrivateData(&m_playParam, bTrue);\n}\n\nvoid CALLBACK CPlayer::OnFisheyeInfo(LONG nPort,\n\t\t\t\t\t\t\t\t\t BYTE byCorrectMode,\n\t\t\t\t\t\t\t\t\t WORD wRadius,\n\t\t\t\t\t\t\t\t\t WORD wCircleX,\n\t\t\t\t\t\t\t\t\t WORD wCircleY,\n\t\t\t\t\t\t\t\t\t UINT widthRatio,\n\t\t\t\t\t\t\t\t\t UINT heightRatio,\n\t\t\t\t\t\t\t\t\t BYTE gain,\n\t\t\t\t\t\t\t\t\t BYTE denoiseLevel,\n\t\t\t\t\t\t\t\t\t BYTE installStyle,\n\t\t\t\t\t\t\t\t\t void* pUserData)\n{\n\tCPlayer* pPlayer = (CPlayer*)pUserData;\n\tif (pPlayer)\n\t{\n\t\tpPlayer->SetFisheyeInfo(wCircleX, wCircleY, wRadius, widthRatio, heightRatio, installStyle);\n\t}\n}\n\nvoid CPlayer::SetFisheyeInfo(int x, int y, int radius, DWORD widthRatio, DWORD heightRatio, BYTE installStyle)\n{\n\tif (x && y && radius)\n\t{\n\t\tm_feOptParams.originX = x;\n\t\tm_feOptParams.originY = y;\n\t\tm_feOptParams.radius = radius;\n\n\t\tif (m_feOptParams.mainStreamSize.w != widthRatio || m_feOptParams.mainStreamSize.h != heightRatio)\n\t\t{\n\t\t\tm_feOptParams.mainStreamSize.w = widthRatio;\n\t\t\tm_feOptParams.mainStreamSize.h = heightRatio;\n\t\t}\n\n\t\tPostMessage(m_playParam.pMainWnd, WM_USER_MSD_FISHEYEDEVICE_DETECT, true, NULL);\n\t}\n\telse\n\t{\n\t\tPostMessage(m_playParam.pMainWnd, WM_USER_MSD_FISHEYEDEVICE_DETECT, false, NULL);\n\t}\n}\n\nvoid CALLBACK fDrawCBFunFishEye(LONG nPort,HDC hDc, void* pUserData)\n{\n\tCPlayer::Instance()->DrawFishEyeLines(hDc);\n}\n\nBOOL CPlayer::ControlFishEye()\n{\n\tif (!m_lpPlay)\n\t{\n\t\treturn -1;\n\t}\n\n\tif (m_bStartFishEye)\n\t{\n\t\tm_bStartFishEye = false;\n\t\tm_bNeedDrawFishEyeLines = false;\n\t\tRegistDrawCallback(0, 0);\n\t\treturn m_lpPlay->StopFisheye(&m_playParam);\n\t}\n\n\tm_bStartFishEye = true;\n\tRegistDrawCallback(fDrawCBFunFishEye, 0);\n\treturn m_lpPlay->StartFisheye(&m_playParam);\n}\n\nBOOL CPlayer::OptFisheyeParams(FISHEYE_OPERATETYPE operatetype, FISHEYE_OPTPARAM* pOptParam)\n{\n\tif (!m_lpPlay)\n\t{\n\t\treturn -1;\n\t}\n\n\treturn m_lpPlay->OptFisheyeParams(&m_playParam, operatetype, pOptParam);\n}\n\nBOOL CPlayer::FisheyeEptzUpdate(FISHEYE_EPTZPARAM* eptzParam, BOOL bSecondRegion)\n{\n\tif (!m_lpPlay)\n\t{\n\t\treturn -1;\n\t}\n\n\treturn m_lpPlay->FisheyeEptzUpdate(&m_playParam, eptzParam, bSecondRegion);\n}\n\nvoid CPlayer::SetFishEyeMode(FISHEYE_MOUNTMODE nMountMode, FISHEYE_CALIBRATMODE nCalibrateMode)\n{\n\tif (!m_bStartFishEye)\n\t{\n\t\treturn;\n\t}\n\n\tm_feOptParams.mainMountMode = (FISHEYE_MOUNTMODE)nMountMode;\n\tm_feOptParams.mainCalibrateMode = (FISHEYE_CALIBRATMODE)nCalibrateMode;\n\n\tBOOL nRet = m_lpPlay->OptFisheyeParams(&m_playParam, FISHEYE_SETPARAM, &m_feOptParams);\n\tif (nRet <= 0)\n\t{\n\t\tOutputDebugString(_T(\"Set Fisheye Params failed.\\n\"));\n\t}\n\tif(nCalibrateMode == FISHEYECALIBRATE_MODE_ORIGINAL_PLUS_THREE_EPTZ_REGION)\n\t{\n\t\tm_bNeedDrawFishEyeLines = true;\n\t}\n\telse\n\t{\n\t\tm_bNeedDrawFishEyeLines = false;\n\t}\n}\n\nBOOL CPlayer::EnableLargePicAdjustment(int bEnable)\n{\n\tif (!m_lpPlay)\n\t{\n\t\treturn -1;\n\t}\n\n\treturn m_lpPlay->EnableLargePicAdjustment(&m_playParam, bEnable);\n}\n\n\nvoid CPlayer::DrawFishEyeLines(HDC hdc)\n{\n\tif(m_bNeedDrawFishEyeLines)\n\tm_feHandler.Draw(m_playParam.hWnd, hdc);\n}\n\nvoid CPlayer::StartDragFE(CPoint point)\n{\n\tif(m_bNeedDrawFishEyeLines)\n\tm_feHandler.StartDrag(point);\n}\n\nvoid CPlayer::StopDragFE()\n{\n\tif(m_bNeedDrawFishEyeLines)\n\tm_feHandler.StopDrag();\n}\n\nvoid CPlayer::UpdateDragFE(CPoint point)\n{\n\tif(m_bNeedDrawFishEyeLines)\n\tm_feHandler.UpdateDrag(point);\n}\n","size_bytes":11845},"bin/Demo/MfcDemo/10.AlarmDevice/include/mdump.cpp":{"content":"//this file is part of eMule\n//Copyright (C)2002-2008 Merkur ( strEmail.Format(\"%s@%s\", \"devteam\", \"emule-project.net\") / http://www.emule-project.net )\n//\n//This program is free software; you can redistribute it and/or\n//modify it under the terms of the GNU General Public License\n//as published by the Free Software Foundation; either\n//version 2 of the License, or (at your option) any later version.\n//\n//This program is distributed in the hope that it will be useful,\n//but WITHOUT ANY WARRANTY; without even the implied warranty of\n//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//GNU General Public License for more details.\n//\n//You should have received a copy of the GNU General Public License\n//along with this program; if not, write to the Free Software\n//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n#include \"stdafx.h\"\n#include \"DbgHelp.h\"\n#include \"mdump.h\"\n#include <shlwapi.h>\n#pragma comment(lib, \"shlwapi.lib\")\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n\ntypedef BOOL (WINAPI *MINIDUMPWRITEDUMP)(HANDLE hProcess, DWORD dwPid, HANDLE hFile, MINIDUMP_TYPE DumpType,\n\t\t\t\t\t\t\t\t\t\t CONST PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam,\n\t\t\t\t\t\t\t\t\t\t CONST PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,\n\t\t\t\t\t\t\t\t\t\t CONST PMINIDUMP_CALLBACK_INFORMATION CallbackParam);\n\nCMiniDumper theCrashDumper;\nTCHAR CMiniDumper::m_szAppName[MAX_PATH] = {0};\nTCHAR CMiniDumper::m_szDumpDir[MAX_PATH] = {0};\n\nvoid CMiniDumper::Enable(LPCTSTR pszAppName, bool bShowErrors, LPCTSTR pszDumpDir)\n{\n\t// if this assert fires then you have two instances of CMiniDumper which is not allowed\n\tASSERT( m_szAppName[0] == _T('\\0') );\n\t_tcsncpy(m_szAppName, pszAppName, _countof(m_szAppName) - 1);\n\tm_szAppName[_countof(m_szAppName) - 1] = _T('\\0');\n\n\t// eMule may not have the permission to create a DMP file in the directory where the \"emule.exe\" is located.\n\t// Need to pre-determine a valid directory.\n\t_tcsncpy(m_szDumpDir, pszDumpDir, _countof(m_szDumpDir) - 1);\n\tm_szDumpDir[_countof(m_szDumpDir) - 1] = _T('\\0');\n\tPathAddBackslash(m_szDumpDir);\n\n\tMINIDUMPWRITEDUMP pfnMiniDumpWriteDump = NULL;\n\tHMODULE hDbgHelpDll = GetDebugHelperDll((FARPROC*)&pfnMiniDumpWriteDump, bShowErrors);\n\tif (hDbgHelpDll)\n\t{\n\t\tif (pfnMiniDumpWriteDump)\n\t\t\tSetUnhandledExceptionFilter(TopLevelFilter);\n\t\tFreeLibrary(hDbgHelpDll);\n\t\thDbgHelpDll = NULL;\n\t\tpfnMiniDumpWriteDump = NULL;\n\t}\n}\n\n#define DBGHELP_HINT _T(\"You can get the required DBGHELP.DLL by downloading the \\\"User Mode Process Dumper\\\" from \\\"Microsoft Download Center\\\".\\r\\n\\r\\n\") \\\n\t_T(\"Extract the \\\"User Mode Process Dumper\\\" and locate the \\\"x86\\\" folder. Copy the DBGHELP.DLL from the \\\"x86\\\" folder into your eMule installation folder and/or into your Windows system/system32 folder.\")\n\n\nHMODULE CMiniDumper::GetDebugHelperDll(FARPROC* ppfnMiniDumpWriteDump, bool bShowErrors)\n{\n\t*ppfnMiniDumpWriteDump = NULL;\n\tHMODULE hDll = LoadLibrary(_T(\"DBGHELP.DLL\"));\n\tif (hDll == NULL)\n\t{\n\t\tif (bShowErrors) {\n\t\t\t// Do *NOT* localize that string (in fact, do not use MFC to load it)!\n\t\t\tMessageBox(NULL, _T(\"DBGHELP.DLL not found. Please install a DBGHELP.DLL.\\r\\n\\r\\n\") DBGHELP_HINT, m_szAppName, MB_ICONSTOP | MB_OK);\n\t\t}\n\t}\n\telse\n\t{\n\t\t*ppfnMiniDumpWriteDump = GetProcAddress(hDll, \"MiniDumpWriteDump\");\n\t\tif (*ppfnMiniDumpWriteDump == NULL)\n\t\t{\n\t\t\tif (bShowErrors) {\n\t\t\t\t// Do *NOT* localize that string (in fact, do not use MFC to load it)!\n\t\t\t\tMessageBox(NULL, _T(\"DBGHELP.DLL found is too old. Please upgrade to version 5.1 (or later) of DBGHELP.DLL.\\r\\n\\r\\n\") DBGHELP_HINT, m_szAppName, MB_ICONSTOP | MB_OK);\n\t\t\t}\n\t\t}\n\t}\n\treturn hDll;\n}\n\nLONG CMiniDumper::TopLevelFilter(struct _EXCEPTION_POINTERS* pExceptionInfo)\n{\n\tLONG lRetValue = EXCEPTION_CONTINUE_SEARCH;\n\tTCHAR szResult[MAX_PATH + 1024] = {0};\n\tMINIDUMPWRITEDUMP pfnMiniDumpWriteDump = NULL;\n\tHMODULE hDll = GetDebugHelperDll((FARPROC*)&pfnMiniDumpWriteDump, true);\n\tif (hDll)\n\t{\n\t\tif (pfnMiniDumpWriteDump)\n\t\t{\n\t\t\t// Ask user if they want to save a dump file\n\t\t\t// Do *NOT* localize that string (in fact, do not use MFC to load it)!\n\t\t\tif (MessageBox(NULL, _T(\"Application crashed :-(\\r\\n\\r\\nA diagnostic file can be created which will help the author to resolve this problem. This file will be saved on your Disk (and not sent).\\r\\n\\r\\nDo you want to create this file now?\"), m_szAppName, MB_ICONSTOP | MB_YESNO) == IDYES)\n\t\t\t{\n\t\t\t\t// Create full path for DUMP file\n\t\t\t\tTCHAR szDumpPath[MAX_PATH];\n\t\t\t\t_tcsncpy(szDumpPath, m_szDumpDir, _countof(szDumpPath) - 1);\n\t\t\t\tszDumpPath[_countof(szDumpPath) - 1] = _T('\\0');\n\t\t\t\tsize_t uDumpPathLen = _tcslen(szDumpPath);\n\n\t\t\t\tTCHAR szBaseName[MAX_PATH];\n\t\t\t\t_tcsncpy(szBaseName, m_szAppName, _countof(szBaseName) - 1);\n\t\t\t\tszBaseName[_countof(szBaseName) - 1] = _T('\\0');\n\t\t\t\tsize_t uBaseNameLen = _tcslen(szBaseName);\n\n\t\t\t\ttime_t tNow = time(NULL);\n\t\t\t\t_tcsftime(szBaseName + uBaseNameLen, _countof(szBaseName) - uBaseNameLen, _T(\"_%Y%m%d-%H%M%S\"), localtime(&tNow));\n\t\t\t\tszBaseName[_countof(szBaseName) - 1] = _T('\\0');\n\n\t\t\t\t// Replace spaces and dots in file name.\n\t\t\t\tLPTSTR psz = szBaseName;\n\t\t\t\twhile (*psz != _T('\\0')) {\n\t\t\t\t\tif (*psz == _T('.'))\n\t\t\t\t\t\t*psz = _T('-');\n\t\t\t\t\telse if (*psz == _T(' '))\n\t\t\t\t\t\t*psz = _T('_');\n\t\t\t\t\tpsz++;\n\t\t\t\t}\n\t\t\t\tif (uDumpPathLen < _countof(szDumpPath) - 1) {\n\t\t\t\t\t_tcsncat(szDumpPath, szBaseName, _countof(szDumpPath) - uDumpPathLen - 1);\n\t\t\t\t\tszDumpPath[_countof(szDumpPath) - 1] = _T('\\0');\n\t\t\t\t\tuDumpPathLen = _tcslen(szDumpPath);\n\t\t\t\t\tif (uDumpPathLen < _countof(szDumpPath) - 1) {\n\t\t\t\t\t\t_tcsncat(szDumpPath, _T(\".dmp\"), _countof(szDumpPath) - uDumpPathLen - 1);\n\t\t\t\t\t\tszDumpPath[_countof(szDumpPath) - 1] = _T('\\0');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tHANDLE hFile = CreateFile(szDumpPath, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n\t\t\t\tif (hFile != INVALID_HANDLE_VALUE)\n\t\t\t\t{\n\t\t\t\t\t_MINIDUMP_EXCEPTION_INFORMATION ExInfo = {0};\n\t\t\t\t\tExInfo.ThreadId = GetCurrentThreadId();\n\t\t\t\t\tExInfo.ExceptionPointers = pExceptionInfo;\n\t\t\t\t\tExInfo.ClientPointers = NULL;\n\n\t\t\t\t\tBOOL bOK = (*pfnMiniDumpWriteDump)(GetCurrentProcess(), GetCurrentProcessId(), hFile, MiniDumpNormal, &ExInfo, NULL, NULL);\n\t\t\t\t\tif (bOK)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Do *NOT* localize that string (in fact, do not use MFC to load it)!\n\t\t\t\t\t\t_sntprintf(szResult, _countof(szResult) - 1, _T(\"Saved dump file to \\\"%s\\\".\\r\\n\\r\\nPlease send this file together with a detailed bug report to us !\\r\\n\\r\\nThank you for helping to improve.\"), szDumpPath);\n\t\t\t\t\t\tszResult[_countof(szResult) - 1] = _T('\\0');\n\t\t\t\t\t\tlRetValue = EXCEPTION_EXECUTE_HANDLER;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Do *NOT* localize that string (in fact, do not use MFC to load it)!\n\t\t\t\t\t\t_sntprintf(szResult, _countof(szResult) - 1, _T(\"Failed to save dump file to \\\"%s\\\".\\r\\n\\r\\nError: %u\"), szDumpPath, GetLastError());\n\t\t\t\t\t\tszResult[_countof(szResult) - 1] = _T('\\0');\n\t\t\t\t\t}\n\t\t\t\t\tCloseHandle(hFile);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Do *NOT* localize that string (in fact, do not use MFC to load it)!\n\t\t\t\t\t_sntprintf(szResult, _countof(szResult) - 1, _T(\"Failed to create dump file \\\"%s\\\".\\r\\n\\r\\nError: %u\"), szDumpPath, GetLastError());\n\t\t\t\t\tszResult[_countof(szResult) - 1] = _T('\\0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFreeLibrary(hDll);\n\t\thDll = NULL;\n\t\tpfnMiniDumpWriteDump = NULL;\n\t}\n\n\tif (szResult[0] != _T('\\0'))\n\t\tMessageBox(NULL, szResult, m_szAppName, MB_ICONINFORMATION | MB_OK);\n\n// #ifndef _DEBUG\n// \t// Exit the process only in release builds, so that in debug builds the exception is passed to a possible\n// \t// installed debugger\n// \tExitProcess(0);\n// #else\n// \treturn lRetValue;\n// #endif\n#ifndef _DEBUG\n\t// Exit the process only in release builds, so that in debug builds the exception is passed to a possible\n\t// installed debugger\n\tExitProcess(0);\n#endif\n\treturn lRetValue;\n}\n","size_bytes":7787},"bin/Demo/MfcDemo/09.AccessControl/DlgUserManage.cpp":{"content":"// DlgUserManage.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AccessControl.h\"\n#include \"DlgUserManage.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgUserManage dialog\n\n\nCDlgUserManage::CDlgUserManage(CWnd* pParent /* = NULL */, LLONG hLoginID /* = 0 */, NET_DEVICE_TYPE emDevType /* = NET_PRODUCT_NONE */)\n\t: CDialog(CDlgUserManage::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgUserManage)\n\tm_csNewPasswd = _T(\"\");\n\tm_csCheckPasswd = _T(\"\");\n\tm_csOldPasswd = _T(\"\");\n\tm_hLoginID = hLoginID;\n\tm_emDevType = emDevType;\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CDlgUserManage::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgUserManage)\n\tDDX_Text(pDX, IDC_MODIFYPSW_EDT_NEW, m_csNewPasswd);\n\tDDX_Text(pDX, IDC_MODIFYPSW_EDT_CHECK, m_csCheckPasswd);\n\tDDX_Text(pDX, IDC_MODIFYPSW_EDT_OLD, m_csOldPasswd);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgUserManage, CDialog)\n\t//{{AFX_MSG_MAP(CDlgUserManage)\n\tON_BN_CLICKED(IDC_MODIFYPSW_BTN_CANCEL, OnButtonCancel)\n\tON_BN_CLICKED(IDC_MODIFYPSW_BTN_SET, OnButtonSet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgUserManage message handlers\n\nvoid CDlgUserManage::OnButtonCancel() \n{\n\t// TODO: Add your control notification handler code here\n\tCDialog::OnCancel();\n}\n\nvoid CDlgUserManage::OnButtonSet() \n{\n\t// TODO: Add your control notification handler code here\n\tUpdateData(TRUE);\n\tif (!m_hLoginID)\n\t{\n\t\tMessageBox(ConvertString(\"Please login first.\", DLG_USER), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tif (!m_csOldPasswd.GetLength())\n\t{\n\t\tMessageBox(ConvertString(\"Input old password.\", DLG_USER), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tif (!m_csNewPasswd.GetLength())\n\t{\n\t\tMessageBox(ConvertString(\"Input new password.\", DLG_USER), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tif (!m_csCheckPasswd.GetLength())\n\t{\n\t\tMessageBox(ConvertString(\"Input check password.\", DLG_USER), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tif (m_csCheckPasswd != m_csNewPasswd)\n\t{\n\t\tMessageBox(ConvertString(\"Two passwords are different, please check again.\", DLG_USER), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tUSER_INFO_NEW stuOldInfo = {sizeof(stuOldInfo)};\n\tGetDlgItemText(IDC_MODIFYPSW_EDT_NAME, stuOldInfo.name, sizeof(stuOldInfo.name) - 1);\t\n\tstrncpy(stuOldInfo.passWord, m_csOldPasswd.GetBuffer(0), sizeof(stuOldInfo.passWord) - 1);\n\n\tUSER_INFO_NEW stuModifiedInfo = {sizeof(stuModifiedInfo)};\n\tstrncpy(stuModifiedInfo.passWord, m_csNewPasswd.GetBuffer(0), sizeof(stuModifiedInfo.passWord)-1);\n\n\tBOOL bRet = CLIENT_OperateUserInfoNew(m_hLoginID, 6, &stuModifiedInfo, &stuOldInfo, NULL, 3000);\n\tif (bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Modify password successfully.\", DLG_USER), ConvertString(\"Prompt\"));\n\t}\n\telse\n\t{\n\t\tCString csOut;\n\t\tcsOut.Format(\"%s %08x\", ConvertString(\"Modify password failed:\", DLG_USER), CLIENT_GetLastError());\n\t\tMessageBox(csOut, ConvertString(\"Prompt\"));\n\t}\n}\n\nBOOL CDlgUserManage::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_USER);\n\n\t// TODO: Add extra initialization here\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n","size_bytes":3349},"bin/Demo/MfcDemo/09.AccessControl/RecordSetFinder.cpp":{"content":"// RecordSetFinder.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"accesscontrol.h\"\n#include \"RecordSetFinder.h\"\n\n#include \"SubDlgInfoCard.h\"\n#include \"DlgSubDlgInfoAccessRecord.h\"\n#include \"DlgSubDlgInfoHoliday.h\"\n#include \"DlgSubDlgInfoPassword.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CRecordSetFinder dialog\n\n\nCRecordSetFinder::CRecordSetFinder(CWnd* pParent /* = NULL */, LLONG lLoginID /* = 0 */, int nAccess /* = 1 */)\n\t: CDialog(CRecordSetFinder::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CRecordSetFinder)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_lLoginID      = lLoginID;\n    m_lFinder       = 0;\n    m_nStartSeq     = 0;\n\tm_emDataType    = DataType_Access;\n    m_nAccessGroup  = nAccess;\n}\n\n\nvoid CRecordSetFinder::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CRecordSetFinder)\n\tDDX_Control(pDX, IDC_RECORDSETFINDER_CMB_RESULT, m_cmbResult);\n\tDDX_Control(pDX, IDC_RECORDSETFINDER_CMB_DATATYPE, m_cmbDataType);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CRecordSetFinder, CDialog)\n\t//{{AFX_MSG_MAP(CRecordSetFinder)\n    ON_BN_CLICKED(IDC_RECORDSETFINDER_BTN_QUERYSTART, OnRecordsetfinderBtnQueryStart)\n    ON_BN_CLICKED(IDC_RECORDSETFINDER_BTN_QUERYNEXT, OnRecordsetfinderBtnQueryNext)\n\tON_BN_CLICKED(IDC_RECORDSETFINDER_BTN_QUERYSTOP, OnRecordsetfinderBtnQueryStop)\n\tON_WM_DESTROY()\n\tON_CBN_SELCHANGE(IDC_RECORDSETFINDER_CMB_RESULT, OnSelchangeRecordsetfinderCmbResult)\n\tON_CBN_SELCHANGE(IDC_RECORDSETFINDER_CMB_DATATYPE, OnSelchangeRecordsetfinderCmbDatatype)\n\tON_BN_CLICKED(IDC_RECORDSETFINDER_BTN_COUNT, OnRecordsetfinderBtnCount)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CRecordSetFinder private method\n\nvoid CRecordSetFinder::InitDlg()\n{\n    GetDlgItem(IDC_RECORDSETFINDER_BTN_QUERYSTART)->EnableWindow();\n    GetDlgItem(IDC_RECORDSETFINDER_BTN_QUERYNEXT)->EnableWindow(FALSE);\n    GetDlgItem(IDC_RECORDSETFINDER_BTN_QUERYSTOP)->EnableWindow(FALSE);\n    GetDlgItem(IDC_RECORDSETFINDER_BTN_COUNT)->EnableWindow(FALSE);\n\n\t// data type\n\tm_cmbDataType.ResetContent();\n    int nWidth = m_cmbDataType.GetDroppedWidth();\n    m_cmbDataType.SetDroppedWidth(nWidth * 2);\n\tfor (int i = 0; i < sizeof(stuDemoDataType)/sizeof(stuDemoDataType[0]); i++)\n\t{\n\t\tm_cmbDataType.InsertString(-1, ConvertString(stuDemoDataType[i].szName));\n\t}\n\tm_cmbDataType.SetCurSel(0);\n\n\t// max num\n\tSetDlgItemInt(IDC_RECORDSETFINDER_EDT_MAXNUM, 10);\n\n\t// ret num\n\tSetDlgItemInt(IDC_RECORDSETFINDER_EDT_RETNUM, 0);\n\n\t// result\n\tClearResult();\n}\n\nvoid CRecordSetFinder::ClearResult()\n{\n\twhile (m_cmbResult.GetCount())\n\t{\n\t\tint nIndex = 0;\n\t\tvoid* dwData = m_cmbResult.GetItemDataPtr(nIndex);\n\n\t\tif (DataType_Card == m_emDataType)\n\t\t{\n\t\t\tNET_RECORDSET_ACCESS_CTL_CARD* p = (NET_RECORDSET_ACCESS_CTL_CARD*)dwData;\n\t\t\tif (p)\n\t\t\t{\n\t\t\t\tdelete p;\n\t\t\t\tp = NULL;\n\t\t\t}\n\t\t}\n\t\telse if (DataType_Password == m_emDataType)\n\t\t{\n\t\t\tNET_RECORDSET_ACCESS_CTL_PWD* p = (NET_RECORDSET_ACCESS_CTL_PWD*)dwData;\n\t\t\tif (p)\n\t\t\t{\n\t\t\t\tdelete p;\n\t\t\t\tp = NULL;\n\t\t\t}\n\t\t}\n\t\telse if (DataType_Access == m_emDataType)\n\t\t{\n\t\t\tNET_RECORDSET_ACCESS_CTL_CARDREC* p = (NET_RECORDSET_ACCESS_CTL_CARDREC*)dwData;\n\t\t\tif (p)\n\t\t\t{\n\t\t\t\tdelete p;\n\t\t\t\tp = NULL;\n\t\t\t}\n\t\t}\n\n\t\tm_cmbResult.DeleteString(nIndex);\n\t}\n\tm_cmbResult.ResetContent();\n}\n//////////////////////////////////////////////////////////////////////////\n//\n// card\n//\n//////////////////////////////////////////////////////////////////////////\nBOOL CRecordSetFinder::QueryCard()\n{\t\n\tLLONG lFinderID = 0;\n\tRecordSetFind_Card(m_lLoginID, lFinderID);\n\tif (lFinderID != 0)\n\t{\n\t\tRecordSetFindNext_Card(lFinderID);\n\t\tCLIENT_FindRecordClose(lFinderID);\n\t\treturn TRUE;\n\t}\n\telse\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%s:%08x\", ConvertString(\"Start to find failed\", DLG_RECORDSET_FINDER), CLIENT_GetLastError());\n\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t}\n\n\treturn FALSE;\n}\n\nvoid CRecordSetFinder::RecordSetFind_Card(LLONG lLoginId, LLONG& lFinderId)\n{\n\tNET_IN_FIND_RECORD_PARAM stuIn = {sizeof(stuIn)};\n\tNET_OUT_FIND_RECORD_PARAM stuOut = {sizeof(stuOut)};\n\t\n\tstuIn.emType = NET_RECORD_ACCESSCTLCARD;\n\t\t\n\tif (CLIENT_FindRecord(lLoginId, &stuIn, &stuOut, SDK_API_WAITTIME))\n\t{\n\t\tlFinderId = stuOut.lFindeHandle;\n\t}\n}\n\nint CRecordSetFinder::RecordSetFindNext_Card(LLONG lFinderId)\n{\n\tint i = 0, j = 0;\n\tint nMaxNum = GetDlgItemInt(IDC_RECORDSETFINDER_EDT_MAXNUM, NULL, TRUE);\n\tif (nMaxNum <= 0)\n\t{\n\t\treturn -1;\n\t}\n\tNET_IN_FIND_NEXT_RECORD_PARAM stuIn = {sizeof(stuIn)};\n\tstuIn.lFindeHandle = lFinderId;\n\tstuIn.nFileCount = nMaxNum;\n\t\n\tNET_OUT_FIND_NEXT_RECORD_PARAM stuOut = {sizeof(stuOut)};\n\tstuOut.nMaxRecordNum = nMaxNum;\n\t\n\tNET_RECORDSET_ACCESS_CTL_CARD* pstuCard = new NET_RECORDSET_ACCESS_CTL_CARD[nMaxNum];\n\tif (NULL == pstuCard)\n\t{\n\t\treturn -1;\n\t}\n\tmemset(pstuCard, 0, sizeof(NET_RECORDSET_ACCESS_CTL_CARD) * nMaxNum);\n\n\tfor (i = 0; i < nMaxNum; i++)\n\t{\n\t\tpstuCard[i].dwSize = sizeof(NET_RECORDSET_ACCESS_CTL_CARD);\n\t}\n\tstuOut.pRecordList = (void*)pstuCard;\n\t\n\tif (CLIENT_FindNextRecord(&stuIn, &stuOut, SDK_API_WAITTIME) >= 0)\n    {\n        if (stuOut.nRetRecordNum > 0)\n        {\n            ClearResult();\n        }\n\t\tfor (i = 0; i < __min(stuOut.nMaxRecordNum, stuOut.nRetRecordNum); i++)\n\t\t{\n\t\t\tCString csInfo;\n\t\t\tcsInfo.Format(\"%d\", m_nStartSeq + 1);\n            m_nStartSeq++;\n\t\t\tint nIndex = m_cmbResult.InsertString(-1, csInfo);\n\n\t\t\tNET_RECORDSET_ACCESS_CTL_CARD* p = new NET_RECORDSET_ACCESS_CTL_CARD;\n\t\t\tif (p != NULL)\n\t\t\t{\n\t\t\t\tmemcpy(p, &pstuCard[i], sizeof(NET_RECORDSET_ACCESS_CTL_CARD));\n\t\t\t\tm_cmbResult.SetItemDataPtr(nIndex, (void*)p);\n\t\t\t}\n\t\t}\n\t\tSetDlgItemInt(IDC_RECORDSETFINDER_EDT_RETNUM, stuOut.nRetRecordNum);\n\t}\n\telse\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%s:%08x\", ConvertString(\"Find card failed\", DLG_RECORDSET_FINDER), CLIENT_GetLastError());\n\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t}\n\n\tdelete[] pstuCard;\n\tpstuCard = NULL;\n    return stuOut.nRetRecordNum;\n}\n\nvoid CRecordSetFinder::ShowCard(NET_RECORDSET_ACCESS_CTL_CARD* pInfo)\n{\n\tif (NULL == pInfo)\n\t{\n\t\treturn;\n\t}\n\tCSubDlgInfoCard dlg(this, pInfo, m_nAccessGroup);\n\tdlg.DoModal();\n}\n//////////////////////////////////////////////////////////////////////////\n//\n// pwd\n//\n//////////////////////////////////////////////////////////////////////////\nBOOL CRecordSetFinder::QueryPwd()\n{\n\tLLONG lFinderID = 0;\n\tRecordSetFind_Pwd(m_lLoginID, lFinderID);\n\tif (lFinderID != 0)\n\t{\n\t\tRecordSetFindNext_Pwd(lFinderID);\n\t\tCLIENT_FindRecordClose(lFinderID);\n\t\treturn TRUE;\n\t}\n\telse\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%s:%08x\", ConvertString(\"Start to find failed\", DLG_RECORDSET_FINDER), CLIENT_GetLastError());\n\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t}\n\t\n\treturn FALSE;\n}\n\nvoid CRecordSetFinder::RecordSetFind_Pwd(LLONG lLoginId, LLONG& lFinderId)\n{\n\tNET_IN_FIND_RECORD_PARAM stuIn = {sizeof(stuIn)};\n\tNET_OUT_FIND_RECORD_PARAM stuOut = {sizeof(stuOut)};\n\t\n\tstuIn.emType = NET_RECORD_ACCESSCTLPWD;\n\t\n\tif (CLIENT_FindRecord(lLoginId, &stuIn, &stuOut, SDK_API_WAITTIME))\n\t{\n\t\tlFinderId = stuOut.lFindeHandle;\n\t}\n}\n\nint CRecordSetFinder::RecordSetFindNext_Pwd(LLONG lFinderId)\n{\n\tint i = 0, j = 0;\n\tint nMaxNum = GetDlgItemInt(IDC_RECORDSETFINDER_EDT_MAXNUM, NULL, TRUE);\n\tif (nMaxNum <= 0)\n\t{\n\t\treturn -1;\n\t}\n\t\n\tNET_IN_FIND_NEXT_RECORD_PARAM stuIn = {sizeof(stuIn)};\n\tstuIn.lFindeHandle = lFinderId;\n\tstuIn.nFileCount = nMaxNum;\n\t\n\tNET_OUT_FIND_NEXT_RECORD_PARAM stuOut = {sizeof(stuOut)};\n\tstuOut.nMaxRecordNum = nMaxNum;\n\t\n\tNET_RECORDSET_ACCESS_CTL_PWD* pstuPwd = new NET_RECORDSET_ACCESS_CTL_PWD[nMaxNum];\n\tif (NULL == pstuPwd)\n\t{\n\t\treturn -1;\n\t}\n\tmemset(pstuPwd, 0, sizeof(NET_RECORDSET_ACCESS_CTL_PWD) * nMaxNum);\n\t\n\tfor (i = 0; i < nMaxNum; i++)\n\t{\n\t\tpstuPwd[i].dwSize = sizeof(NET_RECORDSET_ACCESS_CTL_PWD);\n\t}\n\tstuOut.pRecordList = (void*)pstuPwd;\n\t\n\tif (CLIENT_FindNextRecord(&stuIn, &stuOut, SDK_API_WAITTIME) >= 0)\n\t{\n        if (stuOut.nRetRecordNum > 0)\n        {\n            ClearResult();\n        }\n\t\tfor (i = 0; i < __min(stuOut.nMaxRecordNum, stuOut.nRetRecordNum); i++)\n\t\t{\n\t\t\tCString csInfo;\n\t\t\tcsInfo.Format(\"%d\", m_nStartSeq + 1);\n            m_nStartSeq++;\n\t\t\tint nIndex = m_cmbResult.InsertString(-1, csInfo);\n\n\t\t\tNET_RECORDSET_ACCESS_CTL_PWD* p = new NET_RECORDSET_ACCESS_CTL_PWD;\n\t\t\tif (p != NULL)\n\t\t\t{\n\t\t\t\tmemcpy(p, &pstuPwd[i], sizeof(NET_RECORDSET_ACCESS_CTL_PWD));\n\t\t\t\tm_cmbResult.SetItemDataPtr(nIndex, (void*)p);\n\t\t\t}\n\t\t}\n\t\tSetDlgItemInt(IDC_RECORDSETFINDER_EDT_RETNUM, stuOut.nRetRecordNum);\n\t}\n\telse\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%s:%08x\", ConvertString(\"Find pwd failed\", DLG_RECORDSET_FINDER), CLIENT_GetLastError());\n\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t}\n\t\n\tdelete[] pstuPwd;\n\tpstuPwd = NULL;\n    return stuOut.nRetRecordNum;\n}\n\nvoid CRecordSetFinder::ShowPwd(NET_RECORDSET_ACCESS_CTL_PWD* pInfo)\n{\n\tif (NULL == pInfo)\n\t{\n\t\treturn;\n\t}\n\tCDlgSubDlgInfoPassword dlg(this, pInfo, m_nAccessGroup);\n\tdlg.DoModal();\n}\n//////////////////////////////////////////////////////////////////////////\n//\n// cardrec\n//\n//////////////////////////////////////////////////////////////////////////\nBOOL CRecordSetFinder::QueryCardRec()\n{\n\tLLONG lFinderID = 0;\n\tRecordSetFind_CardRec(m_lLoginID, lFinderID);\n\tif (lFinderID != 0)\n\t{\n\t\tRecordSetFindNext_CardRec(lFinderID);\n\t\tCLIENT_FindRecordClose(lFinderID);\n\t\treturn TRUE;\n\t}\n\telse\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%s:%08x\", ConvertString(\"Start to find failed\", DLG_RECORDSET_FINDER), CLIENT_GetLastError());\n\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t}\n\t\n\treturn FALSE;\n}\n\nvoid CRecordSetFinder::RecordSetFind_CardRec(LLONG lLoginId, LLONG& lFinderId)\n{\n\tNET_IN_FIND_RECORD_PARAM stuIn = {sizeof(stuIn)};\n\tNET_OUT_FIND_RECORD_PARAM stuOut = {sizeof(stuOut)};\n\t\n\tstuIn.emType = NET_RECORD_ACCESSCTLCARDREC;\n\t\n\tif (CLIENT_FindRecord(lLoginId, &stuIn, &stuOut, SDK_API_WAITTIME))\n\t{\n\t\tlFinderId = stuOut.lFindeHandle;\n        GetDlgItem(IDC_RECORDSETFINDER_EDT_MAXNUM)->EnableWindow(FALSE);\n\t}\n}\n\nint CRecordSetFinder::RecordSetFindNext_CardRec(LLONG lFinderId)\n{\n\tint i = 0, j = 0;\n\tint nMaxNum = GetDlgItemInt(IDC_RECORDSETFINDER_EDT_MAXNUM, NULL, TRUE);\n\tif (nMaxNum <= 0)\n\t{\n\t\treturn -1;\n\t}\n\t\n\tNET_IN_FIND_NEXT_RECORD_PARAM stuIn = {sizeof(stuIn)};\n\tstuIn.lFindeHandle = lFinderId;\n\tstuIn.nFileCount = nMaxNum;\n\t\n\tNET_OUT_FIND_NEXT_RECORD_PARAM stuOut = {sizeof(stuOut)};\n\tstuOut.nMaxRecordNum = nMaxNum;\n\t\n\tNET_RECORDSET_ACCESS_CTL_CARDREC* pstuCardRec = new NET_RECORDSET_ACCESS_CTL_CARDREC[nMaxNum];\n\tif (NULL == pstuCardRec)\n\t{\n\t\treturn -1;\n\t}\n\tmemset(pstuCardRec, 0, sizeof(NET_RECORDSET_ACCESS_CTL_CARDREC) * nMaxNum);\n\t\n\tfor (i = 0; i < nMaxNum; i++)\n\t{\n\t\tpstuCardRec[i].dwSize = sizeof(NET_RECORDSET_ACCESS_CTL_CARDREC);\n\t}\n\tstuOut.pRecordList = (void*)pstuCardRec;\n\t\n\tif (CLIENT_FindNextRecord(&stuIn, &stuOut, SDK_API_WAITTIME) >= 0)\n\t{\n        if (stuOut.nRetRecordNum > 0)\n        {\n            ClearResult();\n        }\n\t\tfor (i = 0; i < __min(stuOut.nMaxRecordNum, stuOut.nRetRecordNum); i++)\n\t\t{\n\t\t\tCString csInfo;\n            csInfo.Format(\"%d\", m_nStartSeq + 1);\n            m_nStartSeq++;\n\t\t\tint nIndex = m_cmbResult.InsertString(-1, csInfo);\n\n\t\t\tNET_RECORDSET_ACCESS_CTL_CARDREC* p = new NET_RECORDSET_ACCESS_CTL_CARDREC;\n\t\t\tif (p != NULL)\n\t\t\t{\n\t\t\t\tmemcpy(p, &pstuCardRec[i], sizeof(NET_RECORDSET_ACCESS_CTL_CARDREC));\n\t\t\t\tm_cmbResult.SetItemDataPtr(nIndex, (void*)p);\n\t\t\t}\n\t\t}\n\t\tSetDlgItemInt(IDC_RECORDSETFINDER_EDT_RETNUM, stuOut.nRetRecordNum);\n\t}\n\telse\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%s:%08x\", ConvertString(\"Find CardRec failed\", DLG_RECORDSET_FINDER), CLIENT_GetLastError());\n\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t}\n\t\n\tdelete[] pstuCardRec;\n\tpstuCardRec = NULL;\n    return stuOut.nRetRecordNum;\n}\n\nvoid CRecordSetFinder::ShowCardRec(NET_RECORDSET_ACCESS_CTL_CARDREC* pInfo)\n{\n\tif (NULL == pInfo)\n\t{\n\t\treturn;\n\t}\n\tCDlgSubDlgInfoAccessRecord dlg(this, pInfo);\n\tdlg.DoModal();\n}\n/////////////////////////////////////////////////////////////////////////////\n// CRecordSetFinder message handlers\n\nBOOL CRecordSetFinder::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_RECORDSET_FINDER);\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n//////////////////////////////////////////////////////////////////////////\n//\n// query start\n//\n//////////////////////////////////////////////////////////////////////////\nvoid CRecordSetFinder::OnRecordsetfinderBtnQueryStart() \n{\n\t// TODO: Add your control notification handler code here\n\tClearResult();\n    \n    LLONG lFinder = 0;\n\n\tswitch (m_cmbDataType.GetCurSel())\n\t{\n\tcase DataType_Card:\n        RecordSetFind_Card(m_lLoginID, lFinder);\n\t\tbreak;\n\tcase DataType_Password:\n        RecordSetFind_Pwd(m_lLoginID, lFinder);\n\t\tbreak;\n\tcase DataType_Access:\n        RecordSetFind_CardRec(m_lLoginID, lFinder);\n\t\tbreak;\n// \tcase DataType_Holiday: // not support by BSC\n// \t\tQueryHoliday();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n    }\n\n    if (lFinder != 0)\n    {\n        m_lFinder = lFinder;\n        GetDlgItem(IDC_RECORDSETFINDER_CMB_DATATYPE)->EnableWindow(FALSE);\n        GetDlgItem(IDC_RECORDSETFINDER_EDT_MAXNUM)->EnableWindow(FALSE);\n        GetDlgItem(IDC_RECORDSETFINDER_BTN_QUERYSTART)->EnableWindow(FALSE);\n        GetDlgItem(IDC_RECORDSETFINDER_BTN_QUERYNEXT)->EnableWindow();\n        GetDlgItem(IDC_RECORDSETFINDER_BTN_QUERYSTOP)->EnableWindow();\n        GetDlgItem(IDC_RECORDSETFINDER_BTN_COUNT)->EnableWindow();\n    }\n\tm_emDataType = (DataType)m_cmbDataType.GetCurSel();\n}\n//////////////////////////////////////////////////////////////////////////\n//\n// query next\n//\n//////////////////////////////////////////////////////////////////////////\nvoid CRecordSetFinder::OnRecordsetfinderBtnQueryNext()\n{\n\tint nMaxNum = GetDlgItemInt(IDC_RECORDSETFINDER_EDT_MAXNUM, NULL, TRUE);\n    if (nMaxNum <= 0)\n    {\n        return;\n    }\n\n    int nRet = 0;\n    switch (m_cmbDataType.GetCurSel())\n    {\n    case DataType_Card:\n        nRet = RecordSetFindNext_Card(m_lFinder);\n        break;\n    case DataType_Password:\n        nRet = RecordSetFindNext_Pwd(m_lFinder);\n        break;\n    case DataType_Access:\n        nRet = RecordSetFindNext_CardRec(m_lFinder);\n        break;\n    default:\n        break;\n    }\n    if (nRet <= 0 || nRet < nMaxNum)\n    {\n        GetDlgItem(IDC_RECORDSETFINDER_BTN_QUERYNEXT)->EnableWindow(FALSE);\n    }\n    if (nRet > 0)\n    {\n        m_cmbResult.SetCurSel(0);\n    }\n}\n\nvoid CRecordSetFinder::OnRecordsetfinderBtnQueryStop()\n{\n    CLIENT_FindRecordClose(m_lFinder);\n    m_lFinder = 0;\n    m_nStartSeq = 0;\n    GetDlgItem(IDC_RECORDSETFINDER_CMB_DATATYPE)->EnableWindow();\n    GetDlgItem(IDC_RECORDSETFINDER_EDT_MAXNUM)->EnableWindow();\n    GetDlgItem(IDC_RECORDSETFINDER_BTN_QUERYSTART)->EnableWindow();\n    GetDlgItem(IDC_RECORDSETFINDER_BTN_QUERYNEXT)->EnableWindow(FALSE);\n    GetDlgItem(IDC_RECORDSETFINDER_BTN_QUERYSTOP)->EnableWindow(FALSE);\n    GetDlgItem(IDC_RECORDSETFINDER_BTN_COUNT)->EnableWindow(FALSE);\n    ClearResult();\n\tSetDlgItemInt(IDC_RECORDSETFINDER_EDT_RETNUM, 0);\n}\n\nvoid CRecordSetFinder::OnDestroy() \n{\n\tCDialog::OnDestroy();\n\t\n\t// TODO: Add your message handler code here\n\tClearResult();\n    if (m_lFinder != 0)\n    {\n        CLIENT_FindRecordClose(m_lFinder);\n    }\n}\n\nvoid CRecordSetFinder::OnSelchangeRecordsetfinderCmbResult() \n{\n\t// TODO: Add your control notification handler code here\n\tint nSel = m_cmbResult.GetCurSel();\n\tif (-1 == nSel)\n\t{\n\t\treturn;\n\t}\n\t\n\tvoid* p = m_cmbResult.GetItemDataPtr(nSel);\n    if (NULL == p)\n    {\n        return;\n    }\n\n\tswitch (m_cmbDataType.GetCurSel())\n\t{\n\tcase DataType_Card:\n\t\tShowCard((NET_RECORDSET_ACCESS_CTL_CARD*)p);\n\t\tbreak;\n\tcase DataType_Access:\n\t\tShowCardRec((NET_RECORDSET_ACCESS_CTL_CARDREC*)p);\n\t\tbreak;\n\tcase DataType_Password:\n\t\tShowPwd((NET_RECORDSET_ACCESS_CTL_PWD*)p);\n\t\tbreak;\n// \tcase DataType_Holiday:\n// \t\tShowHoliday((NET_RECORDSET_HOLIDAY*)p);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid CRecordSetFinder::OnSelchangeRecordsetfinderCmbDatatype() \n{\n\t// TODO: Add your control notification handler code here\n\tClearResult();\n\tSetDlgItemInt(IDC_RECORDSETFINDER_EDT_RETNUM, 0);\n\tm_emDataType = (DataType)m_cmbDataType.GetCurSel();\n}\n\nvoid CRecordSetFinder::OnRecordsetfinderBtnCount() \n{\n\t// TODO: Add your control notification handler code here\n    NET_IN_QUEYT_RECORD_COUNT_PARAM stuIn = {sizeof(stuIn)};\n    stuIn.lFindeHandle = m_lFinder;\n    NET_OUT_QUEYT_RECORD_COUNT_PARAM stuOut = {sizeof(stuOut)};\n    if (CLIENT_QueryRecordCount(&stuIn, &stuOut, SDK_API_WAITTIME))\n    {\n        CString csInfo;\n        csInfo.Format(\"%s %d\",\n            ConvertString((\"Total count is\"), DLG_RECORDSET_FINDER),\n            stuOut.nRecordCount);\n        MessageBox(csInfo, ConvertString(\"Prompt\"));\n    }\n    else\n    {\n        CString csInfo;\n        csInfo.Format(\"%s:0x%08x\",\n            ConvertString(\"Get total count failed\", DLG_RECORDSET_FINDER),\n            CLIENT_GetLastError());\n        MessageBox(csInfo, ConvertString(\"Prompt\"));\n    }\n}\n","size_bytes":17177},"bin/Demo/MfcDemo/10.AlarmDevice/AirConditionOperate.cpp":{"content":"// AirConditionOperate.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"alarmdevice.h\"\n#include \"AirConditionOperate.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CAirConditionOperate dialog\n\n\nCAirConditionOperate::CAirConditionOperate(CWnd* pParent /*=NULL*/, LLONG lLoginId /*= 0*/)\n\t: CDialog(CAirConditionOperate::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CAirConditionOperate)\n\tm_lLoginID = lLoginId;\n\tm_fActualTemp = 0.0f;\n    m_nAdjustTemp = 0;\n\tm_nTempState = 0;\n    m_nTemp = 26;\n\tm_nWaitTime = SDK_API_WAIT;\n\tmemset(&m_stuInfo, 0, sizeof(m_stuInfo));\n\tmemset(&m_stuState, 0, sizeof(m_stuState));\n\tm_stuState.dwSize = sizeof(m_stuState);\n\t//}}AFX_DATA_INIT\n}\n\nvoid CAirConditionOperate::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CAirConditionOperate)\n    DDX_Control(pDX, IDC_AIRCONDITION_CMB_DEVICEID, m_cmbDevID);\n    DDX_Control(pDX, IDC_AIRCONDITION_CHECK_ON, m_ctlON);\n    DDX_Control(pDX, IDC_AIRCONDITION_CHECK_ONLINE, m_ctlONLine);\n\tDDX_Text(pDX, IDC_AIRCONDITION_EDT_TEMP, m_nTempState);\n    DDX_Control(pDX, IDC_AIRCONDITION_CMB_MODE, m_cmbModeState);\n    DDX_Control(pDX, IDC_AIRCONDITION_CMB_WINDMODE, m_cmbWindModeState);\n    DDX_Control(pDX, IDC_AIRCONDITION_CMB_SET_MODE, m_cmbMode);\n    DDX_Control(pDX, IDC_AIRCONDITION_CMB_SET_WINDMODE, m_cmbWindMode);\n\tDDX_Text(pDX, IDC_AIRCONDITION_EDT_ACTUALTEMP, m_fActualTemp);\n    DDX_Text(pDX, IDC_AIRCONDITION_EDT_SETTEMP, m_nTemp);\n    DDX_Text(pDX, IDC_AIRCONDITION_EDT_ADJUSTTEMP, m_nAdjustTemp);\n\tDDX_Text(pDX, IDC_AIRCONDITION_EDT_TIME, m_nWaitTime);\n\t\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CAirConditionOperate, CDialog)\n\t//{{AFX_MSG_MAP(CAirConditionOperate)\n\tON_BN_CLICKED(IDC_AIRCONDITION_BTN_OPEN, OnAirconditionBtnOpen)\n\tON_BN_CLICKED(IDC_AIRCONDITION_BTN_CLOSE, OnAirconditionBtnClose)\n\tON_BN_CLICKED(IDC_AIRCONDITION_BTN_MODE, OnAirconditionBtnMode)\n\tON_BN_CLICKED(IDC_AIRCONDITION_BTN_TEMP, OnAirconditionBtnTemp)\n\tON_BN_CLICKED(IDC_AIRCONDITION_BTN_WINDMODE, OnAirconditionBtnWindmode)\n\tON_BN_CLICKED(IDC_AIRCONDITION_BTN_ADJUST, OnAirconditionBtnAdjust)\n\tON_BN_CLICKED(IDC_AIRCONDITION_BTN_GET_STATE, OnAirconditionBtnGetState)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CAirConditionOperate message handlers\n\nvoid CAirConditionOperate::InitDlg()\n{\n    m_cmbMode.ResetContent();\n    int i = 0;\n    for (i = 0; i < sizeof(stuDemoAirConditionMode) / sizeof(stuDemoAirConditionMode[0]); i++)\n    {\n        m_cmbMode.InsertString(-1, ConvertString(stuDemoAirConditionMode[i].pszName, DLG_CFG_AIRCONDITION));\n    }\n    m_cmbMode.SetCurSel(-1);\n    \n    m_cmbWindMode.ResetContent();\n    for (i = 0; i < sizeof(stuDemoWindMode) / sizeof(stuDemoWindMode[0]); i++)\n    {\n        m_cmbWindMode.InsertString(-1, ConvertString(stuDemoWindMode[i].pszName, DLG_CFG_AIRCONDITION));\n    }\n    m_cmbWindMode.SetCurSel(-1);\n    \n    m_cmbModeState.ResetContent();\n    for (i = 0; i < sizeof(stuDemoAirConditionMode) / sizeof(stuDemoAirConditionMode[0]); i++)\n    {\n        m_cmbModeState.InsertString(-1, ConvertString(stuDemoAirConditionMode[i].pszName, DLG_CFG_AIRCONDITION));\n    }\n    m_cmbModeState.SetCurSel(-1);\n    \n    m_cmbWindModeState.ResetContent();\n    for (i = 0; i < sizeof(stuDemoWindMode) / sizeof(stuDemoWindMode[0]); i++)\n    {\n        m_cmbWindModeState.InsertString(-1, ConvertString(stuDemoWindMode[i].pszName, DLG_CFG_AIRCONDITION));\n    }\n    m_cmbWindModeState.SetCurSel(-1);\n    \n    m_ctlON.SetCheck(BST_UNCHECKED);\n    m_ctlONLine.SetCheck(BST_UNCHECKED);\n\tUpdateData(FALSE);\n}\n\nBOOL CAirConditionOperate::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_AIRCONDITION_OPERATE);\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\tif (TRUE == GetConfig())\n\t{\n\t\tGetState();\n        StuToDlg();\n\t}\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t// EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CAirConditionOperate::OnAirconditionBtnOpen() \n{\n\t// TODO: Add your control notification handler code here\n\tUpdateData(TRUE);\n    int nCurrentDevID = m_cmbDevID.GetCurSel();\n    if (0 > nCurrentDevID \n        || m_stuInfo.nAirConditionNum <= nCurrentDevID\n        || MAX_AIRCONDITION_NUM <= nCurrentDevID)\n    {\n        return;\n    }\n    int nRetLen = 0;\n    NET_CTRL_OPEN_AIRCONDITION stuOperate = {0};\n    stuOperate.dwSize = sizeof(NET_CTRL_OPEN_AIRCONDITION);\n    memcpy(stuOperate.szDeviceID, m_stuInfo.stuAirConditions[nCurrentDevID].szDeviceID, MAX_DEVICE_ID_LEN);\n    BOOL bRet = CLIENT_ControlDevice(m_lLoginID, DH_CTRL_AIRCONDITION_OPEN, &stuOperate, m_nWaitTime);\n    if (FALSE == bRet)\n    {\n        CString csInfo;\n        csInfo.Format(\"%s:%08x\", ConvertString(\"Open AirCondition error\", DLG_AIRCONDITION_OPERATE), CLIENT_GetLastError());\n        MessageBox(csInfo, ConvertString(\"Prompt\"));\n    }\n}\n\nvoid CAirConditionOperate::OnAirconditionBtnClose() \n{\n\t// TODO: Add your control notification handler code here\n\tUpdateData(TRUE);\n    int nCurrentDevID = m_cmbDevID.GetCurSel();\n    if (0 > nCurrentDevID \n        || m_stuInfo.nAirConditionNum <= nCurrentDevID\n        || MAX_AIRCONDITION_NUM <= nCurrentDevID)\n    {\n        return;\n    }\n    int nRetLen = 0;\n    NET_CTRL_CLOSE_AIRCONDITION stuOperate = {0};\n    stuOperate.dwSize = sizeof(NET_CTRL_CLOSE_AIRCONDITION);\n    memcpy(stuOperate.szDeviceID, m_stuInfo.stuAirConditions[nCurrentDevID].szDeviceID, MAX_DEVICE_ID_LEN);\n    BOOL bRet = CLIENT_ControlDevice(m_lLoginID, DH_CTRL_AIRCONDITION_CLOSE, &stuOperate, m_nWaitTime);\n    if (FALSE == bRet)\n    {\n        CString csInfo;\n        csInfo.Format(\"%s:%08x\", ConvertString(\"Close AirCondition error\", DLG_AIRCONDITION_OPERATE), CLIENT_GetLastError());\n        MessageBox(csInfo, ConvertString(\"Prompt\"));\n    }\n\t\n}\n\nvoid CAirConditionOperate::OnAirconditionBtnMode() \n{\n\t// TODO: Add your control notification handler code here\n    UpdateData(TRUE);\n\tint nCurrentDevID = m_cmbDevID.GetCurSel();\n    if (0 > nCurrentDevID \n        || m_stuInfo.nAirConditionNum <= nCurrentDevID\n        || MAX_AIRCONDITION_NUM <= nCurrentDevID)\n    {\n        return;\n    }\n    int nRetLen = 0;\n    NET_CTRL_AIRCONDITION_SETMODE stuOperate = {0};\n    stuOperate.dwSize = sizeof(NET_CTRL_AIRCONDITION_SETMODE);\n\tstuOperate.emAirconditionMode = (EM_AIRCONDITION_MODE)(m_cmbMode.GetCurSel() + 1);\n    stuOperate.nTemperature = m_nTemp;\n    memcpy(stuOperate.szDeviceID, m_stuInfo.stuAirConditions[nCurrentDevID].szDeviceID, MAX_DEVICE_ID_LEN);\n    BOOL bRet = CLIENT_ControlDevice(m_lLoginID, DH_CTRL_AIRCONDITION_SETMODE, &stuOperate, m_nWaitTime);\n    if (FALSE == bRet)\n    {\n        CString csInfo;\n        csInfo.Format(\"%s:%08x\", ConvertString(\"Set Mode error\", DLG_AIRCONDITION_OPERATE), CLIENT_GetLastError());\n        MessageBox(csInfo, ConvertString(\"Prompt\"));\n    }\n}\n\nvoid CAirConditionOperate::OnAirconditionBtnTemp() \n{\n\t// TODO: Add your control notification handler code here\n    UpdateData(TRUE);\n    int nCurrentDevID = m_cmbDevID.GetCurSel();\n    if (0 > nCurrentDevID \n        || m_stuInfo.nAirConditionNum <= nCurrentDevID\n        || MAX_AIRCONDITION_NUM <= nCurrentDevID)\n    {\n        return;\n    }\n    int nRetLen = 0;\n    NET_CTRL_SET_TEMPERATURE stuOperate = {0};\n    stuOperate.dwSize = sizeof(NET_CTRL_SET_TEMPERATURE);\n    memcpy(stuOperate.szDeviceID, m_stuInfo.stuAirConditions[nCurrentDevID].szDeviceID, MAX_DEVICE_ID_LEN);\n    stuOperate.nTemperature = m_nTemp;\n    BOOL bRet = CLIENT_ControlDevice(m_lLoginID, DH_CTRL_AIRCONDITION_SET_TEMPERATURE, &stuOperate, m_nWaitTime);\n    if (FALSE == bRet)\n    {\n        CString csInfo;\n        csInfo.Format(\"%s:%08x\", ConvertString(\"Set Temperature error\", DLG_AIRCONDITION_OPERATE), CLIENT_GetLastError());\n        MessageBox(csInfo, ConvertString(\"Prompt\"));\n    }\n}\n\nvoid CAirConditionOperate::OnAirconditionBtnWindmode() \n{\n\t// TODO: Add your control notification handler code here\n    int nCurrentDevID = m_cmbDevID.GetCurSel();\n    if (0 > nCurrentDevID \n        || m_stuInfo.nAirConditionNum <= nCurrentDevID\n        || MAX_AIRCONDITION_NUM <= nCurrentDevID)\n    {\n        return;\n    }\n    int nRetLen = 0;\n    NET_CTRL_AIRCONDITION_SETWINDMODE stuOperate = {0};\n    stuOperate.dwSize = sizeof(NET_CTRL_AIRCONDITION_SETWINDMODE);\n    memcpy(stuOperate.szDeviceID, m_stuInfo.stuAirConditions[nCurrentDevID].szDeviceID, MAX_DEVICE_ID_LEN);\n    stuOperate.emAirconditionWindMode = (EM_AIRCONDITION_WINDMODE)(m_cmbWindMode.GetCurSel() + 1);\n    BOOL bRet = CLIENT_ControlDevice(m_lLoginID, DH_CTRL_AIRCONDITION_SETWINDMODE, &stuOperate, m_nWaitTime);\n    if (FALSE == bRet)\n    {\n        CString csInfo;\n        csInfo.Format(\"%s:%08x\", ConvertString(\"Set WindMode error\", DLG_AIRCONDITION_OPERATE), CLIENT_GetLastError());\n        MessageBox(csInfo, ConvertString(\"Prompt\"));\n    }\n}\n\nvoid CAirConditionOperate::OnAirconditionBtnAdjust() \n{\n\t// TODO: Add your control notification handler code here\n    UpdateData(TRUE);\n    int nCurrentDevID = m_cmbDevID.GetCurSel();\n    if (0 > nCurrentDevID \n        || m_stuInfo.nAirConditionNum <= nCurrentDevID\n        || MAX_AIRCONDITION_NUM <= nCurrentDevID)\n    {\n        return;\n    }\n    int nRetLen = 0;\n    NET_CTRL_ADJUST_TEMPERATURE stuOperate = {0};\n    stuOperate.dwSize = sizeof(NET_CTRL_ADJUST_TEMPERATURE);\n    memcpy(stuOperate.szDeviceID, m_stuInfo.stuAirConditions[nCurrentDevID].szDeviceID, MAX_DEVICE_ID_LEN);\n    stuOperate.nTemperatureScale = m_nAdjustTemp;\n    BOOL bRet = CLIENT_ControlDevice(m_lLoginID, DH_CTRL_AIRCONDITION_ADJUST_TEMPERATURE, &stuOperate, m_nWaitTime);\n    if (FALSE == bRet)\n    {\n        CString csInfo;\n        csInfo.Format(\"%s:%08x\", ConvertString(\"Adjust Temperature error\", DLG_AIRCONDITION_OPERATE), CLIENT_GetLastError());\n        MessageBox(csInfo, ConvertString(\"Prompt\"));\n    }\n}\n\nvoid CAirConditionOperate::OnAirconditionBtnGetState() \n{\n\t// TODO: Add your control notification handler code here\n\tif (TRUE == GetState())\n\t{\n\t    StuToDlg();\n\t}\n}\n\nBOOL CAirConditionOperate::GetConfig()\n{\n\tUpdateData(TRUE);\n    char szBuf[1024*32] = {0};\n    int nErr = 0;\n    BOOL bRet = CLIENT_GetNewDevConfig(m_lLoginID, CFG_CMD_AIRCONDITION, \n        -1, szBuf, sizeof(szBuf), &nErr, m_nWaitTime);\n    if (!bRet)\n    {\n        CString csInfo;\n        csInfo.Format(\"%s:%08x\", ConvertString(\"Get config of AirCondition error\", DLG_CFG_AIRCONDITION), CLIENT_GetLastError());\n        MessageBox(csInfo, ConvertString(\"Prompt\"));\n        return FALSE;\n    }\n    \n    int nRetLen = 0;\n    bRet = CLIENT_ParseData(CFG_CMD_AIRCONDITION, szBuf, &m_stuInfo, sizeof(m_stuInfo), &nRetLen);\n    if (!bRet || nRetLen != sizeof(m_stuInfo))\n    {\n        MessageBox(ConvertString(\"Parse config of AirCondition error\", DLG_CFG_AIRCONDITION), ConvertString(\"Prompt\"));\n        return FALSE;\n    }\n    m_cmbDevID.ResetContent();\n    for (int i = 0; i < m_stuInfo.nAirConditionNum; i++)\n    {\n        m_cmbDevID.InsertString(-1, m_stuInfo.stuAirConditions[i].szDeviceID);\n    }\n    m_cmbDevID.SetCurSel(0);\n    return TRUE;\n}\n\nBOOL CAirConditionOperate::GetState()\n{\n\tUpdateData(TRUE);\n    int nCurrentDevID = m_cmbDevID.GetCurSel();\n    if (0 > nCurrentDevID \n        || m_stuInfo.nAirConditionNum <= nCurrentDevID\n        || MAX_AIRCONDITION_NUM <= nCurrentDevID)\n    {\n        return FALSE;\n    }\n    int nRetLen = 0;\n    memset(&m_stuState, 0, sizeof(NET_GET_AIRCONDITION_STATE));\n    m_stuState.dwSize = sizeof(NET_GET_AIRCONDITION_STATE);\n    m_stuState.stuAirConditionState.dwSize = sizeof(NET_AIRCONDITION_STATE_INFO);\n\n    memcpy(m_stuState.szDeviceID, m_stuInfo.stuAirConditions[nCurrentDevID].szDeviceID, MAX_DEVICE_ID_LEN);\n    BOOL bRet = CLIENT_QueryDevState(m_lLoginID, DH_DEVSTATE_AIRCONDITION_STATE, \n        (char*)&m_stuState,sizeof(m_stuState),&nRetLen, m_nWaitTime);\n    if (FALSE == bRet)\n    {\n        CString csInfo;\n        csInfo.Format(\"%s:%08x\", ConvertString(\"Get AirCondition State error\", DLG_AIRCONDITION_OPERATE), CLIENT_GetLastError());\n        MessageBox(csInfo, ConvertString(\"Prompt\"));\n    }\n\treturn bRet;\n}\n\nvoid CAirConditionOperate::StuToDlg()\n{\n    NET_AIRCONDITION_STATE_INFO& stuAirConditionState = m_stuState.stuAirConditionState;\n    m_nTempState = stuAirConditionState.nTemperature;\n    m_fActualTemp = stuAirConditionState.fActualTemperature;\n    m_ctlON.SetCheck(stuAirConditionState.bIsON);\n    m_ctlONLine.SetCheck(stuAirConditionState.bIsOnline);\n    \n    m_cmbModeState.SetCurSel((int)stuAirConditionState.emAirconditionMode - 1);\n    m_cmbWindModeState.SetCurSel((int)stuAirConditionState.emAirconditionWindMode - 1);\n    UpdateData(FALSE);\n}\n","size_bytes":12757},"bin/Demo/MfcDemo/00.DevInit/InitDeviceDlg.cpp":{"content":"// InitDeviceDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"searchdevice.h\"\n#include \"InitDeviceDlg.h\"\n#include <CTYPE.H>\n#include <string>\n#include <iostream>\n\n/////////////////////////////////////////////////////////////////////////////\n// CInitDeviceDlg dialog\n\n\nCInitDeviceDlg::CInitDeviceDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CInitDeviceDlg::IDD, pParent)\n    , m_strConfirmPwd(_T(\"\"))\n{\n\t//{{AFX_DATA_INIT(CInitDeviceDlg)\n\tm_strPwd = _T(\"\");\n\tm_strRig = _T(\"\");\n\tm_strUserName = _T(\"admin\");\n\tm_strPwdRestWay = _T(\"\");\n    m_nIndex = 0;\n    m_byPwdResetWay = 0;\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CInitDeviceDlg::DoDataExchange(CDataExchange* pDX)\n{\n    CDialog::DoDataExchange(pDX);\n    //{{AFX_DATA_MAP(CInitDeviceDlg)\n    DDX_Text(pDX, IDC_EDIT_PWD, m_strPwd);\n    DDX_Text(pDX, IDC_EDIT_RIG, m_strRig);\n    DDX_Text(pDX, IDC_EDIT_UNAME, m_strUserName);\n    DDX_Text(pDX, IDC_EDIT_PwdRestWsy, m_strPwdRestWay);\n    //}}AFX_DATA_MAP\n    DDX_Text(pDX, IDC_EDIT_CNFM_MPWD, m_strConfirmPwd);\n}\n\n\nBEGIN_MESSAGE_MAP(CInitDeviceDlg, CDialog)\n\t//{{AFX_MSG_MAP(CInitDeviceDlg)\n\t//}}AFX_MSG_MAP\n\tON_BN_CLICKED(IDOK, &CInitDeviceDlg::OnBnClickedOk)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CInitDeviceDlg message handlers\n\nBOOL CInitDeviceDlg::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\t// TODO: Add extra initialization here\n    g_SetWndStaticText(this);\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CInitDeviceDlg::OnOK() \n{\n\t// TODO: Add extra validation here\n\tUpdateData(TRUE); \n    \n    CDialog::OnOK();\n}\n\nvoid CInitDeviceDlg::OnCancel() \n{\n\t// TODO: Add extra cleanup here\n\tCDialog::OnCancel();\n}\n\nBOOL CInitDeviceDlg::DestroyWindow() \n{\n\t// TODO: Add your specialized code here and/or call the base class\n\treturn CDialog::DestroyWindow();\n}\n\n\n\nvoid CInitDeviceDlg::OnBnClickedOk()\n{\n\t// TODO: Add your specialized code here and/or call the base class\n    UpdateData(TRUE);\n\n    if (m_strPwd.IsEmpty())\n    {\n        MessageBox(ConvertString(\"Please input password\"), ConvertString(\"Prompt\"));\n        return;\n    }\n\n    if (m_strConfirmPwd.IsEmpty())\n    {\n        MessageBox(ConvertString(\"Please confirm password\"), ConvertString(\"Prompt\"));\n        return;\n    }\n\n    if (m_strConfirmPwd != m_strPwd)\n    {\n        MessageBox(ConvertString(\"Confirm password is invalid,please input again\"), ConvertString(\"Prompt\"));\n        return;\n    }\n\n\tOnOK();\n}\n\n\nBOOL CInitDeviceDlg::PreTranslateMessage(MSG* pMsg) \n{\n\t// TODO: Add your specialized code here and/or call the base class\n\tif (pMsg->message == WM_KEYDOWN || pMsg->message == WM_KEYUP)\n\t{\n\t\tif (VK_ESCAPE == pMsg->wParam || VK_RETURN == pMsg->wParam)\n\t\t{\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn CDialog::PreTranslateMessage(pMsg);\n}","size_bytes":2859},"bin/Demo/MfcDemo/09.AccessControl/DlgSubDlgInfoHoliday.cpp":{"content":"// DlgSubDlgInfoHoliday.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"accesscontrol.h\"\n#include \"DlgSubDlgInfoHoliday.h\"\n#include \"SubDlgSensorInfoDescription.h\"\n#include <VECTOR>\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgSubDlgInfoHoliday dialog\n\n\nCDlgSubDlgInfoHoliday::CDlgSubDlgInfoHoliday(CWnd* pParent /* = NULL */, NET_RECORDSET_HOLIDAY* p /* = NULL */, int nAccess /* = 1 */)\n\t: CDialog(CDlgSubDlgInfoHoliday::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgSubDlgInfoHoliday)\n\t//}}AFX_DATA_INIT\n\tmemset(&m_stuInfo, 0, sizeof(m_stuInfo));\n\tif (p != NULL)\n\t{\n\t\tmemcpy(&m_stuInfo, p, sizeof(NET_RECORDSET_HOLIDAY));\n\t}\n\tm_stuInfo.dwSize = sizeof(m_stuInfo);\n\n\tm_emOperateType = Em_Operate_Type_Show;\n    m_nAccessGroup  = nAccess;\n}\n\n\nvoid CDlgSubDlgInfoHoliday::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgSubDlgInfoHoliday)\n\tDDX_Control(pDX, IDC_SUBDLG_INFO_HOLIDAY_DATETIMEPICKER_STARTDATE, m_StartDate);\n\tDDX_Control(pDX, IDC_SUBDLG_INFO_HOLIDAY_DATETIMEPICKER_ENDDATE, m_EndDate);\n\tDDX_Control(pDX, IDC_SUBDLG_INFO_HOLIDAY_CHECK_ENABLE, m_ckEnable);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgSubDlgInfoHoliday, CDialog)\n\t//{{AFX_MSG_MAP(CDlgSubDlgInfoHoliday)\n\tON_BN_CLICKED(IDC_SUBDLG_INFO_HOLIDAY_BUTTON_DOORS, OnSubdlgInfoHolidayButtonDoors)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgSubDlgInfoHoliday private method\n\nvoid CDlgSubDlgInfoHoliday::InitDlg()\n{\n\tif (Em_Operate_Type_Show == m_emOperateType)\n\t{\n\t\tGetDlgItem(IDC_SUBDLG_INFO_HOLIDAY_EDIT_RECNO)->EnableWindow(FALSE);\n\t\tStuToDlg();\n\t}\n\telse if (Em_Operate_Type_Insert == m_emOperateType)\n\t{\n\t\tGetDlgItem(IDC_SUBDLG_INFO_HOLIDAY_EDIT_RECNO)->EnableWindow(FALSE);\n\t}\n\telse if (Em_Operate_Type_Get == m_emOperateType)\n\t{\n\t\tGetDlgItem(IDC_SUBDLG_INFO_HOLIDAY_EDIT_RECNO)->EnableWindow();\n\t\tm_StartDate.EnableWindow(FALSE);\n\t\tm_EndDate.EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_SUBDLG_INFO_HOLIDAY_CHECK_ENABLE)->EnableWindow(FALSE);\n        GetDlgItem(IDC_SUBDLG_INFO_HOLIDAY_EDIT_HOLIDAYNO)->EnableWindow(FALSE);\n\t}\n\telse if (Em_Operate_Type_Update == m_emOperateType)\n\t{\n\t\tStuToDlg();\n\t\tGetDlgItem(IDC_SUBDLG_INFO_HOLIDAY_EDIT_RECNO)->EnableWindow(FALSE);\n\t}\n\telse if (Em_Operate_Type_Remove == m_emOperateType)\n\t{\n\t\tStuToDlg();\n\t\tGetDlgItem(IDC_SUBDLG_INFO_HOLIDAY_EDIT_RECNO)->EnableWindow();\n\t\tm_StartDate.EnableWindow(FALSE);\n\t\tm_EndDate.EnableWindow(FALSE);\n        GetDlgItem(IDC_SUBDLG_INFO_HOLIDAY_CHECK_ENABLE)->EnableWindow(FALSE);\n        GetDlgItem(IDC_SUBDLG_INFO_HOLIDAY_EDIT_HOLIDAYNO)->EnableWindow(FALSE);\n\t}\n\telse if (Em_Operate_Type_Clear == m_emOperateType)\n\t{\n\t\t// ...\n\t}\t\n}\n\nvoid CDlgSubDlgInfoHoliday::StuToDlg()\n{\n\t// RecNo\n\tSetDlgItemInt(IDC_SUBDLG_INFO_HOLIDAY_EDIT_RECNO, m_stuInfo.nRecNo);\n\t\n\t// enable\n\tm_ckEnable.SetCheck(m_stuInfo.bEnable ? BST_CHECKED : BST_UNCHECKED);\n\t\n\t// start time\n\tSYSTEMTIME st = {0};\n\tst.wYear\t= (WORD)m_stuInfo.stuStartTime.dwYear;\n\tst.wMonth\t= (WORD)m_stuInfo.stuStartTime.dwMonth;\n\tst.wDay\t\t= (WORD)m_stuInfo.stuStartTime.dwDay;\n\tm_StartDate.SetTime(&st);\n\t\n\t// end time\n\tst.wYear\t= (WORD)m_stuInfo.stuEndTime.dwYear;\n\tst.wMonth\t= (WORD)m_stuInfo.stuEndTime.dwMonth;\n\tst.wDay\t\t= (WORD)m_stuInfo.stuEndTime.dwDay;\n\tm_EndDate.SetTime(&st);\n\t\n\t// door\n\n    // holiday no\n    SetDlgItemText(IDC_SUBDLG_INFO_HOLIDAY_EDIT_HOLIDAYNO, m_stuInfo.szHolidayNo);\n}\n\nvoid CDlgSubDlgInfoHoliday::DlgToStu()\n{\n\t// RecNo\n\tm_stuInfo.nRecNo = GetDlgItemInt(IDC_SUBDLG_INFO_HOLIDAY_EDIT_RECNO);\n\t\n\t// enable\n\tif (m_ckEnable.GetCheck())\n\t{\n\t\tm_stuInfo.bEnable = TRUE;\n\t}\n\telse \n\t{\n\t\tm_stuInfo.bEnable = FALSE;\n\t}\n\t\n\t// start time\n\tSYSTEMTIME st = {0};\n\tm_StartDate.GetTime(&st);\n\tm_stuInfo.stuStartTime.dwYear = st.wYear;\n\tm_stuInfo.stuStartTime.dwMonth = st.wMonth;\n\tm_stuInfo.stuStartTime.dwDay = st.wDay;\n\t\n\t// end time\n\tm_EndDate.GetTime(&st);\n\tm_stuInfo.stuEndTime.dwYear = st.wYear;\n\tm_stuInfo.stuEndTime.dwMonth = st.wMonth;\n\tm_stuInfo.stuEndTime.dwDay = st.wDay;\n\t\n\t// door\n\n    // holiday no\n    GetDlgItemText(IDC_SUBDLG_INFO_HOLIDAY_EDIT_HOLIDAYNO, m_stuInfo.szHolidayNo, sizeof(m_stuInfo.szHolidayNo) - 1);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgSubDlgInfoHoliday message handlers\n\nBOOL CDlgSubDlgInfoHoliday::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\n\tg_SetWndStaticText(this, SUBDLG_INFO_HOLIDAY);\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgSubDlgInfoHoliday::OnSubdlgInfoHolidayButtonDoors() \n{\n\t// TODO: Add your control notification handler code here\n\tstd::vector<int> vecChn;\n\tint i = 0;\n\tfor (; i < __min(m_stuInfo.nDoorNum, DH_MAX_DOOR_NUM); i++)\n\t{\n\t\tvecChn.push_back(m_stuInfo.sznDoors[i]);\n\t}\n\t\n\tCSubDlgSensorInfoDescription dlg(this, m_nAccessGroup);\n\tdlg.SetID(vecChn);\n\tif (IDOK == dlg.DoModal())\n\t{\n\t\tif (Em_Operate_Type_Insert == m_emOperateType\n\t\t\t|| Em_Operate_Type_Update == m_emOperateType)\n\t\t{\n\t\t\tvecChn.clear();\n\t\t\tvecChn = dlg.GetID();\n\t\t\tstd::vector<int>::iterator it = vecChn.begin();\n\t\t\tfor (i = 0; i < __min(vecChn.size(), DH_MAX_DOOR_NUM) && it != vecChn.end(); i++, it++)\n\t\t\t{\n\t\t\t\tm_stuInfo.sznDoors[i] = *it;\n\t\t\t}\n\t\t\tm_stuInfo.nDoorNum = __min(vecChn.size(), DH_MAX_DOOR_NUM);\n\t\t}\n\t}\n}\n\nvoid CDlgSubDlgInfoHoliday::OnOK() \n{\n\t// TODO: Add extra validation here\n\tswitch (m_emOperateType)\n\t{\n\tcase Em_Operate_Type_Show:\n\t\t{\n\t\t\tStuToDlg();\n\t\t}\n\t\tbreak;\n\tcase Em_Operate_Type_Insert:\n\t\t{\n\t\t\tDlgToStu();\n\t\t}\n\t\tbreak;\n\tcase Em_Operate_Type_Get:\n\t\t{\n\t\t\tDlgToStu();\n\t\t}\n\t\tbreak;\n\tcase Em_Operate_Type_Update:\n\t\t{\n\t\t\tDlgToStu();\n\t\t}\n\t\tbreak;\n\tcase Em_Operate_Type_Remove:\n\t\t{\n\t\t\tDlgToStu();\n\t\t}\n\t\tbreak;\n\tcase Em_Operate_Type_Clear:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tCDialog::OnOK();\n}\n","size_bytes":6007},"bin/Demo/MfcDemo/10.AlarmDevice/DlgUserManage.cpp":{"content":"// DlgUserManage.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgUserManage.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgUserManage dialog\n\n\nCDlgUserManage::CDlgUserManage(CWnd* pParent /* = NULL */, LLONG hLoginID /* = 0 */, NET_DEVICE_TYPE emDevType /* = NET_PRODUCT_NONE */)\n\t: CDialog(CDlgUserManage::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgUserManage)\n\tm_csNewPasswd = _T(\"\");\n\tm_csCheckPasswd = _T(\"\");\n\tm_csOldPasswd = _T(\"\");\n\tm_hLoginID = hLoginID;\n\tm_emDevType = emDevType;\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CDlgUserManage::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgUserManage)\n\tDDX_Text(pDX, IDC_MODIFYPSW_EDT_NEW, m_csNewPasswd);\n\tDDX_Text(pDX, IDC_MODIFYPSW_EDT_CHECK, m_csCheckPasswd);\n\tDDX_Text(pDX, IDC_MODIFYPSW_EDT_OLD, m_csOldPasswd);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgUserManage, CDialog)\n\t//{{AFX_MSG_MAP(CDlgUserManage)\n\tON_BN_CLICKED(IDC_MODIFYPSW_BTN_CANCEL, OnButtonCancel)\n\tON_BN_CLICKED(IDC_MODIFYPSW_BTN_SET, OnButtonSet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgUserManage message handlers\n\nvoid CDlgUserManage::OnButtonCancel() \n{\n\t// TODO: Add your control notification handler code here\n\tCDialog::OnCancel();\n}\n\nvoid CDlgUserManage::OnButtonSet() \n{\n\t// TODO: Add your control notification handler code here\n\tUpdateData(TRUE);\n\tif (!m_hLoginID)\n\t{\n\t\tMessageBox(ConvertString(\"Please login first.\", DLG_USER), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n// \tif (!m_csOldPasswd.GetLength())\n// \t{\n// \t\tMessageBox(ConvertString(\"Input old password.\", DLG_USER), ConvertString(\"Prompt\"));\n// \t\treturn;\n// \t}\n\n\tif (!m_csNewPasswd.GetLength())\n\t{\n\t\tMessageBox(ConvertString(\"Input new password.\", DLG_USER), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tif (!m_csCheckPasswd.GetLength())\n\t{\n\t\tMessageBox(ConvertString(\"Input check password.\", DLG_USER), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tif (m_csCheckPasswd != m_csNewPasswd)\n\t{\n\t\tMessageBox(ConvertString(\"Two passwords are different, please check again.\", DLG_USER), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tUSER_INFO_NEW stuOldInfo = {sizeof(stuOldInfo)};\n\tGetDlgItemText(IDC_MODIFYPSW_EDT_NAME, stuOldInfo.name, sizeof(stuOldInfo.name) - 1);\t\n\tstrncpy(stuOldInfo.passWord, m_csOldPasswd.GetBuffer(0), sizeof(stuOldInfo.passWord) - 1);\n\n\tUSER_INFO_NEW stuModifiedInfo = {sizeof(stuModifiedInfo)};\n\tstrncpy(stuModifiedInfo.passWord, m_csNewPasswd.GetBuffer(0), sizeof(stuModifiedInfo.passWord)-1);\n\n\tBOOL bRet = CLIENT_OperateUserInfoNew(m_hLoginID, 6, &stuModifiedInfo, &stuOldInfo, NULL, SDK_API_WAIT);\n\tif (bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Modify password successfully.\", DLG_USER), ConvertString(\"Prompt\"));\n\t}\n\telse\n\t{\n\t\tCString csOut;\n\t\tcsOut.Format(\"%s %08x\", ConvertString(\"Modify password failed:\", DLG_USER), CLIENT_GetLastError());\n\t\tMessageBox(csOut, ConvertString(\"Prompt\"));\n\t}\n}\n\nBOOL CDlgUserManage::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_USER);\n\n\t// TODO: Add extra initialization here\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n","size_bytes":3370},"bin/DemoSrc/AviConvert_Demo/AviConvert_Demo.cpp":{"content":"// AviConvert_Demo.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"AviConvert_Demo.h\"\n#include \"AviConvert_DemoDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CAviConvert_DemoApp\n\nBEGIN_MESSAGE_MAP(CAviConvert_DemoApp, CWinApp)\n\t//{{AFX_MSG_MAP(CAviConvert_DemoApp)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t\t//    DO NOT EDIT what you see in these blocks of generated code!\n\t//}}AFX_MSG\n\tON_COMMAND(ID_HELP, CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CAviConvert_DemoApp construction\n\nCAviConvert_DemoApp::CAviConvert_DemoApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The one and only CAviConvert_DemoApp object\n\nCAviConvert_DemoApp theApp;\n\n/////////////////////////////////////////////////////////////////////////////\n// CAviConvert_DemoApp initialization\n\nBOOL CAviConvert_DemoApp::InitInstance()\n{\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t//  of your final executable, you should remove from the following\n\t//  the specific initialization routines you do not need.\n\n#ifdef _AFXDLL\n\tEnable3dControls();\t\t\t// Call this when using MFC in a shared DLL\n#else\n\tEnable3dControlsStatic();\t// Call this when linking to MFC statically\n#endif\n\n\tCAviConvert_DemoDlg dlg;\n\tm_pMainWnd = &dlg;\n\tint nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n","size_bytes":2115},"bin/Demo/MfcDemo/13.FaceRecognition/FaceRecognition.cpp":{"content":"// FaceRecognition.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"FaceRecognition.h\"\n#include \"FaceRecognitionDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CFaceRecognitionApp\n\nBEGIN_MESSAGE_MAP(CFaceRecognitionApp, CWinApp)\n\t//{{AFX_MSG_MAP(CFaceRecognitionApp)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t\t//    DO NOT EDIT what you see in these blocks of generated code!\n\t//}}AFX_MSG\n\tON_COMMAND(ID_HELP, CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CFaceRecognitionApp construction\n\nCFaceRecognitionApp::CFaceRecognitionApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The one and only CFaceRecognitionApp object\n\nCFaceRecognitionApp theApp;\n\n/////////////////////////////////////////////////////////////////////////////\n// CFaceRecognitionApp initialization\n\nBOOL CFaceRecognitionApp::InitInstance()\n{\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t//  of your final executable, you should remove from the following\n\t//  the specific initialization routines you do not need.\n\n#ifdef _AFXDLL\n\tEnable3dControls();\t\t\t// Call this when using MFC in a shared DLL\n#else\n\tEnable3dControlsStatic();\t// Call this when linking to MFC statically\n#endif\n\n\tCFaceRecognitionDlg dlg;\n\tm_pMainWnd = &dlg;\n\tint nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n","size_bytes":2115},"bin/Demo/MfcDemo/01.RealPlayAndPTZControl/VideoNodeInfo.cpp":{"content":"// VideoNodeInfo.cpp: implementation of the VideoNodeInfo class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"RealPlayAndPTZControl.h\"\n#include \"VideoNodeInfo.h\"\n\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\n//////////////////////////////////////////////////////////////////////\n// Construction/Destruction\n//////////////////////////////////////////////////////////////////////\n\nCVideoNodeInfo::CVideoNodeInfo()\n{\n\tm_iDisplayNum=-1;\n\tm_strDvrIP=\"\";\n\tm_wDvrPort=0;\n\tm_iDvrChannel=-1;\n\tm_strDvrUserName=\"\";\n\tm_strDvrPwd=\"\";\n\tm_playMode=DirectMode;\n}\n\nCVideoNodeInfo::~CVideoNodeInfo()\n{\n\n}\n\n//To get video signal \nint CVideoNodeInfo::GetDisplayNum()\n{\n\treturn m_iDisplayNum;\n}\n\n//Set video number \nvoid CVideoNodeInfo::SetDisplayNum(int iDisplayNum)\n{\n\tm_iDisplayNum=iDisplayNum;\n}\n\n//Get DVR IP address \nCString CVideoNodeInfo::GetDvrIP()\n{\n\treturn m_strDvrIP;\n}\n\n//Set DVR IP address \nvoid CVideoNodeInfo::SetDvrIP(CString strDvrIP)\n{\n\tm_strDvrIP=strDvrIP;\n}\n\n//Get DVR port number \nWORD CVideoNodeInfo::GetDvrPort()\n{\n\treturn m_wDvrPort;\n}\n\n//Set DVR port number \nvoid CVideoNodeInfo::SetDvrPort(WORD wPort)\n{\n\tm_wDvrPort=wPort;\n}\n\n//Get DVR channel number \nint CVideoNodeInfo::GetDvrChannel()\n{\n\treturn m_iDvrChannel;\n}\n\n//Set DVR channel number \nvoid CVideoNodeInfo::SetDvrChannel(int iChannel)\n{\n\tm_iDvrChannel=iChannel;\n}\n\n//Get DVR user name \nCString CVideoNodeInfo::GetDvrUserName()\n{\n\treturn m_strDvrUserName;\n}\n\n//Set DVR user name \nvoid CVideoNodeInfo::SetDvrUserName(CString strDvrUserName)\n{\n\tm_strDvrUserName=strDvrUserName;\n}\n\n//Get DVR password \nCString CVideoNodeInfo::GetDvrPwd()\n{\n\treturn m_strDvrPwd;\n}\n\n//Set DVR password \nvoid CVideoNodeInfo::SetDvrPwd(CString strDvrPwd)\n{\n\tm_strDvrPwd=strDvrPwd;\n}\n\n//Get video play mode \nenum RealPlayMode CVideoNodeInfo::GetPlayMode()\n{\n\treturn m_playMode;\n}\n\n//Set video play mode \nvoid CVideoNodeInfo::SetPlayMode(enum RealPlayMode ePlayMode)\n{\n\tm_playMode=ePlayMode;\n}\n\n// Set VideoInfo\nvoid CVideoNodeInfo::SetVideoInfo(int iDisplayNum, CString strDvrIP, WORD wPort, int iChannel, CString strUserName, CString strPwd, enum RealPlayMode ePlayMode)\n{\n\tm_iDisplayNum=iDisplayNum;\n\tm_strDvrIP=strDvrIP;\n\tm_wDvrPort=wPort;\n\tm_iDvrChannel=iChannel;\n\tm_strDvrUserName=strUserName;\n\tm_strDvrPwd=strPwd;\n\tm_playMode=ePlayMode;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":2732},"bin/Demo/MfcDemo/02.PlayBack/StdAfx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n//\tPlayBack.pch will be the pre-compiled header\n//\tstdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n\n\n","size_bytes":201},"bin/Demo/MfcDemo/01.RealPlayAndPTZControl/BSWndContainer.cpp":{"content":"// BSWndContainer.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"BSWndContainer.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CBSWndContainer\n\nCBSWndContainer::CBSWndContainer()\n{\n\t// init active page pointer\n\tm_pActivePage\t= NULL;\n\n\t// init window state\n\tm_bFullScreen\t= FALSE;\t// Full screen sign \n\tm_bMultiScreen\t= TRUE;\t\t// Multiple-window sign \n\tm_bAutoAdjustPos= FALSE;\t// Auto adjust sign \n\n\tSetDrawActivePage(TRUE);\t//\tEnable frame\n\n\tm_nShowPortion=100;\t\t\t//\tDisplay proportion \n}\n\nCBSWndContainer::~CBSWndContainer()\n{\n\t// remove all pages\n\twhile(!m_PageList.IsEmpty())\n\t\tm_PageList.RemoveHead();\n}\n\n\nBEGIN_MESSAGE_MAP(CBSWndContainer, CWnd)\n\t//{{AFX_MSG_MAP(CBSWndContainer)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n\n/////////////////////////////////////////////////////////////////////////////\n// CBSWndContainer member functions\n\n///////////////////////////////////////////////////\n// call this function to create container object.\n// it is override from cwnd class\nBOOL CBSWndContainer::Create( LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext )\n{\n\tdwStyle|=WS_EX_TOOLWINDOW;\n\treturn CWnd::Create(lpszClassName,lpszWindowName,dwStyle,rect,pParentWnd,nID,pContext );\n}\n\n\n///////////////////////////////////////////////////\n// call this function to add a page wnd to \n// container. if success retrun TRUE,else return \n// FALSE.\nBOOL CBSWndContainer::AddPage(CWnd *pWnd, BOOL bRepaint)\n{\n\t// check parameter\n\tif(\t!pWnd || !IsWindow(pWnd->m_hWnd) )\treturn FALSE;\n\n\t// check list \n\tPOSITION pos=m_PageList.Find(pWnd);\n\tif(pos!=NULL) \n\t{\n\t\tTRACE(\"This Window has been added to container, the operation will terminate.\\n\");\n\t\treturn TRUE;\n\t}\n\n\t// added page\n\tm_PageList.AddTail(pWnd);\n\n\tif( m_bDrawActive ) DrawActivePage(FALSE);\n\n\t// reset active page\n\tSetActivePage(pWnd, bRepaint);\n\n\treturn TRUE;\n}\n\n///////////////////////////////////////////////////\n// call this function to remove a page wnd from\n// container. \nCWnd *CBSWndContainer::DelPage(CWnd *pWnd)\n{\n\t// check list\n\tPOSITION pos=m_PageList.Find(pWnd);\n\tif(pos==NULL)\n\t{\n\t\tTRACE(\"This Window is not a member of container, the operation will terminate.\\n\");\n\t\treturn NULL;\n\t}\n\tif(pWnd==m_pActivePage)\n\t\tif(m_pActivePage==GetPrevPage(pWnd))//m_PageList.IsEmpty()?NULL:m_PageList.GetHead();\n\t\t\tm_pActivePage=NULL;\n\t\telse m_pActivePage=GetPrevPage(pWnd);\n\t\n\tm_PageList.RemoveAt(pos);\n\n\tif (pWnd)\n\t{\n\t\tpWnd->ShowWindow(SW_HIDE);\n\t}\n\n//\tInvalidate();\n\n\treturn pWnd;\n}\n\n///////////////////////////////////////////////////\n// call this function to remove active page from\n// container.\nCWnd *CBSWndContainer::DelPage()\n{\n\treturn DelPage(m_pActivePage);\n}\n\n///////////////////////////////////////////////////\n// call this function to set a page to be active\n// page.\nvoid CBSWndContainer::SetActivePage(CWnd *pWnd, BOOL bRepaint)\n{\n\t// check parameter\n\tif(\t!pWnd || !IsWindow(pWnd->m_hWnd) )\treturn;\n\n\t// if pWnd is the Active Page, return \n\tif( m_pActivePage==pWnd ) return;\n\n\t// check list\n\tPOSITION pos=m_PageList.Find(pWnd);\n\tif(pos==NULL)\n\t{\n\t\tTRACE(\"__This Window is not a member of container, the operation will terminate.\\n\");\n\t\treturn;\n\t}\n\n\tif(bRepaint) UpdateWnd();\n\n\tif( m_bDrawActive ) DrawActivePage(FALSE);\n\n\tm_pActivePage=pWnd;\n\n\tif( m_bDrawActive ) DrawActivePage(TRUE);\n}\n\n///////////////////////////////////////////////////\n// call this function to get the active page's\n// pointer. if no active page,return NULL;\nCWnd *CBSWndContainer::GetActivePage()\n{\n\treturn m_pActivePage;\n}\n\nCWnd *CBSWndContainer::GetTailPage()\n{\n\treturn m_PageList.GetTail();\n}\n\n///////////////////////////////////////////////////\n// call this function to get the next page by\n// the page that user defined. if the defined \n// page is not find in container, return NULL.\nCWnd *CBSWndContainer::GetNextPage(CWnd *pWnd)\n{\n\t// check parameter\n\tif(\t!pWnd || !IsWindow(pWnd->m_hWnd) ) return NULL;\n\n\t// check list\n\tPOSITION pos=m_PageList.Find(pWnd);\n\tif(pos==NULL)\n\t{\n\t\tTRACE(\"This Window is not a member of container, the operation will terminate.\\n\");\n\t\treturn NULL;\n\t}\n\t\n\t//\n\tm_PageList.GetNext(pos);\n\tif(pos==NULL)\n\t\treturn m_PageList.GetHead();\n\telse \n\t\treturn m_PageList.GetNext(pos);\n}\n\n///////////////////////////////////////////////////\n// call this function to get the prev page by\n// the page that user defined. if the defined\n// page is not find in container,return NULL.\nCWnd *CBSWndContainer::GetPrevPage(CWnd *pWnd)\n{\n\t// check parameter\n\tif(\t!pWnd || !IsWindow(pWnd->m_hWnd) ) return NULL;\n\n\t// check list\n\tPOSITION pos=m_PageList.Find(pWnd);\n\tif(pos==NULL)\n\t{\n\t\tTRACE(\"This Window is not a member of container, the operation will terminate.\\n\");\n\t\treturn NULL;\n\t}\n\t\n\t//\n\tm_PageList.GetPrev(pos);\n\tif(pos==NULL)\n\t\treturn m_PageList.GetTail();\n\telse \n\t\treturn m_PageList.GetPrev(pos);\n}\n\nCWnd *CBSWndContainer::GetPage(int nIndex)\n{\n\tCWnd *pRet = NULL;\n\tPOSITION pos = m_PageList.FindIndex(nIndex);\n\tif(pos == NULL) return pRet;\n\n\treturn m_PageList.GetAt(pos);\n}\n\nint CBSWndContainer::GetCount() const\n{\n\treturn m_PageList.GetCount();\n}\n\n///////////////////////////////////////////////////\n// call this function to  page wnds,when\n// the window is resized.\nvoid CBSWndContainer::UpdateWnd()\n{\n\tif(!IsWindowVisible()||IsIconic()) return;\n/////////////////////\n//Calculate display total zone \n\n\t//To get current window device coordinates\n\tCRect rtContainer;\n\tGetClientRect(&rtContainer);\n\tGetShowRect(&rtContainer);\n\trtContainer.DeflateRect(1,1);\n\n\t//Adjust Container position \n\tif(m_bAutoAdjustPos)\t\t\n\t\tAdjustRect(&rtContainer);\n\n/////////////////////\n//\n\tif(m_bMultiScreen)\n\t{ //Multiple-window status \n\t\tCRect rt;\n\t\tint nCount=m_PageList.GetCount();\n\t\tint i=0;\n\t\tfor(POSITION pos=m_PageList.GetHeadPosition();pos!=NULL;)\n\t\t{\n\t\t\tCWnd *p=m_PageList.GetNext(pos);\n\n\t\t\trt=rtContainer;\n\t\t\tCalcPageRect(&rt,i,nCount);\n\t\t\trt.DeflateRect(WINDOW_SPACE,WINDOW_SPACE,WINDOW_SPACE,WINDOW_SPACE); \n\t\t\tp->MoveWindow(&rt);\n\t\t\tp->ShowWindow(SW_SHOW);\n\t\t\ti++;\n\t\t}\n\t\tif( m_bDrawActive && m_PageList.GetCount()>1 ) DrawActivePage(TRUE);\n\t}\n\telse\n\t{ //One-window status \n\t\tfor(POSITION pos=m_PageList.GetHeadPosition();pos!=NULL;)\n\t\t{\n\t\t\tCWnd *p=m_PageList.GetNext(pos);\n\t\t\tif(p==m_pActivePage)\n\t\t\t\tp->MoveWindow(&rtContainer);\n\t\t\telse \n\t\t\t{\n\t\t\t\tif(m_bFullScreen)\n\t\t\t\t\tp->MoveWindow(0,0,1,1);\n\t\t\t\telse\n\t\t\t\t\tp->MoveWindow(rtContainer.right+1,rtContainer.bottom+1,1,1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n///////////////////////////////////////////////////\n// full screen\nvoid CBSWndContainer::SetFullScreen(BOOL bFlag)\n{\n\tif(bFlag==m_bFullScreen) return;\n\n\tif( bFlag )\n\t{//Full screen \n\t\t//Get displayer resolution \n\t\tint cx=GetSystemMetrics(SM_CXSCREEN);\n\t\tint cy=GetSystemMetrics(SM_CYSCREEN);\n\n\t\t//Save position information \n\t\tGetWindowPlacement(&_temppl);\n\t\t//Modify style \n\t\tModifyStyle(WS_CHILD,WS_POPUP);\n\t\t//Modify main-window \n\t\t_tempparent=SetParent(NULL);\n\t\t_tempparent->ShowWindow(SW_HIDE);\n\t\t//Move window \n\t\tMoveWindow(0,0,cx,cy);\n\t//\tSetWindowPos(&wndTopMost,0,0,cx,cy,NULL);\n\t}\n\telse\n\t{//Restore\n\t\t//Restore main window \n\t\t_tempparent->ShowWindow(SW_SHOW);\n\t\tSetParent(_tempparent);\n\t\t//Restore style \n\t\tModifyStyle(WS_POPUP,WS_CHILD);\n\t\t//Restore position \n\t\tSetWindowPlacement(&_temppl);\n\t}\n\n\tm_bFullScreen=bFlag;\n\tInvalidate();\n}\nBOOL CBSWndContainer::GetFullScreen()\n{\n\treturn m_bFullScreen;\n}\n\n///////////////////////////////////////////////////\n// multiscreen\nvoid CBSWndContainer::SetMultiScreen(BOOL bFlag)\n{\n\tif(m_bMultiScreen==bFlag) return;\n\tm_bMultiScreen=bFlag;\n\tInvalidate();\n}\nBOOL CBSWndContainer::GetMultiScreen()\n{\n\treturn m_bMultiScreen;\n}\n\n//////////////////////////////////////////////////\n// autoadjustpos\nvoid CBSWndContainer::SetAutoAdjustPos(BOOL bFlag)\n{\n\tif(m_bAutoAdjustPos==bFlag) return;\n\tm_bAutoAdjustPos=bFlag;\n\tInvalidate();\n}\nBOOL CBSWndContainer::GetAutoAdjustPos()\n{\n\treturn m_bAutoAdjustPos;\n}\n\n//////////////////////////////////////////////////\n// draw active page\nvoid CBSWndContainer::SetDrawActivePage(BOOL bFlag,COLORREF clrTopLeft,COLORREF clrBottomRight)\n{\n\tif(m_bDrawActive==bFlag) return;\n\tif(bFlag)\n\t{\n\t\tm_clrTopLeft=clrTopLeft;\n\t\tm_clrBottomRight=clrBottomRight;\n\t}\n\tm_bDrawActive=bFlag;\n\tDrawActivePage(bFlag);\n}\nBOOL CBSWndContainer::GetDrawActivePage()\n{\n\treturn m_bDrawActive;\n}\n\n//////////////////////////////////////////////////\n//\tDisplay percentage \n//\t40 <= nPortion <=100\nvoid CBSWndContainer::SetShowPortion(int nPortion)\n{\n\tif(m_nShowPortion==nPortion) return;\n\tif(m_nShowPortion<40) m_nShowPortion=40;\n\tif(m_nShowPortion>100) m_nShowPortion=100;\n\tm_nShowPortion=nPortion;\n\tInvalidate();\n}\nint  CBSWndContainer::GetShowPortion()\n{\n\treturn m_nShowPortion;\n}\n\n///////////////////////////////////////////////////\n// clean the no useful page in the container,\n// return the page count.\nint CBSWndContainer::UpdateList()\n{\n\tPOSITION posPrev;\n\tfor(POSITION pos=m_PageList.GetHeadPosition();pos!=NULL;)\n\t{\n\t\tposPrev=pos;\n\t\tCWnd *p=m_PageList.GetNext(pos);\n\t\tif(!IsWindow(p->m_hWnd))\n\t\t\tm_PageList.RemoveAt(posPrev);\n\t}\n\treturn m_PageList.GetCount();\n}\n\n///////////////////////////////////////////////////\n// get a rect by the index of a child\nvoid CBSWndContainer::CalcPageRect(LPRECT lpRect,int nIndex,int nPageCount)\n{\n\tif((nPageCount<=0)||(nIndex>=nPageCount))\n\t{\n\t\tlpRect->left=lpRect->right=lpRect->top=lpRect->bottom=0;\n\t\treturn;\n\t}\n//get row count\n\tint nRow=0;\n\twhile((nRow)*(nRow)<nPageCount) nRow++;\n\n//get singledlg width and height\n\tint nWidth=(lpRect->right-lpRect->left)/nRow;\n\tint nHeight=(lpRect->bottom-lpRect->top)/nRow;\n\n//get top-left point\n\tCPoint pt;\n\tpt.x=lpRect->left+nWidth*(nIndex%nRow);\n\tpt.y=lpRect->top+nHeight*(nIndex/nRow);\n\n//set rect return back\n\tlpRect->left=pt.x;\n\tlpRect->top=pt.y;\n\tlpRect->right=lpRect->left+nWidth;\n\tlpRect->bottom=lpRect->top+nHeight;\n}\n\n///////////////////////////////////////////////////\n// adjust a rect by defined proportion \nvoid CBSWndContainer::AdjustRect(LPRECT lpRect)\n{\n\tint nWidth=lpRect->right-lpRect->left;\n\tint nHeight=lpRect->bottom-lpRect->top;\n\tCPoint pt((lpRect->left+lpRect->right)/2,(lpRect->top+lpRect->bottom)/2);\n\n\tint nTemp=nWidth*8/11;\n\tif(nTemp>nHeight)\n\t{\n\t\tnWidth=nHeight*11/8;\n\t}\n\telse if(nTemp<nHeight)\n\t{\n\t\tnHeight=nTemp;\n\t}\n\tlpRect->left=pt.x-nWidth/2;\n\tlpRect->right=pt.x+nWidth/2;\n\tlpRect->top=pt.y-nHeight/2;\n\tlpRect->bottom=pt.y+nHeight/2;\n}\n\n///////////////////////////////////////////////////\n//To get display zone in proportion \nvoid CBSWndContainer::GetShowRect(LPRECT lpRect)\n{\n\tif(m_nShowPortion<40) m_nShowPortion=40;\n\tif(m_nShowPortion>100) m_nShowPortion=100;\n\n\tint nWidth\t= lpRect->right-lpRect->left;\n\tint nHeight\t= lpRect->bottom-lpRect->top;\n\n\tint nNewWidth\t= (int)(nWidth*m_nShowPortion/100);\n\tint nNewHeight\t= (int)(nHeight*m_nShowPortion/100);\n\n\tint ndx\t= ( nWidth-nNewWidth )/2;\n\tint ndy = ( nHeight-nNewHeight )/2;\n\n\tlpRect->left\t= lpRect->left\t+ ndx;\n\tlpRect->top\t\t= lpRect->top\t+ ndy;\n\tlpRect->right\t= lpRect->left\t+ nNewWidth;\n\tlpRect->bottom\t= lpRect->top\t+ nNewHeight;\t\n}\n\n///////////////////////////////////////////////////\n// draw the frame of active page\nvoid CBSWndContainer::DrawActivePage(BOOL bFlag)\n{\n\tif( !m_bMultiScreen || \n\t\t!m_pActivePage\t|| \n\t\tm_PageList.GetCount()<2 \n\t\t) return;\n\n\tCRect rt;\n\tm_pActivePage->GetWindowRect(&rt);\n\tScreenToClient(&rt);\n\trt.InflateRect(1,1);\n\n\tif(bFlag)\n\t{\n\t\tCDC *pDC=GetDC();\n\t\tif(!pDC) return;\n\n//\t\tpDC->Draw3dRect(&rt,m_clrTopLeft, m_clrBottomRight);\t\n\t\tpDC->Draw3dRect(&rt,RGB(255,0,0), RGB(255,0,0));\n\n\t\tReleaseDC(pDC);\n\t}\n\telse\n\t\tInvalidateRect(&rt);\n}\n\n\n","size_bytes":11638},"bin/DemoSrc/WaterCheck_demo/WaterCheck_demoDlg.cpp":{"content":"// WaterCheck_demoDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"WaterCheck_demo.h\"\n#include \"WaterCheck_demoDlg.h\"\n#include \"dhplay.h\"\n#include \"LanguageConvertor.h\"\n#include <shlwapi.h>\n#include \"CharactorTansfer.h\"\n#include <string>\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CWaterCheck_demoDlg dialog\n#define BUF_SIZE 1024*1024\n\n#pragma comment(lib, \"shlwapi.lib\")\n#pragma comment(lib, \"dhplay.lib\")\n\nCWaterCheck_demoDlg::CWaterCheck_demoDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CWaterCheck_demoDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CWaterCheck_demoDlg)\n\tm_csfilePath = _T(\"\");\n\t//}}AFX_DATA_INIT\n\t// Note that LoadIcon does not require a subsequent DestroyIcon in Win32\n\tm_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);\n\n\tm_hThread = NULL;\n\tm_hExit = CreateEvent(NULL, TRUE, FALSE, NULL);\n\tLANG_INIT();\n}\nCWaterCheck_demoDlg::~CWaterCheck_demoDlg()\n{\n\tSetEvent(m_hExit);\n\tCloseHandle(m_hExit);\n\tif(m_hThread)\n\t\tCloseHandle(m_hThread);\n\n}\n\nBOOL CWaterCheck_demoDlg::PreTranslateMessage(MSG* pMsg) \n{\n\t// TODO: Add your specialized code here and/or call the base class\n\tif(pMsg->wParam == VK_ESCAPE && pMsg->message == WM_KEYDOWN)\n\t\treturn 1;\n\telse if (pMsg->wParam == VK_RETURN && pMsg->message == WM_KEYDOWN)\n\t\treturn 1;\n\telse\n\t\treturn CDialog::PreTranslateMessage(pMsg);\n}\n\nvoid CWaterCheck_demoDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CWaterCheck_demoDlg)\n\tDDX_Control(pDX, IDC_LIST_WATERINFO, m_lscheckInfoList);\n\tDDX_Text(pDX, IDC_EDIT_FILEPATH, m_csfilePath);\n\t//}}AFX_DATA_MAP\n}\n\nBEGIN_MESSAGE_MAP(CWaterCheck_demoDlg, CDialog)\n\t//{{AFX_MSG_MAP(CWaterCheck_demoDlg)\n\tON_WM_PAINT()\n\tON_WM_QUERYDRAGICON()\n\tON_BN_CLICKED(IDC_BUTTON_CHECK, OnButtonCheck)\n\tON_BN_CLICKED(IDC_BUTTON_FILEPATH, OnButtonFilepath)\n\tON_WM_CLOSE()\n\tON_WM_DESTROY()\n\tON_BN_CLICKED(IDC_BUTTON_STOP, OnButtonStop)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CWaterCheck_demoDlg message handlers\n\nBOOL CWaterCheck_demoDlg::OnInitDialog()\n{\n\tCDialog::OnInitDialog();\n\n\t// Set the icon for this dialog.  The framework does this automatically\n\t//  when the application's main window is not a dialog\n\tSetIcon(m_hIcon, TRUE);\t\t\t// Set big icon\n\tSetIcon(m_hIcon, FALSE);\t\t// Set small icon\n\t\n\t// TODO: Add extra initialization here\t\n\n\tLANG_SETWNDSTATICTEXT(this);\n\n\tGetDlgItem(IDC_BUTTON_CHECK)->EnableWindow(FALSE);\n\n\t// Init Track List\n\tDWORD dwStyle=::GetWindowLong(m_lscheckInfoList.m_hWnd,GWL_STYLE);\n\t//Set to report form\n\tSetWindowLong(m_lscheckInfoList.m_hWnd,GWL_STYLE,dwStyle|LVS_REPORT);\n\tDWORD ExStyle =m_lscheckInfoList.GetExtendedStyle();\n\t//Set to full field selection and grid line\n\tm_lscheckInfoList.SetExtendedStyle(ExStyle|LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES);\n\t\n\tm_lscheckInfoList.InsertColumn(0, LANG_CS(\"Num\"), LVCFMT_LEFT, 40);\n\tm_lscheckInfoList.InsertColumn(1, LANG_CS(\"Error Type\"), LVCFMT_LEFT, 200);\n\tm_lscheckInfoList.InsertColumn(2, LANG_CS(\"Time Stamp\"), LVCFMT_LEFT, 150);\n\t\n\t((CProgressCtrl *)GetDlgItem(IDC_PROGRESS))->SetRange(0, 1000);\n\n\tChangeUIstate(INIT);\n\n\treturn TRUE;  // return TRUE  unless you set the focus to a control\n}\n\n// If you add a minimize button to your dialog, you will need the code below\n//  to draw the icon.  For MFC applications using the document/view model,\n//  this is automatically done for you by the framework.\n\nvoid CWaterCheck_demoDlg::OnPaint() \n{\n\tif (IsIconic())\n\t{\n\t\tCPaintDC dc(this); // device context for painting\n\n\t\tSendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);\n\n\t\t// Center icon in client rectangle\n\t\tint cxIcon = GetSystemMetrics(SM_CXICON);\n\t\tint cyIcon = GetSystemMetrics(SM_CYICON);\n\t\tCRect rect;\n\t\tGetClientRect(&rect);\n\t\tint x = (rect.Width() - cxIcon + 1) / 2;\n\t\tint y = (rect.Height() - cyIcon + 1) / 2;\n\n\t\t// Draw the icon\n\t\tdc.DrawIcon(x, y, m_hIcon);\n\t}\n\telse\n\t{\n\t\tCDialog::OnPaint();\n\t}\n}\n\n// The system calls this to obtain the cursor to display while the user drags\n//  the minimized window.\nHCURSOR CWaterCheck_demoDlg::OnQueryDragIcon()\n{\n\treturn (HCURSOR) m_hIcon;\n}\n\nvoid CWaterCheck_demoDlg::OnButtonFilepath() \n{\n\t// TODO: Add your control notification handler code here\n\tCFileDialog fileChooser(TRUE, NULL, NULL, OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, _T(\"All files(*.*)|*.*||\"));\n\tif (fileChooser.DoModal() == IDOK)\n\t{\n\t\tm_csfilePath = fileChooser.GetPathName();\n\t}\n\tSetDlgItemText(IDC_EDIT_FILEPATH, m_csfilePath);\n\tif(m_csfilePath != \"\")\n\t{\n\t\tChangeUIstate(OPENFILE);\n\t}\n}\n\nDWORD WINAPI watermarkCheckPro(LPVOID lParam)\n{\n\tCWaterCheck_demoDlg *dlg = (CWaterCheck_demoDlg *)lParam;\n\tdlg->watermarkCheck();\n\treturn 0;\n}\n\n//convert time stamp info\nbool GetTimeStamp(long lTimeStamp, CString &csTimeStamp)\n{\n\tlong long ltime = static_cast<long long>(lTimeStamp);\n\ttm *tempTime = localtime((time_t*)&ltime);\n\tif(tempTime == 0)\n\t\treturn false;\n\tint nHour = tempTime->tm_hour;\n\tint nMinute = tempTime->tm_min;\n\tint nSec = tempTime->tm_sec;\n\tint nDay = tempTime->tm_mday;\n\tint nMonth = tempTime->tm_mon + 1;\n\tint nYear = tempTime->tm_year + 1900;\n\tcsTimeStamp.Format(_T(\"%d-%02d-%02d-%02d-%02d-%02d\"), nYear, nMonth, nDay, nHour, nMinute, nSec);\n\treturn true;\n}\t\n\nint CALLBACK watermarkCheckCBFunc(long nPort, char* buf, long lTimeStamp, long lInfoType, long len, long reallen, long lCheckResult, void* pUserData)\n{\n\tCWaterCheck_demoDlg *dlg = (CWaterCheck_demoDlg *)pUserData;\n\tCString csErrorType;\n\tCString csItemNum;\n\tCString csTimeStamp;\n\tswitch(lCheckResult)\n\t{\n\t\t//no error:\n\tcase 1:\n\t\t{\n\t\t\tif (lInfoType == WATERMARK_DATA_TEXT)\n\t\t\t{\n\t\t\t\tbuf[reallen] = '\\0';\n\t\t\t\tstd::string waterMark(buf);\n\t\t\t\t//UTF-8תunicode\n\t\t\t\tint len = MultiByteToWideChar(CP_UTF8, 0, waterMark.c_str(), -1, NULL, 0);\n\t\t\t\twchar_t * strUnicode = new wchar_t[len];//len = 2\n\t\t\t\twmemset(strUnicode, 0, len);\n\t            MultiByteToWideChar(CP_UTF8, 0, waterMark.c_str(), -1, strUnicode, len);\n\t\t\t\tdlg->GetDlgItem(IDC_EDIT_WATERMARKINFO)->SetWindowText(strUnicode);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\t//watermark error\n\tcase 2:\n\t\t{\n\t\t\tcsErrorType = LANG_CS(\"Watermark verify error\");\n\t\t\tGetTimeStamp(lTimeStamp, csTimeStamp);\n\t\t\tint errorNum = dlg->m_lscheckInfoList.GetItemCount();\n\t\t\tcsItemNum.Format(_T(\"%d\"), errorNum);\n\t\t\tdlg->m_lscheckInfoList.InsertItem(errorNum, csItemNum);\n\t\t\tdlg->m_lscheckInfoList.SetItemText(errorNum, 1, csErrorType);\n\t\t\tdlg->m_lscheckInfoList.SetItemText(errorNum, 2, csTimeStamp);\t\n\t\t}\n\t\tbreak;\n\t\t//frame data error\n\tcase 3:\n\t\t{\n\t\t\tcsErrorType = LANG_CS(\"Frame data verify error\");\n\t\t\tGetTimeStamp(lTimeStamp, csTimeStamp);\n\t\t\tint errorNum = dlg->m_lscheckInfoList.GetItemCount();\n\t\t\tcsItemNum.Format(_T(\"%d\"), errorNum);\n\t\t\tdlg->m_lscheckInfoList.InsertItem(errorNum, csItemNum);\n\t\t\tdlg->m_lscheckInfoList.SetItemText(errorNum, 1, csErrorType);\n\t\t\tdlg->m_lscheckInfoList.SetItemText(errorNum, 2, csTimeStamp);\n\t\t}\n\t\tbreak;\n\t\t//Frame number discontinuity\n\tcase 4:\n\t\t{\n\t\t\tcsErrorType = LANG_CS(\"Frame number discontinuity\");\n\t\t\tGetTimeStamp(lTimeStamp, csTimeStamp);\n\t\t\tint errorNum = dlg->m_lscheckInfoList.GetItemCount();\n\t\t\tcsItemNum.Format(_T(\"%d\"), errorNum);\n\t\t\tdlg->m_lscheckInfoList.InsertItem(errorNum, csItemNum);\n\t\t\tdlg->m_lscheckInfoList.SetItemText(errorNum, 1, csErrorType);\n\t\t\tdlg->m_lscheckInfoList.SetItemText(errorNum, 2, csTimeStamp);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n//Adjust UI status\nvoid CWaterCheck_demoDlg::ChangeUIstate(int nState)\n{\n\tif(nState == INIT)\n\t{\n\t\tGetDlgItem(IDC_BUTTON_CHECK)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_BUTTON_STOP)->EnableWindow(FALSE);\n\t\t((CProgressCtrl *)GetDlgItem(IDC_PROGRESS))->SetPos(0);\n\t\tGetDlgItem(IDC_EDIT_WATERMARKINFO)->SetWindowText(_T(\"\"));\n\t\tGetDlgItem(IDC_BUTTON_FILEPATH)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_EDIT_FILEPATH)->EnableWindow(TRUE);\n\t}\n\telse if(nState == OPENFILE)\n\t{\n\t\tGetDlgItem(IDC_EDIT_WATERMARKINFO)->SetWindowText(_T(\"\"));\t\n\t\tGetDlgItem(IDC_BUTTON_CHECK)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_BUTTON_STOP)->EnableWindow(FALSE);\n\t\tm_lscheckInfoList.DeleteAllItems();\n\t}\n\telse if(nState == STOP)\n\t{\n\t\tGetDlgItem(IDC_BUTTON_CHECK)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_BUTTON_STOP)->EnableWindow(FALSE);\n\t\t((CProgressCtrl *)GetDlgItem(IDC_PROGRESS))->SetPos(0);\n\t\tGetDlgItem(IDC_EDIT_WATERMARKINFO)->SetWindowText(_T(\"\"));\n\t\tGetDlgItem(IDC_BUTTON_FILEPATH)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_EDIT_FILEPATH)->EnableWindow(TRUE);\n\t\tm_lscheckInfoList.DeleteAllItems();\n\t}\n\telse if(nState == CHECK)\n\t{\n\t\tGetDlgItem(IDC_BUTTON_STOP)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_BUTTON_CHECK)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_BUTTON_FILEPATH)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_EDIT_FILEPATH)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_EDIT_WATERMARKINFO)->SetWindowText(_T(\"\"));\n\t\tm_lscheckInfoList.DeleteAllItems();\n\t}\n\telse\n\t{\n\t\tGetDlgItem(IDC_BUTTON_CHECK)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_BUTTON_STOP)->EnableWindow(FALSE);\n\t\t((CProgressCtrl *)GetDlgItem(IDC_PROGRESS))->SetPos(0);\n\t\tGetDlgItem(IDC_BUTTON_FILEPATH)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_EDIT_FILEPATH)->EnableWindow(TRUE);\n\t}\n}\n\nvoid CWaterCheck_demoDlg::watermarkCheck()\n{\n\tPLAY_SetStreamOpenMode(0, STREAME_FILE);\n\tPLAY_OpenStream(0, NULL, 0, BUF_SIZE);\t\n\tPLAY_Play(0, NULL);\n\tPLAY_SetWaterMarkCallBackEx(0, watermarkCheckCBFunc, this);\n\n\tDWORD dwFileSize = m_checkFile.GetLength();\n\tconst int READ_SIZE = 128*1024;\n\tBYTE pBuf[READ_SIZE];\n\tDWORD dwReadPos = 0;\n\n\tBOOL bInput = TRUE;\n\tDWORD dwReadSize = 0;\n\twhile(WaitForSingleObject(m_hExit, 5)!=WAIT_OBJECT_0)\n\t{\n\t\tif(bInput)\n\t\t{\n\t\t\t((CProgressCtrl *)GetDlgItem(IDC_PROGRESS))->SetPos(((double)dwReadPos*1000)/(double)dwFileSize);\n\t\t\tdwReadSize = m_checkFile.Read(pBuf, READ_SIZE);\n\t\t\tif(dwReadSize<=0)\n\t\t\t\tbreak;\n\t\t\tdwReadPos += dwReadSize;\n\t\t\t\n\t\t}\n\t\t\n\t\tbInput = PLAY_InputData(0, pBuf, dwReadSize);\n\t}\n\n\twhile ( (PLAY_GetBufferValue(0, BUF_VIDEO_RENDER) + PLAY_GetSourceBufferRemain(0)) > 0 )\n\t{\t\n\t\tSleep(5);\n\t}\n\n\tPLAY_Stop(0);\n\tPLAY_CloseStream(0);\n\tm_checkFile.Close();\n\t\n\tChangeUIstate(COMPLETE);\n}\n\nvoid CWaterCheck_demoDlg::OnButtonCheck() \n{\n\t// TODO: Add your control notification handler code here\n\tif(!UpdateData(TRUE))\n\t\treturn;\n\n\tif (!PathFileExists(m_csfilePath))\n\t{\n\t\tMessageBox(LANG_CS(\"Input file error!\"));\n\t\treturn;\n\t}\n\t\n\tif (!m_checkFile.Open(m_csfilePath, CFile::modeRead | CFile::shareDenyNone))\n\t{\n\t\tMessageBox(LANG_CS(\"open file failed!\"));\n\t\treturn;\n\t}\n\n\tDWORD dwID = 0;\n\t\n\tResetEvent(m_hExit);\n\t\n\tm_hThread = CreateThread(NULL, 0, watermarkCheckPro, this, 0, &dwID);\n\t\n\tChangeUIstate(CHECK);\n}\n\nvoid CWaterCheck_demoDlg::OnClose() \n{\n\t// TODO: Add your message handler code here and/or call default\n\tOnButtonStop();\n\tCDialog::OnClose();\n}\n\nvoid CWaterCheck_demoDlg::OnButtonStop() \n{\n\t// TODO: Add your control notification handler code here\n\tSetEvent(m_hExit);\n\tCloseHandle(m_hThread);\n\tm_hThread = NULL;\n\n}\n","size_bytes":10916},"bin/Demo/MfcDemo/10.AlarmDevice/VideoNodeInfo.cpp":{"content":"// VideoNodeInfo.cpp: implementation of the VideoNodeInfo class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"VideoNodeInfo.h\"\n\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\n//////////////////////////////////////////////////////////////////////\n// Construction/Destruction\n//////////////////////////////////////////////////////////////////////\n\nCVideoNodeInfo::CVideoNodeInfo()\n{\n\tm_iDisplayNum=-1;\n\tm_strDvrIP=\"\";\n\tm_wDvrPort=0;\n\tm_iDvrChannel=-1;\n\tm_strDvrUserName=\"\";\n\tm_strDvrPwd=\"\";\n\tm_playMode=DirectMode;\n}\n\nCVideoNodeInfo::~CVideoNodeInfo()\n{\n\n}\n\n//To get video signal \nint CVideoNodeInfo::GetDisplayNum()\n{\n\treturn m_iDisplayNum;\n}\n\n//Set video number \nvoid CVideoNodeInfo::SetDisplayNum(int iDisplayNum)\n{\n\tm_iDisplayNum=iDisplayNum;\n}\n\n//Get DVR IP address \nCString CVideoNodeInfo::GetDvrIP()\n{\n\treturn m_strDvrIP;\n}\n\n//Set DVR IP address \nvoid CVideoNodeInfo::SetDvrIP(CString strDvrIP)\n{\n\tm_strDvrIP=strDvrIP;\n}\n\n//Get DVR port number \nWORD CVideoNodeInfo::GetDvrPort()\n{\n\treturn m_wDvrPort;\n}\n\n//Set DVR port number \nvoid CVideoNodeInfo::SetDvrPort(WORD wPort)\n{\n\tm_wDvrPort=wPort;\n}\n\n//Get DVR channel number \nint CVideoNodeInfo::GetDvrChannel()\n{\n\treturn m_iDvrChannel;\n}\n\n//Set DVR channel number \nvoid CVideoNodeInfo::SetDvrChannel(int iChannel)\n{\n\tm_iDvrChannel=iChannel;\n}\n\n//Get DVR user name \nCString CVideoNodeInfo::GetDvrUserName()\n{\n\treturn m_strDvrUserName;\n}\n\n//Set DVR user name \nvoid CVideoNodeInfo::SetDvrUserName(CString strDvrUserName)\n{\n\tm_strDvrUserName=strDvrUserName;\n}\n\n//Get DVR password \nCString CVideoNodeInfo::GetDvrPwd()\n{\n\treturn m_strDvrPwd;\n}\n\n//Set DVR password \nvoid CVideoNodeInfo::SetDvrPwd(CString strDvrPwd)\n{\n\tm_strDvrPwd=strDvrPwd;\n}\n\n//Get video play mode \nenum RealPlayMode CVideoNodeInfo::GetPlayMode()\n{\n\treturn m_playMode;\n}\n\n//Set video play mode \nvoid CVideoNodeInfo::SetPlayMode(enum RealPlayMode ePlayMode)\n{\n\tm_playMode=ePlayMode;\n}\n\n// Set VideoInfo\nvoid CVideoNodeInfo::SetVideoInfo(int iDisplayNum, CString strDvrIP, WORD wPort, int iChannel, CString strUserName, CString strPwd, enum RealPlayMode ePlayMode)\n{\n\tm_iDisplayNum=iDisplayNum;\n\tm_strDvrIP=strDvrIP;\n\tm_wDvrPort=wPort;\n\tm_iDvrChannel=iChannel;\n\tm_strDvrUserName=strUserName;\n\tm_strDvrPwd=strPwd;\n\tm_playMode=ePlayMode;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":2722},"bin/Demo/MfcDemo/10.AlarmDevice/MultiPlay.cpp":{"content":"// MultiPlay.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"MultiPlay.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CMultiPlay dialog\n\n\nCMultiPlay::CMultiPlay(CWnd* pParent /*=NULL*/)\n\t: CDialog(CMultiPlay::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CMultiPlay)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_nMultiPlay = 0;\n\tm_nChannel = 0;\n\tm_nChannelCount = 0;\n}\n\n\nvoid CMultiPlay::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CMultiPlay)\n\tDDX_Control(pDX, IDC_COMBO_BEGINCHANNEL, m_comboChannel);\n\tDDX_Control(pDX, IDC_COMBO_MULTI, m_comboMulti);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CMultiPlay, CDialog)\n\t//{{AFX_MSG_MAP(CMultiPlay)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CMultiPlay message handlers\n\nvoid CMultiPlay::OnOK() \n{\n\t// TODO: Add extra validation here\n\tint nIndex = m_comboMulti.GetCurSel();\n\tif(CB_ERR != nIndex)\n\t{\n\t\tm_nMultiPlay = m_comboMulti.GetItemData(nIndex);\n\t}\n\tnIndex = m_comboChannel.GetCurSel();\n\tif(CB_ERR != nIndex)\n\t{\n\t\tm_nChannel = m_comboChannel.GetItemData(nIndex);\n\t}\n\tCDialog::OnOK();\n}\n\n//Set dropdown menu \nvoid CMultiPlay::SetMultiPlayDlgInfo(int nChannelCount)\n{\n\tm_nChannelCount = nChannelCount;\n}\n\nBOOL CMultiPlay::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\t// TODO: Add extra initialization here\n\t//Channel dropdown menu \n\tm_comboChannel.ResetContent();\n\tint i = 0;\n\tint nIndex = 0;\n\tfor(i=0;i<m_nChannelCount;i++)\n\t{\n\t\tCString str;\n\t\tstr.Format(\"%d\",i);\n\t\tnIndex = m_comboChannel.AddString(str);\n\t\tm_comboChannel.SetItemData(nIndex,i);\n\t}\n\tif(0 < m_comboChannel.GetCount())\n\t{\n\t\tm_comboChannel.SetCurSel(0);\n\t}\n\t//Video amount dropdown menu \n\tm_comboMulti.ResetContent();\n\tnIndex = m_comboMulti.AddString(ConvertString(\"Single\"));\n\tm_comboMulti.SetItemData(nIndex,1);\n\tnIndex = m_comboMulti.AddString(ConvertString(\"Split-4\"));\n\tm_comboMulti.SetItemData(nIndex,4);\n\tnIndex = m_comboMulti.AddString(ConvertString(\"Split-8\"));\n\tm_comboMulti.SetItemData(nIndex,8);\n\tnIndex = m_comboMulti.AddString(ConvertString(\"Split-9\"));\n\tm_comboMulti.SetItemData(nIndex,9);\n\tnIndex = m_comboMulti.AddString(ConvertString(\"Split-16\"));\n\tm_comboMulti.SetItemData(nIndex,16);\n\tif(0 < m_comboMulti.GetCount())\n\t{\n\t\tm_comboMulti.SetCurSel(0);\n\t}\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":3005},"bin/Demo/MfcDemo/22.ThermalCamera/StatistcisDlg.cpp":{"content":"// StatistcisDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"ThermalCamera.h\"\n#include \"StatistcisDlg.h\"\n#include \"GlobalDlg.h\"\n#include \"ThermalCameraDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CStatistcisDlg dialog\n\n\nCStatistcisDlg::CStatistcisDlg(CWnd* pParent /*=NULL*/,LLONG lLoginId)\n\t: CDialog(CStatistcisDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CStatistcisDlg)\n\tm_Cycle = 0;\n\tm_ITemName = _T(\"\");\n\t//}}AFX_DATA_INIT\n    m_iLoginID = lLoginId;\n\tmemset(&stuInfo, 0, sizeof(stuInfo));\n}\n\n\nvoid CStatistcisDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CStatistcisDlg)\n\tDDX_Control(pDX, IDC_COMBO_TEMPSTANUM, m_Combo_TempStaNum);\n\tDDX_Control(pDX, IDC_COMBO_TEMP, m_Combo_Temp);\n\tDDX_Control(pDX, IDC_COMBO_MODETYPE, m_Combo_ModeType);\n\tDDX_Text(pDX, IDC_EDIT_CYCLE, m_Cycle);\n\tDDX_Text(pDX, IDC_EDIT_ITEMNAME, m_ITemName);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CStatistcisDlg, CDialog)\n\t//{{AFX_MSG_MAP(CStatistcisDlg)\n\tON_CBN_SELCHANGE(IDC_COMBO_TEMPSTANUM, OnSelchangeComboTempstanum)\n\tON_BN_CLICKED(IDC_BTN_GET, OnBtnGet)\n\tON_BN_CLICKED(IDC_BTN_SET, OnBtnSet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CStatistcisDlg message handlers\n\nBOOL CStatistcisDlg::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n    char szJsonBuf[1024 * 40] = {0};\n    int nerror = 0;\n    int nChannel = 1;\n\n\tBOOL ret = CLIENT_GetNewDevConfig(m_iLoginID,CFG_CMD_TEMP_STATISTICS,nChannel,szJsonBuf,1024*40,&nerror,3000);\n    if (0 != ret)\n    {\n        DWORD dwRetLen = 0;\n        ret = CLIENT_ParseData(CFG_CMD_TEMP_STATISTICS,szJsonBuf,(void*)&stuInfo,sizeof(stuInfo),&dwRetLen);\n        if (!ret)\n        {\n            return FALSE;\n        }\n        else\n        {\n            int m_Amout = stuInfo.nCount;\n            int index = 0;\n            for (int i=1;i<=m_Amout;i++)\n            {\n                CString str;\n                str.Format(\"%d\",i);\n                index = m_Combo_TempStaNum.AddString(str);\n                m_Combo_TempStaNum.SetItemData(index,i);\n            }\n            if (0 == stuInfo.stStatistics[0].bEnable)\n            {\n                m_Combo_Temp.SetCurSel(1);\n            }\n            else if (1 == stuInfo.stStatistics[0].bEnable)\n            {\n                m_Combo_Temp.SetCurSel(0);\n            }\n            if (NET_RADIOMETRY_METERTYPE_UNKNOWN == stuInfo.stStatistics[0].nMeterType)\n            {\n                m_Combo_ModeType.SetCurSel(0);\n            }\n            else if (NET_RADIOMETRY_METERTYPE_SPOT == stuInfo.stStatistics[0].nMeterType)\n            {\n                m_Combo_ModeType.SetCurSel(1);\n            }\n            else if (NET_RADIOMETRY_METERTYPE_LINE == stuInfo.stStatistics[0].nMeterType)\n            {\n                m_Combo_ModeType.SetCurSel(2);\n            }\n            else if (NET_RADIOMETRY_METERTYPE_AREA == stuInfo.stStatistics[0].nMeterType)\n            {\n                m_Combo_ModeType.SetCurSel(3);\n            }\n            m_Cycle = stuInfo.stStatistics[0].nPeriod;\n            m_ITemName = stuInfo.stStatistics[0].szName;\n        }\n    }\n    else\n    {\n        return FALSE;\n    }\n\tUpdateData(FALSE);\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CStatistcisDlg::OnSelchangeComboTempstanum() \n{\n\tint i = m_Combo_TempStaNum.GetCurSel();\n    if (0 == stuInfo.stStatistics[i].bEnable)\n    {\n        m_Combo_Temp.SetCurSel(1);\n    }\n    else if (1 == stuInfo.stStatistics[i].bEnable)\n    {\n        m_Combo_Temp.SetCurSel(0);\n    }\n    if (NET_RADIOMETRY_METERTYPE_UNKNOWN == stuInfo.stStatistics[i].nMeterType)\n    {\n        m_Combo_ModeType.SetCurSel(0);\n    }\n    else if (NET_RADIOMETRY_METERTYPE_SPOT == stuInfo.stStatistics[i].nMeterType)\n    {\n        m_Combo_ModeType.SetCurSel(1);\n    }\n    else if (NET_RADIOMETRY_METERTYPE_LINE == stuInfo.stStatistics[i].nMeterType)\n    {\n        m_Combo_ModeType.SetCurSel(2);\n    }\n    else if (NET_RADIOMETRY_METERTYPE_AREA == stuInfo.stStatistics[i].nMeterType)\n    {\n        m_Combo_ModeType.SetCurSel(3);\n    }\n    m_Cycle = stuInfo.stStatistics[i].nPeriod;\n    m_ITemName = stuInfo.stStatistics[i].szName;\n\n}\n\nvoid CStatistcisDlg::OnBtnGet() \n{\n    char szJsonBuf[1024 * 40] = {0};\n    int nerror = 0;\n    int nChannel = -1;\n    \n    BOOL ret = CLIENT_GetNewDevConfig(m_iLoginID,CFG_CMD_TEMP_STATISTICS,nChannel,szJsonBuf,1024*40,&nerror,3000);\n    if (0 != ret)\n    {\n        DWORD dwRetLen = 0;\n        ret = CLIENT_ParseData(CFG_CMD_TEMP_STATISTICS,szJsonBuf,(void*)&stuInfo,sizeof(stuInfo),&dwRetLen);\n        if (!ret)\n        {\n            MessageBox(ConvertString(\"getconfig error\"), ConvertString(\"Prompt\"));\n            return ;\n        }\n        else\n        {\n            int m_Amout = stuInfo.nCount;\n            int index = 0;\n            m_Combo_TempStaNum.ResetContent();\n            for (int i=1;i<=m_Amout;i++)\n            {\n                CString str;\n                str.Format(\"%d\",i);\n                index = m_Combo_TempStaNum.AddString(str);\n                m_Combo_TempStaNum.SetItemData(index,i);\n            }\n            if (0 == stuInfo.stStatistics[0].bEnable)\n            {\n                m_Combo_Temp.SetCurSel(1);\n            }\n            else if (1 == stuInfo.stStatistics[0].bEnable)\n            {\n                m_Combo_Temp.SetCurSel(0);\n            }\n            if (NET_RADIOMETRY_METERTYPE_UNKNOWN == stuInfo.stStatistics[0].nMeterType)\n            {\n                m_Combo_ModeType.SetCurSel(0);\n            }\n            else if (NET_RADIOMETRY_METERTYPE_SPOT == stuInfo.stStatistics[0].nMeterType)\n            {\n                m_Combo_ModeType.SetCurSel(1);\n            }\n            else if (NET_RADIOMETRY_METERTYPE_LINE == stuInfo.stStatistics[0].nMeterType)\n            {\n                m_Combo_ModeType.SetCurSel(2);\n            }\n            else if (NET_RADIOMETRY_METERTYPE_AREA == stuInfo.stStatistics[0].nMeterType)\n            {\n                m_Combo_ModeType.SetCurSel(3);\n            }\n            m_Cycle = stuInfo.stStatistics[0].nPeriod;\n            m_ITemName = stuInfo.stStatistics[0].szName;\n        }\n    }\n    else\n    {\n        MessageBox(ConvertString(\"getconfig error\"), ConvertString(\"Prompt\"));\n        return ;\n    }\n\tUpdateData(FALSE);\n}\n\nvoid CStatistcisDlg::OnBtnSet() \n{\n\t\n}\n","size_bytes":6550},"bin/Demo/MfcDemo/00.DevInit/GetIPDlg.cpp":{"content":"// GetIP.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"SearchDevice.h\"\n#include \"DevInitDlg.h\"\n#include \"GetIPDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// GetIP dialog\n\n\nGetIPDlg::GetIPDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(GetIPDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(GetIP)\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid GetIPDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(GetIP)\n\tDDX_Control(pDX, IDC_IPADDRESS_END, m_ctlEndIP);\n\tDDX_Control(pDX, IDC_IPADDRESS_START, m_ctlStartIP);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(GetIPDlg, CDialog)\n\t//{{AFX_MSG_MAP(GetIP)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// GetIP message handlers\n\nvoid GetIPDlg::OnOK() \n{\n\t// TODO: Add extra validation here\n\tUpdateData(TRUE);\n\tDWORD dwStartIP,dwEndIP;\n\tm_ctlStartIP.GetAddress(dwStartIP);\n\tm_ctlEndIP.GetAddress(dwEndIP);\n\t(this->GetParent())->PostMessage(WM_SEARCHDEVICEBYIPS, WPARAM(dwStartIP), LPARAM(dwEndIP));\n\tCDialog::OnOK();\n}\n\nBOOL GetIPDlg::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\t// TODO: Add extra initialization here\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n","size_bytes":1447},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/ConfigMainDlg.cpp":{"content":"// ConfigMainDlg.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"ConfigMainDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CConfigMainDlg dialog\n\n\nCConfigMainDlg::CConfigMainDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CConfigMainDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CConfigMainDlg)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_pDev = 0;\n}\n\n\nvoid CConfigMainDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CConfigMainDlg)\n\tDDX_Control(pDX, IDC_TAB_BOARD, m_configBoard);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CConfigMainDlg, CDialog)\n\t//{{AFX_MSG_MAP(CConfigMainDlg)\n\tON_NOTIFY(TCN_SELCHANGE, IDC_TAB_BOARD, OnSelchangeTabBoard)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CConfigMainDlg message handlers\n\nBOOL CConfigMainDlg::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\n\tif (!m_pDev)\n\t{\n\t\treturn TRUE;\n\t}\n\t\n\tm_configBoard.InsertItem(0, ConvertString(NAME_CFG_SERVERCONFIG));\n\tm_configBoard.InsertItem(1, ConvertString(NAME_CFG_CHANNELCONFIG));\n\tm_configBoard.InsertItem(2, ConvertString(NAME_CFG_SERIALCONFIG));\n\tm_configBoard.InsertItem(3, ConvertString(NAME_CFG_ALARMRECORD));\n\tm_configBoard.InsertItem(4, ConvertString(NAME_CFG_NETWORK));\n\tm_configBoard.InsertItem(5, ConvertString(NAME_CFG_ALARMCONFIG));\n\n\tm_serverDlg.SetDevice(m_pDev);\n\tm_channelDlg.SetDevice(m_pDev);\n\tm_commDlg.SetDevice(m_pDev);\n\tm_alarmDlg.SetDevice(m_pDev);\n\tm_recordDlg.SetDevice(m_pDev);\n\tm_networkDlg.SetDevice(m_pDev);\n\n\tCRect childRect;\n\tm_configBoard.GetClientRect(childRect);\n\tchildRect.top += 30;\n\tchildRect.bottom -= 4;\n\tchildRect.left += 4;\n\tchildRect.right -= 4;\n\n\tm_serverDlg.Create(IDD_CONFIG_SERVER, &m_configBoard);\n\tm_serverDlg.MoveWindow(childRect);\n\tm_channelDlg.Create(IDD_CONFIG_CHANNEL, &m_configBoard);\n\tm_channelDlg.MoveWindow(childRect);\n\tm_commDlg.Create(IDD_CONFIG_COMM, &m_configBoard);\n\tm_commDlg.MoveWindow(childRect);\n\tm_alarmDlg.Create(IDD_CONFIG_ALARM, &m_configBoard);\n\tm_alarmDlg.MoveWindow(childRect);\n\tm_recordDlg.Create(IDD_CONFIG_RECORD, &m_configBoard);\n\tm_recordDlg.MoveWindow(childRect);\n\tm_networkDlg.Create(IDD_CONFIG_NETWORK, &m_configBoard);\n\tm_networkDlg.MoveWindow(childRect);\n\t\n\tm_configBoard.SetCurSel(0);\n\tm_serverDlg.ShowWindow(SW_SHOW);\n\tm_channelDlg.ShowWindow(SW_HIDE);\n\tm_commDlg.ShowWindow(SW_HIDE);\n\tm_alarmDlg.ShowWindow(SW_HIDE);\n\tm_recordDlg.ShowWindow(SW_HIDE);\n\tm_networkDlg.ShowWindow(SW_HIDE);\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CConfigMainDlg::OnSelchangeTabBoard(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tswitch(m_configBoard.GetCurSel())\n\t{\n\tcase 0:\t\t\t//server config board\n\t\tm_serverDlg.ShowWindow(SW_SHOW);\n\t\tm_channelDlg.ShowWindow(SW_HIDE);\n\t\tm_commDlg.ShowWindow(SW_HIDE);\n\t\tm_alarmDlg.ShowWindow(SW_HIDE);\n\t\tm_recordDlg.ShowWindow(SW_HIDE);\n\t\tm_networkDlg.ShowWindow(SW_HIDE);\n\t\tbreak;\n\tcase 1:\t\t\t//channel config board\n\t\tm_channelDlg.ShowWindow(SW_SHOW);\n\t\tm_serverDlg.ShowWindow(SW_HIDE);\n\t\tm_commDlg.ShowWindow(SW_HIDE);\n\t\tm_alarmDlg.ShowWindow(SW_HIDE);\n\t\tm_recordDlg.ShowWindow(SW_HIDE);\n\t\tm_networkDlg.ShowWindow(SW_HIDE);\n\t\tbreak;\n\tcase 2:\t\t\t//serial comm config board\n\t\tm_commDlg.ShowWindow(SW_SHOW);\n\t\tm_serverDlg.ShowWindow(SW_HIDE);\n\t\tm_channelDlg.ShowWindow(SW_HIDE);\n\t\tm_alarmDlg.ShowWindow(SW_HIDE);\n\t\tm_recordDlg.ShowWindow(SW_HIDE);\n\t\tm_networkDlg.ShowWindow(SW_HIDE);\n\t\tbreak;\n\tcase 3:\t\t\t//record config board\t\n\t\tm_recordDlg.ShowWindow(SW_SHOW);\n\t\tm_alarmDlg.ShowWindow(SW_HIDE);\n\t\tm_serverDlg.ShowWindow(SW_HIDE);\n\t\tm_channelDlg.ShowWindow(SW_HIDE);\n\t\tm_commDlg.ShowWindow(SW_HIDE);\n\t\tm_networkDlg.ShowWindow(SW_HIDE);\n\t\tbreak;\n\tcase 4:\t\t\t//alarm config board\n\t\tm_networkDlg.ShowWindow(SW_SHOW);\n\t\tm_alarmDlg.ShowWindow(SW_HIDE);\n\t\tm_serverDlg.ShowWindow(SW_HIDE);\n\t\tm_channelDlg.ShowWindow(SW_HIDE);\n\t\tm_commDlg.ShowWindow(SW_HIDE);\n\t\tm_recordDlg.ShowWindow(SW_HIDE);\n\t\tbreak;\n\tcase 5:\n\t\tm_alarmDlg.ShowWindow(SW_SHOW);\n\t\tm_networkDlg.ShowWindow(SW_HIDE);\n\t\tm_serverDlg.ShowWindow(SW_HIDE);\n\t\tm_channelDlg.ShowWindow(SW_HIDE);\n\t\tm_commDlg.ShowWindow(SW_HIDE);\n\t\tm_recordDlg.ShowWindow(SW_HIDE);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t*pResult = 0;\n}\n\nvoid CConfigMainDlg::SetDevice(DeviceNode *pDev)\n{\n\tm_pDev = pDev;\n}\n","size_bytes":4605},"bin/Demo/MfcDemo/00.DevInit/LibQREncode/mqrspec.c":{"content":"/*\n * qrencode - QR Code encoder\n *\n * Micor QR Code specification in convenient format. \n * Copyright (C) 2006-2011 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * The following data / specifications are taken from\n * \"Two dimensional symbol -- QR-code -- Basic Specification\" (JIS X0510:2004)\n *  or\n * \"Automatic identification and data capture techniques -- \n *  QR Code 2005 bar code symbology specification\" (ISO/IEC 18004:2006)\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#if HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#ifdef HAVE_LIBPTHREAD\n#include <pthread.h>\n#endif\n\n#include \"mqrspec.h\"\n\n/******************************************************************************\n * Version and capacity\n *****************************************************************************/\n\ntypedef struct {\n\tint width; //< Edge length of the symbol\n\tint ec[4];  //< Number of ECC code (bytes)\n} MQRspec_Capacity;\n\n/**\n * Table of the capacity of symbols\n * See Table 1 (pp.106) and Table 8 (pp.113) of Appendix 1, JIS X0510:2004.\n */\nstatic const MQRspec_Capacity mqrspecCapacity[MQRSPEC_VERSION_MAX + 1] = {\n\t{  0, {0,  0,  0, 0}},\n\t{ 11, {2,  0,  0, 0}},\n\t{ 13, {5,  6,  0, 0}},\n\t{ 15, {6,  8,  0, 0}},\n\t{ 17, {8, 10, 14, 0}}\n};\n\nint MQRspec_getDataLengthBit(int version, QRecLevel level)\n{\n\tint w;\n\tint ecc;\n\n\tw = mqrspecCapacity[version].width - 1;\n\tecc = mqrspecCapacity[version].ec[level];\n\tif(ecc == 0) return 0;\n\treturn w * w - 64 - ecc * 8;\n}\n\nint MQRspec_getDataLength(int version, QRecLevel level)\n{\n\treturn (MQRspec_getDataLengthBit(version, level) + 4) / 8;\n}\n\nint MQRspec_getECCLength(int version, QRecLevel level)\n{\n\treturn mqrspecCapacity[version].ec[level];\n}\n\nint MQRspec_getWidth(int version)\n{\n\treturn mqrspecCapacity[version].width;\n}\n\n/******************************************************************************\n * Length indicator\n *****************************************************************************/\n\n/**\n * See Table 3 (pp.107) of Appendix 1, JIS X0510:2004.\n */\nstatic const int lengthTableBits[4][4] = {\n\t{ 3, 4, 5, 6},\n\t{ 0, 3, 4, 5},\n\t{ 0, 0, 4, 5},\n\t{ 0, 0, 3, 4}\n};\n\nint MQRspec_lengthIndicator(QRencodeMode mode, int version)\n{\n\treturn lengthTableBits[mode][version - 1];\n}\n\nint MQRspec_maximumWords(QRencodeMode mode, int version)\n{\n\tint bits;\n\tint words;\n\n\tbits = lengthTableBits[mode][version - 1];\n\twords = (1 << bits) - 1;\n\tif(mode == QR_MODE_KANJI) {\n\t\twords *= 2; // the number of bytes is required\n\t}\n\n\treturn words;\n}\n\n/******************************************************************************\n * Format information\n *****************************************************************************/\n\n/* See calcFormatInfo in tests/test_mqrspec.c */\nstatic const unsigned int formatInfo[4][8] = {\n\t{0x4445, 0x55ae, 0x6793, 0x7678, 0x06de, 0x1735, 0x2508, 0x34e3},\n\t{0x4172, 0x5099, 0x62a4, 0x734f, 0x03e9, 0x1202, 0x203f, 0x31d4},\n\t{0x4e2b, 0x5fc0, 0x6dfd, 0x7c16, 0x0cb0, 0x1d5b, 0x2f66, 0x3e8d},\n\t{0x4b1c, 0x5af7, 0x68ca, 0x7921, 0x0987, 0x186c, 0x2a51, 0x3bba}\n};\n\n/* See Table 10 of Appendix 1. (pp.115) */\nstatic const int typeTable[MQRSPEC_VERSION_MAX + 1][3] = {\n\t{-1, -1, -1},\n\t{ 0, -1, -1},\n\t{ 1,  2, -1},\n\t{ 3,  4, -1},\n\t{ 5,  6,  7}\n};\n\nunsigned int MQRspec_getFormatInfo(int mask, int version, QRecLevel level)\n{\n\tint type;\n\n\tif(mask < 0 || mask > 3) return 0;\n\tif(version <= 0 || version > MQRSPEC_VERSION_MAX) return 0;\n\tif(level == QR_ECLEVEL_H) return 0;\n\ttype = typeTable[version][level];\n\tif(type < 0) return 0;\n\n\treturn formatInfo[mask][type];\n}\n\n/******************************************************************************\n * Frame\n *****************************************************************************/\n\n/**\n * Cache of initial frames.\n */\n/* C99 says that static storage shall be initialized to a null pointer\n * by compiler. */\nstatic unsigned char *frames[MQRSPEC_VERSION_MAX + 1];\n#ifdef HAVE_LIBPTHREAD\nstatic pthread_mutex_t frames_mutex = PTHREAD_MUTEX_INITIALIZER;\n#endif\n\n/**\n * Put a finder pattern.\n * @param frame\n * @param width\n * @param ox,oy upper-left coordinate of the pattern\n */\nstatic void putFinderPattern(unsigned char *frame, int width, int ox, int oy)\n{\n\tstatic const unsigned char finder[] = {\n\t\t0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,\n\t\t0xc1, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc1,\n\t\t0xc1, 0xc0, 0xc1, 0xc1, 0xc1, 0xc0, 0xc1,\n\t\t0xc1, 0xc0, 0xc1, 0xc1, 0xc1, 0xc0, 0xc1,\n\t\t0xc1, 0xc0, 0xc1, 0xc1, 0xc1, 0xc0, 0xc1,\n\t\t0xc1, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc1,\n\t\t0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,\n\t};\n\tint x, y;\n\tconst unsigned char *s;\n\n\tframe += oy * width + ox;\n\ts = finder;\n\tfor(y=0; y<7; y++) {\n\t\tfor(x=0; x<7; x++) {\n\t\t\tframe[x] = s[x];\n\t\t}\n\t\tframe += width;\n\t\ts += 7;\n\t}\n}\n\nstatic unsigned char *MQRspec_createFrame(int version)\n{\n\tunsigned char *frame, *p, *q;\n\tint width;\n\tint x, y;\n\n\twidth = mqrspecCapacity[version].width;\n\tframe = (unsigned char *)malloc(width * width);\n\tif(frame == NULL) return NULL;\n\n\tmemset(frame, 0, width * width);\n\t/* Finder pattern */\n\tputFinderPattern(frame, width, 0, 0);\n\t/* Separator */\n\tp = frame;\n\tfor(y=0; y<7; y++) {\n\t\tp[7] = 0xc0;\n\t\tp += width;\n\t}\n\tmemset(frame + width * 7, 0xc0, 8);\n\t/* Mask format information area */\n\tmemset(frame + width * 8 + 1, 0x84, 8);\n\tp = frame + width + 8;\n\tfor(y=0; y<7; y++) {\n\t\t*p = 0x84;\n\t\tp += width;\n\t}\n\t/* Timing pattern */\n\tp = frame + 8;\n\tq = frame + width * 8;\n\tfor(x=1; x<width-7; x++) {\n\t\t*p =  0x90 | (x & 1);\n\t\t*q =  0x90 | (x & 1);\n\t\tp++;\n\t\tq += width;\n\t}\n\n\treturn frame;\n}\n\nunsigned char *MQRspec_newFrame(int version)\n{\n\tunsigned char *frame;\n\tint width;\n\n\tif(version < 1 || version > MQRSPEC_VERSION_MAX) return NULL;\n\n#ifdef HAVE_LIBPTHREAD\n\tpthread_mutex_lock(&frames_mutex);\n#endif\n\tif(frames[version] == NULL) {\n\t\tframes[version] = MQRspec_createFrame(version);\n\t}\n#ifdef HAVE_LIBPTHREAD\n\tpthread_mutex_unlock(&frames_mutex);\n#endif\n\tif(frames[version] == NULL) return NULL;\n\n\twidth = mqrspecCapacity[version].width;\n\tframe = (unsigned char *)malloc(width * width);\n\tif(frame == NULL) return NULL;\n\tmemcpy(frame, frames[version], width * width);\n\n\treturn frame;\n}\n\nvoid MQRspec_clearCache(void)\n{\n\tint i;\n\n#ifdef HAVE_LIBPTHREAD\n\tpthread_mutex_lock(&frames_mutex);\n#endif\n\tfor(i=1; i<=MQRSPEC_VERSION_MAX; i++) {\n\t\tfree(frames[i]);\n\t\tframes[i] = NULL;\n\t}\n#ifdef HAVE_LIBPTHREAD\n\tpthread_mutex_unlock(&frames_mutex);\n#endif\n}\n","size_bytes":7089},"bin/Demo/MfcDemo/07.ImageTest/ImageTest.cpp":{"content":"// ImageTest.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"ImageTest.h\"\n#include \"ImageTestDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CImageTestApp\n\nBEGIN_MESSAGE_MAP(CImageTestApp, CWinApp)\n\t//{{AFX_MSG_MAP(CImageTestApp)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t\t//    DO NOT EDIT what you see in these blocks of generated code!\n\t//}}AFX_MSG\n\tON_COMMAND(ID_HELP, CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CImageTestApp construction\n\nCImageTestApp::CImageTestApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The one and only CImageTestApp object\n\nCImageTestApp theApp;\n\n//Set static text in the dialogue box(English->current language) \nvoid g_SetWndStaticText(CWnd * pWnd)\n{\n\tCString strCaption,strText;\n\t\n\t//Set main window title \n\tpWnd->GetWindowText(strCaption);\n\tif(strCaption.GetLength()>0)\n\t{\n\t\tstrText=ConvertString(strCaption);\n\t\tpWnd->SetWindowText(strText);\n\t}\n\t\n\t//Set sub-window title \n\tCWnd * pChild=pWnd->GetWindow(GW_CHILD);\n\tCString strClassName;\n\twhile(pChild)\n\t{\n\t\t//////////////////////////////////////////////////////////////////////////\t\t\n\t\t//Added by Jackbin 2005-03-11\n\t\tstrClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n\t\tif(strClassName == \"CEdit\")\n\t\t{\n\t\t\t//The next sub-window \n\t\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t//////////////////////////////////////////////////////////////////////////\t\n\t\t\n\t\t//Set current language text in the sub-window \n\t\tpChild->GetWindowText(strCaption);\n\t\tstrText=ConvertString(strCaption);\n\t\tpChild->SetWindowText(strText);\n\t\t\n\t\t//The next sub-window \n\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t}\n}\n/////////////////////////////////////////////////////////////////////////////\n// CImageTestApp initialization\nCString ConvertString(CString strText)\n{\n    char *val = new char[200];\n    CString strIniPath,strRet;\n    \n    memset(val,0,200);\n    GetPrivateProfileString(\"String\",strText,\"\",\n        val,200,\"./langchn.ini\");\n    strRet = val;\n    if(strRet.GetLength()==0)\n    {\n        //If there is no corresponding string in ini file then set it to be default value(English)\n        strRet=strText;\n    }\n    delete val;\n    return strRet;\n}\n\n\nBOOL CImageTestApp::InitInstance()\n{\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t//  of your final executable, you should remove from the following\n\t//  the specific initialization routines you do not need.\n\n#ifdef _AFXDLL\n\tEnable3dControls();\t\t\t// Call this when using MFC in a shared DLL\n#else\n\tEnable3dControlsStatic();\t// Call this when linking to MFC statically\n#endif\n\n\tCImageTestDlg dlg;\n\tm_pMainWnd = &dlg;\n\tINT_PTR nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n","size_bytes":3474},"bin/Demo/MfcDemo/22.ThermalCamera/LocalParameter.cpp":{"content":"// LocalParameter.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"ThermalCamera.h\"\n#include \"LocalParameter.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CLocalParameter dialog\n\n\nCLocalParameter::CLocalParameter(CWnd* pParent /*=NULL*/,LLONG lLoginId)\n\t: CDialog(CLocalParameter::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CLocalParameter)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n    m_iLoginID = lLoginId;\n}\n\n\nvoid CLocalParameter::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CLocalParameter)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CLocalParameter, CDialog)\n\t//{{AFX_MSG_MAP(CLocalParameter)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CLocalParameter message handlers\n\nBOOL CLocalParameter::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\n   \n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n","size_bytes":1237},"bin/Demo/MfcDemo/10.AlarmDevice/DlgAnalogAlarmData.cpp":{"content":"// DlgAnalogAlarmData.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgAnalogAlarmData.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgAnalogAlarmData dialog\n\n\nCDlgAnalogAlarmData::CDlgAnalogAlarmData(CWnd* pParent /* = NULL */, LLONG lLoginID /* = 0 */)\n\t: CDialog(CDlgAnalogAlarmData::IDD, pParent)\n\t, m_lLoginID(lLoginID)\n\t, m_lAttachID(0)\n\t, m_nIndex(0)\n{\n\t//{{AFX_DATA_INIT(CDlgAnalogAlarmData)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CDlgAnalogAlarmData::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgAnalogAlarmData)\n\tDDX_Control(pDX, IDC_ANALOGALARM_DATA_LIST_INFO, m_lstDataInfo);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgAnalogAlarmData, CDialog)\n\t//{{AFX_MSG_MAP(CDlgAnalogAlarmData)\n\tON_WM_DESTROY()\n\tON_BN_CLICKED(IDC_ANALOGALARM_DATA_BTN_ATTACH, OnAnalogalarmDataBtnAttach)\n\tON_BN_CLICKED(IDC_ANALOGALARM_DATA_BTN_DETACH, OnAnalogalarmDataBtnDetach)\n\tON_MESSAGE(WM_ON_ANALOGALARM_DATA, OnAnalogAlarmData)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// Private method handlers\n\nvoid CDlgAnalogAlarmData::GetTimeStringByStruct(NET_TIME stuTime, char *pTime)\n{\n\tif (pTime)\n\t{\n\t\tsprintf(pTime, \"%lu-%lu-%lu %lu:%lu:%lu\", stuTime.dwYear, stuTime.dwMonth, stuTime.dwDay,\n\t\t\tstuTime.dwHour, stuTime.dwMinute, stuTime.dwSecond);\n\t}\n}\n\nvoid CDlgAnalogAlarmData::InitListControl()\n{\t\n\tm_lstDataInfo.SetExtendedStyle(m_lstDataInfo.GetExtendedStyle()| LVS_EX_HEADERDRAGDROP | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES );\n\tm_lstDataInfo.InsertColumn(0, ConvertString(\"Index\", DLG_ANALOGALARM_DATA), LVCFMT_LEFT, 40, -1);\n\tm_lstDataInfo.InsertColumn(1, ConvertString(\"Channel\", DLG_ANALOGALARM_DATA), LVCFMT_LEFT, 50, -1);\n\tm_lstDataInfo.InsertColumn(2, ConvertString(\"Sensor\", DLG_ANALOGALARM_DATA), LVCFMT_LEFT, 70, -1);\n\tm_lstDataInfo.InsertColumn(3, ConvertString(\"Data\", DLG_ANALOGALARM_DATA), LVCFMT_LEFT, 80, -1);\n\tm_lstDataInfo.InsertColumn(4, ConvertString(\"Time\", DLG_ANALOGALARM_DATA), LVCFMT_LEFT, 120, -1);\n\tm_lstDataInfo.InsertColumn(5, ConvertString(\"Status\", DLG_ANALOGALARM_DATA), LVCFMT_LEFT, 60, -1);\n}\n\nvoid CDlgAnalogAlarmData::UpdateList()\n{\n\tif (m_nIndex >= MAX_INFO_SHOW)\n\t{\n\t\tm_lstDataInfo.DeleteAllItems();\n\t\tm_nIndex = 0;\n\t}\n}\n\nvoid CDlgAnalogAlarmData::InsertEventInfo(const NET_ANALOGALARM_SENSE_INFO& stuInfo)\n{\n\tUpdateList();\n\t\t\t\t\n\tchar szIndex[32] = {0};\n\t_itoa(m_nIndex + 1, szIndex, 10);\n\tm_lstDataInfo.InsertItem(m_nIndex, NULL);\n\t\n\t// index\n\tm_lstDataInfo.SetItemText(m_nIndex, 0, szIndex);\n\t\n\t// channel id\n\tCString csChannelId;\n\tcsChannelId.Format(\"%s %03d\", ConvertString(\"Channel\", DLG_ANALOGALARM_DATA), stuInfo.nChannelID + 1);\n\tm_lstDataInfo.SetItemText(m_nIndex, 1, csChannelId);\n\n\t// sensor\n\tCString csSensor;\n\tSenseTypeToStr(stuInfo.emSense, csSensor);\n\tm_lstDataInfo.SetItemText(m_nIndex, 2, ConvertString(csSensor, DLG_CFG_ALARM));\n\n\t// data \n\tCString csData;\n\tcsData.Format(\"%f\", stuInfo.fData);\n\tm_lstDataInfo.SetItemText(m_nIndex, 3, csData);\n\n\t// time\n\tchar szTime[64] = {0};\n\tGetTimeStringByStruct(stuInfo.stuTime, szTime);\n\tm_lstDataInfo.SetItemText(m_nIndex, 4, szTime);\n\n\t// status\n\tCString csStatus = AnalogAlarmDataStatusToStr(stuInfo.nStatus);\n\tm_lstDataInfo.SetItemText(m_nIndex, 5, ConvertString(csStatus, DLG_SUBSCRIBE));\n\n\t// update index\n\tm_nIndex++;\n}\n\nvoid CALLBACK OnAnalogAlarmDataCallBack(LLONG lLoginID, LLONG lAttachHandle, NET_ANALOGALARM_SENSE_INFO* pInfo, int nBufLen, LDWORD dwUser)\n{\n\t((CDlgAnalogAlarmData*)dwUser)->AnalogAlarmDataCallBack(lLoginID, lAttachHandle, pInfo, nBufLen);\n}\n\nvoid CDlgAnalogAlarmData::AnalogAlarmDataCallBack(LLONG lLoginID, LLONG lAttachHandle, NET_ANALOGALARM_SENSE_INFO* pInfo, int nBufLen)\n{\n\tif (lLoginID != m_lLoginID || lAttachHandle != m_lAttachID || NULL == pInfo || 0 == pInfo->dwSize || nBufLen <= 0)\n\t{\n\t\treturn;\n\t}\n\n\tNET_ANALOGALARM_SENSE_INFO* pDemo = new NET_ANALOGALARM_SENSE_INFO;\n\tassert(pDemo != NULL);\n\tmemset(pDemo, 0, sizeof(NET_ANALOGALARM_SENSE_INFO));\n\tpDemo->dwSize = sizeof(NET_ANALOGALARM_SENSE_INFO);\n\n\tint nSize = sizeof(pDemo->dwSize);\n\tnSize += sizeof(pDemo->nChannelID);\n\tif (nSize <= pInfo->dwSize)\n\t{\n\t\tpDemo->nChannelID = pInfo->nChannelID;\n\t}\n\n\tnSize += sizeof(pDemo->emSense);\n\tif (nSize <= pInfo->dwSize)\n\t{\n\t\tpDemo->emSense = pInfo->emSense;\n\t}\n\n\tnSize += sizeof(pDemo->fData);\n\tif (nSize <= pInfo->dwSize)\n\t{\n\t\tpDemo->fData = pInfo->fData;\n\t}\n\n\tnSize += sizeof(pDemo->stuTime);\n\tif (nSize <= pInfo->dwSize)\n\t{\n\t\tmemcpy(&pDemo->stuTime, &pInfo->stuTime, sizeof(NET_TIME));\n\t}\n\n    nSize += sizeof(pDemo->nStatus);\n    if (nSize <= pInfo->dwSize)\n    {\n        pDemo->nStatus = pInfo->nStatus;\n    }\n\n\tPostMessage(WM_ON_ANALOGALARM_DATA, (WPARAM)pDemo, (LPARAM)(pDemo->dwSize));\n}\n\nLRESULT CDlgAnalogAlarmData::OnAnalogAlarmData(WPARAM wParam, LPARAM lParam)\n{\n\tNET_ANALOGALARM_SENSE_INFO* pInfo = (NET_ANALOGALARM_SENSE_INFO*)wParam;\n\tDWORD dwSize = (DWORD)lParam;\n\tif (NULL == pInfo || pInfo->dwSize != dwSize)\n\t{\n\t\treturn -1;\n\t}\n\t\n\tInsertEventInfo(*pInfo);\n\t\n\tdelete pInfo;\n\tpInfo = NULL;\n\t\n\treturn 0;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgAnalogAlarmData message handlers\n\nBOOL CDlgAnalogAlarmData::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_ANALOGALARM_DATA);\n\t\n\t// TODO: Add extra initialization here\n\tInitListControl();\n\tGetDlgItem(IDC_ANALOGALARM_DATA_BTN_ATTACH)->EnableWindow();\n\tGetDlgItem(IDC_ANALOGALARM_DATA_BTN_DETACH)->EnableWindow(FALSE);\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgAnalogAlarmData::OnDestroy() \n{\n\tCDialog::OnDestroy();\n\t\n\t// TODO: Add your message handler code here\n\tif (m_lAttachID != NULL)\n\t{\n\t\tCLIENT_DetachAnalogAlarmData(m_lAttachID);\n\t\tm_lAttachID = NULL;\n\t}\n}\n\nvoid CDlgAnalogAlarmData::OnAnalogalarmDataBtnAttach() \n{\n\t// TODO: Add your control notification handler code here\n\tNET_IN_ANALOGALARM_DATA stuIn = {sizeof(stuIn)};\n\tNET_OUT_ANALOGALARM_DATA stuOut = {sizeof(stuOut)};\n\n\tstuIn.cbCallBack = OnAnalogAlarmDataCallBack;\n\tstuIn.dwUser = (LDWORD)this;\n\tstuIn.nChannelId = -1;\n\n\tLLONG lAttach = CLIENT_AttachAnalogAlarmData(m_lLoginID, &stuIn, &stuOut, SDK_API_WAIT);\n\tif (lAttach != NULL)\n\t{\n\t\tm_lAttachID = lAttach;\n\t\tm_lstDataInfo.DeleteAllItems();\n\t\tm_nIndex = 0;\n\t\tGetDlgItem(IDC_ANALOGALARM_DATA_BTN_ATTACH)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_ANALOGALARM_DATA_BTN_DETACH)->EnableWindow();\n\t}\n\telse\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%s:0x%08x\", ConvertString(\"Attach analog alarm data failed\", DLG_ANALOGALARM_DATA), CLIENT_GetLastError());\n\t\tMessageBox(csInfo, ConvertString(\"AnalogAlarmData\", DLG_ANALOGALARM_DATA));\n\t}\n}\n\nvoid CDlgAnalogAlarmData::OnAnalogalarmDataBtnDetach() \n{\n\t// TODO: Add your control notification handler code here\n\tCLIENT_DetachAnalogAlarmData(m_lAttachID);\n\tm_lAttachID = NULL;\n\tGetDlgItem(IDC_ANALOGALARM_DATA_BTN_ATTACH)->EnableWindow();\n\tGetDlgItem(IDC_ANALOGALARM_DATA_BTN_DETACH)->EnableWindow(FALSE);\n}\n","size_bytes":7270},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgNTP.cpp":{"content":"// DlgCfgNTP.cpp : implementation file\n//\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgCfgNTP.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgNTP dialog\n\n\nCDlgCfgNTP::CDlgCfgNTP(CWnd* pParent /* = NULL */, LLONG lLoginId /* = NULL */)\n\t: CDialog(CDlgCfgNTP::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgNTP)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\tm_lLoginId = lLoginId;\n\t//}}AFX_DATA_INIT\n\tmemset(&m_stuInfo, 0, sizeof(m_stuInfo));\n}\n\n\nvoid CDlgCfgNTP::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgNTP)\n\tDDX_Control(pDX, IDC_CFG_NTP_CMB_TIMEZONE, m_cmbTimeZone);\n\tDDX_Control(pDX, IDC_CFG_NTP_CHK_ENABLE, m_chkEnable);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgNTP, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgNTP)\n\tON_BN_CLICKED(IDC_CFG_NTP_BTN_GET, OnCfgNtpBtnGet)\n\tON_BN_CLICKED(IDC_CFG_NTP_BTN_SET, OnCfgNtpBtnSet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgNTP private method\n\nvoid CDlgCfgNTP::InitDlg()\n{\n\t// enable\n\tm_chkEnable.SetCheck(BST_UNCHECKED);\n\n\t// name\n\tSetDlgItemText(IDC_CFG_NTP_EDT_NAME, \"\");\n\n\t// port\n\tSetDlgItemInt(IDC_CFG_NTP_EDT_PORT, 0, FALSE);\n\n\t// update period\n\tSetDlgItemInt(IDC_CFG_NTP_EDT_UPDATEPERIOD, 0, FALSE);\n\n\t// time zone\n\tm_cmbTimeZone.ResetContent();\n\tfor (int i = 0; i < sizeof(DemoTimeZone) / sizeof(DemoTimeZone[0]); i++)\n\t{\n\t\tm_cmbTimeZone.InsertString(-1, DemoTimeZone[i].pszName);\n\t}\n\tm_cmbTimeZone.SetCurSel(-1);\n\n\t// description\n\tSetDlgItemText(IDC_CFG_NTP_EDT_DESCRIPTION, \"\");\n}\n\nvoid CDlgCfgNTP::StuToDlg()\n{\n\tm_chkEnable.SetCheck(m_stuInfo.bEnable ? BST_CHECKED : BST_UNCHECKED);\n\tSetDlgItemText(IDC_CFG_NTP_EDT_NAME, m_stuInfo.szAddress);\n\tSetDlgItemInt(IDC_CFG_NTP_EDT_PORT, m_stuInfo.nPort, FALSE);\n\tSetDlgItemInt(IDC_CFG_NTP_EDT_UPDATEPERIOD, m_stuInfo.nUpdatePeriod, FALSE);\n\tm_cmbTimeZone.SetCurSel((int)m_stuInfo.emTimeZoneType);\n\tSetDlgItemText(IDC_CFG_NTP_EDT_DESCRIPTION, m_stuInfo.szTimeZoneDesc);\n}\n\nvoid CDlgCfgNTP::DlgToStu()\n{\n\tm_stuInfo.bEnable = m_chkEnable.GetCheck() ? TRUE : FALSE;\n\tGetDlgItemText(IDC_CFG_NTP_EDT_NAME, m_stuInfo.szAddress, sizeof(m_stuInfo.szAddress));\n\tm_stuInfo.nPort = GetDlgItemInt(IDC_CFG_NTP_EDT_PORT, NULL, FALSE);\n\tm_stuInfo.nUpdatePeriod = GetDlgItemInt(IDC_CFG_NTP_EDT_UPDATEPERIOD, NULL, FALSE);\n\tm_stuInfo.emTimeZoneType = (EM_CFG_TIME_ZONE_TYPE)m_cmbTimeZone.GetCurSel();\n\tGetDlgItemText(IDC_CFG_NTP_EDT_DESCRIPTION, m_stuInfo.szTimeZoneDesc, sizeof(m_stuInfo.szTimeZoneDesc));\n}\n\nBOOL CDlgCfgNTP::GetConfig()\n{\n\tchar szJsonBuf[1024 * 10] = {0};\n\tint nErr = 0, nRestart = 0;\n\tBOOL bRet = CLIENT_GetNewDevConfig(m_lLoginId, CFG_CMD_NTP,\n\t\t-1, szJsonBuf, sizeof(szJsonBuf), &nErr, SDK_API_WAIT);\n\tif (bRet)\n\t{\n\t\tCFG_NTP_INFO stuInfo = {sizeof(CFG_NTP_INFO)};  \n\t\t\n\t\tDWORD dwRetLen = 0;\n\t\tbRet = CLIENT_ParseData(CFG_CMD_NTP, szJsonBuf, (void*)&stuInfo, sizeof(stuInfo), &dwRetLen);\n\t\tif (!bRet)\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"parse NTP error...\"), DLG_CFG_NTP), ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(&m_stuInfo, &stuInfo, sizeof(CFG_NTP_INFO));\n\t\t}\n\t}\n\telse\n\t{\t\t\t\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"get Config NTP error:\", DLG_CFG_NTP),CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nBOOL CDlgCfgNTP::SetConfig()\n{\n\tchar szJsonBuf[1024 * 10] = {0};\n\tBOOL bRet = CLIENT_PacketData(CFG_CMD_NTP, &m_stuInfo, sizeof(m_stuInfo), szJsonBuf, sizeof(szJsonBuf));\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(CString(\"packet NTP error...\"), DLG_CFG_NTP));\n\t\treturn FALSE;\n\t} \n\telse\n\t{\n#if 0\n\t\tWriteLog(szJsonBuf);\n#endif\t\n\t\tint nErr = 0, nRestart = 0;\n\t\tBOOL bRetSetupCfg = CLIENT_SetNewDevConfig(m_lLoginId, CFG_CMD_NTP,\n\t\t\t-1, szJsonBuf, strlen(szJsonBuf), &nErr, &nRestart, SDK_API_WAIT);\n\t\tif (!bRetSetupCfg)\n\t\t{\n\t\t\tCString csErr;\n\t\t\tcsErr.Format(\"%s %08x\", ConvertString(\"SetupConfig NTP failed:\", DLG_CFG_NTP), CLIENT_GetLastError());\n\t\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"SetConfig NTP ok!\"), DLG_CFG_NTP), ConvertString(\"Prompt\"));\n\t\t}\n\t}\n\treturn TRUE;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgNTP message handlers\n\nBOOL CDlgCfgNTP::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_NTP);\n\t\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\tif (GetConfig())\n\t{\n\t\tStuToDlg();\n\t}\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t// EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgNTP::OnCfgNtpBtnGet() \n{\n\t// TODO: Add your control notification handler code here\n\tif (GetConfig())\n\t{\n\t\tStuToDlg();\n\t}\t\n}\n\nvoid CDlgCfgNTP::OnCfgNtpBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\tSetConfig();\n}\n","size_bytes":5043},"bin/DemoSrc/SoundCapture_demo/SoundCapture_demoDlg.cpp":{"content":"// SoundCapture_demoDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"SoundCapture_demo.h\"\n#include \"SoundCapture_demoDlg.h\"\n#include \"LanguageConvertor.h\"\n#include \"CharactorTansfer.h\"\n#include <string>\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n#pragma comment(lib, \"dhplay.lib\")\n\n/////////////////////////////////////////////////////////////////////////////\n// CSoundCapture_demoDlg dialog\n\nCSoundCapture_demoDlg::CSoundCapture_demoDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CSoundCapture_demoDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CSoundCapture_demoDlg)\n\tm_csFileName = _T(\"\");\n\t//}}AFX_DATA_INIT\n\t// Note that LoadIcon does not require a subsequent DestroyIcon in Win32\n\tm_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);\n\tm_fPCM = NULL;\n\tLANG_INIT();\n}\n\nvoid CSoundCapture_demoDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CSoundCapture_demoDlg)\n\tDDX_Control(pDX, IDC_COMBO_SAMPLEPERSECOND, m_cSamplePerSecondBox);\n\tDDX_Control(pDX, IDC_COMBO_BITPERSAMPLE, m_cBitPerSampleBox);\n\tDDX_Text(pDX, IDC_EDIT_FILEPATH, m_csFileName);\n\t//}}AFX_DATA_MAP\n}\n\nBEGIN_MESSAGE_MAP(CSoundCapture_demoDlg, CDialog)\n\t//{{AFX_MSG_MAP(CSoundCapture_demoDlg)\n\tON_WM_PAINT()\n\tON_WM_QUERYDRAGICON()\n\tON_BN_CLICKED(IDC_BUTTON_RECORD, OnButtonRecord)\n\tON_BN_CLICKED(IDC_BUTTON_STOP, OnButtonStop)\n\tON_BN_CLICKED(IDC_BUTTON_FILEPATH, OnButtonFilepath)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CSoundCapture_demoDlg message handlers\nvoid CSoundCapture_demoDlg::InitCombox()\n{\t\n\tm_cSamplePerSecondBox.SetItemData(m_cSamplePerSecondBox.AddString(_T(\"11025 Hz\")), 11025);\n\tm_cSamplePerSecondBox.SetItemData(m_cSamplePerSecondBox.AddString(_T(\"16000 Hz\")), 16000);\n\tm_cSamplePerSecondBox.SetItemData(m_cSamplePerSecondBox.AddString(_T(\"22050 Hz\")), 22050);\n\tm_cSamplePerSecondBox.SetItemData(m_cSamplePerSecondBox.AddString(_T(\"32000 Hz\")), 32000);\n\tm_cSamplePerSecondBox.SetItemData(m_cSamplePerSecondBox.AddString(_T(\"44100 Hz\")), 44100);\n\tm_cSamplePerSecondBox.SetItemData(m_cSamplePerSecondBox.AddString(_T(\"8000  Hz\")), 8000);\n\tm_cSamplePerSecondBox.SetItemData(m_cSamplePerSecondBox.AddString(_T(\"96000 Hz\")), 96000);\n\tm_cSamplePerSecondBox.SetCurSel(5);\n\n\n\tm_cBitPerSampleBox.SetItemData(m_cBitPerSampleBox.AddString(_T(\"16 bit\")), 16);\n\tm_cBitPerSampleBox.SetItemData(m_cBitPerSampleBox.AddString(_T(\"8 bit\")), 8);\n\tm_cBitPerSampleBox.SetCurSel(0);\n}\n\nBOOL CSoundCapture_demoDlg::OnInitDialog()\n{\n\tCDialog::OnInitDialog();\n\n\t// Set the icon for this dialog.  The framework does this automatically\n\t//  when the application's main window is not a dialog\n\tSetIcon(m_hIcon, TRUE);\t\t\t// Set big icon\n\tSetIcon(m_hIcon, FALSE);\t\t// Set small icon\n\t\n\t// TODO: Add extra initialization here\n\n\tLANG_SETWNDSTATICTEXT(this);\n\tInitCombox();\n\n\treturn TRUE;  // return TRUE  unless you set the focus to a control\n}\n\n// If you add a minimize button to your dialog, you will need the code below\n//  to draw the icon.  For MFC applications using the document/view model,\n//  this is automatically done for you by the framework.\n\nvoid CSoundCapture_demoDlg::OnPaint() \n{\n\tif (IsIconic())\n\t{\n\t\tCPaintDC dc(this); // device context for painting\n\n\t\tSendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);\n\n\t\t// Center icon in client rectangle\n\t\tint cxIcon = GetSystemMetrics(SM_CXICON);\n\t\tint cyIcon = GetSystemMetrics(SM_CYICON);\n\t\tCRect rect;\n\t\tGetClientRect(&rect);\n\t\tint x = (rect.Width() - cxIcon + 1) / 2;\n\t\tint y = (rect.Height() - cyIcon + 1) / 2;\n\n\t\t// Draw the icon\n\t\tdc.DrawIcon(x, y, m_hIcon);\n\t}\n\telse\n\t{\n\t\tCDialog::OnPaint();\n\t}\n}\n\n// The system calls this to obtain the cursor to display while the user drags\n//  the minimized window.\nHCURSOR CSoundCapture_demoDlg::OnQueryDragIcon()\n{\n\treturn (HCURSOR) m_hIcon;\n}\n\nvoid WINAPI AudioRecord(LPBYTE pDataBuffer, DWORD DataLength, void* pUserData)\n{\n\tFILE *fPCM = (FILE *)pUserData;\n\tif(fPCM != NULL)\n\t\tfwrite(pDataBuffer, 1, DataLength, fPCM);\n}\n\nvoid CSoundCapture_demoDlg::OnButtonRecord() \n{\n\t// TODO: Add your control notification handler code here\n\tUpdateData(TRUE);\n\tm_fPCM = _tfopen(m_csFileName.GetBuffer(0), _T(\"wb+\"));\n\tif( m_fPCM == NULL)\n\t{\n\t\tAfxMessageBox(LANG_CS(\"File path error!\"));\n\t\treturn;\n\t}\n\t\n\tm_nBitPerSample = m_cBitPerSampleBox.GetItemData(m_cBitPerSampleBox.GetCurSel());\n\tm_nSamplePerSecond = m_cSamplePerSecondBox.GetItemData(m_cSamplePerSecondBox.GetCurSel());\n\t\n\tlong lSampleLen = 40*m_nBitPerSample*m_nSamplePerSecond/16000;\n\tif(lSampleLen <= 320)\n\t\tlSampleLen = 320;\n\t//else if (lSampleLen >= 1024)\n\t//\tlSampleLen = 1024;\n\n\tPLAY_OpenAudioRecord(AudioRecord, m_nBitPerSample, m_nSamplePerSecond, lSampleLen, NULL, m_fPCM);\n\tGetDlgItem(IDC_BUTTON_STOP)->EnableWindow(TRUE);\n\tGetDlgItem(IDC_BUTTON_RECORD)->EnableWindow(FALSE);\n}\n\nvoid CSoundCapture_demoDlg::OnButtonStop() \n{\n\t// TODO: Add your control notification handler code here\n\tPLAY_CloseAudioRecord();\n\tif(m_fPCM != NULL)\n\t\tfclose(m_fPCM);\n\tGetDlgItem(IDC_BUTTON_RECORD)->EnableWindow(TRUE);\n\tGetDlgItem(IDC_BUTTON_STOP)->EnableWindow(FALSE);\n}\n\nvoid CSoundCapture_demoDlg::OnButtonFilepath() \n{\n\t// TODO: Add your control notification handler code here\n\tCFileDialog FileChooser(TRUE, NULL, NULL, OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, _T(\"All files(*.*)|*.*||\"));\n\n\tif(FileChooser.DoModal() == IDOK)\n\t{\n\t\tm_csFileName = FileChooser.GetPathName();\n\t\tGetDlgItem(IDC_EDIT_FILEPATH)->SetWindowText(m_csFileName);\n\t}\n}\n","size_bytes":5518},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/ConfigAlarmVlost.cpp":{"content":"// ConfigAlarmVlost.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"ConfigAlarmVlost.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CConfigAlarmVlost dialog\n\n\nCConfigAlarmVlost::CConfigAlarmVlost(CWnd* pParent /*=NULL*/)\n\t: CDialog(CConfigAlarmVlost::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CConfigAlarmVlost)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_pDev = 0;\n\tmemset(m_vlostCFG, 0, DH_MAX_VIDEO_IN_NUM*sizeof(DH_VIDEO_LOST_CFG));\n\tm_bReady = FALSE;\n\tm_chlIdx = -1;\n\tm_weekIdx = -1;\n\tm_ptzchlIdx = -1;\n\n\tm_dontsave = 0;\n}\n\nvoid CConfigAlarmVlost::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CConfigAlarmVlost)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CConfigAlarmVlost, CDialog)\n\t//{{AFX_MSG_MAP(CConfigAlarmVlost)\n\tON_CBN_SELCHANGE(IDC_COMBO_VIDEOCHL, OnSelchangeComboVideochl)\n\tON_CBN_SELCHANGE(IDC_COMBO_ALARMWEEK, OnSelchangeComboAlarmweek)\n\tON_CBN_SELCHANGE(IDC_COMBO_ALARMPTZCHL, OnSelchangeComboAlarmptzchl)\n\tON_WM_SHOWWINDOW()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CConfigAlarmVlost message handlers\n\n\nvoid CConfigAlarmVlost::SetDevice(DeviceNode *pDev)\n{\n\tm_pDev = pDev;\n}\n\nvoid CConfigAlarmVlost::SetVlostCFG(DH_VIDEO_LOST_CFG *cfg)\n{\n\tif (!cfg)\n\t{\n\t\treturn;\n\t}\n\n\tmemcpy(m_vlostCFG, cfg, DH_MAX_VIDEO_IN_NUM*sizeof(DH_VIDEO_LOST_CFG));\n\n\tDWORD dwActMask = m_vlostCFG[0].struHandle.dwActionMask;\n\t//sentence if some functions enabled\n\tGetDlgItem(IDC_CHECK_UPLOAD)->EnableWindow((dwActMask & DH_ALARM_UPLOAD)?TRUE:FALSE);\n\tGetDlgItem(IDC_CHECK_LOCALTIP)->EnableWindow((dwActMask & DH_ALARM_TIP)?TRUE:FALSE);\n\tGetDlgItem(IDC_CHECK_LOCALTOUR)->EnableWindow((dwActMask & DH_ALARM_TOUR)?TRUE:FALSE);\n\tGetDlgItem(IDC_CHECK_SENDMAIL)->EnableWindow((dwActMask & DH_ALARM_MAIL)?TRUE:FALSE);\n\t\n\t//sentence if ptz enabled\n\tBOOL bPTZEn = (dwActMask & DH_ALARM_PTZ)?TRUE:FALSE;\n\tGetDlgItem(IDC_CHECK_PTZ)->EnableWindow(bPTZEn);\n\tGetDlgItem(IDC_COMBO_ALARMPTZCHL)->EnableWindow(bPTZEn);\n\tGetDlgItem(IDC_COMBO_ALARMPTZ)->EnableWindow(bPTZEn);\n\tGetDlgItem(IDC_EDIT_PTZNO)->EnableWindow(bPTZEn);\n\t\n\t//sentence if record enabled\n\tBOOL bRecEn = (dwActMask & DH_ALARM_RECORD)?TRUE:FALSE;\n\tGetDlgItem(IDC_CHECK_RECORD)->EnableWindow(bRecEn);\n\tfor (int i = 0; i < 16; i++)\n\t{\n\t\tGetDlgItem(IDC_CHECK_RECCH1+i)->EnableWindow(bRecEn);\n\t}\n\t\n\t//sentence if alarm output enabled\n\tBOOL bOutEn = (dwActMask & DH_ALARM_OUT)?TRUE:FALSE;\n\tGetDlgItem(IDC_CHECK_OUTPUT)->EnableWindow(bOutEn);\n\tfor (int j = 0; j < 16; j++)\n\t{\n\t\tGetDlgItem(IDC_CHECK_ALMOP1+j)->EnableWindow(bOutEn);\n\t}\n\n\tm_bReady = TRUE;\n}\n\nvoid CConfigAlarmVlost::ShowConfig()\n{\n\tif (!m_bReady)\n\t{\n\t\treturn;\n\t}\n\n\tif (((CComboBox*)GetDlgItem(IDC_COMBO_VIDEOCHL))->GetCount() < 0)\n\t{\n\t\treturn;\n\t}\n\n\t//show\n\t((CComboBox*)GetDlgItem(IDC_COMBO_VIDEOCHL))->SetCurSel(0);\n\tOnSelchangeComboVideochl();\n}\n\n\nBOOL CConfigAlarmVlost::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\tif (!m_pDev)\n\t{\n\t\treturn TRUE;\n\t}\n\n\tCString strVlost;\n\tint i = 0;\n\tfor (i = 0; i < m_pDev->Info.byChanNum; i++)\n\t{\n\t\tstrVlost.Format(ConvertString(\"Channel %d\"), i+1);\n\t\t((CComboBox*)GetDlgItem(IDC_COMBO_VIDEOCHL))->InsertString(i, strVlost);\n\t}\n\tfor (int j = 15; j >= m_pDev->Info.byAlarmOutPortNum; j--)\n\t{\n\t\tGetDlgItem(IDC_CHECK_ALMOP1+j)->ShowWindow(SW_HIDE);\n\t}\n\tfor (int k = 15; k >= m_pDev->Info.byChanNum; k--)\n\t{\n\t\tGetDlgItem(IDC_CHECK_RECCH1+k)->ShowWindow(SW_HIDE);\n\t}\n\t\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(0, ConvertString(\"Sunday\"));\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(1, ConvertString(\"Monday\"));\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(2, ConvertString(\"Tuesday\"));\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(3, ConvertString(\"Wedensday\"));\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(4, ConvertString(\"Thursday\"));\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(5, ConvertString(\"Friday\"));\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(6, ConvertString(\"Saturday\"));\n\t\n\tCString strChl;\n\tfor (int l = 0; l < m_pDev->Info.byChanNum; l++)\n\t{\n\t\tstrChl.Format(ConvertString(\"channel %d\"), i+1);\n\t\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMPTZCHL))->InsertString(i, strChl);\n\t}\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CConfigAlarmVlost::OnSelchangeComboVideochl() \n{\n\tif (!m_bReady)\n\t{\n\t\treturn;\n\t}\n\tint i,j,k;\n\n\t//store old\n\tif (m_chlIdx < 0)\n\t{\n\t\tgoto skipsave;\n\t}\n\tm_vlostCFG[m_chlIdx].byAlarmEn = ((CButton*)GetDlgItem(IDC_CHECK_VLOSTENABLE))->GetCheck();\n\t\n\tif (m_weekIdx >= 0)\n\t{\n\t\tint secIdx = 0;\n\t\tfor (i = 0; i < 6; i++)\n\t\t{\n\t\t\tm_vlostCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_vlostCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_vlostCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\t\n\t\t\tm_vlostCFG[m_chlIdx].stSect[m_weekIdx][i].iEndHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_vlostCFG[m_chlIdx].stSect[m_weekIdx][i].iEndMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_vlostCFG[m_chlIdx].stSect[m_weekIdx][i].iEndSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t}\n\t}\n\t\n\tm_vlostCFG[m_chlIdx].struHandle.dwActionFlag = 0;\n\tm_vlostCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_UPLOAD))->GetCheck()?DH_ALARM_UPLOAD:0;\n\tm_vlostCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_LOCALTIP))->GetCheck()?DH_ALARM_TIP:0;\n\tm_vlostCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_LOCALTOUR))->GetCheck()?DH_ALARM_TOUR:0;\n\tm_vlostCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_SENDMAIL))->GetCheck()?DH_ALARM_MAIL:0;\n\tm_vlostCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_PTZ))->GetCheck()?DH_ALARM_PTZ:0;\n\tm_vlostCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_RECORD))->GetCheck()?DH_ALARM_RECORD:0;\n\tm_vlostCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_OUTPUT))->GetCheck()?DH_ALARM_OUT:0;\n\n\tfor (j = 0; j < m_pDev->Info.byAlarmOutPortNum; j++)\n\t{\n\t\tm_vlostCFG[m_chlIdx].struHandle.byRelAlarmOut[j] = ((CButton*)GetDlgItem(IDC_CHECK_ALMOP1+j))->GetCheck();\n\t}\n\n\tfor (k = 0; k < m_pDev->Info.byChanNum; k++)\n\t{\n\t\tm_vlostCFG[m_chlIdx].struHandle.byRecordChannel[k] = ((CButton*)GetDlgItem(IDC_CHECK_RECCH1+k))->GetCheck();\n\t}\n\n\tif (m_ptzchlIdx >= 0)\n\t{\n\t\tm_vlostCFG[m_chlIdx].struHandle.struPtzLink[m_ptzchlIdx].iType = ((CComboBox*)GetDlgItem(IDC_CHECK_PTZ))->GetCurSel();\n\t\tm_vlostCFG[m_chlIdx].struHandle.struPtzLink[m_ptzchlIdx].iValue = GetDlgItemInt(IDC_EDIT_PTZNO);\n\t}\n\t\nskipsave:\n\t//show new\n\tint chlIdx = ((CComboBox*)GetDlgItem(IDC_COMBO_VIDEOCHL))->GetCurSel();\n\tif (chlIdx < 0 || ((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->GetCount() < 0)\n\t{\n\t\treturn;\n\t}\n\n\tm_chlIdx = chlIdx;\n\t((CButton*)GetDlgItem(IDC_CHECK_VLOSTENABLE))->SetCheck(m_vlostCFG[chlIdx].byAlarmEn?1:0);\n\t\n\tif (((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->GetCount() > 0)\n\t{\n\t\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->SetCurSel(0);\n\t\tm_weekIdx = -1; //prevent from unwanted saving\n\t\tOnSelchangeComboAlarmweek() ;\n\t}\n\t\n\t((CButton*)GetDlgItem(IDC_CHECK_UPLOAD))->SetCheck((m_vlostCFG[chlIdx].struHandle.dwActionFlag&DH_ALARM_UPLOAD)?1:0);\n\t((CButton*)GetDlgItem(IDC_CHECK_LOCALTIP))->SetCheck((m_vlostCFG[chlIdx].struHandle.dwActionFlag&DH_ALARM_TIP)?1:0);\n\t((CButton*)GetDlgItem(IDC_CHECK_LOCALTOUR))->SetCheck((m_vlostCFG[chlIdx].struHandle.dwActionFlag&DH_ALARM_TOUR)?1:0);\n\t((CButton*)GetDlgItem(IDC_CHECK_SENDMAIL))->SetCheck((m_vlostCFG[chlIdx].struHandle.dwActionFlag&DH_ALARM_MAIL)?1:0);\n\t((CButton*)GetDlgItem(IDC_CHECK_PTZ))->SetCheck((m_vlostCFG[chlIdx].struHandle.dwActionFlag&DH_ALARM_PTZ)?1:0);\n\t((CButton*)GetDlgItem(IDC_CHECK_RECORD))->SetCheck((m_vlostCFG[chlIdx].struHandle.dwActionFlag&DH_ALARM_RECORD)?1:0);\n\t((CButton*)GetDlgItem(IDC_CHECK_OUTPUT))->SetCheck((m_vlostCFG[chlIdx].struHandle.dwActionFlag&DH_ALARM_OUT)?1:0);\n\t\n\tfor (j = 0; j < m_pDev->Info.byAlarmOutPortNum; j++)\n\t{\n\t\t((CButton*)GetDlgItem(IDC_CHECK_ALMOP1+j))->SetCheck(m_vlostCFG[chlIdx].struHandle.byRelAlarmOut[j]?1:0);\n\t}\n\n\tfor (k = 0; k < m_pDev->Info.byChanNum; k++)\n\t{\n\t\t((CButton*)GetDlgItem(IDC_CHECK_RECCH1+k))->SetCheck(m_vlostCFG[chlIdx].struHandle.byRecordChannel[k]?1:0);\n\t}\n\n\tif (((CComboBox*)GetDlgItem(IDC_COMBO_ALARMPTZCHL))-> GetCount() > 0)\n\t{\n\t\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMPTZCHL))-> SetCurSel(0);\n\t\tm_ptzchlIdx = -1; //prevent from unwanted saving\n\t\tOnSelchangeComboAlarmptzchl();\n\t}\n}\n\nvoid CConfigAlarmVlost::OnSelchangeComboAlarmweek() \n{\n\tif (!m_bReady || m_chlIdx < 0)\n\t{\n\t\treturn;\n\t}\n\n\t//store current time sectors\n\tif (m_weekIdx >= 0)\n\t{\n\t\tint secIdx = 0;\n\t\tfor (int i = 0; i < 6; i++)\n\t\t{\n\t\t\tm_vlostCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_vlostCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_vlostCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\t\n\t\t\tm_vlostCFG[m_chlIdx].stSect[m_weekIdx][i].iEndHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_vlostCFG[m_chlIdx].stSect[m_weekIdx][i].iEndMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_vlostCFG[m_chlIdx].stSect[m_weekIdx][i].iEndSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t}\n\t}\n\n\t//show new time sectors\n\tint weekIdx = ((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->GetCurSel();\n\tif (weekIdx < 0)\n\t{\n\t\treturn;\n\t}\n\tm_weekIdx = weekIdx;\n\n\tint timeCtrlIdx = 0;\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_vlostCFG[m_chlIdx].stSect[weekIdx][i].iBeginHour);\n\t\ttimeCtrlIdx++;\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_vlostCFG[m_chlIdx].stSect[weekIdx][i].iBeginMin);\n\t\ttimeCtrlIdx++;\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_vlostCFG[m_chlIdx].stSect[weekIdx][i].iBeginSec);\n\t\ttimeCtrlIdx++;\n\t\t\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_vlostCFG[m_chlIdx].stSect[weekIdx][i].iEndHour);\n\t\ttimeCtrlIdx++;\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_vlostCFG[m_chlIdx].stSect[weekIdx][i].iEndMin);\n\t\ttimeCtrlIdx++;\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_vlostCFG[m_chlIdx].stSect[weekIdx][i].iEndSec);\n\t\ttimeCtrlIdx++;\n\t}\n}\n\nvoid CConfigAlarmVlost::OnSelchangeComboAlarmptzchl() \n{\n\tif (!m_bReady || m_chlIdx < 0)\n\t{\n\t\treturn;\n\t}\n\n\t//store old\n\tif (m_ptzchlIdx >= 0)\n\t{\n\t\tm_vlostCFG[m_chlIdx].struHandle.struPtzLink[m_ptzchlIdx].iType = ((CComboBox*)GetDlgItem(IDC_CHECK_PTZ))->GetCurSel();\n\t\tm_vlostCFG[m_chlIdx].struHandle.struPtzLink[m_ptzchlIdx].iValue = GetDlgItemInt(IDC_EDIT_PTZNO);\n\t}\n\n\t//show new\n\tint ptzchlIdx = ((CComboBox*)GetDlgItem(IDC_COMBO_ALARMPTZCHL))-> GetCount();\n\tif (ptzchlIdx < 0)\n\t{\n\t\treturn;\n\t}\n\tm_ptzchlIdx = ptzchlIdx;\n\t((CComboBox*)GetDlgItem(IDC_CHECK_PTZ))->SetCurSel(m_vlostCFG[m_chlIdx].struHandle.struPtzLink[ptzchlIdx].iType);\n\tSetDlgItemInt(IDC_EDIT_PTZNO,m_vlostCFG[m_chlIdx].struHandle.struPtzLink[ptzchlIdx].iValue);\n}\n\nvoid CConfigAlarmVlost::OnShowWindow(BOOL bShow, UINT nStatus) \n{\n\tCDialog::OnShowWindow(bShow, nStatus);\n\t\n\tShowConfig();\n}\n\n\nvoid CConfigAlarmVlost::GetVlostCFG(DH_VIDEO_LOST_CFG *cfg)\n{\n\tif (!cfg || !m_bReady || m_chlIdx < 0)\n\t{\n\t\treturn;\n\t}\n\n\tm_vlostCFG[m_chlIdx].byAlarmEn = ((CButton*)GetDlgItem(IDC_CHECK_VLOSTENABLE))->GetCheck();\n\t\n\tif (m_weekIdx >= 0)\n\t{\n\t\tint secIdx = 0;\n\t\tfor (int i = 0; i < 6; i++)\n\t\t{\n\t\t\tm_vlostCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_vlostCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_vlostCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\t\n\t\t\tm_vlostCFG[m_chlIdx].stSect[m_weekIdx][i].iEndHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_vlostCFG[m_chlIdx].stSect[m_weekIdx][i].iEndMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_vlostCFG[m_chlIdx].stSect[m_weekIdx][i].iEndSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t}\n\t}\n\t\n\tm_vlostCFG[m_chlIdx].struHandle.dwActionFlag = 0;\n\tm_vlostCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_UPLOAD))->GetCheck()?DH_ALARM_UPLOAD:0;\n\tm_vlostCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_LOCALTIP))->GetCheck()?DH_ALARM_TIP:0;\n\tm_vlostCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_LOCALTOUR))->GetCheck()?DH_ALARM_TOUR:0;\n\tm_vlostCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_SENDMAIL))->GetCheck()?DH_ALARM_MAIL:0;\n\tm_vlostCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_PTZ))->GetCheck()?DH_ALARM_PTZ:0;\n\tm_vlostCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_RECORD))->GetCheck()?DH_ALARM_RECORD:0;\n\tm_vlostCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_OUTPUT))->GetCheck()?DH_ALARM_OUT:0;\n\n\tfor (int j = 0; j < m_pDev->Info.byAlarmOutPortNum; j++)\n\t{\n\t\tm_vlostCFG[m_chlIdx].struHandle.byRelAlarmOut[j] = ((CButton*)GetDlgItem(IDC_CHECK_ALMOP1+j))->GetCheck();\n\t}\n\n\tfor (int k = 0; k < m_pDev->Info.byChanNum; k++)\n\t{\n\t\tm_vlostCFG[m_chlIdx].struHandle.byRecordChannel[k] = ((CButton*)GetDlgItem(IDC_CHECK_RECCH1+k))->GetCheck();\n\t}\n\n\tif (m_ptzchlIdx >= 0)\n\t{\n\t\tm_vlostCFG[m_chlIdx].struHandle.struPtzLink[m_ptzchlIdx].iType = ((CComboBox*)GetDlgItem(IDC_CHECK_PTZ))->GetCurSel();\n\t\tm_vlostCFG[m_chlIdx].struHandle.struPtzLink[m_ptzchlIdx].iValue = GetDlgItemInt(IDC_EDIT_PTZNO);\n\t}\n\n\tmemcpy(cfg, m_vlostCFG, DH_MAX_ALARM_IN_NUM*sizeof(DH_VIDEO_LOST_CFG));\n}\n\nvoid CConfigAlarmVlost::UndoAll()\n{\n\tm_bReady = FALSE;\n\tm_chlIdx = -1;\n\tm_weekIdx = -1;\n\tm_ptzchlIdx = -1;\n}\n","size_bytes":14220},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/ClientState.cpp":{"content":"// lientState.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"clientState.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CClientState dialog\n\nCClientState::CClientState(CWnd* pParent /*=NULL*/)\n\t: CDialog(CClientState::IDD, pParent)\n{\n\tm_dev = 0;\n\tmemset(&m_myState, 0, sizeof(NET_CLIENT_STATE));\n\t//{{AFX_DATA_INIT(CClientState)\n\tm_isNoMoreShow = FALSE;\n\t//}}AFX_DATA_INIT\n}\n\nCClientState::~CClientState()\n{\n}\n\nvoid CClientState::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CClientState)\n\tDDX_Check(pDX, IDC_NOSHOW, m_isNoMoreShow);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CClientState, CDialog)\n\t//{{AFX_MSG_MAP(CClientState)\n\tON_WM_TIMER()\n\tON_WM_CLOSE()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n\n/////////////////////////////////////////////////////////////////////////////\n// ClientState message handlers\nvoid CClientState::UpdateState()\n{\n\tif (!m_dev)\n\t{\n\t\treturn;\n\t}\n\tCDevMgr::GetDevMgr().GetAlarmInfo(m_dev->LoginID, &m_myState);\n\tCString str;\n\tstr.Format(\"(%s [%s])\",m_dev->Name, m_dev->IP);\n\tCString strTmp;\n\tCString strDiskError = ConvertString(MSG_CLIENTSTATE_DISKERR);\n\tint i = 0;\n    for (i=0; i<32; i++)\n    {  \n\t\tif (m_myState.dError & (0x01<<i))\n        {\n\t\t\tstrTmp.Format(\" %d\", i+1);\n\t\t\tstrDiskError += strTmp;\n        }\n    }\n\n\tCString strDiskFull = ConvertString(MSG_CLIENTSTATE_DISKFULL);\t\n\tif (m_myState.dFull)\n\t{\n\t\tstrDiskFull += ConvertString(\"Full\");\n\t}\n\telse\n\t{\n\t\tstrDiskFull += ConvertString(\"Not\");\n\t}\n\t\n\tCString strShelter = ConvertString(MSG_CLIENTSTATE_SHELTER);\n\tfor (i=0; i<16; i++)\n    {\n        if (m_myState.shelter[i])\n        {\n\t\t\tstrTmp.Format(\" %d\", i+1);\n            strShelter += strTmp;\n        }\n    }\n\n    CString strAlarm = ConvertString(MSG_CLIENTSTATE_ALARM);\n\tint nNum = min(16, m_dev->Info.byAlarmInPortNum);\n    for (i=0; i<nNum; i++)\n    {\n     \n\t\tif (m_myState.cState.alarm[i])\n        {\n\t\t\tstrTmp.Format(\" %d\", i+1);\n\t\t\tstrAlarm += strTmp;\n        }\n    }\n\n    CString strMD = ConvertString(MSG_CLIENTSTATE_MOTION);\n    CString strVideoLost = ConvertString(MSG_CLIENTSTATE_VIDEOLOST);\n\tCString strSD = ConvertString(MSG_CLIENTSTATE_SOUND);\n\tnNum = min(16, m_dev->Info.byChanNum);\n    for (i=0; i<nNum; i++)\n    {\n        if (m_myState.cState.motiondection[i])\n        {\n\t\t\tstrTmp.Format(\" %d\", i+1);\n            strMD += strTmp;\n        }\n        if (m_myState.cState.videolost[i])\n        {\n\t\t\tstrTmp.Format(\" %d\", i+1);\n            strVideoLost += strTmp;\n        }\n        if (m_myState.soundalarm[i])\n        {\n\t\t\tstrTmp.Format(\" %d\", i+1);\n            strSD += strTmp;\n        }\n    }\n\n\tCString strSerial = ConvertString(MSG_CLIENTSTATE_SERIAL);\n\tstrTmp.Format(\"%s\", m_dev->Info.sSerialNumber);\n\tstrSerial += strTmp;\n\n\tCString strAlmDec = ConvertString(MSG_CLIENTSTATE_ALMDEC);\n\tstrAlmDec += \": \\n\";\n\tfor (i = 0; i < 16; i++)\n\t{\n\t\tfor(int j = 0; j < 8; j++)\n\t\t{\n\t\t\tif (m_myState.almDecoder[i] & (1<<j))\n\t\t\t{\n\t\t\t\tstrTmp.Format(\"%d\", 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstrTmp.Format(\"%d\", 0);\n\t\t\t}\n\t\t\tstrAlmDec += strTmp;\n\t\t}\n\t\tstrAlmDec += \" \";\n\t}\n\n\tstr += ConvertString(MSG_CLIENTSTATE_CLIENTSTATE);\n    str = str +\"\\n\" +\"\\n\"+\n\t\tstrDiskError + \"\\n\" +\"\\n\"+\n\t\tstrDiskFull + \"\\n\" +\"\\n\"+\n\t\tstrShelter +\"\\n\" + \"\\n\"+\n        strAlarm + \"\\n\" +\"\\n\"+\n        strMD + \"\\n\" +\"\\n\"+\n        strVideoLost + \"\\n\" +\"\\n\"+\n\t\tstrSD + \"\\n\" +\"\\n\"+\n\t\tstrAlmDec + \"\\n\" + \"\\n\" +\n\t\tstrSerial;\n\n    GetDlgItem(IDC_CLIENT_STATE)->SetWindowText(str);\n}\n/////////////////////////////////////////////////////////////////////////////\n\n/////////////////////////////////////////////////////////////////////////////\n// CClientState message handlers\n\nBOOL CClientState::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\n\tg_SetWndStaticText(this);\n\treturn TRUE;  \n}\n\nvoid CClientState::StartRefresh()\n{\n\tSetTimer((LLONG)this,200,0);\n}\n\nvoid CClientState::StopRefresh()\n{\n\tKillTimer((LLONG)this);\n}\n\nvoid CClientState::OnTimer(UINT_PTR nIDEvent) \n{\n\tUpdateState();\n\tCDialog::OnTimer(nIDEvent);\n}\n\nvoid CClientState::SetDevice(DeviceNode *dev)\n{\n\tm_dev = dev;\n}\n\nDeviceNode* CClientState::GetDevice()\n{\n\treturn m_dev;\n}\n\nvoid CClientState::OnClose() \n{\n\tStopRefresh();\n\tCDialog::OnClose();\n}\n\nvoid CClientState::OnOK() \n{\n\tStopRefresh();\n\tCDialog::OnOK();\n}\n\nBOOL CClientState::PreTranslateMessage(MSG* pMsg) \n{\n\tif (WM_KEYDOWN == pMsg->message && (VK_ESCAPE == pMsg->wParam))\n\t{\n\t\treturn TRUE;\n\t}\n\treturn CDialog::PreTranslateMessage(pMsg);\n}\n","size_bytes":4560},"bin/Demo/MfcDemo/13.FaceRecognition/DispatchGroupChannelDlg.cpp":{"content":"// DispatchGroupChannelDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"FaceRecognition.h\"\n#include \"DispatchGroupChannelDlg.h\"\n\n\n// CDispatchGroupChannelDlg dialog\n\nIMPLEMENT_DYNAMIC(CDispatchGroupChannelDlg, CDialog)\n\nCDispatchGroupChannelDlg::CDispatchGroupChannelDlg(LLONG lLoginId, int nChannel, CWnd* pParent /*=NULL*/)\n: CDialog(CDispatchGroupChannelDlg::IDD, pParent)\n{\n\tm_lLoginID = lLoginId;\n\tm_nChannel = nChannel;\n\tm_bNeedClearItem = TRUE;\n\tm_nStateDlg = 0;\n}\n\nCDispatchGroupChannelDlg::~CDispatchGroupChannelDlg()\n{\n\tClearDispatchGroupInfoList();\n}\n\nvoid CDispatchGroupChannelDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\tDDX_Control(pDX, IDC_LIST_DISPATCH, m_DispatchInfoList);\n}\n\n\nBEGIN_MESSAGE_MAP(CDispatchGroupChannelDlg, CDialog)\n\tON_BN_CLICKED(IDC_dispatch_add, &CDispatchGroupChannelDlg::OnBnClickeddispatchadd)\n\tON_BN_CLICKED(IDC_dispatch_dispatch, &CDispatchGroupChannelDlg::OnBnClickeddispatchdispatch)\n\tON_BN_CLICKED(IDC_DISPATCH_FORCHANNEL_DELETE, &CDispatchGroupChannelDlg::OnBnClickedDispatchForchannelDelete)\n\tON_BN_CLICKED(IDC_DISPATCH_FORCHANNEL_REFRESH, &CDispatchGroupChannelDlg::OnBnClickedDispatchForchannelRefresh)\nEND_MESSAGE_MAP()\n\n\nBOOL CDispatchGroupChannelDlg::OnInitDialog()\n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\t\n\tRefreshDispatchInfoListBox();\n\tInitComboxGroupID();\n\n\tCString str = \"\";\n\n\tCComboBox *pSimiarity = (CComboBox*)GetDlgItem(IDC_DISPATCHCHANNEL_SIMILARITY_COM);\n\tfor(int i = 1; i <=100; i++)\n\t{\n\t\tstr.Format(\"%d\", i);\n\t\tpSimiarity->AddString(str);\n\t}\n\n\tpSimiarity->SetCurSel(79);\n\n\tstr.Format(\"%d\", m_nChannel);\n\tSetDlgItemText(IDC_DISPATCHCHANNEL_CHANNEL, str);\n\n\tGetDlgItem(IDC_dispatch_dispatch)->EnableWindow(FALSE);\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n}\n\nvoid CDispatchGroupChannelDlg::OnBnClickeddispatchadd()\n{\n\tm_nStateDlg = 1;\n\tif (m_bNeedClearItem == TRUE)\n\t{\n\t\tm_DispatchInfoList.ResetContent();\n\t}\n\n\tCComboBox *pSimilarity = (CComboBox*)GetDlgItem(IDC_DISPATCHCHANNEL_SIMILARITY_COM);\n\tint nSimilarity = pSimilarity->GetCurSel() + 1;\n\t\n\tint nNum = 0;\n\tCComboBox *pComboxGroupId = (CComboBox*)GetDlgItem(IDC_DISPATCHCHANNEL_GROUPID);\n\tint nIndex = pComboxGroupId->GetCurSel();\n\tif(CB_ERR != nIndex)\n\t{\n\t\tstd::list<NET_DISPATGROUP_INFO*>::iterator iter = m_lsDispatchGroupInfo.begin();\n\t\twhile(iter != m_lsDispatchGroupInfo.end())\n\t\t{\n\t\t\tif (nIndex == nNum++)\n\t\t\t{\n\t\t\t\tNET_DISPATGROUP_INFO *pInfo = *iter;\n\t\t\t\t\n\t\t\t\tif (pInfo->bAddToList == FALSE)\n\t\t\t\t{\n\t\t\t\t\tpInfo->bAddToList = TRUE;\n\t\t\t\t\tpInfo->nSimilarity = nSimilarity;\n\t\t\t\t\tCString str;\n\t\t\t\t\tstr.Format(\"%s                   %4d                %s\", pInfo->szGroupID, pInfo->nSimilarity, ConvertString(\"Not Dispatch\"));\n\n\t\t\t\t\tint nCount = m_DispatchInfoList.GetCount();\n\t\t\t\t\tm_DispatchInfoList.InsertString(nCount, str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\titer++;\n\t\t}\n\t}\n\tm_bNeedClearItem = FALSE;\n\tGetDlgItem(IDC_dispatch_dispatch)->EnableWindow(TRUE);\n}\n\nvoid CDispatchGroupChannelDlg::InitComboxGroupID()\n{\n\tCComboBox *pComboxGroupId = (CComboBox*)GetDlgItem(IDC_DISPATCHCHANNEL_GROUPID);\n\tstd::list<NET_DISPATGROUP_INFO*>::iterator it = m_lsDispatchGroupInfo.begin();\n\tfor (; it != m_lsDispatchGroupInfo.end(); it++)\n\t{\n\t\tCString str = \"\";\n\t\tstr.Format(\"%s\", (*it)->szGroupID);\n\t\tpComboxGroupId->AddString(str);\n\t}\n\tpComboxGroupId->SetCurSel(0);\n}\n\nvoid CDispatchGroupChannelDlg::OnBnClickeddispatchdispatch()\n{\n\tDispatchListGroupID();\n\tRefreshDispatchInfoListBox();\n\t\n\tm_nStateDlg = 0;\n\tm_bNeedClearItem = TRUE;\n\n\tGetDlgItem(IDC_dispatch_dispatch)->EnableWindow(FALSE);\n}\n\nvoid CDispatchGroupChannelDlg::DispatchListGroupID()\n{\n\tNET_IN_SET_GROUPINFO_FOR_CHANNEL stuInParam;\n\tNET_OUT_SET_GROUPINFO_FOR_CHANNEL strOutParam;\n\tmemset(&stuInParam, 0, sizeof(stuInParam));\n\tmemset(&strOutParam, 0, sizeof(strOutParam));\n\n\tstuInParam.dwSize = sizeof(NET_IN_SET_GROUPINFO_FOR_CHANNEL);\n\tstrOutParam.dwSize = sizeof(NET_OUT_SET_GROUPINFO_FOR_CHANNEL);\n\tstuInParam.nChannelID = m_nChannel - 1;\n\n\tint nGroupNum = 0;\n\n\tstd::list<NET_DISPATGROUP_INFO*>::iterator iter = m_lsDispatchGroupInfo.begin();\n\tfor (; iter != m_lsDispatchGroupInfo.end(); iter++)\n\t{\n\t\tNET_DISPATGROUP_INFO *pInfo = *iter;\n\t\tif (pInfo)\n\t\t{\n\t\t\tif (pInfo->bNeedRevoke)\n\t\t\t{\n\t\t\t\tpInfo->bAddToList = FALSE;\n\t\t\t\tpInfo->bNeedRevoke = FALSE;\n\t\t\t}\n\n\t\t\tpInfo->bDispatch = FALSE;\n\t\t\tif (pInfo && pInfo->bAddToList == TRUE)\n\t\t\t{\n\t\t\t\t//add\n\t\t\t\tpInfo->bAddToList = FALSE;\n\n\t\t\t\tstrncpy(stuInParam.szGroupId[nGroupNum], pInfo->szGroupID, DH_COMMON_STRING_64 - 1);\n\t\t\t\tstuInParam.nSimilary[nGroupNum] = pInfo->nSimilarity;\n\t\t\t\t++nGroupNum;\n\t\t\t}\n\t\t}\n\t}\n\tif (nGroupNum == 0)\n\t{\n\t\tstuInParam.nGroupIdNum = 1;\n\t\tstuInParam.nSimilaryNum = 1;\n\t}\n\telse\n\t{\n\t\tstuInParam.nGroupIdNum = nGroupNum;\n\t\tstuInParam.nSimilaryNum = nGroupNum;\n\t}\n\n\tBOOL bRet = CLIENT_SetGroupInfoForChannel(m_lLoginID, &stuInParam, &strOutParam, DEFAULT_WAIT_TIME);\n\tif (bRet == FALSE)\n\t{\n\t\tMessageBox(ConvertString(\"Dispatch error!\"), \"\");\n\t}\n}\n\nvoid CDispatchGroupChannelDlg::ClearDispatchGroupInfoList()\n{\n\tstd::list<NET_DISPATGROUP_INFO*>::iterator iter = m_lsDispatchGroupInfo.begin();\n\twhile(iter != m_lsDispatchGroupInfo.end())\n\t{\n\t\tNET_DISPATGROUP_INFO *pInfo = *iter;\n\t\tif (pInfo)\n\t\t{\n\t\t\tm_lsDispatchGroupInfo.erase(iter++);\n\t\t\tdelete pInfo;\n\t\t\tpInfo = NULL;\n\t\t}\n\t}\n}\n\nvoid CDispatchGroupChannelDlg::RefreshDispatchInfoListBox()\n{\t\n\tm_DispatchInfoList.ResetContent();\n\tClearDispatchGroupInfoList();\n\n\tint i = 0;\n\n\tNET_IN_FIND_GROUP_INFO stuInParam = {sizeof(stuInParam)};\n\tNET_OUT_FIND_GROUP_INFO stuOutParam = {sizeof(stuOutParam)};\n\tstuOutParam.nMaxGroupNum = 50;\n\tNET_FACERECONGNITION_GROUP_INFO *pGroupInfo = NULL;\n\tstuOutParam.pGroupInfos = new NET_FACERECONGNITION_GROUP_INFO[stuOutParam.nMaxGroupNum];\n\n\tif (NULL == stuOutParam.pGroupInfos)\n\t{\n\t\tMessageBox(ConvertString(\"Memory error\"), \"\");\n\t}\n\n\tmemset(stuOutParam.pGroupInfos, 0, sizeof(NET_FACERECONGNITION_GROUP_INFO)*stuOutParam.nMaxGroupNum);\n\tfor (int i = 0; i < stuOutParam.nMaxGroupNum; i++)\n\t{\n\t\tpGroupInfo = stuOutParam.pGroupInfos + i;\n\t\tpGroupInfo->dwSize = sizeof(*pGroupInfo);\n\t}\n\tBOOL bRet = CLIENT_FindGroupInfo(m_lLoginID, &stuInParam, &stuOutParam, DEFAULT_WAIT_TIME);\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Failed to find group infos!\"), \"\");\n\t}\n\telse\n\t{\n\t\tint nGroupNum = stuOutParam.nRetGroupNum;\n\t\tfor (int i = 0; i < nGroupNum; i++)\n\t\t{\n\t\t\tNET_FACERECONGNITION_GROUP_INFO *pInfoTemp = &stuOutParam.pGroupInfos[i];\n\n\t\t\tNET_DISPATGROUP_INFO *pGroupInfo = new NET_DISPATGROUP_INFO;\n\t\t\tmemset(pGroupInfo, 0, sizeof(NET_DISPATGROUP_INFO));\n\t\t\tpGroupInfo->bAddToList = FALSE;\n\t\t\tpGroupInfo->nSimilarity = 0;\n\t\t\tpGroupInfo->bNeedRevoke = FALSE;\n\t\t\tstrncpy(pGroupInfo->szGroupID, pInfoTemp->szGroupId, DH_COMMON_STRING_64 - 1);\n\n\t\t\tint nRetChannelCount = pInfoTemp->nRetChnCount;\n\t\t\tfor (int n = 0; n < nRetChannelCount; n++)\n\t\t\t{\n\t\t\t\tif (m_nChannel == (pInfoTemp->nChannel[n] + 1))\n\t\t\t\t{\n\t\t\t\t\tpGroupInfo->nSimilarity = pInfoTemp->nSimilarity[n];\n\t\t\t\t\tpGroupInfo->bDispatch = TRUE;\n\n\t\t\t\t\tCString str;\n\t\t\t\t\tstr.Format(\"%s                   %4d                %s\", pGroupInfo->szGroupID, pGroupInfo->nSimilarity, ConvertString(\"Dispatch\"));\n\t\t\t\t\tm_DispatchInfoList.AddString(str);\n\t\t\t\t}\n\t\t\t}\n\t\t\tm_lsDispatchGroupInfo.push_back(pGroupInfo);\n\t\t}\n\t}\n\n\tif (stuOutParam.pGroupInfos)\n\t{\n\t\tdelete[] stuOutParam.pGroupInfos;\n\t\tstuOutParam.pGroupInfos = NULL;\n\t}\n}\n\nvoid CDispatchGroupChannelDlg::OnBnClickedDispatchForchannelDelete()\n{\n\tchar *pGroupID = NULL;\n\tchar szGroupID[DH_COMMON_STRING_64] = {0};\n\tCString str = \"\";\n\tint nCount = m_DispatchInfoList.GetCount();\n\tBOOL bIsDeleteDispatchInfo = FALSE;\n\n\tint nIndex = 0;\n\tfor (int i = 0; i < nCount; i++)\n\t{\n\t\tint nSel = m_DispatchInfoList.GetSel(i);\n\n\t\tif (nSel > 0)\n\t\t{\n\t\t\tm_DispatchInfoList.GetText(i, str);\n\t\t\t\n\t\t\tpGroupID = (LPSTR)(LPCSTR)str;\n\t\t\tsscanf_s(pGroupID, \"%s\", szGroupID, sizeof(szGroupID));\n\n\t\t\tif (IsGroupIDDispatch(szGroupID))\n\t\t\t{\n\t\t\t\tRevokeDispatchGroupID(szGroupID);\n\t\t\t\tbIsDeleteDispatchInfo = TRUE;\n\t\t\t\tnIndex++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDeleteDispatchInfoByGroupID(szGroupID);\n\t\t\t\tbIsDeleteDispatchInfo = FALSE;\n\t\t\t\t\n\t\t\t\tnIndex++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nIndex > 0)\n\t{\n\t\tif (bIsDeleteDispatchInfo == FALSE)\n\t\t{\n\t\t\tm_DispatchInfoList.ResetContent();\n\t\t\tstd::list<NET_DISPATGROUP_INFO*>::iterator iter = m_lsDispatchGroupInfo.begin();\n\t\t\twhile(iter != m_lsDispatchGroupInfo.end())\n\t\t\t{\n\t\t\t\tNET_DISPATGROUP_INFO *pInfo = *iter++;\n\t\t\t\tif (pInfo && pInfo->bAddToList == TRUE)\n\t\t\t\t{\n\t\t\t\t\tCString str;\n\t\t\t\t\tstr.Format(\"%s                   %4d                %s\", pInfo->szGroupID, pInfo->nSimilarity, ConvertString(\"Not Dispatch\"));\n\t\t\t\t\tm_DispatchInfoList.AddString(str);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDispatchListGroupID();\n\t\t\tRefreshDispatchInfoListBox();\n\t\t}\n\t}\n}\n\nvoid CDispatchGroupChannelDlg::DeleteDispatchInfoByGroupID(char *pGroupID)\n{\n\tstd::list<NET_DISPATGROUP_INFO*>::iterator iter = m_lsDispatchGroupInfo.begin();\n\twhile(iter != m_lsDispatchGroupInfo.end())\n\t{\n\t\tNET_DISPATGROUP_INFO *pInfo = *iter++;\n\t\tif (pInfo && strncmp(pInfo->szGroupID, pGroupID, sizeof(pInfo->szGroupID)) == 0)\n\t\t{\n\t\t\tpInfo->bAddToList = FALSE;\n\t\t}\n\t}\n\tGetDlgItem(IDC_dispatch_dispatch)->EnableWindow(TRUE);\n}\n\nvoid CDispatchGroupChannelDlg::OnBnClickedDispatchForchannelRefresh()\n{\n\tm_bNeedClearItem = TRUE;\n\tm_nStateDlg = 0;\n\tRefreshDispatchInfoListBox();\n}\n\nvoid CDispatchGroupChannelDlg::RevokeDispatchGroupID(char *pGroupID)\n{\n\tstd::list<NET_DISPATGROUP_INFO*>::iterator iter = m_lsDispatchGroupInfo.begin();\n\twhile(iter != m_lsDispatchGroupInfo.end())\n\t{\n\t\tNET_DISPATGROUP_INFO *pInfo = *iter++;\n\n\t\tif (pInfo &&  pInfo->bDispatch )\n\t\t{\n\t\t\tpInfo->bAddToList = TRUE;\n\t\t\tif (strncmp(pInfo->szGroupID, pGroupID, sizeof(pInfo->szGroupID)) == 0 )\n\t\t\t{\n\t\t\t\tpInfo->bNeedRevoke = TRUE;\n\t\t\t}\n\t\t}\n\t}\n}\n\nBOOL CDispatchGroupChannelDlg::IsGroupIDDispatch(char *pGroupID)\n{\n\tBOOL bRet = FALSE;\n\tstd::list<NET_DISPATGROUP_INFO*>::iterator iter = m_lsDispatchGroupInfo.begin();\n\twhile(iter != m_lsDispatchGroupInfo.end())\n\t{\n\t\tNET_DISPATGROUP_INFO *pInfo = *iter++;\n\n\t\tif ( pInfo->bDispatch \n\t\t\t\t&& strncmp(pInfo->szGroupID, pGroupID, sizeof(pInfo->szGroupID)) == 0\n\t\t\t\t&& m_nStateDlg == 0)\n\t\t{\n\t\t\tbRet = TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn bRet;\n}\nBOOL CDispatchGroupChannelDlg::PreTranslateMessage(MSG* pMsg)\n{\n\tif(pMsg->message == WM_KEYDOWN &&\n\t\tpMsg->wParam == VK_RETURN)\n\t{\n\t\treturn TRUE;\n\t}\n\n\treturn CDialog::PreTranslateMessage(pMsg);\n}\n","size_bytes":10371},"bin/DemoSrc/DecCB_demo/DecCB_demoDlg.cpp":{"content":"// DecCB_demoDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"DecCB_demo.h\"\n#include \"DecCB_demoDlg.h\"\n#include \"dhplay.h\"\n#include \"LanguageConvertor.h\"\n#include <shlwapi.h>\n#include \"CharactorTansfer.h\"\n#include <string>\n\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDecCB_demoDlg dialog\n#pragma comment(lib, \"shlwapi.lib\")\n#pragma comment(lib, \"dhplay.lib\")\n\nCDecCB_demoDlg::CDecCB_demoDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CDecCB_demoDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDecCB_demoDlg)\n\tm_csSrcFilePath = _T(\"\");\n\tm_csAudiofilePath = _T(\"\");\n\tm_csVideofilePath = _T(\"\");\n\tm_pOutVideoFile = NULL;\n\tm_pOutAudioFile = NULL;\n\tm_nDecType = 0;\n\tm_nInterfaceType = 0;\n\t//}}AFX_DATA_INIT\n\t// Note that LoadIcon does not require a subsequent DestroyIcon in Win32\n\tm_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);\n\tLANG_INIT();\n}\n\nvoid CDecCB_demoDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDecCB_demoDlg)\n\tDDX_Text(pDX, IDC_EDIT_FILEPATH, m_csSrcFilePath);\n\tDDX_Text(pDX, IDC_EDIT_AUDIOFILEPATH, m_csAudiofilePath);\n\tDDX_Text(pDX, IDC_EDIT_VIDEOFILEPATH, m_csVideofilePath);\n\t//}}AFX_DATA_MAP\n}\n\nBEGIN_MESSAGE_MAP(CDecCB_demoDlg, CDialog)\n\t//{{AFX_MSG_MAP(CDecCB_demoDlg)\n\tON_WM_PAINT()\n\tON_WM_QUERYDRAGICON()\n\tON_BN_CLICKED(IDC_BUTTON_FILEPATH, OnButtonFilepath)\n\tON_BN_CLICKED(IDC_BUTTON_DECODE, OnButtonDecode)\n\tON_BN_CLICKED(IDC_BUTTON_STOP, OnButtonStop)\n\tON_BN_CLICKED(IDC_RADIO_AUDIO, OnRadioAudio)\n\tON_BN_CLICKED(IDC_RADIO_COMPLEX, OnRadioComplex)\n\tON_BN_CLICKED(IDC_RADIO_VIDEO, OnRadioVideo)\n\tON_WM_CLOSE()\n\tON_BN_CLICKED(IDC_BUTTON_AUDIOFILE, OnButtonAudiofile)\n\tON_BN_CLICKED(IDC_BUTTON_VIDEOFILE, OnButtonVideofile)\n\tON_BN_CLICKED(IDC_INTERFACE_NEW, OnInterfaceNew)\n\tON_BN_CLICKED(IDC_INTERFACE_OLD, OnInterfaceOld)\n\tON_BN_CLICKED(IDC_INTERFACE_NEW2, OnInterfaceNew2)\n\tON_BN_CLICKED(IDC_INTERFACE_OLD2, OnInterfaceOld2)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDecCB_demoDlg message handlers\n\nBOOL CDecCB_demoDlg::OnInitDialog()\n{\n\tCDialog::OnInitDialog();\n\n\t// Set the icon for this dialog.  The framework does this automatically\n\t//  when the application's main window is not a dialog\n\tSetIcon(m_hIcon, TRUE);\t\t\t// Set big icon\n\tSetIcon(m_hIcon, FALSE);\t\t// Set small icon\n\t\n\t// TODO: Add extra initialization here\n\t\n\tLANG_SETWNDSTATICTEXT(this);\n\t\n\t//init ui\n\t((CButton*)GetDlgItem(IDC_RADIO_VIDEO))->SetCheck(BST_CHECKED);\n\t((CButton*)GetDlgItem(IDC_INTERFACE_NEW))->SetCheck(BST_CHECKED);\n\tm_displayDlg.Create(IDD_DIALOG_DISPLAY, this);\n\n\tChangeUIState(STOPDEC);\n\treturn TRUE;  // return TRUE  unless you set the focus to a control\n}\n\n// If you add a minimize button to your dialog, you will need the code below\n//  to draw the icon.  For MFC applications using the document/view model,\n//  this is automatically done for you by the framework.\n\nvoid CDecCB_demoDlg::OnPaint() \n{\n\tif (IsIconic())\n\t{\n\t\tCPaintDC dc(this); // device context for painting\n\n\t\tSendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);\n\n\t\t// Center icon in client rectangle\n\t\tint cxIcon = GetSystemMetrics(SM_CXICON);\n\t\tint cyIcon = GetSystemMetrics(SM_CYICON);\n\t\tCRect rect;\n\t\tGetClientRect(&rect);\n\t\tint x = (rect.Width() - cxIcon + 1) / 2;\n\t\tint y = (rect.Height() - cyIcon + 1) / 2;\n\n\t\t// Draw the icon\n\t\tdc.DrawIcon(x, y, m_hIcon);\n\t}\n\telse\n\t{\n\t\tCDialog::OnPaint();\n\t}\n}\n\n// The system calls this to obtain the cursor to display while the user drags\n//  the minimized window.\nHCURSOR CDecCB_demoDlg::OnQueryDragIcon()\n{\n\treturn (HCURSOR) m_hIcon;\n}\n\nvoid CDecCB_demoDlg::OnButtonFilepath() \n{\n\t// TODO: Add your control notification handler code here\n\tCFileDialog filechooser(TRUE, NULL, NULL, OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, _T(\"All files(*.*)|*.*||\"));\n\tif(filechooser.DoModal() == IDOK)\n\t\tm_csSrcFilePath = filechooser.GetPathName();\n\tGetDlgItem(IDC_EDIT_FILEPATH)->SetWindowText(m_csSrcFilePath);\n\n\tm_csAudiofilePath = m_csSrcFilePath;\n\tm_csAudiofilePath.Replace(CString(\".\")+filechooser.GetFileExt(), _T(\".pcm\"));\n\tGetDlgItem(IDC_EDIT_AUDIOFILEPATH)->SetWindowText(m_csAudiofilePath);\n\n\tm_csVideofilePath = m_csSrcFilePath;\n\tm_csVideofilePath.Replace(CString(\".\")+filechooser.GetFileExt(), _T(\".yuv\"));\n\tGetDlgItem(IDC_EDIT_VIDEOFILEPATH)->SetWindowText(m_csVideofilePath);\n}\n\nvoid CALLBACK DecCbFun(long nPort, char *pBuf, long nSize, FRAME_INFO * pFrameInfo, void* pUserData, long nReserved2)\n{\n\tCDecCB_demoDlg *dlg = (CDecCB_demoDlg *)pUserData;\n\t\n\tif(pFrameInfo->nType == T_AUDIO16 || pFrameInfo->nType==T_AUDIO8)\n\t\tfwrite(pBuf, 1, nSize, dlg->m_pOutAudioFile);\n\t\n\tif(pFrameInfo->nType == T_IYUV)\n\t\tfwrite(pBuf, 1, nSize, dlg->m_pOutVideoFile);\n}\n\nvoid CALLBACK cbDecode(long nPort, FRAME_DECODE_INFO* pFrameDecodeInfo, FRAME_INFO_EX* pFrameInfo, void* pUser)\n{\n\tCDecCB_demoDlg *dlg = (CDecCB_demoDlg *)pUser;\n\tif(pFrameDecodeInfo->nFrameType==FRAME_TYPE_VIDEO && dlg->m_pOutVideoFile)\n\t{\n\t\tfor(int nIndex=0; nIndex<3; nIndex++)\n\t\t{\n\t\t\tchar* pData = (char*)pFrameDecodeInfo->pVideoData[nIndex];\n\t\t\tfor(int i=0; i<pFrameDecodeInfo->nHeight[nIndex]; i++)\n\t\t\t{\n\t\t\t\tsize_t len = fwrite(pData, 1, pFrameDecodeInfo->nWidth[nIndex], dlg->m_pOutVideoFile);\n\t\t\t\tpData += pFrameDecodeInfo->nStride[nIndex];\n\t\t\t}\n\t\t}\n\t}\n\n\tif(pFrameDecodeInfo->nFrameType==FRAME_TYPE_AUDIO && dlg->m_pOutAudioFile)\n\t{\n\t\tfwrite(pFrameDecodeInfo->pAudioData, 1, pFrameDecodeInfo->nAudioDataLen, dlg->m_pOutAudioFile);\n\t}\n}\n\nvoid CALLBACK cbVisibleDec(long nPort,char * pBuf,long nSize,FRAME_INFO * pFrameInfo, void* pUserData, long nReserved2)\n{\n\tCDecCB_demoDlg *dlg = (CDecCB_demoDlg *)pUserData;\n\tif(dlg->m_nDecType!=CDecCB_demoDlg::DEC_VIDEO \n\t\t&& (pFrameInfo->nType == T_AUDIO16 || pFrameInfo->nType==T_AUDIO8) )\n\t\tfwrite(pBuf, 1, nSize, dlg->m_pOutAudioFile);\n\t\n\tif(dlg->m_nDecType!=CDecCB_demoDlg::DEC_AUDIO \n\t\t&& pFrameInfo->nType == T_IYUV)\n\t\tfwrite(pBuf, 1, nSize, dlg->m_pOutVideoFile);\n}\n\nvoid CALLBACK fileEndCBFun(DWORD nPort, void* pUserData)\n{\n\tCDecCB_demoDlg *dlg = (CDecCB_demoDlg *)pUserData;\n\tdlg->PostMessage(WM_COMMAND, IDC_BUTTON_STOP, 0);\n}\n\nvoid CDecCB_demoDlg::ChangeUIState(int nState)\n{\n\tif (nState == STARTDEC)\n\t{\n\t\tGetDlgItem(IDC_BUTTON_STOP)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_BUTTON_PLAY)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_EDIT_FILEPATH)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_EDIT_AUDIOFILEPATH)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_EDIT_VIDEOFILEPATH)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_BUTTON_FILEPATH)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_BUTTON_VIDEOFILE)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_BUTTON_AUDIOFILE)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_RADIO_VIDEO)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_RADIO_AUDIO)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_RADIO_COMPLEX)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_INTERFACE_NEW)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_INTERFACE_OLD)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_INTERFACE_NEW2)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_INTERFACE_OLD2)->EnableWindow(FALSE);\n\t}\n\tif (nState == STOPDEC)\n\t{\n\t\tGetDlgItem(IDC_BUTTON_STOP)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_BUTTON_PLAY)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_EDIT_FILEPATH)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_BUTTON_FILEPATH)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_BUTTON_VIDEOFILE)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_BUTTON_AUDIOFILE)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_EDIT_AUDIOFILEPATH)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_EDIT_VIDEOFILEPATH)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_RADIO_VIDEO)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_RADIO_AUDIO)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_RADIO_COMPLEX)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_INTERFACE_NEW)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_INTERFACE_OLD)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_INTERFACE_NEW2)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_INTERFACE_OLD2)->EnableWindow(TRUE);\n\t}\n}\n\nvoid CDecCB_demoDlg::OnButtonDecode() \n{\n\tif (!UpdateData(TRUE))\n\t{\n\t\treturn;\n\t}\n\t// TODO: Add your control notification handler code here\n\n\t//check the source file\n\tif (!PathFileExists(m_csSrcFilePath))\n\t{\n\t\tMessageBox(LANG_CS(\"Source file error!\"));\n\t\treturn;\n\t}\n\n\t//check the output file of YUV data\n\tif(m_nDecType != DEC_VIDEO)\n\t{\n\t\tm_pOutAudioFile = _tfopen(m_csAudiofilePath.GetBuffer(0), _T(\"wb+\"));\n\t\tif(m_pOutAudioFile == NULL)\n\t\t{\n\t\t\tMessageBox(LANG_CS(\"Output audio file error!\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\t//check the output file of Audio data\n\tif (m_nDecType != DEC_AUDIO)\n\t{\n\t\tm_pOutVideoFile = _tfopen(m_csVideofilePath.GetBuffer(0), _T(\"wb+\"));\n\t\tif(m_pOutVideoFile == NULL)\n\t\t{\n\t\t\tMessageBox(LANG_CS(\"Output YUV file error!\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tstd::string strFileNameA = UnicodeToGbk(m_csSrcFilePath.GetBuffer(0));\n\tif (!PLAY_OpenFile(0,(char*)strFileNameA.c_str()))\n\t{\n\t\tChangeUIState(STOPDEC);\n\t\tMessageBox(LANG_CS(\"Open source file failed!\"));\n\t\tfclose(m_pOutVideoFile);\n\t\tfclose(m_pOutAudioFile);\n\t\treturn;\n\t}\n\t/*set the callback func of the end of file*/\n\tPLAY_SetFileEndCallBack(0, fileEndCBFun, this);\n\t\n\t/*0,1: decode callback,without video rendering*/\n\tif(m_nInterfaceType==0 || m_nInterfaceType==1) \n\t{\n\t\t/*set callback type*/\n\t\tPLAY_SetDecCBStream(0, m_nDecType+1);\n\t\t/*set callback func.*/\n\t\tPLAY_SetFileEndCallBack(0, fileEndCBFun, this);\n\t\t/*set decode callback func. */\n\t\tif(m_nInterfaceType==0)\n\t\t\tPLAY_SetDecCallBackEx(0, DecCbFun, this);\n\t\tif(m_nInterfaceType==1)\n\t\t\tPLAY_SetDecodeCallBack(0, cbDecode, this);\n\t\tPLAY_Play(0, NULL);\n\t}\n\n\t/*2,3:decode callback with video rendering*/\n\tif(m_nInterfaceType==2 || m_nInterfaceType==3) \n\t{\n\t\tif(m_nInterfaceType==2)\n\t\t\tPLAY_SetVisibleDecodeCallBack(0, cbDecode, this);\t\n\t\tif(m_nInterfaceType==3)\n\t\t\tPLAY_SetVisibleDecCallBack(0, cbVisibleDec, this);\n\t\t\t\n\t\t\n\t\tm_displayDlg.ShowWindow(SW_NORMAL);\n\t\tPLAY_Play(0, m_displayDlg.m_hWnd);\n\t\tPLAY_PlaySound(0);\n\t}\n\t//start decode\n\tChangeUIState(STARTDEC);\n}\n\nvoid CDecCB_demoDlg::OnButtonStop() \n{\n\t// TODO: Add your control notification handler code here\n\n\t//set callback which you choose to null\n\tPLAY_SetDecCallBackEx(0, NULL, NULL);\n\tPLAY_SetDecodeCallBack(0, NULL, NULL);\n\tPLAY_SetVisibleDecodeCallBack(0, NULL, NULL);\t\n\tPLAY_SetVisibleDecCallBack(0, NULL, NULL);\n\n\t//stop decode\n\tPLAY_Stop(0);\n\tPLAY_CloseFile(0);\n\n\t//close file\n\tif(m_pOutVideoFile != NULL)\n\t{\n\t\tfclose(m_pOutVideoFile);\n\t\tm_pOutVideoFile = NULL;\n\t}\n\tif(m_pOutAudioFile != NULL)\n\t{\n\t\tfclose(m_pOutAudioFile);\n\t\tm_pOutAudioFile = NULL;\n\t}\n\t\n\tm_displayDlg.ShowWindow(SW_HIDE);\n\n\tChangeUIState(STOPDEC);\n}\n\nvoid CDecCB_demoDlg::OnRadioAudio() \n{\n\t// TODO: Add your control notification handler code here\n\tm_nDecType = DEC_AUDIO;\n}\n\nvoid CDecCB_demoDlg::OnRadioComplex() \n{\n\t// TODO: Add your control notification handler code here\n\tm_nDecType = DEC_COMPLEX;\n}\n\nvoid CDecCB_demoDlg::OnRadioVideo() \n{\n\t// TODO: Add your control notification handler code here\n\tm_nDecType = DEC_VIDEO;\n}\n\nvoid CDecCB_demoDlg::OnClose() \n{\n\t// TODO: Add your message handler code here and/or call default\n\tOnButtonStop();\n\tCDialog::OnClose();\n}\n\nvoid CDecCB_demoDlg::OnButtonAudiofile() \n{\n\t// TODO: Add your control notification handler code here\n\tCString szTitle = LANG_CS(\"folder\");\n\tTCHAR szDisplayName[MAX_PATH] =_T(\"\");\n\tTCHAR szPath[MAX_PATH] =_T(\"\");\n\tBROWSEINFO bi;\n\tbi.hwndOwner = GetSafeHwnd();\n\tbi.pidlRoot = NULL;\n\tbi.lpszTitle = szTitle;\n\tbi.pszDisplayName = szDisplayName;\n\tbi.ulFlags = BIF_RETURNONLYFSDIRS|BIF_BROWSEINCLUDEFILES;\n\tbi.lpfn = NULL;\n\tbi.lParam = 0;\n\tLPITEMIDLIST pItemIDList = SHBrowseForFolder(&bi);\n\t\n\tif (pItemIDList)\n\t{\n\t\tSHGetPathFromIDList(pItemIDList, szPath);\n\t\tIMalloc *pMalloc;\n\t\tif (SHGetMalloc(&pMalloc) != NOERROR)\n\t\t{\n\t\t\tAfxMessageBox(LANG_CS(\"path choose failed!\"));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint pos  = m_csSrcFilePath.ReverseFind('\\\\');\n\t\tCString FileName =\"\\\\\";\n\t\tFileName += m_csSrcFilePath.Right(m_csSrcFilePath.GetLength() - pos - 1);\n\t\tFileName.Delete(FileName.GetLength() - 3, 3);\n\t\tFileName +=\"pcm\";\n\t\t\n\t\tm_csAudiofilePath = szPath  + FileName;\n\t\tSetDlgItemText(IDC_EDIT_AUDIOFILEPATH, m_csAudiofilePath);\n\t\tpMalloc->Free(pItemIDList);\n\t\tif(pMalloc)\n\t\t\tpMalloc->Release();\n\t}\n}\n\nvoid CDecCB_demoDlg::OnButtonVideofile() \n{\n\t// TODO: Add your control notification handler code here\n\tCString szTitle = LANG_CS(\"folder\");\n\tTCHAR szDisplayName[MAX_PATH] =_T(\"\");\n\tTCHAR szPath[MAX_PATH] =_T(\"\");\n\tBROWSEINFO bi;\n\tbi.hwndOwner = GetSafeHwnd();\n\tbi.pidlRoot = NULL;\n\tbi.lpszTitle = szTitle;\n\tbi.pszDisplayName = szDisplayName;\n\tbi.ulFlags = BIF_RETURNONLYFSDIRS|BIF_BROWSEINCLUDEFILES;\n\tbi.lpfn = NULL;\n\tbi.lParam = 0;\n\tLPITEMIDLIST pItemIDList = SHBrowseForFolder(&bi);\n\t\n\tif (pItemIDList)\n\t{\n\t\tSHGetPathFromIDList(pItemIDList, szPath);\n\t\tIMalloc *pMalloc;\n\t\tif (SHGetMalloc(&pMalloc) != NOERROR)\n\t\t{\n\t\t\tAfxMessageBox(LANG_CS(\"path choose failed!\"));\n\t\t\treturn;\n\t\t}\n\n\t\tint pos  = m_csSrcFilePath.ReverseFind('\\\\');\n\t\tCString FileName =\"\\\\\";\n\t\tFileName += m_csSrcFilePath.Right(m_csSrcFilePath.GetLength() - pos - 1);\n\t\tFileName.Delete(FileName.GetLength() - 3, 3);\n\t\tFileName +=\"yuv\";\n\n\t\tm_csVideofilePath = szPath  + FileName;\n\n\t\tSetDlgItemText(IDC_EDIT_VIDEOFILEPATH, m_csVideofilePath);\n\t\tpMalloc->Free(pItemIDList);\n\t\tif(pMalloc)\n\t\t\tpMalloc->Release();\n\t}\n}\n\nvoid CDecCB_demoDlg::OnInterfaceNew() \n{\n\t// TODO: Add your control notification handler code here\n\tm_nInterfaceType = 0;\n}\n\nvoid CDecCB_demoDlg::OnInterfaceOld() \n{\n\t// TODO: Add your control notification handler code here\n\tm_nInterfaceType = 1;\n}\n\nvoid CDecCB_demoDlg::OnInterfaceNew2() \n{\n\t// TODO: Add your control notification handler code here\n\tm_nInterfaceType = 2;\n}\n\nvoid CDecCB_demoDlg::OnInterfaceOld2() \n{\n\t// TODO: Add your control notification handler code here\n\tm_nInterfaceType = 3;\n}\n\nBOOL CDecCB_demoDlg::PreTranslateMessage(MSG* pMsg) \n{\n\t// TODO: Add your specialized code here and/or call the base class\n\tif(pMsg->message == WM_KEYDOWN && (pMsg->wParam == VK_RETURN || pMsg->wParam == VK_ESCAPE))\n\t\treturn TRUE;\n\treturn CDialog::PreTranslateMessage(pMsg);\n}\n","size_bytes":14026},"bin/DemoSrc/playsdkdemo/PlayStateText.cpp":{"content":"// PlayStateText.cpp: implementation of the CPlayStateText class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"PlayDemo.h\"\n#include \"PlayStateText.h\"\n#include \"CharactorTansfer.h\"\n\n#include <string>\n\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\n//////////////////////////////////////////////////////////////////////\n// Construction/Destruction\n//////////////////////////////////////////////////////////////////////\n\nCPlayStateText::CPlayStateText()\n{\n\tClear();\n}\n\nCPlayStateText::~CPlayStateText()\n{\n\n}\n\nvoid CPlayStateText::SetState(CString szState)\n{\n\tif(szState == \"\")\n\t\treturn;\n\tm_szState = szState;\n}\n\nvoid CPlayStateText::SetPlayedTime(int nPlayedTime , int nTotalTime)\n{\n\tm_nTotalTime = nTotalTime;\n\tm_nPlayedTime = nPlayedTime;\n}\n\nvoid CPlayStateText::SetPlayedFrame(int nPlayedFrame, int nTotoalFrame)\n{\n\tm_nTotalFrame = nTotoalFrame;\n\tm_nPlayedFrame = nPlayedFrame;\n}\n\nvoid CPlayStateText::SetBitrate(double dbBitrate)\n{\n\tm_dbBitrate = dbBitrate;\n}\n\nvoid CPlayStateText::SetRate(int nRate)\n{\n\tm_nRate = nRate;\n}\n\nvoid CPlayStateText::SetPictureSize(int nWidth, int nHeight)\n{\n\tm_nWidth = nWidth;\n\tm_nHeight = nHeight;\n}\n\nvoid CPlayStateText::Init(CWnd* lpWnd)\n{\n\tm_lpWnd = lpWnd;\n\tCFont font;\n\tfont.CreateFont(12,\n\t\t0,0,0,\n\t\tFW_NORMAL,\n\t\tFALSE,\n\t\tFALSE,\n\t\t0,\n\t\tANSI_CHARSET,\n\t\tOUT_DEFAULT_PRECIS,\n\t\tCLIP_DEFAULT_PRECIS,\n\t\tDEFAULT_QUALITY,\n\t\tDEFAULT_PITCH | FF_SWISS,\n\t\t_T(\"Arial\"));\n\tm_lpWnd->SetFont(&font, TRUE);\n}\n\nvoid CPlayStateText::Clear()\n{\n\tm_szState = CString(\"\");\n\tm_nPlayedTime = 0;\n\tm_nTotalTime = 0;\n\tm_nPlayedFrame = 0;\n\tm_nTotalFrame = 0;\n\tm_dbBitrate = 0;\n\tm_nWidth = 0;\n\tm_nHeight = 0;\n\tm_nRate = 0;\n}\n\nvoid ChangeChar(char* szBuf, int nSize, char cSrc, char cDest)\n{\n\tfor(int i = 0; i < nSize; i++)\n\t{\n\t\tif(szBuf[i] == cSrc) szBuf[i] = cDest;\n\t}\n}\n\nvoid CPlayStateText::Show()\n{\n\tif(!m_nTotalFrame || !m_nTotalTime)\n\t{\n\t\tint nHour = (m_nPlayedTime/3600) % 24;\n\t\tint nMinute = (m_nPlayedTime%3600) /60;\n\t\tint nSecond = (m_nPlayedTime%60);\n\t\tTCHAR szText[256] = {0};\n\t\tswprintf(szText, L\"%-85s%4d*%4d%8df/s%8dkb/s\", m_szState.GetBuffer(m_szState.GetLength()), m_nWidth, m_nHeight, m_nRate, (int)m_dbBitrate);\n\t//\tChangeChar(szText, 255, 0, ' ');\n\t\tm_lpWnd->SetWindowText(szText);\n\t}\n\telse\n\t{\n\t\tint nHour = (m_nPlayedTime/3600) % 24;\n\t\tint nMinute = (m_nPlayedTime%3600) /60;\n\t\tint nSecond = (m_nPlayedTime%60);\n\t\tint nHour2 = (m_nTotalTime/3600) % 24;\n\t\tint nMinute2 = (m_nTotalTime%3600) /60;\n\t\tint nSecond2= (m_nTotalTime%60);\n\n\t\tTCHAR szText[256] = {0};\n\t\tswprintf(szText, L\"%-40s%4d*%4d%4df/s%8dkb/s%6d/%-7d%02d:%02d:%02d/%02d:%02d:%02d\", \n\t\t\tm_szState.GetBuffer(m_szState.GetLength()), m_nWidth, m_nHeight, m_nRate, (int)m_dbBitrate, m_nPlayedFrame, m_nTotalFrame,\n\t\t\tnHour, nMinute, nSecond, nHour2, nMinute2, nSecond2);\n\t\t//ChangeChar(szText, 255, 0, ' ');\n\n\t\tm_lpWnd->SetWindowText(szText);\n\t}\n}","size_bytes":2940},"bin/Demo/MfcDemo/14.GateDemo/stdafx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n// IntelligentDevice.pch will be the pre-compiled header\n// stdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n\n\n","size_bytes":210},"bin/Demo/MfcDemo/09.AccessControl/include/mdump.cpp":{"content":"//this file is part of eMule\n//Copyright (C)2002-2008 Merkur ( strEmail.Format(\"%s@%s\", \"devteam\", \"emule-project.net\") / http://www.emule-project.net )\n//\n//This program is free software; you can redistribute it and/or\n//modify it under the terms of the GNU General Public License\n//as published by the Free Software Foundation; either\n//version 2 of the License, or (at your option) any later version.\n//\n//This program is distributed in the hope that it will be useful,\n//but WITHOUT ANY WARRANTY; without even the implied warranty of\n//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//GNU General Public License for more details.\n//\n//You should have received a copy of the GNU General Public License\n//along with this program; if not, write to the Free Software\n//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n#include \"stdafx.h\"\n#include \"DbgHelp.h\"\n#include \"mdump.h\"\n#include <shlwapi.h>\n#pragma comment(lib, \"shlwapi.lib\")\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\ntypedef BOOL (WINAPI *MINIDUMPWRITEDUMP)(HANDLE hProcess, DWORD dwPid, HANDLE hFile, MINIDUMP_TYPE DumpType,\n\t\t\t\t\t\t\t\t\t\t CONST PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam,\n\t\t\t\t\t\t\t\t\t\t CONST PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,\n\t\t\t\t\t\t\t\t\t\t CONST PMINIDUMP_CALLBACK_INFORMATION CallbackParam);\n\nCMiniDumper theCrashDumper;\nTCHAR CMiniDumper::m_szAppName[MAX_PATH] = {0};\nTCHAR CMiniDumper::m_szDumpDir[MAX_PATH] = {0};\n\nvoid CMiniDumper::Enable(LPCTSTR pszAppName, bool bShowErrors, LPCTSTR pszDumpDir)\n{\n\t// if this assert fires then you have two instances of CMiniDumper which is not allowed\n\tASSERT( m_szAppName[0] == _T('\\0') );\n\t_tcsncpy(m_szAppName, pszAppName, _countof(m_szAppName) - 1);\n\tm_szAppName[_countof(m_szAppName) - 1] = _T('\\0');\n\n\t// eMule may not have the permission to create a DMP file in the directory where the \"emule.exe\" is located.\n\t// Need to pre-determine a valid directory.\n\t_tcsncpy(m_szDumpDir, pszDumpDir, _countof(m_szDumpDir) - 1);\n\tm_szDumpDir[_countof(m_szDumpDir) - 1] = _T('\\0');\n\tPathAddBackslash(m_szDumpDir);\n\n\tMINIDUMPWRITEDUMP pfnMiniDumpWriteDump = NULL;\n\tHMODULE hDbgHelpDll = GetDebugHelperDll((FARPROC*)&pfnMiniDumpWriteDump, bShowErrors);\n\tif (hDbgHelpDll)\n\t{\n\t\tif (pfnMiniDumpWriteDump)\n\t\t\tSetUnhandledExceptionFilter(TopLevelFilter);\n\t\tFreeLibrary(hDbgHelpDll);\n\t\thDbgHelpDll = NULL;\n\t\tpfnMiniDumpWriteDump = NULL;\n\t}\n}\n\n#define DBGHELP_HINT _T(\"You can get the required DBGHELP.DLL by downloading the \\\"User Mode Process Dumper\\\" from \\\"Microsoft Download Center\\\".\\r\\n\\r\\n\") \\\n\t_T(\"Extract the \\\"User Mode Process Dumper\\\" and locate the \\\"x86\\\" folder. Copy the DBGHELP.DLL from the \\\"x86\\\" folder into your eMule installation folder and/or into your Windows system/system32 folder.\")\n\n\nHMODULE CMiniDumper::GetDebugHelperDll(FARPROC* ppfnMiniDumpWriteDump, bool bShowErrors)\n{\n\t*ppfnMiniDumpWriteDump = NULL;\n\tHMODULE hDll = LoadLibrary(_T(\"DBGHELP.DLL\"));\n\tif (hDll == NULL)\n\t{\n\t\tif (bShowErrors) {\n\t\t\t// Do *NOT* localize that string (in fact, do not use MFC to load it)!\n\t\t\tMessageBox(NULL, _T(\"DBGHELP.DLL not found. Please install a DBGHELP.DLL.\\r\\n\\r\\n\") DBGHELP_HINT, m_szAppName, MB_ICONSTOP | MB_OK);\n\t\t}\n\t}\n\telse\n\t{\n\t\t*ppfnMiniDumpWriteDump = GetProcAddress(hDll, \"MiniDumpWriteDump\");\n\t\tif (*ppfnMiniDumpWriteDump == NULL)\n\t\t{\n\t\t\tif (bShowErrors) {\n\t\t\t\t// Do *NOT* localize that string (in fact, do not use MFC to load it)!\n\t\t\t\tMessageBox(NULL, _T(\"DBGHELP.DLL found is too old. Please upgrade to version 5.1 (or later) of DBGHELP.DLL.\\r\\n\\r\\n\") DBGHELP_HINT, m_szAppName, MB_ICONSTOP | MB_OK);\n\t\t\t}\n\t\t}\n\t}\n\treturn hDll;\n}\n\nLONG CMiniDumper::TopLevelFilter(struct _EXCEPTION_POINTERS* pExceptionInfo)\n{\n\tLONG lRetValue = EXCEPTION_CONTINUE_SEARCH;\n\tTCHAR szResult[MAX_PATH + 1024] = {0};\n\tMINIDUMPWRITEDUMP pfnMiniDumpWriteDump = NULL;\n\tHMODULE hDll = GetDebugHelperDll((FARPROC*)&pfnMiniDumpWriteDump, true);\n\tif (hDll)\n\t{\n\t\tif (pfnMiniDumpWriteDump)\n\t\t{\n\t\t\t// Ask user if they want to save a dump file\n\t\t\t// Do *NOT* localize that string (in fact, do not use MFC to load it)!\n\t\t\tif (MessageBox(NULL, _T(\"Application crashed :-(\\r\\n\\r\\nA diagnostic file can be created which will help the author to resolve this problem. This file will be saved on your Disk (and not sent).\\r\\n\\r\\nDo you want to create this file now?\"), m_szAppName, MB_ICONSTOP | MB_YESNO) == IDYES)\n\t\t\t{\n\t\t\t\t// Create full path for DUMP file\n\t\t\t\tTCHAR szDumpPath[MAX_PATH];\n\t\t\t\t_tcsncpy(szDumpPath, m_szDumpDir, _countof(szDumpPath) - 1);\n\t\t\t\tszDumpPath[_countof(szDumpPath) - 1] = _T('\\0');\n\t\t\t\tsize_t uDumpPathLen = _tcslen(szDumpPath);\n\n\t\t\t\tTCHAR szBaseName[MAX_PATH];\n\t\t\t\t_tcsncpy(szBaseName, m_szAppName, _countof(szBaseName) - 1);\n\t\t\t\tszBaseName[_countof(szBaseName) - 1] = _T('\\0');\n\t\t\t\tsize_t uBaseNameLen = _tcslen(szBaseName);\n\n\t\t\t\ttime_t tNow = time(NULL);\n\t\t\t\t_tcsftime(szBaseName + uBaseNameLen, _countof(szBaseName) - uBaseNameLen, _T(\"_%Y%m%d-%H%M%S\"), localtime(&tNow));\n\t\t\t\tszBaseName[_countof(szBaseName) - 1] = _T('\\0');\n\n\t\t\t\t// Replace spaces and dots in file name.\n\t\t\t\tLPTSTR psz = szBaseName;\n\t\t\t\twhile (*psz != _T('\\0')) {\n\t\t\t\t\tif (*psz == _T('.'))\n\t\t\t\t\t\t*psz = _T('-');\n\t\t\t\t\telse if (*psz == _T(' '))\n\t\t\t\t\t\t*psz = _T('_');\n\t\t\t\t\tpsz++;\n\t\t\t\t}\n\t\t\t\tif (uDumpPathLen < _countof(szDumpPath) - 1) {\n\t\t\t\t\t_tcsncat(szDumpPath, szBaseName, _countof(szDumpPath) - uDumpPathLen - 1);\n\t\t\t\t\tszDumpPath[_countof(szDumpPath) - 1] = _T('\\0');\n\t\t\t\t\tuDumpPathLen = _tcslen(szDumpPath);\n\t\t\t\t\tif (uDumpPathLen < _countof(szDumpPath) - 1) {\n\t\t\t\t\t\t_tcsncat(szDumpPath, _T(\".dmp\"), _countof(szDumpPath) - uDumpPathLen - 1);\n\t\t\t\t\t\tszDumpPath[_countof(szDumpPath) - 1] = _T('\\0');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tHANDLE hFile = CreateFile(szDumpPath, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n\t\t\t\tif (hFile != INVALID_HANDLE_VALUE)\n\t\t\t\t{\n\t\t\t\t\t_MINIDUMP_EXCEPTION_INFORMATION ExInfo = {0};\n\t\t\t\t\tExInfo.ThreadId = GetCurrentThreadId();\n\t\t\t\t\tExInfo.ExceptionPointers = pExceptionInfo;\n\t\t\t\t\tExInfo.ClientPointers = NULL;\n\n\t\t\t\t\tBOOL bOK = (*pfnMiniDumpWriteDump)(GetCurrentProcess(), GetCurrentProcessId(), hFile, MiniDumpNormal, &ExInfo, NULL, NULL);\n\t\t\t\t\tif (bOK)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Do *NOT* localize that string (in fact, do not use MFC to load it)!\n\t\t\t\t\t\t_sntprintf(szResult, _countof(szResult) - 1, _T(\"Saved dump file to \\\"%s\\\".\\r\\n\\r\\nPlease send this file together with a detailed bug report to us !\\r\\n\\r\\n.\"), szDumpPath);\n\t\t\t\t\t\tszResult[_countof(szResult) - 1] = _T('\\0');\n\t\t\t\t\t\tlRetValue = EXCEPTION_EXECUTE_HANDLER;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Do *NOT* localize that string (in fact, do not use MFC to load it)!\n\t\t\t\t\t\t_sntprintf(szResult, _countof(szResult) - 1, _T(\"Failed to save dump file to \\\"%s\\\".\\r\\n\\r\\nError: %u\"), szDumpPath, GetLastError());\n\t\t\t\t\t\tszResult[_countof(szResult) - 1] = _T('\\0');\n\t\t\t\t\t}\n\t\t\t\t\tCloseHandle(hFile);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Do *NOT* localize that string (in fact, do not use MFC to load it)!\n\t\t\t\t\t_sntprintf(szResult, _countof(szResult) - 1, _T(\"Failed to create dump file \\\"%s\\\".\\r\\n\\r\\nError: %u\"), szDumpPath, GetLastError());\n\t\t\t\t\tszResult[_countof(szResult) - 1] = _T('\\0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFreeLibrary(hDll);\n\t\thDll = NULL;\n\t\tpfnMiniDumpWriteDump = NULL;\n\t}\n\n\tif (szResult[0] != _T('\\0'))\n\t\tMessageBox(NULL, szResult, m_szAppName, MB_ICONINFORMATION | MB_OK);\n\n// #ifndef _DEBUG\n// \t// Exit the process only in release builds, so that in debug builds the exception is passed to a possible\n// \t// installed debugger\n// \tExitProcess(0);\n// #else\n// \treturn lRetValue;\n// #endif\n#ifndef _DEBUG\n\t// Exit the process only in release builds, so that in debug builds the exception is passed to a possible\n\t// installed debugger\n\tExitProcess(0);\n#endif\n\treturn lRetValue;\n}\n","size_bytes":7754},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/StdAfx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n//\tNetSDKDemo.pch will be the pre-compiled header\n//\tstdafx.obj will contain the pre-compiled type information\n\n#include \"StdAfx.h\"\n\n\n\n","size_bytes":204},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/NormalBtnPannel.cpp":{"content":"// NormalBtnPannel.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"NormalBtnPannel.h\"\n#include \"NetSDKDemoDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CNormalBtnPannel dialog\n\nCNormalBtnPannel::CNormalBtnPannel(CWnd* pParent /*=NULL*/)\n\t: CDialog(CNormalBtnPannel::IDD, pParent)\n{\n\tm_myBrush.CreateSolidBrush(RGB(200,200,255));\n\t//{{AFX_DATA_INIT(CNormalBtnPannel)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CNormalBtnPannel::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CNormalBtnPannel)\n\tDDX_Control(pDX, IDC_SUBTYPESEL, m_subtypesel);\n\tDDX_Control(pDX, IDC_SPLITTESEL, m_splitsel);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CNormalBtnPannel, CDialog)\n\t//{{AFX_MSG_MAP(CNormalBtnPannel)\n\tON_CBN_SELCHANGE(IDC_SPLITTESEL, OnSelchangeSplittesel)\n\tON_BN_CLICKED(IDC_FULLSCREEN, OnFullscreen)\n\tON_BN_CLICKED(IDC_ADD_DEVICE, OnAddDevice)\n\tON_BN_CLICKED(IDC_DELETE_DEVICE, OnDeleteDevice)\n\tON_BN_CLICKED(IDC_OPEN_CHANNEL, OnOpenChannel)\n\tON_BN_CLICKED(IDC_OPEN_MULTIPLAY, OnOpenMultiplay)\n\tON_BN_CLICKED(IDC_CLOSE_SCREEN, OnCloseScreen)\n\tON_BN_CLICKED(IDC_CLOSE_ALLCHANNEL, OnCloseAllchannel)\n\tON_BN_CLICKED(IDC_SEARCH_RECORD, OnSearchRecord)\n\tON_BN_CLICKED(IDC_CYCLE_MONITOR, OnCycleMonitor)\n\tON_BN_CLICKED(IDC_PLAYBACKBYTIME, OnPlaybackbytime)\n\tON_BN_CLICKED(IDC_DOWNLOADBYTIME, OnDownloadbytime)\n\tON_BN_CLICKED(IDC_SYSCONFIG, OnSysconfig)\n\tON_WM_CTLCOLOR()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CNormalBtnPannel message handlers\n\nBOOL CNormalBtnPannel::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\tg_SetWndStaticText(this);\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CNormalBtnPannel::OnSelchangeSplittesel() \n{\n\tint nSplit = m_splitsel.GetCurSel();\n\t((CNetSDKDemoDlg *)GetParent())->SwitchMultiWnd(nSplit);\n}\n\nvoid CNormalBtnPannel::OnFullscreen() \n{\n\t((CNetSDKDemoDlg *)GetParent())->SwitchFullScreen();\n}\n\nint CNormalBtnPannel::GetSplit()\n{\n\treturn (m_splitsel.GetCurSel());\n}\n\nvoid CNormalBtnPannel::SetSplit(int nSplit)\n{\n\tm_splitsel.SetCurSel(nSplit);\n}\n\nvoid CNormalBtnPannel::InitSplit(int curSplit)\n{\n\tchar *nStrSplit[SPLIT_TOTAL] = {MSG_DEMODLG_SPLITTYPE_1,\n\t\t\t\t\t\t\t\t\tMSG_DEMODLG_SPLITTYPE_4,\n\t\t\t\t\t\t\t\t\tMSG_DEMODLG_SPLITTYPE_9,\n\t\t\t\t\t\t\t\t\tMSG_DEMODLG_SPLITTYPE_16};\n\t\n\t//here curSplit must be lower 4 so ...\n\tfor(int i = SPLIT1; i <= curSplit ; i++)\n\t{\n\t\tm_splitsel.InsertString(i, nStrSplit[i]);\n\t}\n\tConvertComboBox(m_splitsel);\n\n\tm_subtypesel.InsertString(0, ConvertString(NAME_STREAM_MAIN));\n\tm_subtypesel.InsertString(1, ConvertString(NAME_STREAM_SUB1));\n\tm_subtypesel.InsertString(2, ConvertString(NAME_STREAM_SUB2));\n\tm_subtypesel.InsertString(3, ConvertString(NAME_STREAM_SUB3));\n\t\n\tm_subtypesel.SetCurSel(0);\n\tm_splitsel.SetCurSel(curSplit);\n}\n\nvoid CNormalBtnPannel::OnAddDevice() \n{\n\t((CNetSDKDemoDlg *)GetParent())->AddDevice();\n}\n\nvoid CNormalBtnPannel::OnDeleteDevice() \n{\n\t((CNetSDKDemoDlg *)GetParent())->DeleteDevice();\n}\n\nvoid CNormalBtnPannel::OnOpenChannel() \n{\n\t((CNetSDKDemoDlg *)GetParent())->OpenChannel();\n}\n\nvoid CNormalBtnPannel::OnOpenMultiplay() \n{\n\t((CNetSDKDemoDlg *)GetParent())->OpenMultiplay();\n}\n\nvoid CNormalBtnPannel::OnCloseScreen() \n{\n\t((CNetSDKDemoDlg *)GetParent())->CloseScreen();\n}\n\nvoid CNormalBtnPannel::OnCloseAllchannel() \n{\n\t((CNetSDKDemoDlg *)GetParent())->CloseAllChannel();\n}\n\nvoid CNormalBtnPannel::EnableMultiplay(BOOL bEnable)\n{\n//\tGetDlgItem(IDC_OPEN_MULTIPLAY)->EnableWindow(bEnable);\n}\n\nvoid CNormalBtnPannel::OnSearchRecord() \n{\n\t((CNetSDKDemoDlg *)GetParent())->SearchRecord();\n}\n\nvoid CNormalBtnPannel::OnCycleMonitor() \n{\n\t((CNetSDKDemoDlg *)GetParent())->CycleMonitor();\n}\n\nvoid CNormalBtnPannel::OnPlaybackbytime() \n{\n\t((CNetSDKDemoDlg *)GetParent())->Playbackbytime();\n}\n\nvoid CNormalBtnPannel::OnDownloadbytime() \n{\n\t((CNetSDKDemoDlg *)GetParent())->Downloadbytime();\n}\n\nvoid CNormalBtnPannel::OnSysconfig() \n{\n\t((CNetSDKDemoDlg *)GetParent())->Sysconfig();\n}\n\n\nHBRUSH CNormalBtnPannel::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) \n{\n\tHBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);\n\t\n\tif (pWnd->GetDlgCtrlID() == IDC_SPLITTESEL ||\n\t\tpWnd->GetDlgCtrlID() == IDC_SPLITTESEL) \n\t{\n\t\treturn hbr;\n\t}\n\n\treturn m_myBrush;\n}\n\nBOOL CNormalBtnPannel::PreTranslateMessage(MSG* pMsg) \n{\n\tif (WM_KEYDOWN == pMsg->message && \n\t\t(VK_ESCAPE == pMsg->wParam || VK_RETURN == pMsg->wParam))\n\t{\n\t\treturn TRUE;\n\t}\n\t\n\treturn CDialog::PreTranslateMessage(pMsg);\n}\n\nint CNormalBtnPannel::GetSubType()\n{\n\treturn m_subtypesel.GetCurSel();\n}","size_bytes":4844},"bin/Demo/MfcDemo/09.AccessControl/DlgSubDlgInfoAccessRecord.cpp":{"content":"// DlgSubDlgInfoAccessRecord.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"accesscontrol.h\"\n#include \"DlgSubDlgInfoAccessRecord.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgSubDlgInfoAccessRecord dialog\n\n\nCDlgSubDlgInfoAccessRecord::CDlgSubDlgInfoAccessRecord(CWnd* pParent /*=NULL*/, NET_RECORDSET_ACCESS_CTL_CARDREC* p)\n\t: CDialog(CDlgSubDlgInfoAccessRecord::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgSubDlgInfoAccessRecord)\n\tm_csCardNo = _T(\"\");\n\tm_nDoorNo = 0;\n\tm_csPwd = _T(\"\");\n\tm_nRecNo = 0;\n\t//}}AFX_DATA_INIT\n\tmemset(&m_stuInfo, 0, sizeof(m_stuInfo));\n\tif (p != NULL)\n\t{\n\t\tmemcpy(&m_stuInfo, p, sizeof(NET_RECORDSET_ACCESS_CTL_CARDREC));\n\t}\n\tm_stuInfo.dwSize = sizeof(m_stuInfo);\n\n\tm_emOperateType = Em_Operate_Type_Show;\n}\n\n\nvoid CDlgSubDlgInfoAccessRecord::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgSubDlgInfoAccessRecord)\n\tDDX_Control(pDX, IDC_SUBDLG_INFO_ACCESS_DATETIMEPICKER_TIME, m_Time);\n\tDDX_Control(pDX, IDC_SUBDLG_INFO_ACCESS_DATETIMEPICKER_DATE, m_Date);\n\tDDX_Control(pDX, IDC_SUBDLG_INFO_ACCESS_COMBO_METHOD, m_cmbMethod);\n\tDDX_Control(pDX, IDC_SUBDLG_INFO_ACCESS_CHECK_STATUS, m_ckStatus);\n\tDDX_Text(pDX, IDC_SUBDLG_INFO_ACCESS_EDIT_CARDNO, m_csCardNo);\n\tDDX_Text(pDX, IDC_SUBDLG_INFO_ACCESS_EDIT_DOORNO, m_nDoorNo);\n\tDDX_Text(pDX, IDC_SUBDLG_INFO_ACCESS_EDIT_PWD, m_csPwd);\n\tDDX_Text(pDX, IDC_SUBDLG_INFO_ACCESS_EDIT_RECNO, m_nRecNo);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgSubDlgInfoAccessRecord, CDialog)\n\t//{{AFX_MSG_MAP(CDlgSubDlgInfoAccessRecord)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgSubDlgInfoAccessRecord private method\n\nvoid CDlgSubDlgInfoAccessRecord::InitDlg()\n{\n\tm_cmbMethod.ResetContent();\n\tfor (int i = 0; i < sizeof(stuDemoMethod) / sizeof(stuDemoMethod[0]); i++)\n\t{\n\t\tm_cmbMethod.InsertString(-1, ConvertString(stuDemoMethod[i].pszName, SUBDLG_INFO_ACCESS));\n\t}\n    m_cmbMethod.SetDroppedWidth(160);\n\t\n\tif (Em_Operate_Type_Show == m_emOperateType)\n\t{\n\t\tGetDlgItem(IDC_SUBDLG_INFO_ACCESS_EDIT_RECNO)->EnableWindow(FALSE);\n\t\tStuToDlg();\n\t}\n\telse if (Em_Operate_Type_Insert == m_emOperateType)\n\t{\n\t\tGetDlgItem(IDC_SUBDLG_INFO_ACCESS_EDIT_RECNO)->EnableWindow(FALSE);\n\t}\n\telse if (Em_Operate_Type_Get == m_emOperateType)\n\t{\n\t\tGetDlgItem(IDC_SUBDLG_INFO_ACCESS_EDIT_RECNO)->EnableWindow();\n\t\tGetDlgItem(IDC_SUBDLG_INFO_ACCESS_EDIT_CARDNO)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_SUBDLG_INFO_ACCESS_EDIT_PWD)->EnableWindow(FALSE);\n\t\tm_Date.EnableWindow(FALSE);\n\t\tm_Time.EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_SUBDLG_INFO_ACCESS_CHECK_STATUS)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_SUBDLG_INFO_ACCESS_COMBO_METHOD)->EnableWindow(FALSE);\n\t}\n\telse if (Em_Operate_Type_Update == m_emOperateType)\n\t{\n\t\tStuToDlg();\n\t\tGetDlgItem(IDC_SUBDLG_INFO_ACCESS_EDIT_RECNO)->EnableWindow(FALSE);\n\t}\n\telse if (Em_Operate_Type_Remove == m_emOperateType)\n\t{\n\t\tStuToDlg();\n\t\tGetDlgItem(IDC_SUBDLG_INFO_ACCESS_EDIT_RECNO)->EnableWindow();\n\t\tGetDlgItem(IDC_SUBDLG_INFO_ACCESS_EDIT_CARDNO)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_SUBDLG_INFO_ACCESS_EDIT_PWD)->EnableWindow(FALSE);\n\t\tm_Date.EnableWindow(FALSE);\n\t\tm_Time.EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_SUBDLG_INFO_ACCESS_CHECK_STATUS)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_SUBDLG_INFO_ACCESS_COMBO_METHOD)->EnableWindow(FALSE);\n\t}\n\telse if (Em_Operate_Type_Clear == m_emOperateType)\n\t{\n\t\t// ...\n\t}\n}\n\nvoid CDlgSubDlgInfoAccessRecord::StuToDlg()\n{\n\t// RecNo\n\tSetDlgItemInt(IDC_SUBDLG_INFO_ACCESS_EDIT_RECNO, m_stuInfo.nRecNo);\n\t\n\t// card\n\tSetDlgItemText(IDC_SUBDLG_INFO_ACCESS_EDIT_CARDNO, m_stuInfo.szCardNo);\n\t\n\t// pwd\n\tSetDlgItemText(IDC_SUBDLG_INFO_ACCESS_EDIT_PWD, m_stuInfo.szPwd);\n\t\n\t// time\n\tSYSTEMTIME st = {0};\n\tst.wYear\t= (WORD)m_stuInfo.stuTime.dwYear;\n\tst.wMonth\t= (WORD)m_stuInfo.stuTime.dwMonth;\n\tst.wDay\t\t= (WORD)m_stuInfo.stuTime.dwDay;\n\tm_Date.SetTime(&st);\n\tst.wHour\t= (WORD)m_stuInfo.stuTime.dwHour;\n\tst.wMinute\t= (WORD)m_stuInfo.stuTime.dwMinute;\n\tst.wSecond\t= (WORD)m_stuInfo.stuTime.dwSecond;\n\tm_Time.SetTime(&st);\n\t\n\t// status\n\tm_ckStatus.SetCheck(m_stuInfo.bStatus ? BST_CHECKED : BST_UNCHECKED);\n\t\n\t// open method\n    BOOL bMethodFound = FALSE;\n    for (int i = 0; i < sizeof(stuDemoMethod)/sizeof(stuDemoMethod[0]); i++)\n    {\n        if (m_stuInfo.emMethod == stuDemoMethod[i].emMethod)\n        {\n            bMethodFound = TRUE;\n            m_cmbMethod.SetCurSel(i);\n            break;\n        }\n    }\n    if (!bMethodFound)\n    {\n        m_cmbMethod.SetCurSel(-1);\n    }\n\t\n\t// door\n\tSetDlgItemInt(IDC_SUBDLG_INFO_ACCESS_EDIT_DOORNO, m_stuInfo.nDoor);\n}\n\nvoid CDlgSubDlgInfoAccessRecord::DlgToStu()\n{\n\t// RecNo\n\tm_stuInfo.nRecNo = GetDlgItemInt(IDC_SUBDLG_INFO_ACCESS_EDIT_RECNO);\n\t\n\t// card\n\tGetDlgItemText(IDC_SUBDLG_INFO_ACCESS_EDIT_CARDNO, m_stuInfo.szCardNo, sizeof(m_stuInfo.szCardNo) - 1);\n\t\n\t// pwd\n\tGetDlgItemText(IDC_SUBDLG_INFO_ACCESS_EDIT_PWD, m_stuInfo.szPwd, sizeof(m_stuInfo.szPwd) - 1);\n\t\n\t// time\n\tSYSTEMTIME st = {0};\n\tm_Date.GetTime(&st);\n\tm_stuInfo.stuTime.dwYear = st.wYear;\n\tm_stuInfo.stuTime.dwMonth = st.wMonth;\n\tm_stuInfo.stuTime.dwDay = st.wDay;\n\tm_Time.GetTime(&st);\n\tm_stuInfo.stuTime.dwHour = st.wHour;\n\tm_stuInfo.stuTime.dwMinute = st.wMinute;\n\tm_stuInfo.stuTime.dwSecond = st.wSecond;\n\t\n\t// status\n\tif (m_ckStatus.GetCheck())\n\t{\n\t\tm_stuInfo.bStatus = TRUE;\n\t}\n\telse\n\t{\n\t\tm_stuInfo.bStatus = FALSE;\n\t}\n\t\n\t// open method\n    int nMethodIndex = m_cmbMethod.GetCurSel();\n    if (nMethodIndex > 0 && nMethodIndex < sizeof(stuDemoMethod)/sizeof(stuDemoMethod[0]))\n    {\n        m_stuInfo.emMethod = (NET_ACCESS_DOOROPEN_METHOD)stuDemoMethod[nMethodIndex].emMethod;\n    }\n    else\n    {\n        m_stuInfo.emMethod = NET_ACCESS_DOOROPEN_METHOD_UNKNOWN;\n    }\n\t\n\t// door\n\tm_stuInfo.nDoor = GetDlgItemInt(IDC_SUBDLG_INFO_ACCESS_EDIT_DOORNO);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgSubDlgInfoAccessRecord message handlers\n\nBOOL CDlgSubDlgInfoAccessRecord::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\tg_SetWndStaticText(this, SUBDLG_INFO_ACCESS);\n\t// TODO: Add extra initialization here\n\tInitDlg();\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgSubDlgInfoAccessRecord::OnOK() \n{\n\t// TODO: Add extra validation here\t\n\tswitch (m_emOperateType)\n\t{\n\tcase Em_Operate_Type_Show:\n\t\t{\n\t\t\tStuToDlg();\n\t\t}\n\t\tbreak;\n\tcase Em_Operate_Type_Insert:\n\t\t{\n\t\t\tDlgToStu();\n\t\t}\n\t\tbreak;\n\tcase Em_Operate_Type_Get:\n\t\t{\n\t\t\tDlgToStu();\n\t\t}\n\t\tbreak;\n\tcase Em_Operate_Type_Update:\n\t\t{\n\t\t\tDlgToStu();\n\t\t}\n\t\tbreak;\n\tcase Em_Operate_Type_Remove:\n\t\t{\n\t\t\tDlgToStu();\n\t\t}\n\t\tbreak;\n\tcase Em_Operate_Type_Clear:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tCDialog::OnOK();\n}\n","size_bytes":6884},"bin/DemoSrc/playsdkdemo/IPlay.cpp":{"content":"// IPlay.cpp: implementation of the IPlay class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"PlayDemo.h\"\n#include \"IPlay.h\"\n\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\n//////////////////////////////////////////////////////////////////////\n// Construction/Destruction\n//////////////////////////////////////////////////////////////////////\n\n","size_bytes":452},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgAlarmCenter.cpp":{"content":"// DlgCfgAlarmCenter.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgCfgAlarmCenter.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgAlarmCenter dialog\n\n\nCDlgCfgAlarmCenter::CDlgCfgAlarmCenter(CWnd* pParent /*=NULL*/, LLONG hLoginID /*= NULL*/)\n\t: CDialog(CDlgCfgAlarmCenter::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgAlarmCenter)\n\tm_hLogin = hLoginID;\n\t//}}AFX_DATA_INIT\n\tmemset(&m_stuAlarmServerInfo, 0, sizeof(m_stuAlarmServerInfo));\n}\n\nvoid CDlgCfgAlarmCenter::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgAlarmCenter)\n\tDDX_Control(pDX, IDC_ALARMCENTER_IPADDR_IP, m_ctrlIP);\n\tDDX_Control(pDX, IDC_ALARMCENTER_COMBO_SECOND, m_cmbSecond);\n\tDDX_Control(pDX, IDC_ALARMCENTER_COMBO_MINUTE, m_cmbMin);\n\tDDX_Control(pDX, IDC_ALARMCENTER_COMBO_HOUR, m_cmbHour);\n\tDDX_Control(pDX, IDC_ALARMCENTER_COMBO_ONTIMEUPDAY, m_cbUpday);\n\tDDX_Control(pDX, IDC_ALARMCENTER_CHECK_ENABLE, m_ckUpEnable);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgAlarmCenter, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgAlarmCenter)\n\tON_BN_CLICKED(IDC_ALARMCENTER_BUTTON_GET_A3, OnAlarmcenterButtonGetA3)\n\tON_BN_CLICKED(IDC_ALARMCENTER_BUTTON_SET_A3, OnAlarmcenterButtonSetA3)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgAlarmCenter message handlers\nBOOL CDlgCfgAlarmCenter::OnInitDialog()\n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_ALARMCENTER);\n\n\tInitDlg();\n\n\tif (!m_hLogin)\n\t{\n\t\tMessageBox(ConvertString(\"we haven't login a device yet!\", DLG_CFG_ALARMCENTER), ConvertString(\"Prompt\"));\n\t\treturn TRUE;\n\t}\n\t\n\tOnAlarmcenterButtonGetA3();\t\n\n\treturn TRUE; \n}\n\nvoid CDlgCfgAlarmCenter::OnAlarmcenterButtonGetA3() \n{\n\t// TODO: Add your control notification handler code here\n\tif (GetConfigFromDevice())\n\t{\n\t\tshowInfo();\n\t}\n}\n\nvoid CDlgCfgAlarmCenter::OnAlarmcenterButtonSetA3() \n{\n\t// TODO: Add your control notification handler code here\n\tif (getInfo())\n\t{\n\t\tSetConfigToDevice();\n\t}\n}\n\nvoid CDlgCfgAlarmCenter::InitDlg()\n{\n\tm_ckUpEnable.SetCheck(BST_UNCHECKED);\n\t\n\tint i = 0;\n\n\tm_cbUpday.ResetContent();\n\tfor (i = 0; i < sizeof(stuDemoReportWeekDay) / sizeof(stuDemoReportWeekDay[0]); i++)\n\t{\n\t\tm_cbUpday.InsertString(-1, ConvertString(stuDemoReportWeekDay[i].szName, DLG_CFG_ALARMCENTER));\n\t}\n\tm_cbUpday.SetCurSel(-1);\n\t\n\tm_cmbHour.ResetContent();\n\tfor (i = 0; i < 24; ++i)\n\t{\n\t\tCString csTemp;\n\t\tcsTemp.Format(\"%02d\", i);\n\t\tm_cmbHour.InsertString(-1, csTemp);\n\t}\n\tm_cmbHour.SetCurSel(-1);\n\t\n\tm_cmbMin.ResetContent();\n\tm_cmbSecond.ResetContent();\n\tfor (i = 0; i < 60; i++)\n\t{\n\t\tCString csTemp;\n\t\tcsTemp.Format(\"%02d\", i);\n\t\tm_cmbMin.InsertString(-1, csTemp);\n\t\tm_cmbSecond.InsertString(-1, csTemp);\n\t}\n\tm_cmbMin.SetCurSel(-1);\n\tm_cmbSecond.SetCurSel(-1);\n}\n\nvoid CDlgCfgAlarmCenter::showInfo()\n{\n\t// Enable\n\tif (m_stuAlarmServerInfo.stuMainServer.bEnable)\n\t{\n\t\tm_ckUpEnable.SetCheck(BST_CHECKED);\n\t}\n\telse\n\t{\n\t\tm_ckUpEnable.SetCheck(BST_UNCHECKED);\n\t}\n\n\t// ReportWeekDay\n\tif (m_stuAlarmServerInfo.stuMainServer.emReportWeekDay >= emReportWeekDay_DoNotReport\n\t\t&& m_stuAlarmServerInfo.stuMainServer.emReportWeekDay <= emReportWeekDay_Everyday)\n\t{\n\t\tm_cbUpday.SetCurSel(int(m_stuAlarmServerInfo.stuMainServer.emReportWeekDay + 1));\n\t}\n\telse\n\t{\n\t\tm_cbUpday.SetCurSel(-1);\n\t}\n\t\n\t// ReportHour\n\tif (m_stuAlarmServerInfo.stuMainServer.nHour >= 0\n\t\t&& m_stuAlarmServerInfo.stuMainServer.nHour <= 23)\n\t{\n\t\tm_cmbHour.SetCurSel(m_stuAlarmServerInfo.stuMainServer.nHour);\n\t}\n\telse\n\t{\n\t\tm_cmbHour.SetCurSel(-1);\n\t}\n\n\t// ReportMinute\n\tif (m_stuAlarmServerInfo.stuMainServer.nMinute >= 0\n\t\t&& m_stuAlarmServerInfo.stuMainServer.nMinute <= 59)\n\t{\n\t\tm_cmbMin.SetCurSel(m_stuAlarmServerInfo.stuMainServer.nMinute);\n\t}\n\telse\n\t{\n\t\tm_cmbMin.SetCurSel(-1);\n\t}\n\n\t// ReportSecond\n\tif (m_stuAlarmServerInfo.stuMainServer.nSecond >= 0\n\t\t&& m_stuAlarmServerInfo.stuMainServer.nSecond <= 59)\n\t{\n\t\tm_cmbSecond.SetCurSel(m_stuAlarmServerInfo.stuMainServer.nSecond);\n\t}\n\telse\n\t{\n\t\tm_cmbSecond.SetCurSel(-1);\n\t}\n\n\t// IP address\n\tm_ctrlIP.SetWindowText(m_stuAlarmServerInfo.stuMainServer.szAddress);\n\n\t// Port\n\tSetDlgItemInt(IDC_ALARMCENTER_EDIT_PORT, m_stuAlarmServerInfo.stuMainServer.nPort);\n}\n\nBOOL CDlgCfgAlarmCenter::getInfo()\n{\n\t// Enable\n\tm_stuAlarmServerInfo.stuMainServer.bEnable = m_ckUpEnable.GetCheck() ? TRUE : FALSE;\n\t\n\t// ReportWeekDay\n\tm_stuAlarmServerInfo.stuMainServer.emReportWeekDay = emCFG_REPORTWEEKDAY(m_cbUpday.GetCurSel() - 1);\n\n\t// ReportHour\n\tm_stuAlarmServerInfo.stuMainServer.nHour = m_cmbHour.GetCurSel();\n\n\t// ReportMinute\n\tm_stuAlarmServerInfo.stuMainServer.nMinute = m_cmbMin.GetCurSel();\n\n\t// ReportSecond\n\tm_stuAlarmServerInfo.stuMainServer.nSecond = m_cmbSecond.GetCurSel();\n\n\t// IP address\n\tCString csIp;\n\tm_ctrlIP.GetWindowText(csIp);\n\tstrncpy(m_stuAlarmServerInfo.stuMainServer.szAddress, csIp.GetBuffer(0), sizeof(m_stuAlarmServerInfo.stuMainServer.szAddress) - 1);\n\n\t// Port\n\tint nPort = GetDlgItemInt(IDC_ALARMCENTER_EDIT_PORT);\n\tif (nPort > 0 && nPort <= 65535)\n\t{\n\t\tm_stuAlarmServerInfo.stuMainServer.nPort = nPort;\n\t}\n\telse\n\t{\n\t\tMessageBox(ConvertString(\"Port error!\", DLG_CFG_ALARMCENTER), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nBOOL CDlgCfgAlarmCenter::SetConfigToDevice()\n{\n\tchar szJsonBuf[1024] = {0};\n\tBOOL bRet = CLIENT_PacketData(CFG_CMD_ALARMSERVER, &m_stuAlarmServerInfo, sizeof(m_stuAlarmServerInfo), \n\t\tszJsonBuf, sizeof(szJsonBuf));\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(CString(\"packet AlarmServer error...\"), DLG_CFG_ALARMCENTER), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t} \n\telse\n\t{\n\t\tint nerror = 0;\n\t\tint nrestart = 0;\n\t\tbRet = CLIENT_SetNewDevConfig(m_hLogin, CFG_CMD_ALARMSERVER, -1, szJsonBuf, sizeof(szJsonBuf), &nerror, &nrestart, SDK_API_WAIT);\n\t\tif (!bRet)\n\t\t{\n\t\t\tCString csErr;\n\t\t\tcsErr.Format(\"%s %08x\", ConvertString(\"SetupConfig AlarmServer failed:\", DLG_CFG_ALARMCENTER), CLIENT_GetLastError());\n\t\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMessageBox(ConvertString(\"SetConfig AlarmServer ok!\", DLG_CFG_ALARMCENTER), ConvertString(\"Prompt\"));\n\t\t}\n\t}\n\treturn TRUE;\n}\n\nBOOL CDlgCfgAlarmCenter::GetConfigFromDevice()\n{\n\tchar szJsonBuf[1024] = {0};\n\tint nerror = 0;\n\tint nSelChn = -1;\n\tBOOL bRet = CLIENT_GetNewDevConfig(m_hLogin, CFG_CMD_ALARMSERVER, nSelChn, szJsonBuf, sizeof(szJsonBuf), &nerror, SDK_API_WAIT);\n\t\n\tif (bRet)\n\t{\n\t\tDWORD dwRetLen = 0;\n\t\tbRet = CLIENT_ParseData(CFG_CMD_ALARMSERVER, szJsonBuf, (void*)&m_stuAlarmServerInfo, sizeof(m_stuAlarmServerInfo), &dwRetLen);\n\t\tif (!bRet)\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"parse AlarmServer error...\"), DLG_CFG_ALARMCENTER), ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\t\t\t\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"QueryConfig AlarmServer error:\" ,DLG_CFG_ALARMCENTER),CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n","size_bytes":7058},"bin/Demo/MfcDemo/10.AlarmDevice/DlgBypassCtl.cpp":{"content":"// DlgBypassCtl.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgBypassCtl.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgBypassCtl dialog\n\n\nCDlgBypassCtl::CDlgBypassCtl(CWnd* pParent /* = NULL */, LLONG lLoginId /* = NULL */, unsigned int uiChannelNum /* = 0 */)\n\t: CDialog(CDlgBypassCtl::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgBypassCtl)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\tm_lLoginId = lLoginId;\n\tm_uiChannelNum = uiChannelNum;\n\tm_nExtChannelNum = 256;\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CDlgBypassCtl::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgBypassCtl)\n\tDDX_Control(pDX, IDC_BYPASSCTL_CMB_EXTCHANNEL, m_cmbExtChannel);\n\tDDX_Control(pDX, IDC_BYPASSCTL_CMB_MODE, m_cmbBypassMode);\n\tDDX_Control(pDX, IDC_BYPASSCTL_CMB_CHANNEL, m_cmbChannel);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgBypassCtl, CDialog)\n\t//{{AFX_MSG_MAP(CDlgBypassCtl)\n\tON_WM_DESTROY()\n\tON_BN_CLICKED(IDC_BYPASSCTL_BTN_GET, OnBypassctlBtnGet)\n\tON_BN_CLICKED(IDC_BYPASSCTL_BTN_SET, OnBypassctlBtnSet)\n\tON_BN_CLICKED(IDC_BYPASSCTL_RADIO_CHANNEL, OnBypassctlRadioChannel)\n\tON_BN_CLICKED(IDC_BYPASSCTL_RADIO_EXTCHANNEL, OnBypassctlRadioExtchannel)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgBypassCtl private methods\n\nvoid CDlgBypassCtl::InitDlg()\n{\n\tif (m_uiChannelNum <= 0)\n\t{\n\t\treturn;\n\t}\n\n\tm_cmbChannel.ResetContent();\n\tfor (unsigned int i = 0; i < m_uiChannelNum; i++)\n\t{\n\t\tCString csName;\n\t\tcsName.Format(\"%s %d\", ConvertString(\"Channel\", DLG_BYPASSCTL), i+1);\n\t\tm_cmbChannel.InsertString(-1, csName);\n\t}\n\tm_cmbChannel.SetCurSel(-1);\n\tm_cmbChannel.SetDroppedWidth(100);\n\n\tm_cmbExtChannel.ResetContent();\n\tfor (int k = 0; k < m_nExtChannelNum; k++)\n\t{\n\t\tCString csName;\n\t\tcsName.Format(\"%s %d\", ConvertString(\"ExtChannel\", DLG_BYPASSCTL), k+1);\n\t\tm_cmbExtChannel.InsertString(-1, csName);\n\t}\n\tm_cmbExtChannel.SetCurSel(-1);\n\tm_cmbExtChannel.SetDroppedWidth(120);\n\n\tCButton* pBtn = (CButton*)GetDlgItem(IDC_BYPASSCTL_RADIO_CHANNEL);\n\tpBtn->SetCheck(BST_CHECKED);\n\tpBtn = (CButton*)GetDlgItem(IDC_BYPASSCTL_RADIO_EXTCHANNEL);\n\tpBtn->SetCheck(BST_UNCHECKED);\n\tGetDlgItem(IDC_BYPASSCTL_CMB_CHANNEL)->EnableWindow();\n\tGetDlgItem(IDC_BYPASSCTL_CMB_EXTCHANNEL)->EnableWindow(FALSE);\n\n\tm_cmbBypassMode.ResetContent();\n\tfor (int j = 0; j < sizeof(stuBypassModeInfo) / sizeof(stuBypassModeInfo[0]); j++)\n\t{\n\t\tm_cmbBypassMode.InsertString(-1, ConvertString(stuBypassModeInfo[j].szMode, DLG_BYPASSCTL));\n\t}\n\tm_cmbBypassMode.SetCurSel(-1);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgBypassCtl message handlers\n\nBOOL CDlgBypassCtl::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_BYPASSCTL);\n\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgBypassCtl::OnDestroy() \n{\n\tCDialog::OnDestroy();\n\t\n\t// TODO: Add your message handler code here\n\t\n}\n\nvoid CDlgBypassCtl::OnBypassctlBtnGet() \n{\n\t// TODO: Add your control notification handler code here\n\tCButton* pBtnChn = (CButton*)GetDlgItem(IDC_BYPASSCTL_RADIO_CHANNEL);\n\tCButton* pBtnExtChn = (CButton*)GetDlgItem(IDC_BYPASSCTL_RADIO_EXTCHANNEL);\n\n\n\tNET_BYPASS_MODE emBypassMode = NET_BYPASS_MODE_UNKNOW;\n\tint nLocal[] = {m_cmbChannel.GetCurSel()};\n\tint nExtLocal[] = {m_cmbExtChannel.GetCurSel()};\n\n\tNET_DEVSTATE_GET_BYPASS stuGetBypass = {sizeof(stuGetBypass)};\n\n\tif (pBtnChn->GetCheck())\n\t{\n\t\tstuGetBypass.nLocalCount = sizeof(nLocal)/sizeof(nLocal[0]);\n\t\tstuGetBypass.pemLocal = &emBypassMode;\n\t\tstuGetBypass.pnLocal = nLocal;\n\t}\n\telse if (pBtnExtChn->GetCheck())\n\t{\n\t\tstuGetBypass.nExtendedCount = sizeof(nExtLocal)/sizeof(nExtLocal[0]);\n\t\tstuGetBypass.pemExtended = &emBypassMode;\n\t\tstuGetBypass.pnExtended = nExtLocal;\n\t}\n\n\n\tint nRetLen = 0;\n\tBOOL bRet = CLIENT_QueryDevState(m_lLoginId, DH_DEVSTATE_GET_BYPASS, \n\t\t(char*)&stuGetBypass, sizeof(NET_DEVSTATE_GET_BYPASS), &nRetLen, SDK_API_WAIT);\n\tif (!bRet)\n\t{\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"QueryChannelMode failed:\", DLG_BYPASSCTL), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn;\n\t} \n\telse\n\t{\n\t\tm_cmbBypassMode.SetCurSel((int)emBypassMode);\n\t}\n}\n\nvoid CDlgBypassCtl::OnBypassctlBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n\tCButton* pBtnChn = (CButton*)GetDlgItem(IDC_BYPASSCTL_RADIO_CHANNEL);\n\tCButton* pBtnExtChn = (CButton*)GetDlgItem(IDC_BYPASSCTL_RADIO_EXTCHANNEL);\n\n\tCString csPsw;\n\tGetDlgItemText(IDC_BYPASSCTL_EDT_PSW, csPsw);\n\n\tNET_CTRL_SET_BYPASS stuSetBypass = {sizeof(stuSetBypass)};\n\tstuSetBypass.szDevPwd = csPsw.GetBuffer(0);\n\tstuSetBypass.emMode = (NET_BYPASS_MODE)m_cmbBypassMode.GetCurSel();\n\n\tint nLocal[] = {m_cmbChannel.GetCurSel()};\n\tint nExtLocal[] = {m_cmbExtChannel.GetCurSel()};\n\n\tif (pBtnChn->GetCheck())\n\t{\n\t\tstuSetBypass.nLocalCount = sizeof(nLocal)/sizeof(nLocal[0]);\n\t\tstuSetBypass.pnLocal = nLocal;\n\t}\n\telse if (pBtnExtChn->GetCheck())\n\t{\n\t\tstuSetBypass.nExtendedCount = sizeof(nExtLocal)/sizeof(nExtLocal[0]);\n\t\tstuSetBypass.pnExtended = nExtLocal;\n\t}\n\n\tBOOL bRet = CLIENT_ControlDevice(m_lLoginId, DH_CTRL_SET_BYPASS, &stuSetBypass, SDK_API_WAIT);\n\tif (bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Set bypass ok!\", DLG_BYPASSCTL), ConvertString(\"Prompt\"));\n\t} \n\telse\n\t{\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"set bypass failed:\", DLG_BYPASSCTL), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t}\n}\n\nvoid CDlgBypassCtl::OnBypassctlRadioChannel() \n{\n\t// TODO: Add your control notification handler code here\n\tCButton* pBtn = (CButton*)GetDlgItem(IDC_BYPASSCTL_RADIO_CHANNEL);\n\tpBtn->SetCheck(BST_CHECKED);\n\tpBtn = (CButton*)GetDlgItem(IDC_BYPASSCTL_RADIO_EXTCHANNEL);\n\tpBtn->SetCheck(BST_UNCHECKED);\n\tGetDlgItem(IDC_BYPASSCTL_CMB_CHANNEL)->EnableWindow();\n\tGetDlgItem(IDC_BYPASSCTL_CMB_EXTCHANNEL)->EnableWindow(FALSE);\n}\n\nvoid CDlgBypassCtl::OnBypassctlRadioExtchannel() \n{\n\t// TODO: Add your control notification handler code here\n\tCButton* pBtn = (CButton*)GetDlgItem(IDC_BYPASSCTL_RADIO_CHANNEL);\n\tpBtn->SetCheck(BST_UNCHECKED);\n\tpBtn = (CButton*)GetDlgItem(IDC_BYPASSCTL_RADIO_EXTCHANNEL);\n\tpBtn->SetCheck(BST_CHECKED);\n\tGetDlgItem(IDC_BYPASSCTL_CMB_CHANNEL)->EnableWindow(FALSE);\n\tGetDlgItem(IDC_BYPASSCTL_CMB_EXTCHANNEL)->EnableWindow();\n}\n","size_bytes":6609},"bin/Demo/MfcDemo/22.ThermalCamera/ThermalCameraDlg.cpp":{"content":"// ThermalCameraDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"ThermalCamera.h\"\n#include \"ThermalCameraDlg.h\"\n#include \"control.h\"\n#include \"AlarmDlg.h\"\n#include \"Info.h\"\n#include \"QueryDlg.h\"\n#include \"Property.h\"\n#include \"RuleDlg.h\"\n#include \"GlobalDlg.h\"\n#include \"StatistcisDlg.h\"\n#include \"AlarmConfigDlg.h\"\n#include \"LocalParameter.h\"\n#include \"MessageText.h\"\n#include \"QueryPointInfoDlg.h\"\n#include \"QueryItemInfoDlg.h\"\n#include \"heatmap.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n#define WM_DEVICE_DISCONNECT\t(WM_USER + 100)\n#define WM_DEVICE_RECONNECT\t\t(WM_USER + 101)\n/////////////////////////////////////////////////////////////////////////////\n// CThermalCameraDlg dialog\n\nCThermalCameraDlg::CThermalCameraDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CThermalCameraDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CThermalCameraDlg)\n\tm_DvrUserName = _T(\"admin\");\n\tm_DvrPassword = _T(\"admin123\");\n\tm_DvrPort = 37777;\n\tm_bOriginal = FALSE;\n\t//}}AFX_DATA_INIT\n\t// Note that LoadIcon does not require a subsequent DestroyIcon in Win32\n\tm_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);\n    m_LoginID = 0;\n    m_nChannelCount = 0;\n    m_nChannelNum = 0;\n    for (int i = 0;i<2;++i)\n    {\n        m_DispHanle[i] =0;\n    }\n}\n\nvoid CThermalCameraDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CThermalCameraDlg)\n\tDDX_Control(pDX, IDC_BUTTON_STOP, m_BtnStop);\n\tDDX_Control(pDX, IDC_BUTTON_Play, m_BtnPlay);\n\tDDX_Control(pDX, IDC_COMBO_PLAYMODE, m_comboPlayMode);\n\tDDX_Control(pDX, IDC_IPADDRESS, m_DvrIPAddr);\n\tDDX_Text(pDX, IDC_EDIT_USERNAME, m_DvrUserName);\n\tDDX_Text(pDX, IDC_EDIT_PASSWORD, m_DvrPassword);\n\tDDX_Text(pDX, IDC_EDIT_PORT, m_DvrPort);\n\tDDX_Check(pDX, IDC_CHECK_ORIGINAL, m_bOriginal);\n\t//}}AFX_DATA_MAP\n}\n\nBEGIN_MESSAGE_MAP(CThermalCameraDlg, CDialog)\n\t//{{AFX_MSG_MAP(CThermalCameraDlg)\n\tON_WM_PAINT()\n\tON_WM_QUERYDRAGICON()\n\tON_COMMAND(ID_ALARM, OnAlarm)\n\tON_COMMAND(ID_QUERY, OnQuery)\n\tON_COMMAND(ID_Preperty, OnPreperty)\n\tON_COMMAND(ID_GLOBAL, OnGlobal)\n\tON_COMMAND(ID_STATISTCIS, OnStatistcis)\n\tON_BN_CLICKED(IDC_BTN_Login, OnBTNLogin)\n\tON_BN_CLICKED(IDC_BTN_LEAVE, OnBtnLeave)\n\tON_BN_CLICKED(IDC_BUTTON_Play, OnBUTTONPlay)\n\tON_BN_CLICKED(IDC_BUTTON_STOP, OnButtonStop)\n\tON_COMMAND(ID_PRESETINFO, OnPresetinfo)\n\tON_COMMAND(ID_POINTINFO, OnPointinfo)\n\tON_COMMAND(ID_ITEMINFO, OnIteminfo)\n\tON_COMMAND(ID_RULE, OnRule)\n\tON_BN_CLICKED(IDC_BTN_PTZMENU, OnBtnPtzmenu)\n\tON_COMMAND(ID_HEATMAP, OnHeatmap)\n\tON_MESSAGE(WM_DEVICE_DISCONNECT, OnDisConnect)\n\tON_MESSAGE(WM_DEVICE_RECONNECT, OnReConnect)\n\tON_WM_DESTROY()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CThermalCameraDlg message handlers\n\nBOOL CThermalCameraDlg::OnInitDialog()\n{\n\tCDialog::OnInitDialog();\n\t// Set the icon for this dialog.  The framework does this automatically\n\t//  when the application's main window is not a dialog\n\tSetIcon(m_hIcon, TRUE);\t\t\t// Set big icon\n\tSetIcon(m_hIcon, FALSE);\t\t// Set small icon\n\tm_Menu.LoadMenu(IDR_MENU);\n    m_Menu.GetSubMenu(0)->ModifyMenu(0,MF_BYPOSITION,ID_PRESETINFO,ConvertString(\"presetinfo\"));\n    m_Menu.GetSubMenu(0)->ModifyMenu(1,MF_BYPOSITION,ID_POINTINFO,ConvertString(\"pointinfo\"));\n    m_Menu.GetSubMenu(0)->ModifyMenu(2,MF_BYPOSITION,ID_ITEMINFO,ConvertString(\"iteminfo\"));\n    m_Menu.ModifyMenu(1,MF_BYPOSITION,ID_ALARM,ConvertString(\"alarm\"));\n//    m_Menu.ModifyMenu(0,MF_BYPOSITION,ID_CONTROL,ConvertString(\"control\"));\n    m_Menu.ModifyMenu(0,MF_BYPOSITION,ID_INFO,ConvertString(\"info\"));\n    m_Menu.ModifyMenu(2,MF_BYPOSITION,ID_HEATMAP,ConvertString(\"heatmap\"));\n    SetMenu(&m_Menu);\n    g_SetWndStaticText(this);\n    m_DvrIPAddr.SetAddress(172,32,101,83);\n\tint nIndex = 0;\n    CString strPlayMode[2]={ConvertString(\"Direct-play\"), ConvertString(\"Data-callback\")};\n    m_comboPlayMode.ResetContent();\n    nIndex = m_comboPlayMode.AddString(strPlayMode[0]);\n    m_comboPlayMode.SetItemData(nIndex,DirectMode);\n    nIndex = m_comboPlayMode.AddString(strPlayMode[1]);\n    m_comboPlayMode.SetItemData(nIndex,ServerMode);\n\tm_comboPlayMode.SetCurSel(0);\n\tInitNetSDK();\n\treturn TRUE;  // return TRUE  unless you set the focus to a control\n}\n\n// If you add a minimize button to your dialog, you will need the code below\n//  to draw the icon.  For MFC applications using the document/view model,\n//  this is automatically done for you by the framework.\n\nvoid CThermalCameraDlg::OnPaint() \n{\n\tif (IsIconic())\n\t{\n\t\tCPaintDC dc(this); // device context for painting\n\n\t\tSendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);\n\n\t\t// Center icon in client rectangle\n\t\tint cxIcon = GetSystemMetrics(SM_CXICON);\n\t\tint cyIcon = GetSystemMetrics(SM_CYICON);\n\t\tCRect rect;\n\t\tGetClientRect(&rect);\n\t\tint x = (rect.Width() - cxIcon + 1) / 2;\n\t\tint y = (rect.Height() - cyIcon + 1) / 2;\n\n\t\t// Draw the icon\n\t\tdc.DrawIcon(x, y, m_hIcon);\n\t}\n\telse\n\t{\n\t\tCDialog::OnPaint();\n\t}\n\n}\n\n//Callback function when device disconnected\nvoid CALLBACK DisConnectFunc(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser)\n{    \n\tif(dwUser == 0)\n\t{\n\t\treturn;\n\t}\n\n\tCThermalCameraDlg *pThis = (CThermalCameraDlg *)dwUser;\n\tHWND hWnd = pThis->GetSafeHwnd();\n\tif (NULL == hWnd)\n\t{\n\t\treturn;\n\t}\n\tPostMessage(hWnd, WM_DEVICE_DISCONNECT, NULL, NULL);\t\n}\n\n//Callback function when device reconnect\nvoid CALLBACK ReConnectFunc(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser)\n{\n\tif(dwUser == 0)\n\t{\n\t\treturn;\n\t}\n\n\tCThermalCameraDlg *pThis = (CThermalCameraDlg *)dwUser;\n\tHWND hWnd = pThis->GetSafeHwnd();\n\tif (NULL == hWnd)\n\t{\n\t\treturn;\n\t}\n\tPostMessage(hWnd, WM_DEVICE_RECONNECT, NULL, NULL);\t\n}\n\n//Initialize net SDK\nvoid CThermalCameraDlg::InitNetSDK()\n{\n    //Initialize net sdk, All callback begins here.\n    BOOL bSuccess = CLIENT_Init(DisConnectFunc, (LDWORD)this);\n    if (!bSuccess)\n    {\n        //Display function error occurrs reason.\n//        LastError();\n    }\n\telse\n\t{\n\t\tCLIENT_SetAutoReconnect(ReConnectFunc, (LDWORD)this);\n\t}\n}\n\n\n//Process when device disconnected \nLRESULT CThermalCameraDlg::OnDisConnect(WPARAM wParam, LPARAM lParam)\n{\n    //The codes need to be processed when device disconnected\n\tSetWindowText(ConvertString(\"Network disconnected\"));\n\treturn 0;\n}\n\n//Process when device disconnected \nLRESULT CThermalCameraDlg::OnReConnect(WPARAM wParam, LPARAM lParam)\n{\n\t//The codes need to be processed when device reconnect\n\tSetWindowText(ConvertString(\"ThermalCamera\"));\n\treturn 0;\n}\n\n\n// The system calls this to obtain the cursor to display while the user drags\n//  the minimized window.\nHCURSOR CThermalCameraDlg::OnQueryDragIcon()\n{\n\treturn (HCURSOR) m_hIcon;\n}\n\n// void CThermalCameraDlg::OnControl() \n// {\n//     if (0 != m_LoginID)\n//     {\n//         CControl Dlg(this,m_LoginID);\n//         Dlg.DoModal();\n//     }\n// }\n\nvoid CThermalCameraDlg::OnAlarm() \n{\n\t\n\tCAlarmDlg dlg(this,m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CThermalCameraDlg::OnPresetinfo() \n{\n    CInfo Dlg(this, m_LoginID,m_nChannelCount-1);\n\tDlg.DoModal();\n}\n\nvoid CThermalCameraDlg::OnQuery() \n{\n    CQueryDlg Dlg(this,m_LoginID);\n\tDlg.DoModal();\n\t\n}\n\nvoid CThermalCameraDlg::OnPreperty() \n{\n\tCProperty Dlg(this,m_LoginID);\n\tDlg.DoModal();\n}\n\nvoid CThermalCameraDlg::OnGlobal() \n{\n\tCGlobalDlg Dlg(this,m_LoginID);\n\tDlg.DoModal();\n}\n\nvoid CThermalCameraDlg::OnStatistcis() \n{\n\tCStatistcisDlg Dlg(this,m_LoginID);\n\tDlg.DoModal();\n\t\n}\n\nvoid CThermalCameraDlg::OnBTNLogin() \n{\n    BOOL bValid = UpdateData(TRUE);\t//Get interface input \n    if(bValid)\n    {\n        int err = 0;\t//Storage the possible error return value.\n\t\tchar *pchDVRIP;\n        CString strDvrIP = GetDvrIP();\n        pchDVRIP = (LPSTR)(LPCSTR)strDvrIP;\n        WORD wDVRPort=(WORD)m_DvrPort;\n        char *pchUserName=(LPSTR)(LPCSTR)m_DvrUserName;\n        char *pchPassword=(LPSTR)(LPCSTR)m_DvrPassword;\n\t\tNET_DEVICEINFO deviceInfo = {0};\n        //Call log in interface \n        LLONG lRet = CLIENT_Login(pchDVRIP,wDVRPort,pchUserName,pchPassword,&deviceInfo,&err);\n        if(0 != lRet)\n        {\n            m_nChannelCount = min(deviceInfo.byChanNum, 2); // thermal camera max channel is two\n            m_LoginID = lRet;\n            GetDlgItem(IDC_BTN_Login)->EnableWindow(FALSE);\n            GetDlgItem(IDC_BTN_LEAVE)->EnableWindow(TRUE);\n\t\t\tGetDlgItem(IDC_BUTTON_Play)->EnableWindow(TRUE);\n            GetDlgItem(IDC_BUTTON_STOP)->EnableWindow(FALSE);\n        }\n        else\n        {\n            ShowLoginErrorReason(err);\n        }\n    }\n\tSetWindowText(ConvertString(\"ThermalCamera\"));\n}\nvoid g_SetWndStaticText(CWnd * pWnd)\n{\n    CString strCaption,strText;\n    \n    //Set main window title \n    pWnd->GetWindowText(strCaption);\n    if(strCaption.GetLength()>0)\n    {\n        strText=ConvertString(strCaption);\n        pWnd->SetWindowText(strText);\n    }\n    \n    //Set sub-window title \n    CWnd * pChild=pWnd->GetWindow(GW_CHILD);\n    CString strClassName;\n    while(pChild)\n    {\n        //////////////////////////////////////////////////////////////////////////\t\t\n        strClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n        if(strClassName == \"CEdit\")\n        {\n            //Nex sub-window \n            pChild=pChild->GetWindow(GW_HWNDNEXT);\n            continue;\n        }\n        \n        //////////////////////////////////////////////////////////////////////////\t\n        \n        //Set sub-window current language text\n        pChild->GetWindowText(strCaption);\n        strText=ConvertString(strCaption);\n        pChild->SetWindowText(strText);\n        \n        //Next sub-window \n        pChild=pChild->GetWindow(GW_HWNDNEXT);\n    }\n}\nCString ConvertString(CString strText, const char* pszSeg /* = NULL */)\n{\n    CString strIniPath, strRet;\n    char szVal[256] = {0};\n    \n    if (!pszSeg)\n    {\n        pszSeg = DLG_MAIN;\n    }\n    \n    GetPrivateProfileString(pszSeg, strText, \"\", szVal, sizeof(szVal), \"./langchn.ini\");\n    strRet = szVal;\n    if(strRet.GetLength()==0)\n    {\n        //If there is no corresponding string in ini file then set it to be default value(English).\n        strRet=strText;\n\t}\n    return strRet;\n}\n//Display log in failure reason \nvoid CThermalCameraDlg::ShowLoginErrorReason(int nError)\n{\n    if(1 == nError)\t\tMessageBox(ConvertString(\"Invalid password!\"), ConvertString(\"Prompt\"));\n    else if(2 == nError)\tMessageBox(ConvertString(\"Invalid account!\"), ConvertString(\"Prompt\"));\n    else if(3 == nError)\tMessageBox(ConvertString(\"Timeout!\"), ConvertString(\"Prompt\"));\n    else if(4 == nError)\tMessageBox(ConvertString(\"The user has logged in!\"), ConvertString(\"Prompt\"));\n    else if(5 == nError)\tMessageBox(ConvertString(\"The user has been locked!\"), ConvertString(\"Prompt\"));\n    else if(6 == nError)\tMessageBox(ConvertString(\"The user has listed into illegal!\"), ConvertString(\"Prompt\"));\n    else if(7 == nError)\tMessageBox(ConvertString(\"The system is busy!\"), ConvertString(\"Prompt\"));\n    else if(9 == nError)\tMessageBox(ConvertString(\"You Can't find the network server!\"), ConvertString(\"Prompt\"));\n    else\tMessageBox(ConvertString(\"Login failed!\"), ConvertString(\"Prompt\"));\n}\nCString CThermalCameraDlg::GetDvrIP()\n{\n    CString strRet=\"\";\n    BYTE nField0,nField1,nField2,nField3;\n    m_DvrIPAddr.GetAddress(nField0,nField1,nField2,nField3);\n    strRet.Format(\"%d.%d.%d.%d\",nField0,nField1,nField2,nField3);\n    return strRet;\n}\n\n\nvoid CThermalCameraDlg::OnBtnLeave() \n{\n    for (int i = 0; i<2; ++i)\n    {\n        CloseDispVideo(i);\n    }\n\tif (0 != m_LoginID)\n\t{\n        BOOL bSuccess = CLIENT_Logout(m_LoginID);\n        if (bSuccess)\n        {\n            m_LoginID = 0;\n            m_DispHanle[0] = 0;\n            m_DispHanle[1] = 0;\n            GetDlgItem(IDC_BTN_Login)->EnableWindow(TRUE);\n            GetDlgItem(IDC_BTN_LEAVE)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_BUTTON_Play)->EnableWindow(FALSE);\n            GetDlgItem(IDC_BUTTON_STOP)->EnableWindow(FALSE);\n            Invalidate();\n        }\n        else\n        {\n            MessageBox(ConvertString(\"Fail to Logout!\"), ConvertString(\"Prompt\"));\n\t\t}\n\t}\n    m_comboPlayMode.EnableWindow(TRUE);\n\tSetWindowText(ConvertString(\"ThermalCamera\"));\n}\n\n//Play video directly \nvoid CThermalCameraDlg::DirectPlayMode(int iDispNum,int iChannel,HWND hWnd)\n{\n    //Close current video \n    CloseDispVideo(iDispNum);\n    \n    LLONG lRet = CLIENT_RealPlay(m_LoginID,iChannel,hWnd);\n    if(0 != lRet)\n    {\n        m_DispHanle[iDispNum] = lRet;\n    }\n    else\n    {\n        MessageBox(ConvertString(\"Fail to play\"), ConvertString(\"Prompt\"));\n    }\n}\n\nvoid CALLBACK RealDataCallBackEx(LLONG lRealHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize, LLONG lParam, LDWORD dwUser)\n{\n\tif(dwUser == 0)\n\t{\n\t\treturn;\n\t}\n\n\tCThermalCameraDlg *dlg = (CThermalCameraDlg *)dwUser;\n\tdlg->ReceiveRealData(lRealHandle,dwDataType, pBuffer, dwBufSize, lParam);\n}\n\n\n//Play video in data callback mode \nvoid CThermalCameraDlg::ServerPlayMode(int iDispNum,int iChannel, HWND hWnd)\n{\n    //Close current video \n    CloseDispVideo(iDispNum);\n    \n    //Enable stream\n    BOOL bOpenRet = PLAY_OpenStream(iDispNum,0,0,1024*512*6);\n    if(bOpenRet)\n    {\n        //Begin play \n        BOOL bPlayRet = PLAY_Play(iDispNum,hWnd);\n        if(bPlayRet)\n        {\n            //Real-time play \n            LLONG lRet = CLIENT_RealPlayEx(m_LoginID,iChannel,0);\n            if(0 != lRet)\n            {\n                m_DispHanle[iDispNum] =lRet;\n                //Callback monitor data and then save \n                CLIENT_SetRealDataCallBackEx2(lRet, RealDataCallBackEx, (LDWORD)this, 0x0f);\n            }\n            else\n            {\n                MessageBox(ConvertString(\"Fail to play\"), ConvertString(\"Prompt\"));\n                PLAY_Stop(iDispNum);\n                PLAY_CloseStream(iDispNum);\n            }\n        }\n        else\n        {\n            PLAY_CloseStream(iDispNum);\n        }\n    }\n    else\n    {\n        TRACE(\"PLAY_OpenStream failed, error: %d\\n\", PLAY_GetLastError(1));\n    }\n}\n\n//Close video \nvoid CThermalCameraDlg::CloseDispVideo(int iDispNum)\n{\n    //Close current video \n    int ePlayMode = m_comboPlayMode.GetCurSel();\n    if(ePlayMode == DirectMode)\n    {\n        if(0 != m_DispHanle[iDispNum])\n        {\n            BOOL bRet = CLIENT_StopRealPlay(m_DispHanle[iDispNum]);\n            m_DispHanle[iDispNum] = 0;\n    \t}\n    }\n    else if(ePlayMode == ServerMode)\n    {\n        if(0 != m_DispHanle[iDispNum])\n        {\n            BOOL bRealPlay = CLIENT_StopRealPlay(m_DispHanle[iDispNum]);\n            if(bRealPlay)\n            {\n                //And then close PLAY_Play\n                BOOL bPlay = PLAY_Stop(iDispNum);\n                if(bPlay)\n                {\n                    //At last close PLAY_OpenStream\n                    BOOL bStream = PLAY_CloseStream(iDispNum);\n\t\t\t\t\tm_DispHanle[iDispNum] = 0;\n                }\n            }\n    \t}\n    }\n}\n\n\n//Process after receiving real-time data \nvoid CThermalCameraDlg::ReceiveRealData(LLONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, LLONG lParam)\n{\n\tint nPort = 0;\n\tfor (int i=0; i<m_nChannelCount; i++)\n\t{\n\t\tif (m_DispHanle[i] == lRealHandle)\n\t\t{\n\t\t\tnPort = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    BOOL bInput=FALSE;\n    if(0 != lRealHandle)\n    {\n        switch(dwDataType) \n        {\n        case 0:\n            //Original data \n            bInput = PLAY_InputData(nPort,pBuffer,dwBufSize);\n            if (!bInput)\n            {\n                TRACE(\"input data error: %d\\n\", PLAY_GetLastError(nPort));\n            }\n            break;\n        case 1:\n            //Standard video data \n            \n            break;\n        case 2:\n            //yuv data \n            \n            break;\n        case 3:\n            //pcm audio data \n            \n            break;       \n        default:\n            break;\n        }\t\n    }\n}\n\nvoid CThermalCameraDlg::OnBUTTONPlay() \n{\n    for (int i = 0;i < m_nChannelCount;i++)\n    {\n        HWND hWnd = NULL;\n\t\tint nPort = 0;\n        int iDispNum = i;\n\t    int ePlayMode = m_comboPlayMode.GetCurSel();\n        m_nChannelNum = i;                              \n        if (0 == i)\n        {\n            hWnd = GetDlgItem(IDC_REALPALY)->m_hWnd;\n\t\t\tnPort = 1;\n        }\n        else if(1 == i)\n        {\n            hWnd = GetDlgItem(IDC_HEATPALY)->m_hWnd;\n\t\t\tnPort = 2;\n        }\n        if (-1 != ePlayMode)\n        {\n            if(ePlayMode == DirectMode)\n            {\n                //Play directly \n                DirectPlayMode(iDispNum,m_nChannelNum,hWnd);\n            }\n            if(ePlayMode == ServerMode)\n            {\n                //Play in data callback mode \n                ServerPlayMode(iDispNum,m_nChannelNum,hWnd);\n\t        }\n        }\n    }\n    m_comboPlayMode.EnableWindow(FALSE);\n    m_BtnPlay.EnableWindow(FALSE);\n    m_BtnStop.EnableWindow(TRUE);\n}\n\nvoid CThermalCameraDlg::OnButtonStop() \n{\n    for (int i = 0;i<m_nChannelCount;++i)\n    {\n        CloseDispVideo(i);\n        //Refresh page \n    }\n    Invalidate();\n    m_comboPlayMode.EnableWindow(TRUE);\n    m_BtnPlay.EnableWindow(TRUE);\n    m_BtnStop.EnableWindow(FALSE);\n}\n\n\nvoid CThermalCameraDlg::OnPointinfo() \n{\n\tCQueryPointInfoDlg Dlg(this,m_LoginID,m_nChannelCount-1);\n    Dlg.DoModal();\n}\n\nvoid CThermalCameraDlg::OnIteminfo() \n{\n\tCQueryItemInfoDlg Dlg(this,m_LoginID,m_nChannelCount-1);\n    Dlg.DoModal();\n}\n\nvoid CThermalCameraDlg::OnRule() \n{\n    CRuleDlg Dlg(this,m_LoginID,m_nChannelCount -1);\n \tDlg.DoModal();\n}\n\n\nvoid CThermalCameraDlg::OnBtnPtzmenu() \n{\n    DWORD bytesReturned = 0;\n    DH_ALARMIN_CFG_EX tmpIPCAlarmCfg;\n    memset(&tmpIPCAlarmCfg, 0 ,sizeof(DH_ALARMIN_CFG_EX));\n    BOOL bResult = CLIENT_GetDevConfig(m_LoginID, DH_DEV_LOCALALARM_CFG, 0, &tmpIPCAlarmCfg, sizeof(DH_ALARMIN_CFG_EX), &bytesReturned, 1000);\n\n}\n\nvoid CThermalCameraDlg::OnHeatmap() \n{\n\tCHeatmap Dlg(this,m_LoginID,m_nChannelCount-1);\n    Dlg.DoModal();\n}\n\nvoid CThermalCameraDlg::OnDestroy() \n{\n\tCDialog::OnDestroy();\n\t\n\tfor (int i = 0;i < m_nChannelCount; ++i)\n\t{\n\t\tCloseDispVideo(i);\t\t\n\t}\n\n\tif (m_LoginID != 0)\n\t{\n\t\tCLIENT_Logout(m_LoginID);\n\t}\n\t\n\tCLIENT_Cleanup();\t\n}\n\nvoid CThermalCameraDlg::OnOK() \n{\n\t// TODO: Add extra validation here\n\t\n//\tCDialog::OnOK();\n}\n\n\nBOOL CThermalCameraDlg::PreTranslateMessage(MSG* pMsg) \n{\n\t// TODO: Add your specialized code here and/or call the base class\n\tif (pMsg->message == WM_KEYDOWN || pMsg->message == WM_KEYUP)\n\t{\n\t\tif (VK_ESCAPE == pMsg->wParam || VK_RETURN == pMsg->wParam)\n\t\t{\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn CDialog::PreTranslateMessage(pMsg);\n}","size_bytes":18496},"bin/Demo/MfcDemo/09.AccessControl/DlgRecordSetControl.cpp":{"content":"// DlgRecordSetControl.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"accesscontrol.h\"\n#include \"DlgRecordSetControl.h\"\n#include \"SubDlgInfoCard.h\"\n#include \"DlgSubDlgInfoPassword.h\"\n#include \"DlgSubDlgInfoAccessRecord.h\"\n#include \"DlgSubDlgInfoHoliday.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgRecordSetControl dialog\n\n\nCDlgRecordSetControl::CDlgRecordSetControl(CWnd* pParent /* = NULL */, LLONG lLoginID /* = 0 */, int nAccess /* = 1 */)\n\t: CDialog(CDlgRecordSetControl::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgRecordSetControl)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_lLoginID      = lLoginID;\n    m_nAccessGroup  = nAccess;\n\tm_emOpType = Em_Operate_Type_Show;\n}\n\n\nvoid CDlgRecordSetControl::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgRecordSetControl)\n\tDDX_Control(pDX, IDD_RECORDSET_CTL_CMB_SETTYPE, m_cmbSetType);\n\tDDX_Control(pDX, IDD_RECORDSET_CTL_CMB_CTLTYPE, m_cmbCtlType);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgRecordSetControl, CDialog)\n\t//{{AFX_MSG_MAP(CDlgRecordSetControl)\n\tON_BN_CLICKED(IDD_RECORDSET_CTL_BTN_EXECUTE, OnRecordsetCtlBtnExecute)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgRecordSetControl private method\n\nvoid CDlgRecordSetControl::InitDlg()\n{\n\tint n = 0;\n\n\tm_cmbSetType.ResetContent();\n    int nWidth = m_cmbSetType.GetDroppedWidth();\n    m_cmbSetType.SetDroppedWidth(nWidth * 2);\n\tfor (n = 0; n < sizeof(stuDemoRecordSetType)/sizeof(stuDemoRecordSetType[0]); n++)\n\t{\n\t\tm_cmbSetType.InsertString(-1, ConvertString(stuDemoRecordSetType[n].szName));\n\t}\n\tm_cmbSetType.SetCurSel(0);\n\t\n\tm_cmbCtlType.ResetContent();\n\tfor (n = 0; n < sizeof(stuDemoRecordSetCtlType)/sizeof(stuDemoRecordSetCtlType[0]); n++)\n\t{\n\t\tm_cmbCtlType.InsertString(-1, ConvertString(stuDemoRecordSetCtlType[n].szName, DLG_RECORDSET_CONTROL));\n\t}\n\tm_cmbCtlType.SetCurSel(0);\n}\n//////////////////////////////////////////////////////////////////////////\n// card\n//////////////////////////////////////////////////////////////////////////\nvoid CDlgRecordSetControl::CardInsert()\n{\n\tCSubDlgInfoCard dlg(this, NULL, m_nAccessGroup);\n\tdlg.SetOperateType(m_emOpType);\n\tif (IDOK == dlg.DoModal())\n\t{\n\t\tif (!dlg.IsDirty())\n\t\t{\n\t\t\tconst NET_RECORDSET_ACCESS_CTL_CARD& stuInfo = dlg.GetInfo();\n\t\t\t\n\t\t\tNET_CTRL_RECORDSET_INSERT_PARAM stuParam = {sizeof(stuParam)};\n\t\t\tstuParam.stuCtrlRecordSetInfo.dwSize = sizeof(NET_CTRL_RECORDSET_INSERT_IN);\n\t\t\tstuParam.stuCtrlRecordSetInfo.emType = NET_RECORD_ACCESSCTLCARD;\n\t\t\tstuParam.stuCtrlRecordSetInfo.pBuf = (void*)&stuInfo;\n\t\t\tstuParam.stuCtrlRecordSetInfo.nBufLen = sizeof(stuInfo);\n\t\t\t\n\t\t\tstuParam.stuCtrlRecordSetResult.dwSize = sizeof(NET_CTRL_RECORDSET_INSERT_OUT);\n\t\t\t\n\t\t\tBOOL bRet = FALSE;\n\t\t\tif (m_emOpType == Em_Operate_Type_Insert)\n\t\t\t{\n\t\t\t\tbRet = CLIENT_ControlDevice(m_lLoginID, DH_CTRL_RECORDSET_INSERT, &stuParam, SDK_API_WAITTIME);\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tbRet = CLIENT_ControlDevice(m_lLoginID, DH_CTRL_RECORDSET_INSERTEX, &stuParam, SDK_API_WAITTIME);\n\t\t\t}\n\t\t\t\n\t\t\tif (bRet)\n\t\t\t{\n\t\t\t\tCString csInfo;\n\t\t\t\tcsInfo.Format(\"%s:%d\", ConvertString(\"Insert card ok with RecNo\", DLG_RECORDSET_CONTROL), stuParam.stuCtrlRecordSetResult.nRecNo);\n\t\t\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCString csInfo;\n\t\t\t\tcsInfo.Format(\"%s:0x%08x\", ConvertString(\"Insert card failed\", DLG_RECORDSET_CONTROL), CLIENT_GetLastError());\n\t\t\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid CDlgRecordSetControl::CardGet()\n{\n\tCSubDlgInfoCard dlg(this, NULL, m_nAccessGroup);\n\tdlg.SetOperateType(Em_Operate_Type_Get);\n\tif (IDOK == dlg.DoModal())\n\t{\n\t\t// get info by RecNo\n\t\tconst NET_RECORDSET_ACCESS_CTL_CARD& stuInfo = dlg.GetInfo();\n\n\t\tNET_CTRL_RECORDSET_PARAM stuParam = {sizeof(stuParam)};\n\t\tstuParam.emType = NET_RECORD_ACCESSCTLCARD;\n\n\t\tNET_RECORDSET_ACCESS_CTL_CARD stuCard = {sizeof(stuCard)};\n\t\tstuCard.nRecNo = stuInfo.nRecNo;\n\t\tstuParam.pBuf = &stuCard;\n\t\t\n\t\tint nRet = 0;\n\t\tBOOL bRet = CLIENT_QueryDevState(m_lLoginID, DH_DEVSTATE_DEV_RECORDSET, (char*)&stuParam, \n\t\t\tsizeof(stuParam), &nRet, SDK_API_WAITTIME);\n\t\tif (bRet)\n\t\t{\n\t\t\tdlg.SetInfo(&stuCard);\n\t\t\tdlg.SetOperateType(Em_Operate_Type_Show);\n\t\t\tdlg.DoModal();\n\t\t} \n\t\telse\n\t\t{\n\t\t\tCString csInfo;\n\t\t\tcsInfo.Format(\"%s:0x%08x\", ConvertString(\"Get card failed\", DLG_RECORDSET_CONTROL), CLIENT_GetLastError());\n\t\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\t}\n\t}\n}\n\nvoid CDlgRecordSetControl::CardUpdate()\n{\n\tCSubDlgInfoCard dlg(this, NULL, m_nAccessGroup);\n\tdlg.SetOperateType(Em_Operate_Type_Get);\n\tif (IDOK == dlg.DoModal())\n\t{\n\t\tif (!dlg.IsDirty())\n\t\t{\n\t\t\t// get full info by RecNo before update it\n\t\t\tNET_RECORDSET_ACCESS_CTL_CARD stuInfo = dlg.GetInfo();\n\t\t\t\n\t\t\tNET_CTRL_RECORDSET_PARAM stuParam = {sizeof(stuParam)};\n\t\t\tstuParam.emType = NET_RECORD_ACCESSCTLCARD;\n\t\t\tstuParam.pBuf = (void*)&stuInfo;\n\t\t\tstuParam.nBufLen = sizeof(stuInfo);\n\t\t\t\n\t\t\tint nRet = 0;\n\t\t\tBOOL bRet = CLIENT_QueryDevState(m_lLoginID, DH_DEVSTATE_DEV_RECORDSET, (char*)&stuParam,\n\t\t\t\tsizeof(stuParam), &nRet, SDK_API_WAITTIME);\n\t\t\tif (bRet)\n\t\t\t{\n\t\t\t\tdlg.SetInfo(&stuInfo);\n\t\t\t\tdlg.SetOperateType(m_emOpType);\n\t\t\t\tif (IDOK == dlg.DoModal())\n\t\t\t\t{\n\t\t\t\t\tstuInfo = dlg.GetInfo();\n\t\t\t\t\t\n\t\t\t\t\tstuParam.emType = NET_RECORD_ACCESSCTLCARD;\n\t\t\t\t\tstuParam.pBuf = (void*)&stuInfo;\n\t\t\t\t\tstuParam.nBufLen = sizeof(stuInfo);\n\t\t\t\t\t\n\t\t\t\t\t// update info\n\t\t\t\t\tBOOL bRet = FALSE;\n\t\t\t\t\tif (m_emOpType == Em_Operate_Type_Update)\n\t\t\t\t\t{\n\t\t\t\t\t\tbRet = CLIENT_ControlDevice(m_lLoginID, DH_CTRL_RECORDSET_UPDATE, &stuParam, SDK_API_WAITTIME);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbRet = CLIENT_ControlDevice(m_lLoginID, DH_CTRL_RECORDSET_UPDATEEX, &stuParam, SDK_API_WAITTIME);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (bRet)\n\t\t\t\t\t{\n\t\t\t\t\t\tMessageBox(ConvertString(\"Update card ok\", DLG_RECORDSET_CONTROL), ConvertString(\"Prompt\"));\n\t\t\t\t\t} \n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tCString csInfo;\n\t\t\t\t\t\tcsInfo.Format(\"%s:0x%08x\", ConvertString(\"Update card failed\", DLG_RECORDSET_CONTROL), CLIENT_GetLastError());\n\t\t\t\t\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} \n\t\t\telse\n\t\t\t{\n\t\t\t\tCString csInfo;\n\t\t\t\tcsInfo.Format(\"%s:0x%08x\", ConvertString(\"Get card failed\", DLG_RECORDSET_CONTROL), CLIENT_GetLastError());\n\t\t\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid CDlgRecordSetControl::CardRemove()\n{\n\tCSubDlgInfoCard dlg(this, NULL, m_nAccessGroup);\n\tdlg.SetOperateType(Em_Operate_Type_Remove);\n\tif (IDOK == dlg.DoModal())\n\t{\n\t\tconst NET_RECORDSET_ACCESS_CTL_CARD& stuInfo = dlg.GetInfo();\n\t\t\n\t\tNET_CTRL_RECORDSET_PARAM stuParam = {sizeof(stuParam)};\n\t\tstuParam.emType = NET_RECORD_ACCESSCTLCARD;\n\t\tstuParam.pBuf = (void*)&stuInfo.nRecNo;\n\t\tstuParam.nBufLen = sizeof(stuInfo.nRecNo);\n\n\t\tBOOL bRet = CLIENT_ControlDevice(m_lLoginID, DH_CTRL_RECORDSET_REMOVE, &stuParam, SDK_API_WAITTIME);\n\t\tif (bRet)\n\t\t{\n\t\t\tMessageBox(ConvertString(\"Remove card ok\", DLG_RECORDSET_CONTROL), ConvertString(\"Prompt\"));\n\t\t} \n\t\telse\n\t\t{\n\t\t\tCString csInfo;\n\t\t\tcsInfo.Format(\"%s:0x%08x\", ConvertString(\"Remove card failed\", DLG_RECORDSET_CONTROL), CLIENT_GetLastError());\n\t\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\t}\n\t}\n}\n\nvoid CDlgRecordSetControl::CardClear()\n{\t\n\tNET_CTRL_RECORDSET_PARAM stuParam = {sizeof(stuParam)};\n\tstuParam.emType = NET_RECORD_ACCESSCTLCARD;\n    BOOL bRet = CLIENT_ControlDevice(m_lLoginID, DH_CTRL_RECORDSET_CLEAR, &stuParam, SDK_API_WAITTIME);\n\tif (bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Clear card ok\", DLG_RECORDSET_CONTROL), ConvertString(\"Prompt\"));\n\t} \n\telse\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%s:0x%08x\", ConvertString(\"Clear card failed\", DLG_RECORDSET_CONTROL), CLIENT_GetLastError());\n\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t}\n}\n//////////////////////////////////////////////////////////////////////////\n// password\n//////////////////////////////////////////////////////////////////////////\nvoid CDlgRecordSetControl::PwdInsert()\n{\n\tCDlgSubDlgInfoPassword dlg(this, NULL, m_nAccessGroup);\n\tdlg.SetOperateType(Em_Operate_Type_Insert);\n\tif (IDOK == dlg.DoModal())\n\t{\n\t\tconst NET_RECORDSET_ACCESS_CTL_PWD& stuInfo = dlg.GetInfo();\n\t\t\n\t\tNET_CTRL_RECORDSET_INSERT_PARAM stuParam = {sizeof(stuParam)};\n\t\tstuParam.stuCtrlRecordSetInfo.dwSize = sizeof(NET_CTRL_RECORDSET_INSERT_IN);\n\t\tstuParam.stuCtrlRecordSetInfo.emType = NET_RECORD_ACCESSCTLPWD;\n\t\tstuParam.stuCtrlRecordSetInfo.pBuf = (void*)&stuInfo;\n\t\tstuParam.stuCtrlRecordSetInfo.nBufLen = sizeof(stuInfo);\n\t\t\n\t\tstuParam.stuCtrlRecordSetResult.dwSize = sizeof(NET_CTRL_RECORDSET_INSERT_OUT);\n\t\t\n\t\tBOOL bRet = CLIENT_ControlDevice(m_lLoginID, DH_CTRL_RECORDSET_INSERT, &stuParam, SDK_API_WAITTIME);\n\t\tif (bRet)\n\t\t{\n\t\t\tCString csInfo;\n\t\t\tcsInfo.Format(\"%s:%d\", ConvertString(\"Insert pwd ok with RecNo\", DLG_RECORDSET_CONTROL), stuParam.stuCtrlRecordSetResult.nRecNo);\n\t\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCString csInfo;\n\t\t\tcsInfo.Format(\"%s:0x%08x\", ConvertString(\"Insert pwd failed\", DLG_RECORDSET_CONTROL), CLIENT_GetLastError());\n\t\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\t}\n\t}\n}\n\nvoid CDlgRecordSetControl::PwdGet()\n{\n\tCDlgSubDlgInfoPassword dlg(this, NULL, m_nAccessGroup);\n\tdlg.SetOperateType(Em_Operate_Type_Get);\n\tif (IDOK == dlg.DoModal())\n\t{\n\t\t// get info by RecNo\n\t\tconst NET_RECORDSET_ACCESS_CTL_PWD& stuInfo = dlg.GetInfo();\n\t\t\n\t\tNET_CTRL_RECORDSET_PARAM stuParam = {sizeof(stuParam)};\n\t\tstuParam.emType = NET_RECORD_ACCESSCTLPWD;\n\t\t\n\t\tNET_RECORDSET_ACCESS_CTL_PWD stuPwd = {sizeof(stuPwd)};\n\t\tstuPwd.nRecNo = stuInfo.nRecNo;\n\t\tstuParam.pBuf = &stuPwd;\n\t\t\n\t\tint nRet = 0;\n\t\tBOOL bRet = CLIENT_QueryDevState(m_lLoginID, DH_DEVSTATE_DEV_RECORDSET, (char*)&stuParam, \n\t\t\tsizeof(stuParam), &nRet, SDK_API_WAITTIME);\n\t\tif (bRet)\n\t\t{\n\t\t\tdlg.SetInfo(&stuPwd);\n\t\t\tdlg.SetOperateType(Em_Operate_Type_Show);\n\t\t\tdlg.DoModal();\n\t\t} \n\t\telse\n\t\t{\n\t\t\tCString csInfo;\n\t\t\tcsInfo.Format(\"%s:0x%08x\", ConvertString(\"Get pwd failed\", DLG_RECORDSET_CONTROL), CLIENT_GetLastError());\n\t\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\t}\n\t}\n}\n\nvoid CDlgRecordSetControl::PwdUpdate()\n{\n\tCDlgSubDlgInfoPassword dlg(this, NULL, m_nAccessGroup);\n\tdlg.SetOperateType(Em_Operate_Type_Get);\n\tif (IDOK == dlg.DoModal())\n\t{\n\t\t// get full info by RecNo before update it\n\t\tNET_RECORDSET_ACCESS_CTL_PWD stuInfo = dlg.GetInfo();\n\t\t\n\t\tNET_CTRL_RECORDSET_PARAM stuParam = {sizeof(stuParam)};\n\t\tstuParam.emType = NET_RECORD_ACCESSCTLPWD;\n\t\tstuParam.pBuf = (void*)&stuInfo;\n\t\tstuParam.nBufLen = sizeof(stuInfo);\n\t\t\n\t\tint nRet = 0;\n\t\tBOOL bRet = CLIENT_QueryDevState(m_lLoginID, DH_DEVSTATE_DEV_RECORDSET, (char*)&stuParam,\n\t\t\tsizeof(stuParam), &nRet, SDK_API_WAITTIME);\n\t\tif (bRet)\n\t\t{\n\t\t\tdlg.SetInfo(&stuInfo);\n\t\t\tdlg.SetOperateType(Em_Operate_Type_Update);\n\t\t\tif (IDOK == dlg.DoModal())\n\t\t\t{\n\t\t\t\tstuInfo = dlg.GetInfo();\n\t\t\t\t\n\t\t\t\tstuParam.emType = NET_RECORD_ACCESSCTLPWD;\n\t\t\t\tstuParam.pBuf = (void*)&stuInfo;\n\t\t\t\tstuParam.nBufLen = sizeof(stuInfo);\n\t\t\t\t\n\t\t\t\t// update info\n\t\t\t\tBOOL bRet = CLIENT_ControlDevice(m_lLoginID, DH_CTRL_RECORDSET_UPDATE, &stuParam, SDK_API_WAITTIME);\n\t\t\t\tif (bRet)\n\t\t\t\t{\n\t\t\t\t\tMessageBox(ConvertString(\"Update pwd ok\", DLG_RECORDSET_CONTROL), ConvertString(\"Prompt\"));\n\t\t\t\t} \n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tCString csInfo;\n\t\t\t\t\tcsInfo.Format(\"%s:0x%08x\", ConvertString(\"Update pwd failed\", DLG_RECORDSET_CONTROL), CLIENT_GetLastError());\n\t\t\t\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t\telse\n\t\t{\n\t\t\tCString csInfo;\n\t\t\tcsInfo.Format(\"%s:0x%08x\", ConvertString(\"Get pwd failed\", DLG_RECORDSET_CONTROL), CLIENT_GetLastError());\n\t\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\t}\n\t}\n}\n\nvoid CDlgRecordSetControl::PwdRemove()\n{\n\tCDlgSubDlgInfoPassword dlg(this, NULL, m_nAccessGroup);\n\tdlg.SetOperateType(Em_Operate_Type_Remove);\n\tif (IDOK == dlg.DoModal())\n\t{\n\t\tconst NET_RECORDSET_ACCESS_CTL_PWD& stuInfo = dlg.GetInfo();\n\t\t\n\t\tNET_CTRL_RECORDSET_PARAM stuParam = {sizeof(stuParam)};\n\t\tstuParam.emType = NET_RECORD_ACCESSCTLPWD;\n\t\tstuParam.pBuf = (void*)&stuInfo.nRecNo;\n\t\tstuParam.nBufLen = sizeof(stuInfo.nRecNo);\n\t\t\n\t\tBOOL bRet = CLIENT_ControlDevice(m_lLoginID, DH_CTRL_RECORDSET_REMOVE, &stuParam, SDK_API_WAITTIME);\n\t\tif (bRet)\n\t\t{\n\t\t\tMessageBox(ConvertString(\"Remove pwd ok\", DLG_RECORDSET_CONTROL), ConvertString(\"Prompt\"));\n\t\t} \n\t\telse\n\t\t{\n\t\t\tCString csInfo;\n\t\t\tcsInfo.Format(\"%s:0x%08x\", ConvertString(\"Remove pwd failed\", DLG_RECORDSET_CONTROL), CLIENT_GetLastError());\n\t\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\t}\n\t}\n}\n\nvoid CDlgRecordSetControl::PwdClear()\n{\n\tNET_CTRL_RECORDSET_PARAM stuParam = {sizeof(stuParam)};\n\tstuParam.emType = NET_RECORD_ACCESSCTLPWD;\n    BOOL bRet = CLIENT_ControlDevice(m_lLoginID, DH_CTRL_RECORDSET_CLEAR, &stuParam, SDK_API_WAITTIME);\n\tif (bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Clear pwd ok\", DLG_RECORDSET_CONTROL), ConvertString(\"Prompt\"));\n\t} \n\telse\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%s:0x%08x\", ConvertString(\"Clear pwd failed\", DLG_RECORDSET_CONTROL), CLIENT_GetLastError());\n\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t}\n}\n//////////////////////////////////////////////////////////////////////////\n// access\n//////////////////////////////////////////////////////////////////////////\nvoid CDlgRecordSetControl::AccessInsert()\n{\n\tMessageBox(ConvertString(\"Not supported by device\", DLG_RECORDSET_CONTROL),\tConvertString(\"Prompt\"));\n}\n\nvoid CDlgRecordSetControl::AccessGet()\n{\n\tCDlgSubDlgInfoAccessRecord dlg(this, NULL);\n\tdlg.SetOperateType(Em_Operate_Type_Get);\n\tif (IDOK == dlg.DoModal())\n\t{\n\t\t// get info by RecNo\n\t\tconst NET_RECORDSET_ACCESS_CTL_CARDREC& stuInfo = dlg.GetInfo();\n\t\t\n\t\tNET_CTRL_RECORDSET_PARAM stuParam = {sizeof(stuParam)};\n\t\tstuParam.emType = NET_RECORD_ACCESSCTLCARDREC;\n\t\t\n\t\tNET_RECORDSET_ACCESS_CTL_CARDREC stuCardRec = {sizeof(stuCardRec)};\n\t\tstuCardRec.nRecNo = stuInfo.nRecNo;\n\t\tstuParam.pBuf = &stuCardRec;\n\t\t\n\t\tint nRet = 0;\n\t\tBOOL bRet = CLIENT_QueryDevState(m_lLoginID, DH_DEVSTATE_DEV_RECORDSET, (char*)&stuParam, \n\t\t\tsizeof(stuParam), &nRet, SDK_API_WAITTIME);\n\t\tif (bRet)\n\t\t{\n\t\t\tdlg.SetInfo(&stuCardRec);\n\t\t\tdlg.SetOperateType(Em_Operate_Type_Show);\n\t\t\tdlg.DoModal();\n\t\t} \n\t\telse\n\t\t{\n\t\t\tCString csInfo;\n\t\t\tcsInfo.Format(\"%s:0x%08x\", ConvertString(\"Get card access record failed\", DLG_RECORDSET_CONTROL), CLIENT_GetLastError());\n\t\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\t}\n\t}\n}\n\nvoid CDlgRecordSetControl::AccessUpdate()\n{\t\n\tMessageBox(ConvertString(\"Not supported by device\", DLG_RECORDSET_CONTROL),\tConvertString(\"Prompt\"));\n}\n\nvoid CDlgRecordSetControl::AccessRemove()\n{\n\tMessageBox(ConvertString(\"Not supported by device\", DLG_RECORDSET_CONTROL),\tConvertString(\"Prompt\"));\n}\n\nvoid CDlgRecordSetControl::AccessClear()\n{\n\tMessageBox(ConvertString(\"Not supported by device\", DLG_RECORDSET_CONTROL),\tConvertString(\"Prompt\"));\n}\n//////////////////////////////////////////////////////////////////////////\n// holiday\n//////////////////////////////////////////////////////////////////////////\nvoid CDlgRecordSetControl::HolidayInsert()\n{\n\tCDlgSubDlgInfoHoliday dlg(this, NULL, m_nAccessGroup);\n\tdlg.SetOperateType(Em_Operate_Type_Insert);\n\tif (IDOK == dlg.DoModal())\n\t{\n\t\tconst NET_RECORDSET_HOLIDAY& stuInfo = dlg.GetInfo();\n\t\t\n\t\tNET_CTRL_RECORDSET_INSERT_PARAM stuParam = {sizeof(stuParam)};\n\t\tstuParam.stuCtrlRecordSetInfo.dwSize = sizeof(NET_CTRL_RECORDSET_INSERT_IN);\n\t\tstuParam.stuCtrlRecordSetInfo.emType = NET_RECORD_ACCESSCTLHOLIDAY;\n\t\tstuParam.stuCtrlRecordSetInfo.pBuf = (void*)&stuInfo;\n\t\tstuParam.stuCtrlRecordSetInfo.nBufLen = sizeof(stuInfo);\n\t\t\n\t\tstuParam.stuCtrlRecordSetResult.dwSize = sizeof(NET_CTRL_RECORDSET_INSERT_OUT);\n\t\t\n\t\tBOOL bRet = CLIENT_ControlDevice(m_lLoginID, DH_CTRL_RECORDSET_INSERT, &stuParam, SDK_API_WAITTIME);\n\t\tif (bRet)\n\t\t{\n\t\t\tCString csInfo;\n\t\t\tcsInfo.Format(\"%s:%d\", ConvertString(\"Insert holiday ok with RecNo\", DLG_RECORDSET_CONTROL), stuParam.stuCtrlRecordSetResult.nRecNo);\n\t\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCString csInfo;\n\t\t\tcsInfo.Format(\"%s:0x%08x\", ConvertString(\"Insert holiday failed\", DLG_RECORDSET_CONTROL), CLIENT_GetLastError());\n\t\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\t}\n\t}\n}\n\nvoid CDlgRecordSetControl::HolidayGet()\n{\n\tCDlgSubDlgInfoHoliday dlg(this, NULL, m_nAccessGroup);\n\tdlg.SetOperateType(Em_Operate_Type_Get);\n\tif (IDOK == dlg.DoModal())\n\t{\n\t\t// get info by RecNo\n\t\tconst NET_RECORDSET_HOLIDAY& stuInfo = dlg.GetInfo();\n\t\t\n\t\tNET_CTRL_RECORDSET_PARAM stuParam = {sizeof(stuParam)};\n\t\tstuParam.emType = NET_RECORD_ACCESSCTLHOLIDAY;\n\t\t\n\t\tNET_RECORDSET_HOLIDAY stuHoliday = {sizeof(stuHoliday)};\n\t\tstuHoliday.nRecNo = stuInfo.nRecNo;\n\t\tstuParam.pBuf = &stuHoliday;\n\t\t\n\t\tint nRet = 0;\n\t\tBOOL bRet = CLIENT_QueryDevState(m_lLoginID, DH_DEVSTATE_DEV_RECORDSET, (char*)&stuParam, \n\t\t\tsizeof(stuParam), &nRet, SDK_API_WAITTIME);\n\t\tif (bRet)\n\t\t{\n\t\t\tdlg.SetInfo(&stuHoliday);\n\t\t\tdlg.SetOperateType(Em_Operate_Type_Show);\n\t\t\tdlg.DoModal();\n\t\t} \n\t\telse\n\t\t{\n\t\t\tCString csInfo;\n\t\t\tcsInfo.Format(\"%s:0x%08x\", ConvertString(\"Get holiday failed\", DLG_RECORDSET_CONTROL), CLIENT_GetLastError());\n\t\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\t}\n\t}\n}\n\nvoid CDlgRecordSetControl::HolidayUpdate()\n{\n\tCDlgSubDlgInfoHoliday dlg(this, NULL, m_nAccessGroup);\n\tdlg.SetOperateType(Em_Operate_Type_Get);\n\tif (IDOK == dlg.DoModal())\n\t{\n\t\t// get full info by RecNo before update it\n\t\tNET_RECORDSET_HOLIDAY stuInfo = dlg.GetInfo();\n\t\t\n\t\tNET_CTRL_RECORDSET_PARAM stuParam = {sizeof(stuParam)};\n\t\tstuParam.emType = NET_RECORD_ACCESSCTLHOLIDAY;\n\t\tstuParam.pBuf = (void*)&stuInfo;\n\t\tstuParam.nBufLen = sizeof(stuInfo);\n\t\t\n\t\tint nRet = 0;\n\t\tBOOL bRet = CLIENT_QueryDevState(m_lLoginID, DH_DEVSTATE_DEV_RECORDSET, (char*)&stuParam,\n\t\t\tsizeof(stuParam), &nRet, SDK_API_WAITTIME);\n\t\tif (bRet)\n\t\t{\n\t\t\tdlg.SetInfo(&stuInfo);\n\t\t\tdlg.SetOperateType(Em_Operate_Type_Update);\n\t\t\tif (IDOK == dlg.DoModal())\n\t\t\t{\n\t\t\t\tstuInfo = dlg.GetInfo();\n\t\t\t\t\n\t\t\t\tstuParam.emType = NET_RECORD_ACCESSCTLHOLIDAY;\n\t\t\t\tstuParam.pBuf = (void*)&stuInfo;\n\t\t\t\tstuParam.nBufLen = sizeof(stuInfo);\n\t\t\t\t\n\t\t\t\t// update info\n\t\t\t\tBOOL bRet = CLIENT_ControlDevice(m_lLoginID, DH_CTRL_RECORDSET_UPDATE, &stuParam, SDK_API_WAITTIME);\n\t\t\t\tif (bRet)\n\t\t\t\t{\n\t\t\t\t\tMessageBox(ConvertString(\"Update holiday ok\", DLG_RECORDSET_CONTROL), ConvertString(\"Prompt\"));\n\t\t\t\t} \n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tCString csInfo;\n\t\t\t\t\tcsInfo.Format(\"%s:0x%08x\", ConvertString(\"Update holiday failed\", DLG_RECORDSET_CONTROL), CLIENT_GetLastError());\n\t\t\t\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t\telse\n\t\t{\n\t\t\tCString csInfo;\n\t\t\tcsInfo.Format(\"%s:0x%08x\", ConvertString(\"Get holiday failed\", DLG_RECORDSET_CONTROL), CLIENT_GetLastError());\n\t\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\t}\n\t}\n}\n\nvoid CDlgRecordSetControl::HolidayRemove()\n{\n\tCDlgSubDlgInfoHoliday dlg(this, NULL, m_nAccessGroup);\n\tdlg.SetOperateType(Em_Operate_Type_Remove);\n\tif (IDOK == dlg.DoModal())\n\t{\n\t\tconst NET_RECORDSET_HOLIDAY& stuInfo = dlg.GetInfo();\n\t\t\n\t\tNET_CTRL_RECORDSET_PARAM stuParam = {sizeof(stuParam)};\n\t\tstuParam.emType = NET_RECORD_ACCESSCTLHOLIDAY;\n\t\tstuParam.pBuf = (void*)&stuInfo.nRecNo;\n\t\tstuParam.nBufLen = sizeof(stuInfo.nRecNo);\n\t\t\n\t\tBOOL bRet = CLIENT_ControlDevice(m_lLoginID, DH_CTRL_RECORDSET_REMOVE, &stuParam, SDK_API_WAITTIME);\n\t\tif (bRet)\n\t\t{\n\t\t\tMessageBox(ConvertString(\"Remove holiday rec ok\", DLG_RECORDSET_CONTROL), ConvertString(\"Prompt\"));\n\t\t} \n\t\telse\n\t\t{\n\t\t\tCString csInfo;\n\t\t\tcsInfo.Format(\"%s:0x%08x\", ConvertString(\"Remove holiday rec failed\", DLG_RECORDSET_CONTROL), CLIENT_GetLastError());\n\t\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\t}\n\t}\n}\n\nvoid CDlgRecordSetControl::HolidayClear()\n{\n\tNET_CTRL_RECORDSET_PARAM stuParam = {sizeof(stuParam)};\n\tstuParam.emType = NET_RECORD_ACCESSCTLHOLIDAY;\n    BOOL bRet = CLIENT_ControlDevice(m_lLoginID, DH_CTRL_RECORDSET_CLEAR, &stuParam, SDK_API_WAITTIME);\n\tif (bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Clear holiday ok\", DLG_RECORDSET_CONTROL), ConvertString(\"Prompt\"));\n\t} \n\telse\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%s:0x%08x\", ConvertString(\"Clear holiday failed\", DLG_RECORDSET_CONTROL), CLIENT_GetLastError());\n\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t}\n}\n/////////////////////////////////////////////////////////////////////////////\n// CDlgRecordSetControl message handlers\n\nBOOL CDlgRecordSetControl::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_RECORDSET_CONTROL);\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgRecordSetControl::OnRecordsetCtlBtnExecute() \n{\n\t// TODO: Add your control notification handler code here\n\tint nSetType = m_cmbSetType.GetCurSel();\n\tint nCtlType = m_cmbCtlType.GetCurSel();\n\tif (-1 == nSetType || -1 == nCtlType)\n\t{\n\t\treturn;\n\t}\n\n\tif (Em_RecordSet_Type_Card == nSetType)\n\t{\n\t\tif (Em_Operate_Type_Insert == nCtlType + 1 || Em_Operate_Type_InsertEX == nCtlType + 1)\n\t\t{\n\t\t\tm_emOpType = static_cast<Em_RecordSet_Operate_Type>(nCtlType+1);\n\t\t\tCardInsert();\n\t\t}\n\t\telse if (Em_Operate_Type_Get == nCtlType + 1)\n\t\t{\n\t\t\tCardGet();\n\t\t}\n\t\telse if (Em_Operate_Type_Update == nCtlType + 1 || Em_Operate_Type_UpdateEX == nCtlType + 1)\n\t\t{\n\t\t\tm_emOpType = static_cast<Em_RecordSet_Operate_Type>(nCtlType+1);\n\t\t\tCardUpdate();\n\t\t}\n\t\telse if (Em_Operate_Type_Remove == nCtlType + 1)\n\t\t{\n\t\t\tCardRemove();\n\t\t}\n\t\telse if (Em_Operate_Type_Clear == nCtlType + 1)\n\t\t{\n\t\t\tCardClear();\n\t\t}\n\t}\n\telse if (Em_RecordSet_Type_Pwd == nSetType)\n\t{\n\t\tif (Em_Operate_Type_Insert == nCtlType + 1)\n\t\t{\n\t\t\tPwdInsert();\n\t\t}\n\t\telse if (Em_Operate_Type_Get == nCtlType + 1)\n\t\t{\n\t\t\tPwdGet();\n\t\t}\n\t\telse if (Em_Operate_Type_Update == nCtlType + 1)\n\t\t{\n\t\t\tPwdUpdate();\n\t\t}\n\t\telse if (Em_Operate_Type_Remove == nCtlType + 1)\n\t\t{\n\t\t\tPwdRemove();\n\t\t}\n\t\telse if (Em_Operate_Type_Clear == nCtlType + 1)\n\t\t{\n\t\t\tPwdClear();\n\t\t}\n\t}\n\telse if (Em_RecordSet_Type_Access == nSetType)\n\t{\n\t\tif (Em_Operate_Type_Insert == nCtlType + 1)\n\t\t{\n\t\t\tAccessInsert();\n\t\t}\n\t\telse if (Em_Operate_Type_Get == nCtlType + 1)\n\t\t{\n\t\t\tAccessGet();\n\t\t}\n\t\telse if (Em_Operate_Type_Update == nCtlType + 1)\n\t\t{\n\t\t\tAccessUpdate();\n\t\t}\n\t\telse if (Em_Operate_Type_Remove == nCtlType + 1)\n\t\t{\n\t\t\tAccessRemove();\n\t\t}\n\t\telse if (Em_Operate_Type_Clear == nCtlType + 1)\n\t\t{\n\t\t\tAccessClear();\n\t\t}\n\t}\n\telse if (Em_RecordSet_Type_Holiday == nSetType)\n\t{\n\t\tif (Em_Operate_Type_Insert == nCtlType + 1)\n\t\t{\n\t\t\tHolidayInsert();\n\t\t}\n\t\telse if (Em_Operate_Type_Get == nCtlType + 1)\n\t\t{\n\t\t\tHolidayGet();\n\t\t}\n\t\telse if (Em_Operate_Type_Update == nCtlType + 1)\n\t\t{\n\t\t\tHolidayUpdate();\n\t\t}\n\t\telse if (Em_Operate_Type_Remove == nCtlType + 1)\n\t\t{\n\t\t\tHolidayRemove();\n\t\t}\n\t\telse if (Em_Operate_Type_Clear == nCtlType + 1)\n\t\t{\n\t\t\tHolidayClear();\n\t\t}\n\t}\n}\n","size_bytes":22777},"bin/Demo/MfcDemo/20.MonitorWall/src/ToolBarEx.cpp":{"content":"// ToolBarEx.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"demomonitorwall.h\"\n#include \"ToolBarEx.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CToolBarEx\n\nCToolBarEx::CToolBarEx()\n{\n\n}\n\nCToolBarEx::~CToolBarEx()\n{\n\tUINT nID = 0;;\n\tCWnd* pWnd = NULL;\n\tfor (POSITION pos = m_mapTitleWnd.GetStartPosition(); pos != NULL; )\n\t{\n\t\tm_mapTitleWnd.GetNextAssoc(pos, nID, pWnd);\n\t\tif (pWnd)\n\t\t{\n\t\t\tpWnd->DestroyWindow();\n\t\t\tdelete pWnd;\n\t\t}\n\t}\n}\n\n\nBEGIN_MESSAGE_MAP(CToolBarEx, CToolBar)\n\t//{{AFX_MSG_MAP(CToolBarEx)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CToolBarEx message handlers\n\nBOOL CToolBarEx::SetButtonTitle( UINT nID, LPCTSTR lpszText )\n{\n\tstatic CFont s_textFont;\n\tif (s_textFont.m_hObject == NULL)\n\t{\n\t\tLOGFONT lf = {0};\n\t\tCFont* cf = GetFont();\n\t\tif(cf)\n\t\t{\n\t\t\tcf->GetObject(sizeof(LOGFONT), &lf);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tGetObject(GetStockObject(SYSTEM_FIXED_FONT), sizeof(LOGFONT), &lf);\n\t\t}\n\t\ts_textFont.DeleteObject();\n\t\ts_textFont.CreateFontIndirect(&lf);\n\t}\n\n\tint nIndex = CommandToIndex(nID);\n\tif (nIndex >= 0)\n\t{\n\t\tCWnd* pWnd = GetTitleWnd(nID);\n\t\tif (pWnd)\n\t\t{\n\t\t\tpWnd->SetWindowText(lpszText);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCRect rect;\n\t\t\tGetToolBarCtrl().GetItemRect(nIndex, &rect);\n\t\t\trect.InflateRect(-1, -2);\n\n\t\t\tCStatic* pStatic = new CStatic;\n\t\t\tpStatic->Create(lpszText, WS_VISIBLE | WS_CHILD | SS_CENTERIMAGE | SS_CENTER, rect, this);\n\t\t\tpStatic->SetFont(&s_textFont);\n\t\t\tpStatic->ShowWindow(SW_SHOW);\n\t\t\tm_mapTitleWnd.SetAt(nID, pStatic);\n\n\t\t\tif (!GetToolBarCtrl().IsButtonEnabled(nID))\n\t\t\t{\n\t\t\t\tpStatic->EnableWindow(FALSE);\n\t\t\t}\n\t\t}\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nBOOL CToolBarEx::EnableButton( UINT nID, BOOL bEnable /*= TRUE*/ )\n{\n\tGetToolBarCtrl().EnableButton(nID, bEnable);\n\tCWnd* pWnd = GetTitleWnd(nID);\n\tif (pWnd)\n\t{\n\t\tpWnd->EnableWindow(bEnable);\n\t\tpWnd->RedrawWindow();\n\t}\n\treturn FALSE;\n}\n\nvoid CToolBarEx::ShowButton( UINT nID, BOOL bShow /*= TRUE*/ )\n{\n\tGetToolBarCtrl().HideButton(nID, !bShow);\n\tif (CWnd* pWnd = GetTitleWnd(nID))\n\t{\n\t\tpWnd->ShowWindow(bShow);\n\t}\n\n//\tGetToolBarCtrl().CommandToIndex()\n}","size_bytes":2326},"bin/Demo/MfcDemo/00.DevInit/LibQREncode/mmask.c":{"content":"/*\n * qrencode - QR Code encoder\n *\n * Masking for Micro QR Code.\n * Copyright (C) 2006-2011 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#if HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <errno.h>\n\n#include \"qrencode.h\"\n#include \"mqrspec.h\"\n#include \"mmask.h\"\n\n__STATIC void MMask_writeFormatInformation(int version, int width, unsigned char *frame, int mask, QRecLevel level)\n{\n\tunsigned int format;\n\tunsigned char v;\n\tint i;\n\n\tformat = MQRspec_getFormatInfo(mask, version, level);\n\n\tfor(i=0; i<8; i++) {\n\t\tv = 0x84 | (format & 1);\n\t\tframe[width * (i + 1) + 8] = v;\n\t\tformat = format >> 1;\n\t}\n\tfor(i=0; i<7; i++) {\n\t\tv = 0x84 | (format & 1);\n\t\tframe[width * 8 + 7 - i] = v;\n\t\tformat = format >> 1;\n\t}\n}\n\n#define MASKMAKER(__exp__) \\\n\tint x, y;\\\n\\\n\tfor(y=0; y<width; y++) {\\\n\t\tfor(x=0; x<width; x++) {\\\n\t\t\tif(*s & 0x80) {\\\n\t\t\t\t*d = *s;\\\n\t\t\t} else {\\\n\t\t\t\t*d = *s ^ ((__exp__) == 0);\\\n\t\t\t}\\\n\t\t\ts++; d++;\\\n\t\t}\\\n\t}\n\nstatic void Mask_mask0(int width, const unsigned char *s, unsigned char *d)\n{\n\tMASKMAKER(y&1)\n}\n\nstatic void Mask_mask1(int width, const unsigned char *s, unsigned char *d)\n{\n\tMASKMAKER(((y/2)+(x/3))&1)\n}\n\nstatic void Mask_mask2(int width, const unsigned char *s, unsigned char *d)\n{\n\tMASKMAKER((((x*y)&1)+(x*y)%3)&1)\n}\n\nstatic void Mask_mask3(int width, const unsigned char *s, unsigned char *d)\n{\n\tMASKMAKER((((x+y)&1)+((x*y)%3))&1)\n}\n\n#define maskNum (4)\ntypedef void MaskMaker(int, const unsigned char *, unsigned char *);\nstatic MaskMaker *maskMakers[maskNum] = {\n\tMask_mask0, Mask_mask1, Mask_mask2, Mask_mask3\n};\n\n#ifdef WITH_TESTS\nunsigned char *MMask_makeMaskedFrame(int width, unsigned char *frame, int mask)\n{\n\tunsigned char *masked;\n\n\tmasked = (unsigned char *)malloc(width * width);\n\tif(masked == NULL) return NULL;\n\n\tmaskMakers[mask](width, frame, masked);\n\n\treturn masked;\n}\n#endif\n\nunsigned char *MMask_makeMask(int version, unsigned char *frame, int mask, QRecLevel level)\n{\n\tunsigned char *masked;\n\tint width;\n\n\tif(mask < 0 || mask >= maskNum) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\twidth = MQRspec_getWidth(version);\n\tmasked = (unsigned char *)malloc(width * width);\n\tif(masked == NULL) return NULL;\n\n\tmaskMakers[mask](width, frame, masked);\n\tMMask_writeFormatInformation(version, width, masked, mask, level);\n\n\treturn masked;\n}\n\n__STATIC int MMask_evaluateSymbol(int width, unsigned char *frame)\n{\n\tint x, y;\n\tunsigned char *p;\n\tint sum1 = 0, sum2 = 0;\n\n\tp = frame + width * (width - 1);\n\tfor(x=1; x<width; x++) {\n\t\tsum1 += (p[x] & 1);\n\t}\n\n\tp = frame + width * 2 - 1;\n\tfor(y=1; y<width; y++) {\n\t\tsum2 += (*p & 1);\n\t\tp += width;\n\t}\n\n\treturn (sum1 <= sum2)?(sum1 * 16 + sum2):(sum2 * 16 + sum1);\n}\n\nunsigned char *MMask_mask(int version, unsigned char *frame, QRecLevel level)\n{\n\tint i;\n\tunsigned char *mask, *bestMask;\n\tint maxScore = 0;\n\tint score;\n\tint width;\n\n\twidth = MQRspec_getWidth(version);\n\n\tmask = (unsigned char *)malloc(width * width);\n\tif(mask == NULL) return NULL;\n\tbestMask = NULL;\n\n\tfor(i=0; i<maskNum; i++) {\n\t\tscore = 0;\n\t\tmaskMakers[i](width, frame, mask);\n\t\tMMask_writeFormatInformation(version, width, mask, i, level);\n\t\tscore = MMask_evaluateSymbol(width, mask);\n\t\tif(score > maxScore) {\n\t\t\tmaxScore = score;\n\t\t\tfree(bestMask);\n\t\t\tbestMask = mask;\n\t\t\tmask = (unsigned char *)malloc(width * width);\n\t\t\tif(mask == NULL) break;\n\t\t}\n\t}\n\tfree(mask);\n\treturn bestMask;\n}\n","size_bytes":4103},"bin/Demo/MfcDemo/19.MasterSlaveSensor/ExButton.cpp":{"content":"// ExButton.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"ExButton.h\"\n#include \"MasterSlaverSensorDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CExButton\n\nCExButton::CExButton()\n{\n\tm_dwPTZCommand = -1;\n\tm_bIsMouseDown = FALSE;\n}\n\nCExButton::~CExButton()\n{\n}\n\n\nBEGIN_MESSAGE_MAP(CExButton, CButton)\n\t//{{AFX_MSG_MAP(CExButton)\n\tON_WM_LBUTTONDOWN()\n\tON_WM_LBUTTONUP()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CExButton message handlers\n\nvoid CExButton::OnLButtonDown(UINT nFlags, CPoint point) \n{\n\t// TODO: Add your message handler code here and/or call default\n\t//Check mous has been clicked or not \n\tif(!m_bIsMouseDown)\n\t{\n\t\tm_bIsMouseDown = TRUE;\n\t\tif((int)m_dwPTZCommand < 0)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t((CMasterSlaver_watcherDlg*)GetParent())->PtzControl(m_dwPTZCommand,FALSE);\n\t\tTRACE(\"START\\n\");\n\t}\n\t\n\tCButton::OnLButtonDown(nFlags, point);\n}\n\nvoid CExButton::OnLButtonUp(UINT nFlags, CPoint point) \n{\n\t// TODO: Add your message handler code here and/or call default\n\tif(m_bIsMouseDown)\n\t{\n\t\tm_bIsMouseDown = FALSE;\n\t\tif((int)m_dwPTZCommand < 0)\n\t\t{\n\t\t\treturn;\t\t\n\t\t}\n\t\t((CMasterSlaver_watcherDlg*)GetParent())->PtzControl(m_dwPTZCommand,TRUE);\n\t\tTRACE(\"STOP\\n\");\n\t}\n\t\n\tCButton::OnLButtonUp(nFlags, point);\n}\n\nvoid CExButton::SetButtonCommand(DWORD dwPTZCommand)\n{\n\tm_dwPTZCommand = dwPTZCommand;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":1867},"bin/Demo/MfcDemo/03.Alarm/TabAlarmDlg.cpp":{"content":"// TabAlarmDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"ClientDemo1.h\"\n#include \"TabAlarmDlg.h\"\n#include <math.h>\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CTabAlarmDlg dialog\n\n\nCTabAlarmDlg::CTabAlarmDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CTabAlarmDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CTabAlarmDlg)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_nChannelCount = 16;\n\tm_nInputAlarmCount = 16;\n}\n\n\nvoid CTabAlarmDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CTabAlarmDlg)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CTabAlarmDlg, CDialog)\n\t//{{AFX_MSG_MAP(CTabAlarmDlg)\n\tON_WM_DESTROY()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CTabAlarmDlg message handlers\n\nBOOL CTabAlarmDlg::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\t// TODO: Add extra initialization here\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CTabAlarmDlg::OnDestroy() \n{\n\tCDialog::OnDestroy();\n\t\n\t// TODO: Add your message handler code here\n\t\n}\n\n//Set general alamr output display \nvoid CTabAlarmDlg::SetCommonAlarmInfo(WORD wInputAlarm,WORD wVideoLost,WORD wMotionAlarm,\n\t\t\t\t\t\t\t\t\t  int nChannelCount,int nInputAlarmCount)\n{\n\tSetCheckBox(nChannelCount,nInputAlarmCount);\n\tint i = 0;\n\tdouble x = 2;\n\tint nInputAlarmID = 1029;\n\tint nVideoLost = 1077;\n\tint nMotionID = 1061;\n\t//External input channel alarm \n\tif(0 != wInputAlarm)\n\t{\n\t\tfor(i=0;i<m_nInputAlarmCount;i++)\n\t\t{\n\t\t\tWORD wAI = (WORD)pow(x,i);\n\t\t\tWORD wInput = wInputAlarm | (~wAI);\n\t\t\tWORD wReverse = ~wInput;\n\t\t\tif(0 == wReverse)\n\t\t\t{\n\t\t\t\tint nIsChecked = ((CButton*)GetDlgItem(nInputAlarmID + i))->GetCheck();\n\t\t\t\tif(1 == nIsChecked)\n\t\t\t\t{\n\t\t\t\t\t((CButton*)GetDlgItem(nInputAlarmID + i))->SetCheck(0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t((CButton*)GetDlgItem(nInputAlarmID + i))->SetCheck(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//Video loss alarm \n\tif(0 != wVideoLost)\n\t{\n\t\tfor(i=0;i<m_nChannelCount;i++)\n\t\t{\n\t\t\tWORD wAV = (WORD)pow(x,i);\n\t\t\tWORD wVideo = wVideoLost | (~wAV);\n\t\t\tWORD wReverse = ~wVideo;\n\t\t\tif(0 == wReverse)\n\t\t\t{\n\t\t\t\tint nIsChecked = ((CButton*)GetDlgItem(nVideoLost + i))->GetCheck();\n\t\t\t\tif(1 == nIsChecked)\n\t\t\t\t{\n\t\t\t\t\t((CButton*)GetDlgItem(nVideoLost + i))->SetCheck(0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t((CButton*)GetDlgItem(nVideoLost + i))->SetCheck(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//Motion detection alarm \n\tif(0 != wMotionAlarm)\n\t{\n\t\tfor(i=0;i<m_nChannelCount;i++)\n\t\t{\n\t\t\tWORD wAV = (WORD)pow(x,i);\n\t\t\tWORD wMotion = wMotionAlarm | (~wAV);\n\t\t\tWORD wReverse = ~wMotion;\n\t\t\tif(0 == wReverse)\n\t\t\t{\n\t\t\t\tint nIsChecked = ((CButton*)GetDlgItem(nMotionID + i))->GetCheck();\n\t\t\t\tif(1 == nIsChecked)\n\t\t\t\t{\n\t\t\t\t\t((CButton*)GetDlgItem(nMotionID + i))->SetCheck(0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t((CButton*)GetDlgItem(nMotionID + i))->SetCheck(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//TRACE(\" %d  %d  %d \\n\",wInputAlarm,wVideoLost,wMotionAlarm);\n}\n\n//Set CheckBox according to channel amount \nvoid CTabAlarmDlg::SetCheckBox(int nChannelCount, int nInputAlarmCount)\n{\n\t//Video input channel setup \n\tif(m_nChannelCount != nChannelCount)\n\t{\n\t\tint i = 0;\n\t\tint nShelterID = 1045;\n\t\tint nMotionID = 1061;\n\t\tint nVideoLost = 1077;\n\t\tint nSoundID = 1093;\n\t\tif(m_nInputAlarmCount > nInputAlarmCount)\n\t\t{\n\t\t\tfor(i=nInputAlarmCount;i<m_nInputAlarmCount;i++)\n\t\t\t{\n\t\t\t\t((CButton*)GetDlgItem(nShelterID + i))->SetCheck(0);\n\t\t\t\tGetDlgItem(nShelterID + i)->EnableWindow(FALSE);\n\t\t\t\t((CButton*)GetDlgItem(nMotionID + i))->SetCheck(0);\n\t\t\t\tGetDlgItem(nMotionID + i)->EnableWindow(FALSE);\n\t\t\t\t((CButton*)GetDlgItem(nVideoLost + i))->SetCheck(0);\n\t\t\t\tGetDlgItem(nVideoLost + i)->EnableWindow(FALSE);\n\t\t\t\t((CButton*)GetDlgItem(nSoundID + i))->SetCheck(0);\n\t\t\t\tGetDlgItem(nSoundID + i)->EnableWindow(FALSE);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(i=m_nInputAlarmCount;i<nInputAlarmCount;i++)\n\t\t\t{\n\t\t\t\t((CButton*)GetDlgItem(nShelterID + i))->SetCheck(0);\n\t\t\t\tGetDlgItem(nShelterID + i)->EnableWindow(TRUE);\n\t\t\t\t((CButton*)GetDlgItem(nMotionID + i))->SetCheck(0);\n\t\t\t\tGetDlgItem(nMotionID + i)->EnableWindow(TRUE);\n\t\t\t\t((CButton*)GetDlgItem(nVideoLost + i))->SetCheck(0);\n\t\t\t\tGetDlgItem(nVideoLost + i)->EnableWindow(TRUE);\n\t\t\t\t((CButton*)GetDlgItem(nSoundID + i))->SetCheck(0);\n\t\t\t\tGetDlgItem(nSoundID + i)->EnableWindow(TRUE);\n\t\t\t}\n\t\t}\n\t\tm_nChannelCount = nChannelCount;\n\t}\n\t//External input channel setup \n\tif(m_nInputAlarmCount != nInputAlarmCount)\n\t{\n\t\tint i = 0;\n\t\tint nID = 1029;\n\t\tif(m_nInputAlarmCount > nInputAlarmCount)\n\t\t{\n\t\t\tfor(i=nInputAlarmCount;i<m_nInputAlarmCount;i++)\n\t\t\t{\n\t\t\t\t((CButton*)GetDlgItem(nID + i))->SetCheck(0);\n\t\t\t\tGetDlgItem(nID + i)->EnableWindow(FALSE);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(i=m_nInputAlarmCount;i<nInputAlarmCount;i++)\n\t\t\t{\n\t\t\t\t((CButton*)GetDlgItem(nID + i))->SetCheck(0);\n\t\t\t\tGetDlgItem(nID + i)->EnableWindow(TRUE);\n\t\t\t}\n\t\t}\n\t\tm_nInputAlarmCount = nInputAlarmCount;\n\t}\n}\n\n//Display camera masking alarm \nvoid CTabAlarmDlg::SetShelterAlarmInfo(WORD wVideoShelter)\n{\n\tint i = 0;\n\tdouble x = 2;\n\tint nShelterAlarmID = 1045;\n\t//Camera masking alarm \n\tfor(i=0;i<m_nChannelCount;i++)\n\t{\n\t\tWORD wAS = (WORD)pow(x,i);\n\t\tWORD wShelter = wVideoShelter | (~wAS);\n\t\tWORD wReverse = ~wShelter;\n\t\tif(0 == wReverse)\n\t\t{\n\t\t\tint nIsChecked = ((CButton*)GetDlgItem(nShelterAlarmID + i))->GetCheck();\n\t\t\tif(1 == nIsChecked)\n\t\t\t{\n\t\t\t\t((CButton*)GetDlgItem(nShelterAlarmID + i))->SetCheck(0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t((CButton*)GetDlgItem(nShelterAlarmID + i))->SetCheck(1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n//Display audio alarm \nvoid CTabAlarmDlg::SetSoundAlarmInfo(WORD wSoundAlarm)\n{\n\tint i = 0;\n\tdouble x = 2;\n\tint nSoundAlarmID = 1093;\n\t//Audio alarm \n\tfor(i=0;i<m_nChannelCount;i++)\n\t{\n\t\tWORD wAS = (WORD)pow(x,i);\n\t\tWORD wSound = wSoundAlarm | (~wAS);\n\t\tWORD wReverse = ~wSound;\n\t\tif(0 == wReverse)\n\t\t{\n\t\t\tint nIsChecked = ((CButton*)GetDlgItem(nSoundAlarmID + i))->GetCheck();\n\t\t\tif(1 == nIsChecked)\n\t\t\t{\n\t\t\t\t((CButton*)GetDlgItem(nSoundAlarmID + i))->SetCheck(0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t((CButton*)GetDlgItem(nSoundAlarmID + i))->SetCheck(1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n//Display HDD space is insufficient. \nvoid CTabAlarmDlg::SetDiskFullAlarmInfo(BOOL bDiskFull)\n{\n\tif(bDiskFull)\n\t{\n\t\t((CButton*)GetDlgItem(IDC_ALARM_DISKFULL))->SetCheck(1);\n\t}\n\telse\n\t{\n\t\t((CButton*)GetDlgItem(IDC_ALARM_DISKFULL))->SetCheck(0);\n\t}\n}\n\n//Display HDD malfucntion alarm \nvoid CTabAlarmDlg::SetDiskErrorAlarmInfo(DWORD dwDiskError)\n{\n\tdouble x = 2;\n\tCString strDiskError;\n\tfor(int i=0;i<32;i++)\n\t{\n\t\tDWORD dwAD = (DWORD)pow(x,i);\n\t\tDWORD dwDisk = dwDiskError | (~dwAD);\n\t\tDWORD wReverse = ~dwDisk;\n\t\tif(0 == wReverse)\n\t\t{\n\t\t\tCString str;\n\t\t\tstr.Format(\" %d \",i);\n\t\t\tstrDiskError = strDiskError +str;\n\t\t}\n\t}\n\tSetDlgItemText(IDC_ALARM_DISKERROR,strDiskError);\n}\n\nvoid CTabAlarmDlg::CleanAllInfo(void) \n{\n\tCleanColum(IDC_ALARM_SHELTER0, 16);\n\tCleanColum(IDC_ALARM_INPUT0, 16);\n\tCleanColum(IDC_ALARM_MOTION0, 16);\n\tCleanColum(IDC_ALARM_VIDEOLOST0, 16);\n\tCleanColum(IDC_ALARM_SOUND0, 16);\n\tCleanColum(IDC_ALARM_DISKFULL,1);\n}\n\nvoid CTabAlarmDlg::CleanColum(UINT uID, int nLen) \n{\n\tfor(int i = 0; i < nLen; i++)\n\t{\n\t\t((CButton*)GetDlgItem(uID + i))->SetCheck(FALSE);\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":7487},"bin/Demo/MfcDemo/01.RealPlayAndPTZControl/StdAfx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n//\tRealPlayAndPTZControl.pch will be the pre-compiled header\n//\tstdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":555},"bin/Demo/MfcDemo/01.RealPlayAndPTZControl/PlayApi.cpp":{"content":"\n#include \"StdAfx.h\"\n#include \"PlayApi.h\"\n#include \"vector\"\n#include \"string\"\n\n//////////////////////////////////////////////////////////////////////////\n//\n\nCPlayAPI::CPlayAPI():\nm_hModule(NULL),\nm_APIOpenStream(NULL),\nm_APISetDisplayCallBack(NULL),\nm_APIRigisterDrawFun(NULL),\nm_APIPlay(NULL),\nm_APIInputData(NULL),\nm_APIQueryInfo(NULL),\nm_APIStop(NULL),\nm_APICloseStream(NULL),\nm_APIGetLastError(NULL),\nm_APISetSecurityKey(NULL)\n{\n}\n\nCPlayAPI::~CPlayAPI()\n{\n\tif (m_hModule)\n\t{\n\t\tFreeLibrary(m_hModule);\n\t\tm_hModule = NULL;\n\n\t\tOutputDebugString(_T(\"Unload PlaySDK!\\n\"));\n\t}\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//\n\nvoid CPlayAPI::LoadPlayDll()\n{\n\tHMODULE hLib = ::LoadLibraryEx(\"dhplay.dll\", NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n\tif (hLib)\n\t{\n\t\tm_APIOpenStream = (PLAY_API_OPENSTREAM)GetProcAddress(hLib, \"PLAY_OpenStream\");;\n\t\tm_APISetDisplayCallBack = (PLAY_API_SETIVSCALLBACK)GetProcAddress(hLib, \"PLAY_SetIVSCallBack\");\n\t\tm_APIRigisterDrawFun = (PLAY_API_RIGISTERDRAWFUN)GetProcAddress(hLib, \"PLAY_RigisterDrawFun\");\n\t\tm_APIPlay = (PLAY_API_PLAY)GetProcAddress(hLib, \"PLAY_Play\");\n\t\tm_APIInputData = (PLAY_API_INPUTDATA)GetProcAddress(hLib, \"PLAY_InputData\");\n\t\tm_APIQueryInfo = (PLAY_API_QUERYINFO)GetProcAddress(hLib, \"PLAY_QueryInfo\");\n\t\tm_APIStop = (PLAY_API_STOP)GetProcAddress(hLib, \"PLAY_Stop\");\n\t\tm_APICloseStream = (PLAY_API_CLOSESTREAM)GetProcAddress(hLib, \"PLAY_CloseStream\");\n\t\tm_APIGetLastError = (PLAY_API_GetLastError)GetProcAddress(hLib, \"PLAY_GetLastError\");\n        m_APISetSecurityKey = (PLAY_API_SetSecurityKey)GetProcAddress(hLib , \"PLAY_SetSecurityKey\");\n\n\t\tm_hModule = hLib;\n\t\tOutputDebugString(_T(\"Load PlaySDK Successfully!\\n\"));\n\t}\n\telse\n\t{\n\t\tOutputDebugString(_T(\"Load PlaySDK Failed!\\n\"));\n\t}\n}\n\nBOOL CPlayAPI::PLAY_OpenStream(LONG nPort,PBYTE pFileHeadBuf,DWORD nSize,DWORD nBufPoolSize)\n{\n\tif (m_APIOpenStream)\n\t{\n\t\treturn m_APIOpenStream(nPort, pFileHeadBuf, nSize, nBufPoolSize);\n\t}\n\n\treturn FALSE;\n}\n\nBOOL CPlayAPI::PLAY_SetIVSCallBack(LONG nPort, GetIVSInfoCallbackFunc pFunc, void* pUserData)\n{\n\tif (m_APISetDisplayCallBack)\n\t{\n\t\treturn m_APISetDisplayCallBack(nPort, pFunc, pUserData);\n\t}\n\n\treturn FALSE;\n}\n\nBOOL CPlayAPI::PLAY_RigisterDrawFun(LONG nPort, DrawFun DrawFuncb, void* pUserData)\n{\n\tif (m_APIRigisterDrawFun)\n\t{\n\t\treturn m_APIRigisterDrawFun(nPort, DrawFuncb, pUserData);\n\t}\n\n\treturn FALSE;\n}\n\nBOOL CPlayAPI::PLAY_Play(LONG nPort, HWND hWnd)\n{\n\tif (m_APIPlay)\n\t{\n\t\treturn m_APIPlay(nPort, hWnd);\n\t}\n\n\treturn FALSE;\n}\n\nBOOL CPlayAPI::PLAY_InputData(LONG nPort, PBYTE pBuf, DWORD nSize)\n{\n\tif (m_APIInputData)\n\t{\n\t\treturn m_APIInputData(nPort, pBuf, nSize);\n\t}\n\n\treturn FALSE;\n}\n\nBOOL CPlayAPI::PLAY_QueryInfo(LONG nPort , int cmdType, char* buf, int buflen, int* returnlen)\n{\n\tif (m_APIQueryInfo)\n\t{\n\t\treturn m_APIQueryInfo(nPort, cmdType, buf, buflen, returnlen);\n\t}\n\n\treturn FALSE;\n}\n\nBOOL CPlayAPI::PLAY_Stop(LONG nPort)\n{\n\tif (m_APIStop)\n\t{\n\t\treturn m_APIStop(nPort);\n\t}\n\n\treturn FALSE;\n}\n\nBOOL CPlayAPI::PLAY_CloseStream(LONG nPort)\n{\n\tif (m_APICloseStream)\n\t{\n\t\treturn m_APICloseStream(nPort);\n\t}\n\n\treturn FALSE;\n}\n\n\nDWORD CPlayAPI::PLAY_GetLastError(LONG nPort)\n{\n\tif (m_APIGetLastError)\n\t{\n\t\treturn m_APIGetLastError(nPort);\n\t}\n\treturn -1;\n}\nBOOL CPlayAPI::PLAY_SetSecurityKey( LONG nPort,const char* szKeyID, DWORD nKeyIDLen,const char* szKey, DWORD nKeyLen )\n{\n    if ((m_APISetSecurityKey) == NULL)\n    {\n        return FALSE;\n    }\n    if (NULL == szKeyID || NULL == szKey)\n    {\n        return FALSE;\n    }\n    if (nKeyIDLen == 0 || nKeyLen == 0)\n    {\n        return FALSE;\n    }\n    std::vector<char> acBuf;\n    acBuf.resize(nKeyIDLen + nKeyLen,0);\n    std::copy(szKeyID,szKeyID + nKeyIDLen,acBuf.begin());\n    std::copy(szKey,szKey + nKeyLen,acBuf.begin() + nKeyIDLen);\n    acBuf.insert(acBuf.begin(),0x01);\n    return (m_APISetSecurityKey)(nPort, &acBuf[0],acBuf.size());\n    return FALSE;\n}\n\n","size_bytes":3906},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgRCEmergencyCall.cpp":{"content":"// DlgCfgRCEmergencyCall.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"alarmdevice.h\"\n#include \"DlgCfgRCEmergencyCall.h\"\n#include \"SubDlgCfgEventHandler.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgRCEmergencyCall dialog\n\n\nCDlgCfgRCEmergencyCall::CDlgCfgRCEmergencyCall(CWnd* pParent /* = NULL */, LLONG lLoginID /* = 0 */)\n\t: CDialog(CDlgCfgRCEmergencyCall::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgRCEmergencyCall)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n    m_lLoginId = lLoginID;\n    memset(&m_stuInfo, 0, sizeof(m_stuInfo));\n}\n\n\nvoid CDlgCfgRCEmergencyCall::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgRCEmergencyCall)\n\tDDX_Control(pDX, IDC_CFGRCEMERGENCYCALL_CMB_CHN, m_cmbChn);\n\tDDX_Control(pDX, IDC_CFGRCEMERGENCYCALL_CMB_MODE, m_cmbMode);\n\tDDX_Control(pDX, IDC_CFGRCEMERGENCYCALL_CMB_ALARMTYPE, m_cmbAlarmType);\n\tDDX_Control(pDX, IDC_CFGRCEMERGENCYCALL_CHK_ENABLE, m_ckEnable);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgRCEmergencyCall, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgRCEmergencyCall)\n\tON_BN_CLICKED(IDC_CFGRCEMERGENCYCALL_BTN_EVENTHANDLER, OnCfgRCEmergencyCallBtnEventhandler)\n\tON_BN_CLICKED(IDC_CFGRCEMERGENCYCALL_BTN_GET, OnCfgRCEmergencyCallBtnGet)\n\tON_BN_CLICKED(IDC_CFGRCEMERGENCYCALL_BTN_SET, OnCfgRCEmergencyCallBtnSet)\n\tON_CBN_SELCHANGE(IDC_CFGRCEMERGENCYCALL_CMB_CHN, OnSelchangeCfgRCEmergencyCallCmbChn)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgRCEmergencyCall private method\n\nvoid CDlgCfgRCEmergencyCall::InitDlg()\n{\n    int i = 0;\n    m_cmbChn.ResetContent();\n    for (i = 0; i < 8; i++)\n    {\n        CString csItem;\n        csItem.Format(\"%s %03d\", ConvertString(\"Channel:\", DLG_CFG_ALARM), i + 1);\n        m_cmbChn.InsertString(-1, csItem);\n    }\n\tm_cmbChn.SetCurSel(0);\n\n    m_ckEnable.SetCheck(BST_UNCHECKED);\n\n    m_cmbMode.ResetContent();\n    for (i = 0; i < sizeof(stuDemoRCEMode)/sizeof(stuDemoRCEMode[0]); i++)\n    {\n        m_cmbMode.InsertString(-1, ConvertString(stuDemoRCEMode[i].szInfo, DLG_CFG_RCEMERGENCYCALL));\n    }\n    m_cmbMode.SetCurSel(0);\n\n    m_cmbAlarmType.ResetContent();\n    for (i = 0; i < sizeof(stuDemoRCEAlarmType)/sizeof(stuDemoRCEAlarmType[0]); i++)\n    {\n        m_cmbAlarmType.InsertString(-1, ConvertString(stuDemoRCEAlarmType[i].szInfo, DLG_CFG_RCEMERGENCYCALL));\n    }\n    m_cmbAlarmType.SetCurSel(0);\n}\n\nBOOL CDlgCfgRCEmergencyCall::GetConfigFromDevice()\n{\n    char szJsonBuf[1024 * 40] = {0};\n    int nerror = 0;\n    int nSelChn = m_cmbChn.GetCurSel() == -1 ? 0 : m_cmbChn.GetCurSel();;\n    BOOL bRet = CLIENT_GetNewDevConfig(m_lLoginId, CFG_CMD_RCEMERGENCY_CALL, nSelChn, szJsonBuf, sizeof(szJsonBuf), &nerror, SDK_API_WAIT);\n    \n    if (bRet)\n    {\n        DWORD dwRetLen = 0;\n        bRet = CLIENT_ParseData(CFG_CMD_RCEMERGENCY_CALL, szJsonBuf, (void*)&m_stuInfo, sizeof(m_stuInfo), &dwRetLen);\n        if (!bRet)\n        {\n            MessageBox(ConvertString(CString(\"parse RCEmergencyCall error...\"), DLG_CFG_RCEMERGENCYCALL), ConvertString(\"Prompt\"));\n            return FALSE;\n        }\n    }\n    else\n    {\t\t\t\n        CString csErr;\n        csErr.Format(\"%s 0x%08x\",ConvertString(\"QueryConfig RCEmergencyCall error:\", DLG_CFG_RCEMERGENCYCALL), CLIENT_GetLastError());\n        MessageBox(csErr, ConvertString(\"Prompt\"));\n        return FALSE;\n    }\n    return TRUE;\n}\n\nBOOL CDlgCfgRCEmergencyCall::SetConfigToDevice()\n{\n    char szJsonBuf[1024 * 40] = {0};    \n    BOOL bRet = CLIENT_PacketData(CFG_CMD_RCEMERGENCY_CALL, &m_stuInfo, sizeof(m_stuInfo), szJsonBuf, sizeof(szJsonBuf));\n    if (!bRet)\n    {\n        MessageBox(ConvertString(CString(\"packet RCEmergencyCall error...\"), DLG_CFG_RCEMERGENCYCALL), ConvertString(\"Prompt\"));\n        return FALSE;\n    } \n    else\n    {\n\t\tint nSelChn = m_cmbChn.GetCurSel() == -1 ? 0 : m_cmbChn.GetCurSel();\n        int nerror = 0;\n        int nrestart = 0;\n        bRet = CLIENT_SetNewDevConfig(m_lLoginId, CFG_CMD_RCEMERGENCY_CALL, nSelChn, szJsonBuf, sizeof(szJsonBuf), &nerror, &nrestart, SDK_API_WAIT);\n        if (!bRet)\n        {\n            CString csErr;\n            csErr.Format(\"%s 0x%08x\", ConvertString(\"SetupConfig RCEmergencyCall failed:\", DLG_CFG_RCEMERGENCYCALL), CLIENT_GetLastError());\n            MessageBox(csErr, ConvertString(\"Prompt\"));\n            return FALSE;\n        }\n        else\n        {\n            MessageBox(ConvertString(CString(\"SetConfig RCEmergencyCall ok!\"), DLG_CFG_RCEMERGENCYCALL), ConvertString(\"Prompt\"));\n        }\n    }\n    return TRUE;\n}\n\nBOOL CDlgCfgRCEmergencyCall::showInfo()\n{\n    m_ckEnable.SetCheck(m_stuInfo.bEnable ? BST_CHECKED : BST_UNCHECKED);\n    m_cmbMode.SetCurSel((int)m_stuInfo.emMode);\n    m_cmbAlarmType.SetCurSel((int)m_stuInfo.emAlarmType);\n    return TRUE;\n}\n\nBOOL CDlgCfgRCEmergencyCall::getInfo()\n{\n    m_stuInfo.bEnable = m_ckEnable.GetCheck() ? TRUE : FALSE;\n    \n    if (m_cmbMode.GetCurSel() == -1)\n    {\n        m_stuInfo.emMode = EM_CFG_RCEMERGENCY_MODE_UNKNOWN;\n    }\n    else\n    {\n        m_stuInfo.emMode = (EM_CFG_RCEMERGENCY_MODE_TYPE)m_cmbMode.GetCurSel();\n    }\n    \n    if (m_cmbAlarmType.GetCurSel() == -1)\n    {\n        m_stuInfo.emAlarmType = EM_CFG_RCEMERGENCY_CALL_UNKNOWN;\n    }\n    else\n    {\n        m_stuInfo.emAlarmType = (EM_CFG_RCEMERGENCY_CALL_TYPE)m_cmbAlarmType.GetCurSel();\n    }\n    return TRUE;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgRCEmergencyCall message handlers\n\nBOOL CDlgCfgRCEmergencyCall::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_RCEMERGENCYCALL);\n\t// TODO: Add extra initialization here\n    InitDlg();\n    if (GetConfigFromDevice())\n    {\n        showInfo();\n\t}\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgRCEmergencyCall::OnCfgRCEmergencyCallBtnEventhandler() \n{\n\t// TODO: Add your control notification handler code here\n    CSubDlgCfgEventHandler* pdlgEventHandler = new CSubDlgCfgEventHandler;\n    if (pdlgEventHandler != NULL)\n    {\n        pdlgEventHandler->SetEventHandler(m_stuInfo.stuEventHandler);\n        \n        if (IDOK == pdlgEventHandler->DoModal())\n        {\n            const CFG_ALARM_MSG_HANDLE& stuEventHandler = pdlgEventHandler->GetEventHandler();\n            memcpy(&m_stuInfo.stuEventHandler, &stuEventHandler, sizeof(CFG_ALARM_MSG_HANDLE));\n        }\n        \n        delete pdlgEventHandler;\n        pdlgEventHandler = NULL;\n    }\n    else\n    {\n        MessageBox(ConvertString(\"new handler dialog error!\", DLG_CFG_NETABORT), ConvertString(\"Prompt\"));\n\t}\n}\n\nvoid CDlgCfgRCEmergencyCall::OnCfgRCEmergencyCallBtnGet() \n{\n\t// TODO: Add your control notification handler code here\n    if (GetConfigFromDevice())\n    {\n        showInfo();\n\t}\n}\n\nvoid CDlgCfgRCEmergencyCall::OnCfgRCEmergencyCallBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n    getInfo();\n    SetConfigToDevice();\n}\n\nvoid CDlgCfgRCEmergencyCall::OnSelchangeCfgRCEmergencyCallCmbChn() \n{\n\t// TODO: Add your control notification handler code here\n    if (GetConfigFromDevice())\n    {\n        showInfo();\n\t}\n}\n","size_bytes":7381},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/UserConfig.cpp":{"content":"// UserConfig.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"UserConfig.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CUserConfig dialog\n\nCUserConfig::CUserConfig(CWnd* pParent /*=NULL*/)\n\t: CDialog(CUserConfig::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CUserConfig)\n\tm_bLright_log = FALSE;\n\tm_bLright_more = FALSE;\n\tm_bLright_playback = FALSE;\n\tm_bLright_ptz = FALSE;\n\tm_bLright_rec = FALSE;\n\tm_mac1 = _T(\"\");\n\tm_mac2 = _T(\"\");\n\tm_mac3 = _T(\"\");\n\tm_mac4 = _T(\"\");\n\tm_mac5 = _T(\"\");\n\tm_mac6 = _T(\"\");\n\tm_bRright_alarm = FALSE;\n\tm_bRright_cfg = FALSE;\n\tm_bRright_localop = FALSE;\n\tm_bRright_log = FALSE;\n\tm_bRright_monitor = FALSE;\n\tm_bRright_more = FALSE;\n\tm_bRright_playback = FALSE;\n\tm_bRright_ptz = FALSE;\n\tm_bRright_rec = FALSE;\n\tm_bRright_serial = FALSE;\n\tm_bRright_talk = FALSE;\n\tm_userip = _T(\"\");\n\tm_username = _T(\"\");\n\tm_userpsw = _T(\"\");\n\tm_userpsw2 = _T(\"\");\n\tm_bLright_cfg = FALSE;\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CUserConfig::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CUserConfig)\n\tDDX_Control(pDX, IDC_USERSEL, m_usersel);\n\tDDX_Check(pDX, IDC_LRIGHT_LOG, m_bLright_log);\n\tDDX_Check(pDX, IDC_LRIGHT_MORE, m_bLright_more);\n\tDDX_Check(pDX, IDC_LRIGHT_PLAYBACK, m_bLright_playback);\n\tDDX_Check(pDX, IDC_LRIGHT_PTZ, m_bLright_ptz);\n\tDDX_Check(pDX, IDC_LRIGHT_REC, m_bLright_rec);\n\tDDX_Text(pDX, IDC_MAC1, m_mac1);\n\tDDX_Text(pDX, IDC_MAC2, m_mac2);\n\tDDX_Text(pDX, IDC_MAC3, m_mac3);\n\tDDX_Text(pDX, IDC_MAC4, m_mac4);\n\tDDX_Text(pDX, IDC_MAC5, m_mac5);\n\tDDX_Text(pDX, IDC_MAC6, m_mac6);\n\tDDX_Check(pDX, IDC_RRIGHT_ALARM, m_bRright_alarm);\n\tDDX_Check(pDX, IDC_RRIGHT_CFG, m_bRright_cfg);\n\tDDX_Check(pDX, IDC_RRIGHT_LOCALOP, m_bRright_localop);\n\tDDX_Check(pDX, IDC_RRIGHT_LOG, m_bRright_log);\n\tDDX_Check(pDX, IDC_RRIGHT_MONITOR, m_bRright_monitor);\n\tDDX_Check(pDX, IDC_RRIGHT_MORE, m_bRright_more);\n\tDDX_Check(pDX, IDC_RRIGHT_PLAYBACK, m_bRright_playback);\n\tDDX_Check(pDX, IDC_RRIGHT_PTZ, m_bRright_ptz);\n\tDDX_Check(pDX, IDC_RRIGHT_REC, m_bRright_rec);\n\tDDX_Check(pDX, IDC_RRIGHT_SERIAL, m_bRright_serial);\n\tDDX_Check(pDX, IDC_RRIGHT_TALK, m_bRright_talk);\n\tDDX_Text(pDX, IDC_USERIP, m_userip);\n\tDDX_Text(pDX, IDC_USERNAME, m_username);\n\tDDX_Text(pDX, IDC_USERPSW, m_userpsw);\n\tDDX_Text(pDX, IDC_USERPSW2, m_userpsw2);\n\tDDX_Check(pDX, IDC_LRIGHT_CFG, m_bLright_cfg);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CUserConfig, CDialog)\n\t//{{AFX_MSG_MAP(CUserConfig)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CUserConfig message handlers\n\nvoid CUserConfig::SetDevice(DeviceNode *nDev)\n{\n\tm_Device = nDev;\n}\n\nBOOL CUserConfig::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\t\n\tCRect rc(0, 0, 0, 0);\n\tGetParent()->GetClientRect(&rc);\n\t((CTabCtrl*)GetParent())->AdjustRect(FALSE, &rc);\n\tMoveWindow(&rc);\n\t\n\tCString csUserName;\n\tDWORD dwReturned;\n\tbSetUserParams = FALSE;\n\tchar cTemp[100];\n\n//\tif(m_bConnectServer)\n//\t{\n\t\tif(!CLIENT_GetDevConfig(m_Device->LoginID, DEV_GET_USERCFG , 0,&m_user, sizeof(NET_DEV_USER), &dwReturned, CONFIG_WAITTIME))\n\t\t{\n\t\t//\tCString sTemp;\n\t\t//\tsTemp.Format(\"ERROR: NET_DVR_GET_USERCFG = %d \\n\", NET_DVR_GetLastError());\n\t\t\tAfxMessageBox(ConvertString(\"usercfg error\"));\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(m_bSuperUser)\n\t\t\t{\n\t\t\t\tm_usernum = 0;\n\t\t\t\tm_usersel.SetCurSel(m_usernum);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int i=0; i<MAX_USERNUM; i++)\n\t\t\t\t{\n\t\t\t\t\tZeroMemory(cTemp, 100);\n\t\t\t\t\tmemcpy(cTemp, m_user.struUser[i].sUserName, MAX_NAMELEN);\n\t\t\t\t\tcsUserName.Format(\"%s\", cTemp);\n\t\t\t\t\tif(strcmp(csUserName, m_Device->UserNanme) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tm_usernum = i;\n\t\t\t\tm_usersel.SetCurSel(m_usernum);\n\t\t\t}\n\t\t\tZeroMemory(cTemp, 100);\n\t\t\tmemcpy(cTemp, m_user.struUser[m_usernum].sUserName, MAX_NAMELEN);\n\t\t\tm_username.Format(\"%s\", cTemp);\n\t\t\tZeroMemory(cTemp, 100);\n\t\t\tmemcpy(cTemp, m_user.struUser[m_usernum].sPassword, PASSWD_LEN);\n\t\t\tm_userpsw.Format(\"%s\", cTemp);\n\t\t\tZeroMemory(cTemp, 100);\n\t\t\tmemcpy(cTemp, m_user.struUser[m_usernum].sPassword, PASSWD_LEN);\n\t\t\tm_userpsw2.Format(\"%s\", cTemp);\n\t\t\tm_userip.Format(\"%s\",m_user.struUser[m_usernum].sUserIP);\n\t\t\tm_mac1.Format(\"%02x\",m_user.struUser[m_usernum].byMACAddr[0]);\n\t\t\tm_mac2.Format(\"%02x\",m_user.struUser[m_usernum].byMACAddr[1]);\n\t\t\tm_mac3.Format(\"%02x\",m_user.struUser[m_usernum].byMACAddr[2]);\n\t\t\tm_mac4.Format(\"%02x\",m_user.struUser[m_usernum].byMACAddr[3]);\n\t\t\tm_mac5.Format(\"%02x\",m_user.struUser[m_usernum].byMACAddr[4]);\n\t\t\tm_mac6.Format(\"%02x\",m_user.struUser[m_usernum].byMACAddr[5]);\t\t\n\t\t\tm_bLright_ptz = m_user.struUser[m_usernum].dwLocalRight[0];\n\t\t\tm_bLright_rec = m_user.struUser[m_usernum].dwLocalRight[1];\n\t\t\tm_bLright_playback = m_user.struUser[m_usernum].dwLocalRight[2];\n\t\t\tm_bLright_cfg = m_user.struUser[m_usernum].dwLocalRight[3];\n\t\t\tm_bLright_log = m_user.struUser[m_usernum].dwLocalRight[4];\n\t\t\tm_bLright_more = m_user.struUser[m_usernum].dwLocalRight[5];\n\t\t\tm_bRright_ptz = m_user.struUser[m_usernum].dwRemoteRight[0];\n\t\t\tm_bRright_rec = m_user.struUser[m_usernum].dwRemoteRight[1];\n\t\t\tm_bRright_playback = m_user.struUser[m_usernum].dwRemoteRight[2];\n\t\t\tm_bRright_cfg = m_user.struUser[m_usernum].dwRemoteRight[3];\n\t\t\tm_bRright_log = m_user.struUser[m_usernum].dwRemoteRight[4];\n\t\t\tm_bRright_more = m_user.struUser[m_usernum].dwRemoteRight[5];\n\t\t\tm_bRright_talk = m_user.struUser[m_usernum].dwRemoteRight[6];\n\t\t\tm_bRright_monitor = m_user.struUser[m_usernum].dwRemoteRight[7];\n\t\t\tm_bRright_alarm = m_user.struUser[m_usernum].dwRemoteRight[8];\n\t\t\tm_bRright_localop = m_user.struUser[m_usernum].dwRemoteRight[9];\n\t\t\tm_bRright_serial = m_user.struUser[m_usernum].dwRemoteRight[10];\n\t\t\tGetDlgItem(IDC_USERSEL)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_USERIP)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_MAC1)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_MAC2)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_MAC3)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_MAC4)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_MAC5)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_MAC6)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_USERNAME)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_USERPSW)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_USERPSW2)->EnableWindow(FALSE);\t\t\t\n\t\t\tGetDlgItem(IDC_LRIGHT_PTZ)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_LRIGHT_REC)->EnableWindow(FALSE);\t\n\t\t\tGetDlgItem(IDC_LRIGHT_PLAYBACK)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_LRIGHT_CFG)->EnableWindow(FALSE);\t\n\t\t\tGetDlgItem(IDC_LRIGHT_LOG)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_LRIGHT_MORE)->EnableWindow(FALSE);\t\n\t\t\tGetDlgItem(IDC_RRIGHT_PTZ)->EnableWindow(FALSE);\t\n\t\t\tGetDlgItem(IDC_RRIGHT_REC)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_RRIGHT_PLAYBACK)->EnableWindow(FALSE);\t\n\t\t\tGetDlgItem(IDC_RRIGHT_CFG)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_RRIGHT_LOG)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_RRIGHT_MORE)->EnableWindow(FALSE);\t\n\t\t\tGetDlgItem(IDC_RRIGHT_TALK)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_RRIGHT_MONITOR)->EnableWindow(FALSE);\t\n\t\t\tGetDlgItem(IDC_RRIGHT_ALARM)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_RRIGHT_LOCALOP)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_RRIGHT_SERIAL)->EnableWindow(FALSE);\n\t\t\t\n\t\t\tif(m_bSuperUser)\n\t\t\t{\n\t\t\t\tGetDlgItem(IDC_USERSEL)->EnableWindow(FALSE);\n\t\t\t\tGetDlgItem(IDC_USERIP)->EnableWindow(FALSE);\n\t\t\t\tGetDlgItem(IDC_MAC1)->EnableWindow(FALSE);\n\t\t\t\tGetDlgItem(IDC_MAC2)->EnableWindow(FALSE);\n\t\t\t\tGetDlgItem(IDC_MAC3)->EnableWindow(FALSE);\n\t\t\t\tGetDlgItem(IDC_MAC4)->EnableWindow(FALSE);\n\t\t\t\tGetDlgItem(IDC_MAC5)->EnableWindow(FALSE);\n\t\t\t\tGetDlgItem(IDC_MAC6)->EnableWindow(FALSE);\n\t\t\t\tGetDlgItem(IDC_USERNAME)->EnableWindow(FALSE);\n\t\t\t\tGetDlgItem(IDC_USERPSW)->EnableWindow(FALSE);\n\t\t\t\tGetDlgItem(IDC_USERPSW2)->EnableWindow(FALSE);\t\n\t\t\t}\t\t\n\t\t\tGetDlgItem(IDC_USERCFG_APPLY)->EnableWindow(TRUE);\n\t\t}\n//\t}\n\t\n\tGetDlgItem(IDC_USERNAME)->EnableWindow(FALSE);\n\tUpdateData(FALSE);\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n","size_bytes":8075},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/ConfigAlarmBlind.cpp":{"content":"// ConfigAlarmBlind.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"ConfigAlarmBlind.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CConfigAlarmBlind dialog\n\n\nCConfigAlarmBlind::CConfigAlarmBlind(CWnd* pParent /*=NULL*/)\n\t: CDialog(CConfigAlarmBlind::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CConfigAlarmBlind)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_pDev = 0;\n\tmemset(m_blindCFG, 0, DH_MAX_VIDEO_IN_NUM*sizeof(DH_BLIND_CFG));\n\tm_bReady = FALSE;\n\tm_chlIdx = -1;\n\tm_weekIdx = -1;\n\tm_ptzchlIdx = -1;\n\n\tm_dontsave = 0;\n}\n\n\nvoid CConfigAlarmBlind::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CConfigAlarmBlind)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CConfigAlarmBlind, CDialog)\n\t//{{AFX_MSG_MAP(CConfigAlarmBlind)\n\tON_WM_SHOWWINDOW()\n\tON_CBN_SELCHANGE(IDC_COMBO_VIDEOCHL, OnSelchangeComboVideochl)\n\tON_CBN_SELCHANGE(IDC_COMBO_ALARMWEEK, OnSelchangeComboAlarmweek)\n\tON_CBN_SELCHANGE(IDC_COMBO_ALARMPTZCHL, OnSelchangeComboAlarmptzchl)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CConfigAlarmBlind message handlers\n\nvoid CConfigAlarmBlind::SetDevice(DeviceNode *pDev)\n{\n\tm_pDev = pDev;\n}\n\nvoid CConfigAlarmBlind::SetBlindCFG(DH_BLIND_CFG *cfg)\n{\n\tif (!cfg)\n\t{\n\t\treturn;\n\t}\n\n\tmemcpy(m_blindCFG, cfg, DH_MAX_VIDEO_IN_NUM*sizeof(DH_BLIND_CFG));\n\n\tDWORD dwActMask = m_blindCFG[0].struHandle.dwActionMask;\n\t//sentence if some functions enabled\n\tGetDlgItem(IDC_CHECK_UPLOAD)->EnableWindow((dwActMask & DH_ALARM_UPLOAD)?TRUE:FALSE);\n\tGetDlgItem(IDC_CHECK_LOCALTIP)->EnableWindow((dwActMask & DH_ALARM_TIP)?TRUE:FALSE);\n\tGetDlgItem(IDC_CHECK_LOCALTOUR)->EnableWindow((dwActMask & DH_ALARM_TOUR)?TRUE:FALSE);\n\tGetDlgItem(IDC_CHECK_SENDMAIL)->EnableWindow((dwActMask & DH_ALARM_MAIL)?TRUE:FALSE);\n\t\n\t//sentence if ptz enabled\n\tBOOL bPTZEn = (dwActMask & DH_ALARM_PTZ)?TRUE:FALSE;\n\tGetDlgItem(IDC_CHECK_PTZ)->EnableWindow(bPTZEn);\n\tGetDlgItem(IDC_COMBO_ALARMPTZCHL)->EnableWindow(bPTZEn);\n\tGetDlgItem(IDC_COMBO_ALARMPTZ)->EnableWindow(bPTZEn);\n\tGetDlgItem(IDC_EDIT_PTZNO)->EnableWindow(bPTZEn);\n\t\n\t//sentence if record enabled\n\tBOOL bRecEn = (dwActMask & DH_ALARM_RECORD)?TRUE:FALSE;\n\tGetDlgItem(IDC_CHECK_RECORD)->EnableWindow(bRecEn);\n\tfor (int i = 0; i < 16; i++)\n\t{\n\t\tGetDlgItem(IDC_CHECK_RECCH1+i)->EnableWindow(bRecEn);\n\t}\n\t\n\t//sentence if alarm output enabled\n\tBOOL bOutEn = (dwActMask & DH_ALARM_OUT)?TRUE:FALSE;\n\tGetDlgItem(IDC_CHECK_OUTPUT)->EnableWindow(bOutEn);\n\tfor (int j = 0; j < 16; j++)\n\t{\n\t\tGetDlgItem(IDC_CHECK_ALMOP1+j)->EnableWindow(bOutEn);\n\t}\n\t\n\tm_bReady = TRUE;\n}\n\nvoid CConfigAlarmBlind::ShowConfig()\n{\n\tif (!m_bReady)\n\t{\n\t\treturn;\n\t}\n\n\tif (((CComboBox*)GetDlgItem(IDC_COMBO_VIDEOCHL))->GetCount() < 0)\n\t{\n\t\treturn;\n\t}\n\n\t//show\n\t((CComboBox*)GetDlgItem(IDC_COMBO_VIDEOCHL))->SetCurSel(0);\n\tOnSelchangeComboVideochl();\n}\n\nBOOL CConfigAlarmBlind::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\t\n\tif (!m_pDev)\n\t{\n\t\treturn TRUE;\n\t}\n\n\tCString strBlind;\n\tint i = 0;\n\tfor (i = 0; i < m_pDev->Info.byChanNum; i++)\n\t{\n\t\tstrBlind.Format(ConvertString(\"Channel %d\"), i+1);\n\t\t((CComboBox*)GetDlgItem(IDC_COMBO_VIDEOCHL))->InsertString(i, strBlind);\n\t}\n\tfor (int j = 15; j >= m_pDev->Info.byAlarmOutPortNum; j--)\n\t{\n\t\tGetDlgItem(IDC_CHECK_ALMOP1+j)->ShowWindow(SW_HIDE);\n\t}\n\tfor (int k = 15; k >= m_pDev->Info.byChanNum; k--)\n\t{\n\t\tGetDlgItem(IDC_CHECK_RECCH1+k)->ShowWindow(SW_HIDE);\n\t}\n\t\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(0, ConvertString(\"Sunday\"));\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(1, ConvertString(\"Monday\"));\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(2, ConvertString(\"Tuesday\"));\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(3, ConvertString(\"Wedensday\"));\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(4, ConvertString(\"Thursday\"));\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(5, ConvertString(\"Friday\"));\n\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->InsertString(6, ConvertString(\"Saturday\"));\n\t\n\tCString strChl;\n\tfor (int l = 0; l < m_pDev->Info.byChanNum; l++)\n\t{\n\t\tstrChl.Format(ConvertString(\"channel %d\"), i+1);\n\t\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMPTZCHL))->InsertString(i, strChl);\n\t}\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CConfigAlarmBlind::OnShowWindow(BOOL bShow, UINT nStatus) \n{\n\tCDialog::OnShowWindow(bShow, nStatus);\n\t\n\tShowConfig();\n}\n\nvoid CConfigAlarmBlind::OnSelchangeComboVideochl() \n{\n\tif (!m_bReady)\n\t{\n\t\treturn;\n\t}\n\tint i,j,k;\n\n\t//store current config\n\tif (m_chlIdx < 0)\n\t{\n\t\tgoto skipsave;\n\t}\n\tm_blindCFG[m_chlIdx].byBlindEnable = ((CButton*)GetDlgItem(IDC_CHECK_BLINDENABLE))->GetCheck();\n\tm_blindCFG[m_chlIdx].byBlindLevel = GetDlgItemInt(IDC_EDIT_SENSELVL);\n\t\n\tif (m_weekIdx >= 0)\n\t{\n\t\tint secIdx = 0;\n\t\tfor (i = 0; i < 6; i++)\n\t\t{\n\t\t\tm_blindCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_blindCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_blindCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\t\n\t\t\tm_blindCFG[m_chlIdx].stSect[m_weekIdx][i].iEndHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_blindCFG[m_chlIdx].stSect[m_weekIdx][i].iEndMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_blindCFG[m_chlIdx].stSect[m_weekIdx][i].iEndSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t}\n\t}\n\t\n\tm_blindCFG[m_chlIdx].struHandle.dwActionFlag = 0;\n\tm_blindCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_UPLOAD))->GetCheck()?DH_ALARM_UPLOAD:0;\n\tm_blindCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_LOCALTIP))->GetCheck()?DH_ALARM_TIP:0;\n\tm_blindCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_LOCALTOUR))->GetCheck()?DH_ALARM_TOUR:0;\n\tm_blindCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_SENDMAIL))->GetCheck()?DH_ALARM_MAIL:0;\n\tm_blindCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_PTZ))->GetCheck()?DH_ALARM_PTZ:0;\n\tm_blindCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_RECORD))->GetCheck()?DH_ALARM_RECORD:0;\n\tm_blindCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_OUTPUT))->GetCheck()?DH_ALARM_OUT:0;\n\n\tfor (j = 0; j < m_pDev->Info.byAlarmOutPortNum; j++)\n\t{\n\t\tm_blindCFG[m_chlIdx].struHandle.byRelAlarmOut[j] = ((CButton*)GetDlgItem(IDC_CHECK_ALMOP1+j))->GetCheck();\n\t}\n\n\tfor (k = 0; k < m_pDev->Info.byChanNum; k++)\n\t{\n\t\tm_blindCFG[m_chlIdx].struHandle.byRecordChannel[k] = ((CButton*)GetDlgItem(IDC_CHECK_RECCH1+k))->GetCheck();\n\t}\n\n\tif (m_ptzchlIdx >= 0)\n\t{\n\t\tm_blindCFG[m_chlIdx].struHandle.struPtzLink[m_ptzchlIdx].iType = ((CComboBox*)GetDlgItem(IDC_CHECK_PTZ))->GetCurSel();\n\t\tm_blindCFG[m_chlIdx].struHandle.struPtzLink[m_ptzchlIdx].iValue = GetDlgItemInt(IDC_EDIT_PTZNO);\n\t}\n\t\nskipsave:\n\t//show new ones\n\tint chlIdx = ((CComboBox*)GetDlgItem(IDC_COMBO_VIDEOCHL))->GetCurSel();\n\tif (chlIdx < 0 || ((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->GetCount() < 0)\n\t{\n\t\treturn;\n\t}\n\n\tm_chlIdx = chlIdx;\n\t((CButton*)GetDlgItem(IDC_CHECK_BLINDENABLE))->SetCheck(m_blindCFG[chlIdx].byBlindEnable?1:0);\n\tSetDlgItemInt(IDC_EDIT_SENSELVL, m_blindCFG[chlIdx].byBlindLevel);\n\t\n\tif (((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->GetCount() > 0)\n\t{\n\t\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->SetCurSel(0);\n\t\tm_weekIdx = -1; //prevent from unwanted saving\n\t\tOnSelchangeComboAlarmweek() ;\n\t}\n\t\n\t((CButton*)GetDlgItem(IDC_CHECK_UPLOAD))->SetCheck((m_blindCFG[chlIdx].struHandle.dwActionFlag&DH_ALARM_UPLOAD)?1:0);\n\t((CButton*)GetDlgItem(IDC_CHECK_LOCALTIP))->SetCheck((m_blindCFG[chlIdx].struHandle.dwActionFlag&DH_ALARM_TIP)?1:0);\n\t((CButton*)GetDlgItem(IDC_CHECK_LOCALTOUR))->SetCheck((m_blindCFG[chlIdx].struHandle.dwActionFlag&DH_ALARM_TOUR)?1:0);\n\t((CButton*)GetDlgItem(IDC_CHECK_SENDMAIL))->SetCheck((m_blindCFG[chlIdx].struHandle.dwActionFlag&DH_ALARM_MAIL)?1:0);\n\t((CButton*)GetDlgItem(IDC_CHECK_PTZ))->SetCheck((m_blindCFG[chlIdx].struHandle.dwActionFlag&DH_ALARM_PTZ)?1:0);\n\t((CButton*)GetDlgItem(IDC_CHECK_RECORD))->SetCheck((m_blindCFG[chlIdx].struHandle.dwActionFlag&DH_ALARM_RECORD)?1:0);\n\t((CButton*)GetDlgItem(IDC_CHECK_OUTPUT))->SetCheck((m_blindCFG[chlIdx].struHandle.dwActionFlag&DH_ALARM_OUT)?1:0);\n\t\n\tfor (j = 0; j < m_pDev->Info.byAlarmOutPortNum; j++)\n\t{\n\t\t((CButton*)GetDlgItem(IDC_CHECK_ALMOP1+j))->SetCheck(m_blindCFG[chlIdx].struHandle.byRelAlarmOut[j]?1:0);\n\t}\n\n\tfor (k = 0; k < m_pDev->Info.byChanNum; k++)\n\t{\n\t\t((CButton*)GetDlgItem(IDC_CHECK_RECCH1+k))->SetCheck(m_blindCFG[chlIdx].struHandle.byRecordChannel[k]?1:0);\n\t}\n\n\tif (((CComboBox*)GetDlgItem(IDC_COMBO_ALARMPTZCHL))-> GetCount() > 0)\n\t{\n\t\t((CComboBox*)GetDlgItem(IDC_COMBO_ALARMPTZCHL))-> SetCurSel(0);\n\t\tm_ptzchlIdx = -1; //prevent from unwanted saving\n\t\tOnSelchangeComboAlarmptzchl();\n\t}\n}\n\nvoid CConfigAlarmBlind::OnSelchangeComboAlarmweek() \n{\n\tif (!m_bReady || m_chlIdx < 0)\n\t{\n\t\treturn;\n\t}\n\n\t//store current time sectors\n\tif (m_weekIdx >= 0)\n\t{\n\t\tint secIdx = 0;\n\t\tfor (int i = 0; i < 6; i++)\n\t\t{\n\t\t\tm_blindCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_blindCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_blindCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\t\n\t\t\tm_blindCFG[m_chlIdx].stSect[m_weekIdx][i].iEndHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_blindCFG[m_chlIdx].stSect[m_weekIdx][i].iEndMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_blindCFG[m_chlIdx].stSect[m_weekIdx][i].iEndSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t}\n\t}\n\n\t//show new time sectors\n\tint weekIdx = ((CComboBox*)GetDlgItem(IDC_COMBO_ALARMWEEK))->GetCurSel();\n\tif (weekIdx < 0)\n\t{\n\t\treturn;\n\t}\n\tm_weekIdx = weekIdx;\n\n\tint timeCtrlIdx = 0;\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_blindCFG[m_chlIdx].stSect[weekIdx][i].iBeginHour);\n\t\ttimeCtrlIdx++;\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_blindCFG[m_chlIdx].stSect[weekIdx][i].iBeginMin);\n\t\ttimeCtrlIdx++;\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_blindCFG[m_chlIdx].stSect[weekIdx][i].iBeginSec);\n\t\ttimeCtrlIdx++;\n\t\t\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_blindCFG[m_chlIdx].stSect[weekIdx][i].iEndHour);\n\t\ttimeCtrlIdx++;\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_blindCFG[m_chlIdx].stSect[weekIdx][i].iEndMin);\n\t\ttimeCtrlIdx++;\n\t\tSetDlgItemInt(IDC_TIME_18+timeCtrlIdx, m_blindCFG[m_chlIdx].stSect[weekIdx][i].iEndSec);\n\t\ttimeCtrlIdx++;\n\t}\n}\n\nvoid CConfigAlarmBlind::OnSelchangeComboAlarmptzchl() \n{\n\tif (!m_bReady || m_chlIdx < 0)\n\t{\n\t\treturn;\n\t}\n\n\tif (m_ptzchlIdx >= 0)\n\t{\n\t\tm_blindCFG[m_chlIdx].struHandle.struPtzLink[m_ptzchlIdx].iType = ((CComboBox*)GetDlgItem(IDC_CHECK_PTZ))->GetCurSel();\n\t\tm_blindCFG[m_chlIdx].struHandle.struPtzLink[m_ptzchlIdx].iValue = GetDlgItemInt(IDC_EDIT_PTZNO);\n\t}\n\n\tint ptzchlIdx = ((CComboBox*)GetDlgItem(IDC_COMBO_ALARMPTZCHL))-> GetCount();\n\tif (ptzchlIdx < 0)\n\t{\n\t\treturn;\n\t}\n\tm_ptzchlIdx = ptzchlIdx;\n\t((CComboBox*)GetDlgItem(IDC_CHECK_PTZ))->SetCurSel(m_blindCFG[m_chlIdx].struHandle.struPtzLink[ptzchlIdx].iType);\n\tSetDlgItemInt(IDC_EDIT_PTZNO,m_blindCFG[m_chlIdx].struHandle.struPtzLink[ptzchlIdx].iValue);\n}\n\nvoid CConfigAlarmBlind::GetBlindCFG(DH_BLIND_CFG *cfg)\n{\n\tif (!cfg || !m_bReady || m_chlIdx < 0)\n\t{\n\t\treturn;\n\t}\n\n\tm_blindCFG[m_chlIdx].byBlindEnable = ((CButton*)GetDlgItem(IDC_CHECK_BLINDENABLE))->GetCheck();\n\tm_blindCFG[m_chlIdx].byBlindLevel = GetDlgItemInt(IDC_EDIT_SENSELVL);\n\t\n\tif (m_weekIdx >= 0)\n\t{\n\t\tint secIdx = 0;\n\t\tfor (int i = 0; i < 6; i++)\n\t\t{\n\t\t\tm_blindCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_blindCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_blindCFG[m_chlIdx].stSect[m_weekIdx][i].iBeginSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\t\n\t\t\tm_blindCFG[m_chlIdx].stSect[m_weekIdx][i].iEndHour = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_blindCFG[m_chlIdx].stSect[m_weekIdx][i].iEndMin = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t\tm_blindCFG[m_chlIdx].stSect[m_weekIdx][i].iEndSec = GetDlgItemInt(IDC_TIME_18+secIdx);\n\t\t\tsecIdx++;\n\t\t}\n\t}\n\t\n\tm_blindCFG[m_chlIdx].struHandle.dwActionFlag = 0;\n\tm_blindCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_UPLOAD))->GetCheck()?DH_ALARM_UPLOAD:0;\n\tm_blindCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_LOCALTIP))->GetCheck()?DH_ALARM_TIP:0;\n\tm_blindCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_LOCALTOUR))->GetCheck()?DH_ALARM_TOUR:0;\n\tm_blindCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_SENDMAIL))->GetCheck()?DH_ALARM_MAIL:0;\n\tm_blindCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_PTZ))->GetCheck()?DH_ALARM_PTZ:0;\n\tm_blindCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_RECORD))->GetCheck()?DH_ALARM_RECORD:0;\n\tm_blindCFG[m_chlIdx].struHandle.dwActionFlag |= ((CButton*)GetDlgItem(IDC_CHECK_OUTPUT))->GetCheck()?DH_ALARM_OUT:0;\n\n\tfor (int j = 0; j < m_pDev->Info.byAlarmOutPortNum; j++)\n\t{\n\t\tm_blindCFG[m_chlIdx].struHandle.byRelAlarmOut[j] = ((CButton*)GetDlgItem(IDC_CHECK_ALMOP1+j))->GetCheck();\n\t}\n\n\tfor (int k = 0; k < m_pDev->Info.byChanNum; k++)\n\t{\n\t\tm_blindCFG[m_chlIdx].struHandle.byRecordChannel[k] = ((CButton*)GetDlgItem(IDC_CHECK_RECCH1+k))->GetCheck();\n\t}\n\n\tif (m_ptzchlIdx >= 0)\n\t{\n\t\tm_blindCFG[m_chlIdx].struHandle.struPtzLink[m_ptzchlIdx].iType = ((CComboBox*)GetDlgItem(IDC_CHECK_PTZ))->GetCurSel();\n\t\tm_blindCFG[m_chlIdx].struHandle.struPtzLink[m_ptzchlIdx].iValue = GetDlgItemInt(IDC_EDIT_PTZNO);\n\t}\n\n\tmemcpy(cfg, m_blindCFG, DH_MAX_ALARM_IN_NUM*sizeof(DH_BLIND_CFG));\n}\n\nvoid CConfigAlarmBlind::UndoAll()\n{\n\tm_bReady = FALSE;\n\tm_chlIdx = -1;\n\tm_weekIdx = -1;\n\tm_ptzchlIdx = -1;\n}\n","size_bytes":14409},"bin/Demo/MfcDemo/18.IntelligentDevice/stdafx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n// IntelligentDevice.pch will be the pre-compiled header\n// stdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n\n\n","size_bytes":210},"bin/Demo/MfcDemo/13.FaceRecognition/FaceRecognitionDlg.cpp":{"content":"// FaceRecognitionDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"FaceRecognition.h\"\n#include \"FaceRecognitionDlg.h\"\n#include \"FaceDbOpreate.h\"\n#include <atlconv.h>\n#include <assert.h>\n#include \"SearchByPic.h\"\n#include \"QueryDownLoad.h\"\n// #include <winuser.h>\n// #include <crtdbg.h>\n// #include <OLE2.H>\n// #include <ocidl.h>\n// #include <olectl.h>\n// #include <shlwapi.h>\n// \n// #pragma comment(lib, \"Shlwapi.lib\");\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\nstruct strAnalyInfo\n{\n\tLLONG lAnalyzerHandle;\n\tDWORD dwAlarmType;\n\tvoid* pAlarmInfo;\n\tBYTE *pBuffer;\n\tDWORD dwBufSize;\n};\n\n#define WM_DEVICE_DOATTACH\t\t(WM_USER + 110)\n#define WM_DEVICE_DISCONNECT\t(WM_USER + 111)\n#define WM_DEVICE_RECONNECT\t\t(WM_USER + 112)\n\n/////////////////////////////////////////////////////////////////////////////\n// CAboutDlg dialog used for App About\n\nclass CAboutDlg : public CDialog\n{\npublic:\n\tCAboutDlg();\n\n// Dialog Data\n\t//{{AFX_DATA(CAboutDlg)\n\tenum { IDD = IDD_ABOUTBOX };\n\t//}}AFX_DATA\n\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CAboutDlg)\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n\t//}}AFX_VIRTUAL\n\n// Implementation\nprotected:\n\t//{{AFX_MSG(CAboutDlg)\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\n};\n\nCAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)\n{\n\t//{{AFX_DATA_INIT(CAboutDlg)\n\t//}}AFX_DATA_INIT\n}\n\nvoid CAboutDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CAboutDlg)\n\t//}}AFX_DATA_MAP\n}\n\nBEGIN_MESSAGE_MAP(CAboutDlg, CDialog)\n\t//{{AFX_MSG_MAP(CAboutDlg)\n\t\t// No message handlers\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CFaceRecognitionDlg dialog\n\nCFaceRecognitionDlg::CFaceRecognitionDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CFaceRecognitionDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CFaceRecognitionDlg)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\t// Note that LoadIcon does not require a subsequent DestroyIcon in Win32\n\tm_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);\n\tm_nChnCnt = 0;\n\tm_lLoginID = 0;\n\tm_lRealPicHandle = 0;\n\tm_lRealHandle = 0;\n\tm_nFaceDetectGroupId = 0;\n\n\tm_pszSoftPath = NULL;\n\tm_pszSoftPath= new char[1024];\n\tif (m_pszSoftPath)\n\t{\n\t\tmemset(m_pszSoftPath, 0, 1024);\n\t}\n}\n\nCFaceRecognitionDlg::~CFaceRecognitionDlg()\n{\n\tif (m_pszSoftPath)\n\t{\n\t\tdelete[] m_pszSoftPath;\n\t\tm_pszSoftPath = NULL;\n\t}\n\n\tif (0 != m_lRealPicHandle)\n\t{\n\t\tBOOL bRet = CLIENT_StopLoadPic(m_lRealPicHandle);\n\t\tif (!bRet)\n\t\t{\n\t\t\tMessageBox(ConvertString(\"Failed to stop load picture!\"), \"\");\n\t\t}\n\t\tm_lRealPicHandle = 0;\n\t}\n\t\n\tif (0 != m_lRealHandle) \n\t{\n\t\tCLIENT_StopRealPlayEx(m_lRealHandle);\n\t\tm_lRealHandle = 0;\n\t}\n\n\tif (0 != m_lLoginID)\n\t{\n\t\tBOOL bRet = CLIENT_Logout(m_lLoginID);\n\t\tif (!bRet)\n\t\t{\n\t\t\tMessageBox(ConvertString(\"Failed to login out!\"), \"\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_lRealHandle = 0;\n\t\t}\n\t}\n\t\n\tCLIENT_Cleanup();\n}\n\nvoid CFaceRecognitionDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CFaceRecognitionDlg)\n\tDDX_Control(pDX, IDC_COMBO_CHANNEL, m_comboChannel);\n\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n\tDDX_Control(pDX, IDC_STATIC_BIG_PIC, m_pBicPic);\n\tDDX_Control(pDX, IDC_STATIC_CANDI1, m_pCandiPic);\n\tDDX_Control(pDX, IDC_STATIC_PERSON1, m_pFacePic);\n}\n\nBEGIN_MESSAGE_MAP(CFaceRecognitionDlg, CDialog)\n\t//{{AFX_MSG_MAP(CFaceRecognitionDlg)\n\tON_WM_SYSCOMMAND()\n\tON_WM_PAINT()\n\tON_WM_QUERYDRAGICON()\n\tON_BN_CLICKED(IDC_BUTTON_LOGIN, OnButtonLogin)\n\tON_BN_CLICKED(IDC_BUTTON_ATTACH, OnButtonAttachOrDeteach)\n\tON_BN_CLICKED(IDC_BUTTON_DETEACH, OnButtonDeteach)\n\tON_BN_CLICKED(IDC_BUTTON_FACE_DB, OnButtonFaceDb)\n\t//}}AFX_MSG_MAP\n\tON_BN_CLICKED(IDC_BUTTON_REALPLAY, &CFaceRecognitionDlg::OnBnClickedButtonRealplay)\n\tON_BN_CLICKED(IDC_BUTTON_QUERY_DOWNLOAD, &CFaceRecognitionDlg::OnBnClickedButtonQueryDownload)\n\tON_BN_CLICKED(IDC_BUTTON_SearchByPic, &CFaceRecognitionDlg::OnBnClickedButtonSearchbypic)\n\n\tON_MESSAGE(WM_DEVICE_DOATTACH, &CFaceRecognitionDlg::DoDeviceAttach)\n\tON_MESSAGE(WM_DEVICE_DISCONNECT, &CFaceRecognitionDlg::OnDisConnect)\n\tON_MESSAGE(WM_DEVICE_RECONNECT, &CFaceRecognitionDlg::OnReConnect)\n\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CFaceRecognitionDlg message handlers\n\nvoid CALLBACK DisConnectFunc(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser)\n{\n\tif(dwUser == 0)\n\t{\n\t\treturn;\n\t}\n\n\tCFaceRecognitionDlg *pThis = (CFaceRecognitionDlg *)dwUser;\n\tHWND hWnd = pThis->GetSafeHwnd();\n\tif (NULL == hWnd)\n\t{\n\t\treturn;\n\t}\n\t::PostMessage(hWnd, WM_DEVICE_DISCONNECT, NULL, NULL);\n}\n\nvoid CALLBACK ReConnectFunc(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser)\n{\n\tif(dwUser == 0)\n\t{\n\t\treturn;\n\t}\n\n\tCFaceRecognitionDlg *pThis = (CFaceRecognitionDlg *)dwUser;\n\tHWND hWnd = pThis->GetSafeHwnd();\n\tif (NULL == hWnd)\n\t{\n\t\treturn;\n\t}\n\t::PostMessage(hWnd, WM_DEVICE_RECONNECT, NULL, NULL);\t\n}\n\nvoid CFaceRecognitionDlg::ShowLoginErrorReason(int nError)\n{\n\tif(1 == nError)\t\tMessageBox(ConvertString(\"incorrect password!\"), ConvertString(\"Prompt\"));\n\telse if(2 == nError)\tMessageBox(ConvertString(\"no this account!\"), ConvertString(\"Prompt\"));\n\telse if(3 == nError)\tMessageBox(ConvertString(\"time out!\"), ConvertString(\"Prompt\"));\n\telse if(4 == nError)\tMessageBox(ConvertString(\"account have been logined!\"), ConvertString(\"Prompt\"));\n\telse if(5 == nError)\tMessageBox(ConvertString(\"account have been locked!\"), ConvertString(\"Prompt\"));\n\telse if(6 == nError)\tMessageBox(ConvertString(\"The user has listed into illegal!\"), ConvertString(\"Prompt\"));\n\telse if(7 == nError)\tMessageBox(ConvertString(\"The system is busy!\"), ConvertString(\"Prompt\"));\n\telse if(9 == nError)\tMessageBox(ConvertString(\"You Can't find the network server!\"), ConvertString(\"Prompt\"));\n\telse if(10 == nError)\tMessageBox(ConvertString(\"More than the maximum number of connections!\"), ConvertString(\"Prompt\"));\n\telse\tMessageBox(ConvertString(\"Login falied!\"), ConvertString(\"Prompt\"));\n}\n\n\nBOOL CFaceRecognitionDlg::OnInitDialog()\n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\n\t// Add \"About...\" menu item to system menu.\n\n\t// IDM_ABOUTBOX must be in the system command range.\n\tASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);\n\tASSERT(IDM_ABOUTBOX < 0xF000);\n\n\tCMenu* pSysMenu = GetSystemMenu(FALSE);\n\tif (pSysMenu != NULL)\n\t{\n\t\tCString strAboutMenu;\n\t\tstrAboutMenu.LoadString(IDS_ABOUTBOX);\n\t\tif (!strAboutMenu.IsEmpty())\n\t\t{\n\t\t\tpSysMenu->AppendMenu(MF_SEPARATOR);\n\t\t\tpSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);\n\t\t}\n\t}\n\n\t// Set the icon for this dialog.  The framework does this automatically\n\t//  when the application's main window is not a dialog\n\tSetIcon(m_hIcon, TRUE);\t\t\t// Set big icon\n\tSetIcon(m_hIcon, FALSE);\t\t// Set small icon\n\t\n\t// TODO: Add extra initialization here\n\tSetDlgItemText(IDC_IPADDRESS, \"172.23.12.30\");\n\tSetDlgItemText(IDC_EDIT_PORT, \"37777\");\n\tSetDlgItemText(IDC_EDIT_USER, \"admin\");\n\tSetDlgItemText(IDC_EDIT_PASS, \"admin123\");\n\t\n\tGetDlgItem(IDC_BUTTON_LOGIN)->EnableWindow(TRUE);\n\n\tGetDlgItem(IDC_BUTTON_ATTACH)->EnableWindow(FALSE);\n\tGetDlgItem(IDC_BUTTON_FACE_DB)->EnableWindow(FALSE);\n\tGetDlgItem(IDC_BUTTON_REALPLAY)->EnableWindow(FALSE);\n\tGetDlgItem(IDC_BUTTON_QUERY_DOWNLOAD)->EnableWindow(FALSE);\n\tGetDlgItem(IDC_BUTTON_SearchByPic)->EnableWindow(FALSE);\n\n\tFillCWndWithDefaultColor(GetDlgItem(IDC_STATIC_BIG_PIC));\n\tFillCWndWithDefaultColor(GetDlgItem(IDC_STATIC_PERSON1));\n\tFillCWndWithDefaultColor(GetDlgItem(IDC_STATIC_CANDI1));\n\n\tInitSdk();\n\treturn TRUE;  // return TRUE  unless you set the focus to a control\n}\n\nvoid CFaceRecognitionDlg::InitSdk()\n{\n\tBOOL ret = CLIENT_Init(DisConnectFunc, (LDWORD)this);\n\tif (!ret)\n\t{\n\t\tMessageBox(ConvertString(\"Initialize SDK failed!\"), ConvertString(\"Prompt\"));\n\t}\n\telse\n\t{\n\t\tCLIENT_SetAutoReconnect(ReConnectFunc, (LDWORD)this);\n\t}\n}\n\n//Process when device disconnected \nLRESULT CFaceRecognitionDlg::OnDisConnect(WPARAM wParam, LPARAM lParam)\n{\n\t//The codes need to be processed when device disconnected\n\tSetWindowText(ConvertString(\"Network disconnected!\"));\n\treturn 0;\n}\n\n//Process when device reconnect\nLRESULT CFaceRecognitionDlg::OnReConnect(WPARAM wParam, LPARAM lParam)\n{\n\t//The codes need to be processed when device reconnect\n\tSetWindowText(ConvertString(\"FaceRecognition\"));\n\treturn 0;\n}\n\nvoid CFaceRecognitionDlg::OnSysCommand(UINT nID, LPARAM lParam)\n{\n\tif ((nID & 0xFFF0) == IDM_ABOUTBOX)\n\t{\n\t\tCAboutDlg dlgAbout;\n\t\tdlgAbout.DoModal();\n\t}\n\telse\n\t{\n\t\tCDialog::OnSysCommand(nID, lParam);\n\t}\n}\n\n// If you add a minimize button to your dialog, you will need the code below\n//  to draw the icon.  For MFC applications using the document/view model,\n//  this is automatically done for you by the framework.\n\nvoid CFaceRecognitionDlg::OnPaint() \n{\n\tif (IsIconic())\n\t{\n\t\tCPaintDC dc(this); // device context for painting\n\n\t\tSendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);\n\n\t\t// Center icon in client rectangle\n\t\tint cxIcon = GetSystemMetrics(SM_CXICON);\n\t\tint cyIcon = GetSystemMetrics(SM_CYICON);\n\t\tCRect rect;\n\t\tGetClientRect(&rect);\n\t\tint x = (rect.Width() - cxIcon + 1) / 2;\n\t\tint y = (rect.Height() - cyIcon + 1) / 2;\n\n\t\t// Draw the icon\n\t\tdc.DrawIcon(x, y, m_hIcon);\n\t}\n\telse\n\t{\t\n\t\tCDialog::OnPaint();\n\t}\n}\n\n// The system calls this to obtain the cursor to display while the user drags\n//  the minimized window.\nHCURSOR CFaceRecognitionDlg::OnQueryDragIcon()\n{\n\treturn (HCURSOR) m_hIcon;\n}\n\nvoid CFaceRecognitionDlg::OnButtonLoginIn()\n{\n\tCString strIp;\n\tCString strUser;\n\tCString strPwd;\n\tint\t\tnPort;\n\n\tGetDlgItemText(IDC_IPADDRESS, strIp);\n\tGetDlgItemText(IDC_EDIT_USER, strUser);\n\tGetDlgItemText(IDC_EDIT_PASS, strPwd);\n\tnPort = GetDlgItemInt(IDC_EDIT_PORT);\n\n\tchar *pcIP = (LPSTR)(LPCSTR)strIp;\n\tchar *pcUser = (LPSTR)(LPCSTR)strUser;\n\tchar *pcPwssd = (LPSTR)(LPCSTR)strPwd;\n\n\tint nError = 0;\n\n\tNET_DEVICEINFO_Ex deviceInfo = {0};\n\tm_lLoginID = CLIENT_LoginEx2(pcIP, nPort, pcUser, pcPwssd, EM_LOGIN_SPEC_CAP_TCP, NULL, &deviceInfo, &nError);\n\tif (0 == m_lLoginID)\n\t{\n\t\tShowLoginErrorReason(nError);\n\t}\n\telse\n\t{\n\n\t\tSetDlgItemText(IDC_BUTTON_LOGIN, ConvertString(\"Logout\"));\n\n\t\t// Get the program path\n\t\tint filelen = GetModuleFileName(NULL, m_pszSoftPath, 1024);\n\t\tint k = filelen;\n\t\twhile (*(m_pszSoftPath+k) != '\\\\')\n\t\t{\n\t\t\tk--;\n\t\t}\n\t\t*(m_pszSoftPath+(k+1)) = '\\0';\n\n\t\t// create the floder to save face picture\n\t\tCString str = \"\\\\Face\";\n\t\tCString DownLoad = \"\\\\DownLoad\";\n\t\tDownLoad = m_pszSoftPath + DownLoad;\t\t// DwonLoad path\n\t\tstr = m_pszSoftPath + str;\n\t\tBOOL bCreate = CreateDirectory(str, NULL);\n\t\tBOOL bCreateDownLoad = CreateDirectory(DownLoad, NULL);\n\t\tif (bCreate && bCreateDownLoad)\n\t\t{\n\t\t\tCString Candidate = str + \"\\\\Candidate\"; // Save Contrast diagram path\n\t\t\tCString Global = str + \"\\\\Global\";\t\t // Save Global picture path\n\t\t\tCString Person = str + \"\\\\Person\";\t\t // Save Face Picture path\n\t\t\tCString RemoteFace = str + \"\\\\RemoteFace\"; // Save picture which search by picture path\n\n\t\t\tCString DwonLoadVideo = DownLoad + \"\\\\FaceVideo\";\t\t//FaveVideo Download path\n\t\t\tCString DwonLoadFaceDetection = DownLoad + \"\\\\FaceDetection\";\t\t//FaceDetection Download path\n\t\t\tCString DwonLoadFaceRecognition = DownLoad + \"\\\\FaceRecognition\";\t\t//FaceRecognition Download path\n\n\t\t\tCreateDirectory(Candidate, NULL);\n\t\t\tCreateDirectory(Global, NULL);\n\t\t\tCreateDirectory(Person, NULL);\n\t\t\tCreateDirectory(RemoteFace, NULL);\n\t\t\tCreateDirectory(DwonLoadVideo, NULL);\n\t\t\tCreateDirectory(DwonLoadFaceDetection, NULL);\n\t\t\tCreateDirectory(DwonLoadFaceRecognition, NULL);\n\t\t}\n\n\t\tGetDlgItem(IDC_BUTTON_ATTACH)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_BUTTON_FACE_DB)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_BUTTON_REALPLAY)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_BUTTON_QUERY_DOWNLOAD)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_BUTTON_SearchByPic)->EnableWindow(TRUE);\n\n\t\tm_nChnCnt = deviceInfo.nChanNum; // Total number of channels\n\t\tint nIndex = 0;\n\t\tm_comboChannel.ResetContent();\n\t\tfor(int i = 1;i <= m_nChnCnt;i++)\n\t\t{\n\t\t\tCString str;\n\t\t\tstr.Format(\"%d\",i);\n\t\t\tnIndex = m_comboChannel.AddString(str);\n\t\t\tm_comboChannel.SetItemData(nIndex,i);\n\t\t}\n\t\tm_comboChannel.SetCurSel(0);\n\t}\n}\nvoid CFaceRecognitionDlg::OnButtonLogin() \n{\n\tBOOL bValid = UpdateData(TRUE);\n\tif (bValid)\n\t{\n\t\tCString strButton;\n\t\tGetDlgItemText(IDC_BUTTON_LOGIN, strButton);\n\t\tif (strButton == ConvertString(\"Login\"))\n\t\t{\n\t\t\tOnButtonLoginIn();\n\t\t}\n\t\telse if (strButton == ConvertString(\"Logout\"))\n\t\t{\n\t\t\tOnButtonLoginOut();\n\t\t}\n\t}\n}\n\nvoid CFaceRecognitionDlg::FillCWndWithDefaultColor(CWnd* cwnd) \n{\n\tif (NULL == cwnd)\n\t{\n\t\treturn;\n\t}\n\n\tCDC* cdc = cwnd->GetDC();\n\tif (NULL == cdc)\n\t{\n\t\treturn;\n\t}\n\n\tRECT rect;\n\tcwnd->GetClientRect(&rect);\n\tCBrush brush(RGB(105,105,105));\n\tcdc->FillRect(&rect, &brush);\n\tcwnd->ReleaseDC(cdc);\n}\n\nvoid CFaceRecognitionDlg::ClearShowEventInfo()\n{\n\tSetDlgItemText(IDC_EVENT_TYPE, ConvertString(\"(Event Type)\"));\n\tSetDlgItemText(IDC_EDIT_EVENT_TIME, ConvertString(\"\"));\n\tSetDlgItemText(IDC_EDIT_SEX, ConvertString(\"\"));\n\tSetDlgItemText(IDC_EDIT_AGE, ConvertString(\"\"));\n\tSetDlgItemText(IDC_EDIT_RACE, ConvertString(\"\"));\n\tSetDlgItemText(IDC_EDIT_EYE, ConvertString(\"\"));\n\tSetDlgItemText(IDC_EDIT_MOUTH, ConvertString(\"\"));\n\tSetDlgItemText(IDC_EDIT_MASK, ConvertString(\"\"));\n\tSetDlgItemText(IDC_EDIT_BEARD, ConvertString(\"\"));\n\tSetDlgItemText(IDC_EDIT_PERSON_NAME, ConvertString(\"\"));\n\tSetDlgItemText(IDC_EDIT_SEX2, ConvertString(\"\"));\n\tSetDlgItemText(IDC_EDIT_BIRTHDAY, ConvertString(\"\"));\n\tSetDlgItemText(IDC_EDIT_GROUP_ID, ConvertString(\"\"));\n\tSetDlgItemText(IDC_EDIT_GROUP_NAME, ConvertString(\"\"));\n\tSetDlgItemText(IDC_EDIT_SIMILARITY, ConvertString(\"\"));\n}\n\nvoid CFaceRecognitionDlg::ShowFaceDataInfo(NET_FACE_DATA *pstDataInfo)\n{\n\tif (NULL == pstDataInfo)\n\t{\n\t\treturn;\n\t}\n\tif (pstDataInfo->emSex == EM_DEV_EVENT_FACEDETECT_SEX_TYPE_UNKNOWN)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_SEX, ConvertString(\"Unknown\"));\n\t}\n\telse if (pstDataInfo->emSex == EM_DEV_EVENT_FACEDETECT_SEX_TYPE_MAN)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_SEX, ConvertString(\"Male\"));\n\t}\n\tif (pstDataInfo->emSex == EM_DEV_EVENT_FACEDETECT_SEX_TYPE_WOMAN)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_SEX, ConvertString(\"Female\"));\n\t}\n\n\tif (pstDataInfo->nAge > 0)\n\t{\n\t\tSetDlgItemInt(IDC_EDIT_AGE, pstDataInfo->nAge);\n\t}\n\telse\n\t{\n\t\tSetDlgItemText(IDC_EDIT_AGE, ConvertString(\"Unknown\"));\n\t}\n\n\tif (pstDataInfo->emRace == EM_RACE_YELLOW)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_RACE, ConvertString(\"Yellow\"));\n\t}\n\telse if (pstDataInfo->emRace == EM_RACE_BLACK)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_RACE, ConvertString(\"Black\"));\n\t}\n\telse if (pstDataInfo->emRace == EM_RACE_WHITE)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_RACE, ConvertString(\"White\"));\n\t}\n\telse\n\t{\n\t\tSetDlgItemText(IDC_EDIT_RACE, ConvertString(\"Unknown\"));\n\t}\n\n\tif (pstDataInfo->emEye == EM_EYE_STATE_CLOSE)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_EYE, ConvertString(\"Close Eyes\"));\n\t}\n\telse if (pstDataInfo->emEye == EM_EYE_STATE_OPEN)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_EYE, ConvertString(\"Open Eyes\"));\n\t}\n\telse\n\t{\n\t\tSetDlgItemText(IDC_EDIT_EYE, ConvertString(\"Unknown\"));\n\t}\n\n\tif (pstDataInfo->emMouth == EM_MOUTH_STATE_CLOSE)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_MOUTH, ConvertString(\"Close Mouth\"));\n\t}\n\telse if (pstDataInfo->emMouth == EM_MOUTH_STATE_OPEN)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_MOUTH, ConvertString(\"Open Mouth\"));\n\t}\n\telse\n\t{\n\t\tSetDlgItemText(IDC_EDIT_MOUTH, ConvertString(\"Unknown\"));\n\t}\n\n\tif (pstDataInfo->emMask == EM_MASK_STATE_NOMASK)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_MASK, ConvertString(\"Not Wear\"));\n\t}\n\telse if (pstDataInfo->emMask == EM_MASK_STATE_WEAR)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_MASK, ConvertString(\"Wear\"));\n\t}\n\telse\n\t{\n\t\tSetDlgItemText(IDC_EDIT_MASK, ConvertString(\"Unknown\"));\n\t}\n\n\tif (pstDataInfo->emBeard == EM_BEARD_STATE_NOBEARD)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_BEARD, ConvertString(\"No Beard\"));\n\t}\n\telse if (pstDataInfo->emBeard == EM_BEARD_STATE_HAVEBEARD)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_BEARD, ConvertString(\"Have Beard\"));\n\t}\n\telse\n\t{\n\t\tSetDlgItemText(IDC_EDIT_BEARD, ConvertString(\"Unknown\"));\n\t}\n}\n\nvoid CFaceRecognitionDlg::ShowFaceDataInfo(DEV_EVENT_FACEDETECT_INFO *pstDataInfo)\n{\n\tif (NULL == pstDataInfo)\n\t{\n\t\treturn;\n\t}\n\tif (pstDataInfo->emSex == EM_DEV_EVENT_FACEDETECT_SEX_TYPE_UNKNOWN)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_SEX, ConvertString(\"Unknown\"));\n\t}\n\telse if (pstDataInfo->emSex == EM_DEV_EVENT_FACEDETECT_SEX_TYPE_MAN)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_SEX, ConvertString(\"Male\"));\n\t}\n\tif (pstDataInfo->emSex == EM_DEV_EVENT_FACEDETECT_SEX_TYPE_WOMAN)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_SEX, ConvertString(\"Female\"));\n\t}\n\n\tif (pstDataInfo->nAge > 0)\n\t{\n\t\tSetDlgItemInt(IDC_EDIT_AGE, pstDataInfo->nAge);\n\t}\n\telse\n\t{\n\t\tSetDlgItemText(IDC_EDIT_AGE, ConvertString(\"Unknown\"));\n\t}\n\n\tif (pstDataInfo->emRace == EM_RACE_YELLOW)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_RACE, ConvertString(\"Yellow\"));\n\t}\n\telse if (pstDataInfo->emRace == EM_RACE_BLACK)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_RACE, ConvertString(\"Black\"));\n\t}\n\telse if (pstDataInfo->emRace == EM_RACE_WHITE)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_RACE, ConvertString(\"White\"));\n\t}\n\telse\n\t{\n\t\tSetDlgItemText(IDC_EDIT_RACE, ConvertString(\"Unknown\"));\n\t}\n\n\tif (pstDataInfo->emEye == EM_EYE_STATE_CLOSE)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_EYE, ConvertString(\"Close Eyes\"));\n\t}\n\telse if (pstDataInfo->emEye == EM_EYE_STATE_OPEN)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_EYE, ConvertString(\"Open Eyes\"));\n\t}\n\telse\n\t{\n\t\tSetDlgItemText(IDC_EDIT_EYE, ConvertString(\"Unknown\"));\n\t}\n\n\tif (pstDataInfo->emMouth == EM_MOUTH_STATE_CLOSE)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_MOUTH, ConvertString(\"Close Mouth\"));\n\t}\n\telse if (pstDataInfo->emMouth == EM_MOUTH_STATE_OPEN)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_MOUTH, ConvertString(\"Open Mouth\"));\n\t}\n\telse\n\t{\n\t\tSetDlgItemText(IDC_EDIT_MOUTH, ConvertString(\"Unknown\"));\n\t}\n\n\tif (pstDataInfo->emMask == EM_MASK_STATE_NOMASK)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_MASK, ConvertString(\"Not Wear\"));\n\t}\n\telse if (pstDataInfo->emMask == EM_MASK_STATE_WEAR)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_MASK, ConvertString(\"Wear\"));\n\t}\n\telse\n\t{\n\t\tSetDlgItemText(IDC_EDIT_MASK, ConvertString(\"Unknown\"));\n\t}\n\n\tif (pstDataInfo->emBeard == EM_BEARD_STATE_NOBEARD)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_BEARD, ConvertString(\"No Beard\"));\n\t}\n\telse if (pstDataInfo->emBeard == EM_BEARD_STATE_HAVEBEARD)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_BEARD, ConvertString(\"Have Beard\"));\n\t}\n\telse\n\t{\n\t\tSetDlgItemText(IDC_EDIT_BEARD, ConvertString(\"Unknown\"));\n\t}\n}\n\nvoid CFaceRecognitionDlg::ShowFaceDetectPicture(DEV_EVENT_FACEDETECT_INFO *pstInfo, BYTE *pBuffer, DWORD dwBufSize)\n{\n\tif (NULL == pstInfo)\n\t{\n\t\treturn;\n\t}\n\n\tchar szPicName[128] = {0};\n\n\tif (m_nFaceDetectGroupId != pstInfo->stuObject.nRelativeID) // \n\t//if (m_nFaceDetectGroupId != pstInfo->stuFileInfo.nGroupId)\n\t{\n\t\tm_nFaceDetectGroupId = pstInfo->stuObject.nObjectID;\n\t\tif ((dwBufSize > 0) && pBuffer)\n\t\t{\n\t\t\tstd::string filepath(m_pszSoftPath);\n\t\t\tfilepath += \"Face\\\\Global\\\\GlobalFace.jpg\";\n\n\t\t\tFILE *fPic = fopen(filepath.c_str(), \"wb+\");\n\t\t\tif (fPic)\n\t\t\t{\n\t\t\t\tfwrite(pBuffer, 1, dwBufSize, fPic);\n\t\t\t\tfclose(fPic);\n\n\t\t\t\t// Display global picture\n\t\t\t\tm_pBicPic.SetImageFile(filepath.c_str());\n\t\t\t}\n\t\t}\n\t}\n\telse if (m_nFaceDetectGroupId == pstInfo->stuObject.nRelativeID) // First face \n\t//else if (m_nFaceDetectGroupId == pstInfo->stuFileInfo.nGroupId) // First face picture\n\t{\n\t\tif ((dwBufSize > 0) && pBuffer)\n\t\t{\n\t\t\tstd::string filepath(m_pszSoftPath);\n\t\t\tfilepath += \"Face\\\\Person\\\\PersonFace.jpg\";\n\n\t\t\tFILE *fPic = fopen(filepath.c_str(), \"wb+\");\n\t\t\tif (fPic)\n\t\t\t{\n\t\t\t\tfwrite(pBuffer, 1, dwBufSize, fPic);\n\t\t\t\tfclose(fPic);\n\n\t\t\t\t// Display small picture\n\t\t\t\tm_pFacePic.SetImageFile(filepath.c_str());\n\t\t\t\t//ShowFacePicture(pFileName, IDC_STATIC_PERSON1, &m_pPersonPicture);\n\t\t\t}\n\t\t\tShowFaceDataInfo(pstInfo);\n\t\t}\n\t}\n}\n\n// Display global picture\nvoid CFaceRecognitionDlg::ShowGlobalPicture(DEV_EVENT_FACERECOGNITION_INFO *pstInfo, BYTE *pBuffer)\n{\n\tchar szPicName[128] = {0};\n\tchar *pFileName = NULL;\n\n\tif (FALSE == pstInfo->bGlobalScenePic) // No global picture\n\t{\n\t\tFillCWndWithDefaultColor(GetDlgItem(IDC_STATIC_BIG_PIC));\n\t\tMessageBox(ConvertString(\"No global scene picture!\"), \"\");\n\t}\n\telse\n\t{\n\t\tDH_PIC_INFO *pGlobalPic = &(pstInfo->stuGlobalScenePicInfo);\n\t\tif ((pGlobalPic->dwFileLenth > 0) && pBuffer)\n\t\t{\n\t\t\tCString filepath(m_pszSoftPath);\n\t\t\tCString filename(\"Face\\\\Global\\\\GlobalFace.jpg\");\n\t\t\tCString strFile = filepath + filename;\n\t\t\tpFileName = strFile.GetBuffer(200);\n\t\t\tFILE *fPic = fopen(pFileName, \"wb+\");\n\t\t\tif (fPic)\n\t\t\t{\n\t\t\t\tfwrite(pBuffer + pGlobalPic->dwOffSet, 1, pGlobalPic->dwFileLenth, fPic);\n\t\t\t\tfclose(fPic);\n\t\t\t\t\n\t\t\t\t// show global picture\n\t\t\t\tm_pBicPic.SetImageFile(pFileName);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tFillCWndWithDefaultColor(GetDlgItem(IDC_STATIC_BIG_PIC));\n\n\t\t\tCString str1 = ConvertString(\"The path of global scene picture on the device is:\");\n\t\t\tmemset(szPicName, 0, sizeof(szPicName));\n\t\t\t_snprintf(szPicName, sizeof(szPicName)-1, \"%s!\", pGlobalPic->pszFilePath);\n\t\t\tCString str2(szPicName);\n\t\t\tCString str = str1+str2;\n\t\t\tMessageBox(str, \"\");\n\t\t}\n\t}\n}\n\n// Display face picture\nvoid CFaceRecognitionDlg::ShowPersonPicture(DEV_EVENT_FACERECOGNITION_INFO *pstInfo, BYTE *pBuffer)\n{\n\tchar szPicName[128] = {0};\n\tchar *pFileName = NULL;\n\n\tDH_MSG_OBJECT *pstFaceInfo = &(pstInfo->stuObject);\n\tif ((pstFaceInfo->stPicInfo.dwFileLenth >0) && pBuffer)\n\t{\n\t\tCString filepath(m_pszSoftPath);\n\t\tCString filename(\"Face\\\\Person\\\\PersonFace.jpg\");\n\t\tCString strFile = filepath + filename;\n\t\tpFileName = strFile.GetBuffer(200);\n\t\tFILE *fPic = fopen(pFileName, \"wb+\");\n\t\tif (fPic)\n\t\t{\n\t\t\tfwrite(pBuffer + pstFaceInfo->stPicInfo.dwOffSet, 1, pstFaceInfo->stPicInfo.dwFileLenth, fPic);\n\t\t\tfclose(fPic);\n\t\t\t\n\t\t\t// Display small picture\n\t\t\tm_pFacePic.SetImageFile(pFileName);\n\t\t\t//ShowFacePicture(pFileName, IDC_STATIC_PERSON1, &m_pPersonPicture);\n\t\t}\n\t}\n\telse\n\t{\n\t\tFillCWndWithDefaultColor(GetDlgItem(IDC_STATIC_PERSON1));\n\n\t\tCString str1 = ConvertString(\"The path of person picture on the device is:\");\n\t\tmemset(szPicName, 0, sizeof(szPicName));\n\t\t_snprintf(szPicName, sizeof(szPicName)-1, \"%s!\", pstFaceInfo->stPicInfo.pszFilePath);\n\t\tCString str2(szPicName);\n\t\tCString str = str1+str2;\n\t\tMessageBox(str, \"\");\n\t}\n}\n\n// Display Contrast diagram\nvoid CFaceRecognitionDlg::ShowCandidatePicture(DEV_EVENT_FACERECOGNITION_INFO *pstInfo, BYTE *pBuffer)\n{\n\tchar szPicName[128] = {0};\n\tchar *pFileName = NULL;\n\tint i = 0;\n\n\tSetDlgItemInt(IDC_EDIT_SIMILARITY, 0);\n\tSetDlgItemText(IDC_EDIT_GROUP_ID, ConvertString(\"Unknown\"));\n\tSetDlgItemText(IDC_EDIT_GROUP_NAME, ConvertString(\"Unknown\"));\n\tSetDlgItemText(IDC_EDIT_PERSON_NAME, ConvertString(\"Unknown\"));\n\tSetDlgItemText(IDC_EDIT_BIRTHDAY, ConvertString(\"Unknown\"));\n\tSetDlgItemText(IDC_EDIT_SEX2, ConvertString(\"Unknown\"));\n\tif (pstInfo->nCandidateNum <= 0)\n\t{\n\t\tSetDlgItemText(IDC_EDIT_SIMILARITY, ConvertString(\"Stranger\"));\n\t\tFillCWndWithDefaultColor(GetDlgItem(IDC_STATIC_CANDI1));\n\t}\n\telse\n\t{\n\t\tCANDIDATE_INFOEX *pstCandidate = &(pstInfo->stuCandidatesEx[0]);\n\t\tfor (i = 0; i < pstInfo->nCandidateNum; i++)\n\t\t{\n\t\t\tif (NULL != pstCandidate)\n\t\t\t{\n\t\t\t\tif (pstInfo->stuCandidatesEx[i].bySimilarity > pstCandidate->bySimilarity)\n\t\t\t\t{\n\t\t\t\t\tpstCandidate = &(pstInfo->stuCandidatesEx[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tSetDlgItemInt(IDC_EDIT_SIMILARITY, (int)pstCandidate->bySimilarity);\n\t\t\t\n\t\t//Person info\n\t\tFACERECOGNITION_PERSON_INFOEX  *pstPersonInfo = &(pstCandidate->stPersonInfo);\n\t\tif (strlen(pstPersonInfo->szGroupID) > 0)\n\t\t{\n\t\t\tSetDlgItemText(IDC_EDIT_GROUP_ID, pstPersonInfo->szGroupID);\n\t\t}\n\t\tif (strlen(pstPersonInfo->szGroupName) > 0)\n\t\t{\n\t\t\tSetDlgItemText(IDC_EDIT_GROUP_NAME, pstPersonInfo->szGroupName);\n\t\t}\n\t\tif (strlen(pstPersonInfo->szPersonName) > 0)\n\t\t{\n\t\t\tSetDlgItemText(IDC_EDIT_PERSON_NAME, pstPersonInfo->szPersonName);\n\t\t}\n\t\tchar szBirthDay[11] = {0};\n\t\t_snprintf(szBirthDay, sizeof(szBirthDay)-1, \"%04d-%02d-%02d\", pstPersonInfo->wYear, pstPersonInfo->byMonth, pstPersonInfo->byDay);\n\t\tSetDlgItemText(IDC_EDIT_BIRTHDAY, szBirthDay);\n\n\t\tif (1 == pstPersonInfo->bySex)\n\t\t{\n\t\t\tSetDlgItemText(IDC_EDIT_SEX2, ConvertString(\"Male\"));\n\t\t}\n\t\telse if (2 == pstPersonInfo->bySex)\n\t\t{\n\t\t\tSetDlgItemText(IDC_EDIT_SEX2, ConvertString(\"Female\"));\n\t\t}\n\t\t\t\n\t\tfor (int j = 0; j < pstPersonInfo->wFacePicNum && j < 1; j++) // Only report one picture\n\t\t{\n\t\t\tDH_PIC_INFO *pstFacePicInfo = &(pstPersonInfo->szFacePicInfo[j]);\n\t\t\tif ((pstFacePicInfo->dwFileLenth > 0) && pBuffer)\n\t\t\t{\t\n\t\t\t\tCString filepath(m_pszSoftPath);\n\t\t\t\tCString filename(\"Face\\\\Candidate\\\\Candidate.jpg\");\n\t\t\t\tCString strFile = filepath + filename;\n\t\t\t\tpFileName = strFile.GetBuffer(200);\n\t\t\t\tFILE *fPic = fopen(pFileName, \"wb+\");\n\t\t\t\tif (fPic)\n\t\t\t\t{\n\t\t\t\t\tfwrite(pBuffer + pstFacePicInfo->dwOffSet, 1, pstFacePicInfo->dwFileLenth, fPic);\n\t\t\t\t\tfclose(fPic);\n\t\t\t\t\t// Display Contrast diagram\n\t\t\t\t\tm_pCandiPic.SetImageFile(pFileName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFillCWndWithDefaultColor(GetDlgItem(IDC_STATIC_CANDI1+j));\n\n\t\t\t\tCString str1 = ConvertString(\"The path of candidate picture on the device is:\");\n\t\t\t\tmemset(szPicName, 0, sizeof(szPicName));\n\t\t\t\t_snprintf(szPicName, sizeof(szPicName), \"%s!\", pstCandidate->stuSceneImage.szFilePath);\n\t\t\t\tCString str2(szPicName);\n\t\t\t\tCString str = str1+str2;\n\t\t\t\tMessageBox(str, \"\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid CFaceRecognitionDlg::ClearCandidateShowInfo()\n{\n\tSetDlgItemText(IDC_EDIT_SIMILARITY, \"\");\n\tSetDlgItemText(IDC_EDIT_GROUP_ID, \"\");\n\tSetDlgItemText(IDC_EDIT_GROUP_NAME, \"\");\n\tSetDlgItemText(IDC_EDIT_PERSON_NAME, \"\");\n\tSetDlgItemText(IDC_EDIT_BIRTHDAY, \"\");\n\tSetDlgItemText(IDC_EDIT_SEX2, \"\");\n\n\tm_pCandiPic.SetImageFile(NULL);\t\n\tFillCWndWithDefaultColor(GetDlgItem(IDC_STATIC_CANDI1));\n}\n\nvoid CFaceRecognitionDlg::DoFaceData(LLONG lAnalyzerHandle, DWORD dwAlarmType, void* pAlarmInfo, BYTE *pBuffer, DWORD dwBufSize)\n{\n\tif (0 == lAnalyzerHandle || NULL == pAlarmInfo)\n\t{\n\t\tMessageBox(ConvertString(\"Invalid param!\"), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tswitch(dwAlarmType)\n\t{\n\tcase EVENT_IVS_FACERECOGNITION: // FACERECOGNITION event\n\t\t{\n\t\t\tSetDlgItemText(IDC_EVENT_TYPE, ConvertString(\"(Face Recognition)\"));\n\t\t\tDEV_EVENT_FACERECOGNITION_INFO *pstInfo = (DEV_EVENT_FACERECOGNITION_INFO *)pAlarmInfo;\n\n\t\t\tchar szEventTime[20] = {0};\n\t\t\t_snprintf(szEventTime, sizeof(szEventTime)-1, \"%04d-%02d-%02d %02d:%02d:%02d\", pstInfo->UTC.dwYear, pstInfo->UTC.dwMonth, pstInfo->UTC.dwDay, pstInfo->UTC.dwHour,pstInfo->UTC.dwMinute,pstInfo->UTC.dwSecond);\n\t\t\tSetDlgItemText(IDC_EDIT_EVENT_TIME, szEventTime);\n\n\t\t\tShowGlobalPicture(pstInfo, pBuffer); // Global picture\n\n\t\t\t/**************Face attributes info ******************************/\n\t\t\tNET_FACE_DATA *pstDataInfo = &(pstInfo->stuFaceData);\n\t\t\tShowFaceDataInfo(pstDataInfo);\n\n\t\t\t/*************Face picture**********************************************/\n\t\t\tDH_MSG_OBJECT *pstFaceInfo = &(pstInfo->stuObject);\n\t\t\tShowPersonPicture(pstInfo, pBuffer);\n\n\t\t\t/**************Candidate info (Contrast diagram)*******************************/\n\t\t\tShowCandidatePicture(pstInfo, pBuffer);\n\t\t\tbreak;\n\t\t}\n\tcase  EVENT_IVS_FACEDETECT:\t\t\t//FACEDETECTION event\n\t\t{\n\t\t\tSetDlgItemText(IDC_EVENT_TYPE, ConvertString(\"(Face Detect)\"));\n\t\t\tDEV_EVENT_FACEDETECT_INFO *pstInfo = (DEV_EVENT_FACEDETECT_INFO*)pAlarmInfo;\n\n\t\t\tchar szEventTime[20] = {0};\n\t\t\t_snprintf(szEventTime, sizeof(szEventTime)-1, \"%04d-%02d-%02d %02d:%02d:%02d\", pstInfo->UTC.dwYear, pstInfo->UTC.dwMonth, pstInfo->UTC.dwDay, pstInfo->UTC.dwHour,pstInfo->UTC.dwMinute,pstInfo->UTC.dwSecond);\n\t\t\tSetDlgItemText(IDC_EDIT_EVENT_TIME, szEventTime);\n\t\t\tClearCandidateShowInfo();\n\t\t\tShowFaceDetectPicture(pstInfo, pBuffer, dwBufSize);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint CALLBACK AnalyzerData(LLONG lAnalyzerHandle, DWORD dwAlarmType, void* pAlarmInfo, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser, int nSequence, void *reserved)\n{\n\tif(dwUser == 0)\n\t{\n\t\treturn 0;\n\t}\n\n\tCFaceRecognitionDlg *dlg = (CFaceRecognitionDlg*)dwUser;\n\n\tHWND hWnd = dlg->GetSafeHwnd();\n\tif (NULL == hWnd)\n\t{\n\t\treturn 0;\n\t}\n\tstrAnalyInfo *info = new strAnalyInfo;\n\tmemset(info, 0, sizeof(strAnalyInfo));\n\tinfo->lAnalyzerHandle = lAnalyzerHandle;\n\tinfo->dwAlarmType = dwAlarmType;\n\tif (dwAlarmType == EVENT_IVS_FACERECOGNITION)\n\t{\n\t\tinfo->pAlarmInfo = new DEV_EVENT_FACERECOGNITION_INFO;\n\t\tmemcpy(info->pAlarmInfo, (DEV_EVENT_FACERECOGNITION_INFO*)pAlarmInfo, sizeof(DEV_EVENT_FACERECOGNITION_INFO));\n\t}\n\telse if (dwAlarmType == EVENT_IVS_FACEDETECT)\n\t{\n\t\tinfo->pAlarmInfo = new DEV_EVENT_FACEDETECT_INFO;\n\t\tmemcpy(info->pAlarmInfo, (DEV_EVENT_FACEDETECT_INFO*)pAlarmInfo, sizeof(DEV_EVENT_FACEDETECT_INFO));\n\t}\n\telse\n\t{\n\t\tdelete info;\n\t\tinfo = NULL;\n\t\treturn 0;\n\t}\n\tinfo->dwBufSize=dwBufSize;\n\tif (dwBufSize > 0)\n\t{\n\t\tinfo->pBuffer = new BYTE[dwBufSize];\n\t\tmemset(info->pBuffer, 0, dwBufSize);\n\t\tmemcpy(info->pBuffer, pBuffer, dwBufSize);\n\t}\n\n\t::PostMessage(hWnd, WM_DEVICE_DOATTACH, WPARAM(info), NULL);\n\n\treturn 1;\n}\n\nvoid CFaceRecognitionDlg::OnButtonAttachOrDeteach() \n{\n\tCString strButton;\n\tGetDlgItemText(IDC_BUTTON_ATTACH, strButton);\n\tif (strButton == ConvertString(\"Attach\"))\n\t{\n\t\tint nIndex = m_comboChannel.GetCurSel();\n\t\tif(CB_ERR != nIndex)\n\t\t{\n\t\t\tint nChannel = m_comboChannel.GetItemData(nIndex) - 1;\n\t\t\tm_lRealPicHandle = CLIENT_RealLoadPictureEx(m_lLoginID, nChannel, EVENT_IVS_ALL, TRUE, AnalyzerData, (DWORD)this, NULL);\n\t\t\tif (0 == m_lRealPicHandle)\n\t\t\t{\n\t\t\t\tMessageBox(ConvertString(\"Failed to attach face event!\"), \"\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\t\n\t\t\t\tSetDlgItemText(IDC_BUTTON_ATTACH, ConvertString(\"Detach\"));\n\t\t\t}\n\t\t}\n\t}\n\telse if (strButton == ConvertString(\"Detach\"))\n\t{\n\t\tOnButtonDeteach();\n\t}\n\n\treturn;\n}\n\nvoid CFaceRecognitionDlg::OnButtonDeteach() \n{\n\tm_nFaceDetectGroupId = 0;\n\tif (0 != m_lRealPicHandle)\n\t{\n\t\tBOOL bRet = CLIENT_StopLoadPic(m_lRealPicHandle);\n\t\tif (!bRet)\n\t\t{\n\t\t\tMessageBox(ConvertString(\"Failed to stop load picture!\"), \"\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tClearShowEventInfo();\n\t\t\tSetDlgItemText(IDC_BUTTON_ATTACH, ConvertString(\"Attach\"));\n\t\t\tm_lRealPicHandle = 0;\n\t\t\t\n\t\t\tFillCWndWithDefaultColor(GetDlgItem(IDC_STATIC_BIG_PIC));\n\t\t\tm_pBicPic.SetImageFile(NULL);\n\t\t\t\n\t\t\tFillCWndWithDefaultColor(GetDlgItem(IDC_STATIC_PERSON1));\n\t\t\tm_pFacePic.SetImageFile(NULL);\n\n\t\t\tFillCWndWithDefaultColor(GetDlgItem(IDC_STATIC_CANDI1));\n\t\t\tm_pCandiPic.SetImageFile(NULL);\t\n\t\t}\n\t}\n\n\treturn;\n}\n\nvoid CFaceRecognitionDlg::OnButtonLoginOut() \n{\n\tSetWindowText(ConvertString(\"FaceRecognition\"));\n\tOnButtonDeteach(); // Stop attach\n\n\tif (0 != m_lRealHandle) //Stop realplay\n\t{\n\t\tCLIENT_StopRealPlayEx(m_lRealHandle);\n\t\tm_lRealHandle = 0;\n\t\tSetDlgItemText(IDC_BUTTON_REALPLAY, ConvertString(\"StartRealPlay\"));\n\t\tFillCWndWithDefaultColor(GetDlgItem(IDC_STATIC_VIDEO));\n\t}\n\n\tif (0 != m_lLoginID)\n\t{\n\t\t// logout device\n\t\tBOOL bRet = CLIENT_Logout(m_lLoginID);\n\t\tif (!bRet)\n\t\t{\n\t\t\tMessageBox(ConvertString(\"Failed to login out!\"), \"\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_lRealHandle = 0;\n\t\t\tSetDlgItemText(IDC_BUTTON_LOGIN, ConvertString(\"Login\"));\n\t\t\tGetDlgItem(IDC_BUTTON_LOGIN)->EnableWindow(TRUE);\n\t\t\tGetDlgItem(IDC_BUTTON_ATTACH)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_BUTTON_FACE_DB)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_BUTTON_REALPLAY)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_BUTTON_QUERY_DOWNLOAD)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_BUTTON_SearchByPic)->EnableWindow(FALSE);\n\t\t}\n\t}\n}\n\n\nvoid CFaceRecognitionDlg::OnButtonFaceDb() \n{\n\tCFaceDbOpreate FaceDbOpreateDlg(m_lLoginID, m_nChnCnt, m_pszSoftPath);\n\tFaceDbOpreateDlg.DoModal();\n}\n\nvoid CFaceRecognitionDlg::OnBnClickedButtonRealplay()\n{\n\tCString strButton;\n\tGetDlgItemText(IDC_BUTTON_REALPLAY, strButton);\n\tif (strButton == ConvertString(\"StartRealPlay\"))\n\t{\n\t\tint nIndex = m_comboChannel.GetCurSel();\n\t\tif(CB_ERR != nIndex)\n\t\t{\n\t\t\tint nChannel = m_comboChannel.GetItemData(nIndex) - 1;\n\t\t\tHWND hWnd = GetDlgItem(IDC_STATIC_VIDEO)->m_hWnd;\n\t\t\tif (NULL == hWnd)\n\t\t\t{\n\t\t\t\tMessageBox(ConvertString(\"Failed to get window handle!\"), \"\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLLONG lRet = CLIENT_RealPlayEx(m_lLoginID, nChannel, hWnd, DH_RType_Realplay_0);\n\t\t\t\tif (0 == lRet)\n\t\t\t\t{\n\t\t\t\t\tMessageBox(ConvertString(\"Failed to real play!\"), \"\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSetDlgItemText(IDC_BUTTON_REALPLAY, ConvertString(\"StopRealPlay\"));\n\n\t\t\t\t\tm_lRealHandle = lRet;\n\t\t\t\t\tBOOL bRet = CLIENT_RenderPrivateData(m_lRealHandle, TRUE);\n\t\t\t\t\tif (!bRet)\n\t\t\t\t\t{\n\t\t\t\t\t\tMessageBox(ConvertString(\"Failed to render private data failed!\"), \"\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse if (strButton == ConvertString(\"StopRealPlay\"))\n\t{\n\t\tif (0 != m_lRealHandle)\n\t\t{\n\t\t\tBOOL bRet = CLIENT_RenderPrivateData(m_lRealHandle, FALSE);\n\t\t\tif (!bRet)\n\t\t\t{\n\t\t\t\tMessageBox(ConvertString(\"Failed to stop render private data!\"), \"\");\n\t\t\t}\n\t\t\tCLIENT_StopRealPlayEx(m_lRealHandle);\n\t\t\tSetDlgItemText(IDC_BUTTON_REALPLAY, ConvertString(\"StartRealPlay\"));\n\t\t\tm_lRealHandle = 0;\n\t\t\tFillCWndWithDefaultColor(GetDlgItem(IDC_STATIC_VIDEO));\n\t\t}\n\t}\n}\n\nvoid CFaceRecognitionDlg::OnBnClickedButtonQueryDownload()\n{\n\tCQueryDownLoad dlg(m_nChnCnt, m_lLoginID, m_pszSoftPath);\n\tdlg.DoModal();\n}\n\nvoid CFaceRecognitionDlg::OnBnClickedButtonSearchbypic()\n{\n\tCSearchByPic SearchByPicDlg(m_lLoginID, m_nChnCnt, m_pszSoftPath);\n\tSearchByPicDlg.DoModal();\n}\n\nBOOL CFaceRecognitionDlg::PreTranslateMessage(MSG* pMsg)\n{\n\t// Enter key\n\tif(pMsg->message == WM_KEYDOWN &&\n\t\tpMsg->wParam == VK_RETURN)\n\t{\n\t\treturn TRUE;\n\t}\n\n\t// Escape key\n\tif(pMsg->message == WM_KEYDOWN &&\n\t\tpMsg->wParam == VK_ESCAPE)\n\t{\n\t\treturn TRUE;\n\t}\n\treturn CDialog::PreTranslateMessage(pMsg);\n}\n\nLRESULT CFaceRecognitionDlg::DoDeviceAttach(WPARAM wParam, LPARAM lParam)\n{\n\tstrAnalyInfo *pInfo = (strAnalyInfo *)wParam;\n\tif (pInfo == NULL)\n\t{\n\t\treturn 0;\n\t}\n\n\tDoFaceData(pInfo->lAnalyzerHandle, pInfo->dwAlarmType, pInfo->pAlarmInfo, pInfo->pBuffer, pInfo->dwBufSize);\n\n\tif (pInfo->pBuffer)\n\t{\n\t\tdelete[] pInfo->pBuffer;\n\t\tpInfo->pBuffer = NULL;\n\t}\n\tif (pInfo->pAlarmInfo)\n\t{\n\t\tdelete pInfo->pAlarmInfo;\n\t\tpInfo->pAlarmInfo = NULL;\n\t}\n\n\tif (pInfo)\n\t{\n\t\tdelete pInfo;\n\t\tpInfo = NULL;\n\t}\n\treturn 0;\n}","size_bytes":33724},"bin/DemoSrc/playsdkdemo/PlayDemo.cpp":{"content":"// PlayDemo.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"PlayDemo.h\"\n#include \"PlayDemoDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CPlayDemoApp\n\nBEGIN_MESSAGE_MAP(CPlayDemoApp, CWinApp)\n\t//{{AFX_MSG_MAP(CPlayDemoApp)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t\t//    DO NOT EDIT what you see in these blocks of generated code!\n\t//}}AFX_MSG\n\tON_COMMAND(ID_HELP, CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CPlayDemoApp construction\n\nCPlayDemoApp::CPlayDemoApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The one and only CPlayDemoApp object\n\nCPlayDemoApp theApp;\n\n/////////////////////////////////////////////////////////////////////////////\n// CPlayDemoApp initialization\n\nBOOL CPlayDemoApp::InitInstance()\n{\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t//  of your final executable, you should remove from the following\n\t//  the specific initialization routines you do not need.\n\n#ifdef _AFXDLL\n\tEnable3dControls();\t\t\t// Call this when using MFC in a shared DLL\n#else\n\tEnable3dControlsStatic();\t// Call this when linking to MFC statically\n#endif\n\n\tCPlayDemoDlg dlg;\n\tm_pMainWnd = &dlg;\n\tint nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n","size_bytes":2017},"bin/Demo/MfcDemo/10.AlarmDevice/ModifyPwd.cpp":{"content":"// ModifyPwd.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"ModifyPwd.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CModifyPwd dialog\n\n\nCModifyPwd::CModifyPwd(CWnd* pParent /*=NULL*/)\n\t: CDialog(CModifyPwd::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CModifyPwd)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_usersInfo = 0;\n\tm_hLoginID = 0;\n\tm_dwUserID = 0;\n}\n\n\nvoid CModifyPwd::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CModifyPwd)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CModifyPwd, CDialog)\n\t//{{AFX_MSG_MAP(CModifyPwd)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CModifyPwd message handlers\n\nvoid CModifyPwd::OnOK() \n{\n\t// TODO: Add extra validation here\n\tUSER_INFO_NEW newInfo = {sizeof(newInfo)};\n\tUSER_INFO_NEW oldInfo = {sizeof(oldInfo)};\n\tchar strPwd1[DH_NEW_USER_PSW_LENGTH + 1] = {0};\n\tchar strPwd2[DH_NEW_USER_PSW_LENGTH + 1] = {0};\n\tGetDlgItem(IDC_MODIFY_PWD_EDIT_NEWPWD1)->GetWindowText(strPwd1, DH_NEW_USER_PSW_LENGTH+1);\n\tGetDlgItem(IDC_MODIFY_PWD_EDIT_NEWPWD2)->GetWindowText(strPwd2, DH_NEW_USER_PSW_LENGTH+1);\n\tif (strcmp(strPwd1, strPwd2) == 0)\n\t{\n\t\tmemcpy(newInfo.passWord, strPwd1, DH_NEW_USER_PSW_LENGTH);\n\t}\n\telse\n\t{\n\t\tMessageBox(ConvertString(\"Please check the new words you have set, they are not matching!\", DLG_USERMANAGER), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\t\n\tmemcpy(oldInfo.name, m_usersInfo->userList[m_dwUserID].name, DH_NEW_USER_NAME_LENGTH);\n\tGetDlgItem(IDC_MODIFY_PWD_EDIT_OLDPWD)->GetWindowText(strPwd1, DH_NEW_USER_PSW_LENGTH+1);\n\tmemcpy(oldInfo.passWord, strPwd1, DH_NEW_USER_PSW_LENGTH);\n\n\tBOOL bRet = CLIENT_OperateUserInfoNew(m_hLoginID, 6, (void *)&newInfo, &oldInfo, 0, 1000 * 10);\n\tif (!bRet)\n\t{\n\t\tint nError = CLIENT_GetLastError();\n\t\tif(nError == NET_RETURN_DATA_ERROR)\tMessageBox(ConvertString(\"checkout return data error!\", DLG_USERMANAGER), ConvertString(\"Prompt\"));\n\t\telse if(nError == NET_ILLEGAL_PARAM) MessageBox(ConvertString(\"Input error!\", DLG_USERMANAGER), ConvertString(\"Prompt\"));\n\t\telse if(nError == NET_USER_PWD) MessageBox(ConvertString(\"Reserved account is not able to modify password!\", DLG_USERMANAGER), ConvertString(\"Prompt\"));\n\t\telse if(nError == NET_USER_FLASEPWD) MessageBox(ConvertString(\"Invalid password!\", DLG_USERMANAGER), ConvertString(\"Prompt\"));\n\t\telse if(nError == NET_USER_NOMATCHING) MessageBox(ConvertString(\"The password is not matching!\", DLG_USERMANAGER), ConvertString(\"Prompt\"));\n\t\telse MessageBox(ConvertString(\"Modify user password failed!\", DLG_USERMANAGER), ConvertString(\"Prompt\"));\n\t}\n\telse\n\t{\n\t\tCDialog::OnOK();\n\t}\n}\nvoid CModifyPwd::InitModifyPwdInfoDlg(USER_MANAGE_INFO_NEW *info, DWORD dwID, LLONG hLoginID)\n{\n\tm_usersInfo = info;\n\tm_dwUserID = dwID;\n\tm_hLoginID = hLoginID;\n}\n\nBOOL CModifyPwd::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_USERMANAGER);\n\t// TODO: Add extra initialization here\n\tif (!m_usersInfo || !m_hLoginID)\n\t{\n\t\treturn TRUE;\n\t}\n\n\tchar szUserName[DH_NEW_USER_NAME_LENGTH + 1] = {0};\n\tmemcpy(szUserName, m_usersInfo->userList[m_dwUserID].name, DH_NEW_USER_NAME_LENGTH);\n\tGetDlgItem(IDC_MODIFY_PWD_EDIT_USERNAME)->SetWindowText(szUserName);\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nBOOL CModifyPwd::IsValid()\n{\n\tBOOL bValid = TRUE;\n\tCString str1,str2,str3;\n\tGetDlgItemText(IDC_MODIFY_PWD_EDIT_OLDPWD,str1);\n\tGetDlgItemText(IDC_MODIFY_PWD_EDIT_NEWPWD1,str2);\n\tGetDlgItemText(IDC_MODIFY_PWD_EDIT_NEWPWD2,str3);\n\tif(str1.IsEmpty() || str2.IsEmpty() || str3.IsEmpty())\n\t{\n\t\tMessageBox(ConvertString(\"Please Input!\", DLG_USERMANAGER), ConvertString(\"Prompt\"));\n\t\tbValid = FALSE;\n\t}\n\telse if(str2 != str3)\n\t{\n\t\tMessageBox(ConvertString(\"Input  password error, please input again.\", DLG_USERMANAGER), ConvertString(\"Prompt\"));\n\t\tbValid = FALSE;\n\t}\n\treturn bValid;\n}\n\n","size_bytes":4188},"bin/Demo/MfcDemo/11.Attendance/Util.cpp":{"content":"#include \"stdafx.h\"\n#include \"Util.h\"\n\nCString ConvertString(CString strText)\n{\n\tchar val[200] = {0};\n\tCString strIniPath,strRet;\n\n\tchar szSoftPath[256] = {0};\n\tint filelen = GetModuleFileName(NULL, szSoftPath, 256);\n\tint k = filelen;\n\twhile (szSoftPath[k] != '\\\\')\n\t{\n\t\tk--;\n\t}\n\tszSoftPath[k+1] = '\\0';\n\tCString str = \"\\\\langchn.ini\";\n\tstr = szSoftPath + str;\n\t\n\tmemset(val,0,200);\n\tGetPrivateProfileString(\"String\",strText,\"\",\n\t\tval,200, str/*\"./langchn.ini\"*/);\n\tstrRet = val;\n\tif(strRet.GetLength()==0)\n\t{\n\t\t//If there is no corresponding string in ini file then set it to be default value(English)\n\t\tstrRet=strText;\n\t}\n\treturn strRet;\n}\n\nvoid g_SetWndStaticText(CWnd * pWnd)\n{\n\tCString strCaption,strText;\n\t\n\t//Set main widnow title \n\tpWnd->GetWindowText(strCaption);\n\tif(strCaption.GetLength()>0)\n\t{\n\t\tstrText=ConvertString(strCaption);\n\t\tpWnd->SetWindowText(strText);\n\t}\n\t\n\t//Set small window title \n\tCWnd * pChild=pWnd->GetWindow(GW_CHILD);\n\tCString strClassName;\n\twhile(pChild)\n\t{\n\t\t//////////////////////////////////////////////////////////////////////////\t\t\n\t\t//Added by Jackbin 2005-03-11\n\t\tstrClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n\t\tif(strClassName == \"CEdit\")\n\t\t{\n\t\t\t//The next small window \n\t\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t//////////////////////////////////////////////////////////////////////////\t\n\t\t\n\t\t//Set current language text in small window\n\t\tpChild->GetWindowText(strCaption);\n\t\tstrText=ConvertString(strCaption);\n\t\tpChild->SetWindowText(strText);\n\t\t\n\t\t//The next small window \n\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t}\n}","size_bytes":1614},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgGuard.cpp":{"content":"// DlgCfgGuard.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgCfgGuard.h\"\n\n#define MAX_SCENE_NUM 2\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgGuard dialog\n\n\nCDlgCfgGuard::CDlgCfgGuard(CWnd* pParent /* = NULL */, LLONG lLoginID /* = 0 */)\n\t: CDialog(CDlgCfgGuard::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgGuard)\n\tm_lLoginID = lLoginID;\n\t//}}AFX_DATA_INIT\n\tmemset(&m_stuInfo, 0, sizeof(m_stuInfo));\n\tm_stuInfo.bSceneEnable = TRUE;\n}\n\n\nvoid CDlgCfgGuard::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgGuard)\n\tDDX_Control(pDX, IDC_GUARD_CMB_SCENE, m_cmbScene);\n\tDDX_Control(pDX, IDC_GUARD_EDT_RETSCENECOUNT, m_edRetSceneCount);\n\tDDX_Control(pDX, IDC_GUARD_CMB_SCENENAME, m_cmbSceneName);\n\tDDX_Control(pDX, IDC_GUARD_CMB_CURRENTSCENE, m_cmbCurrentScene);\n\tDDX_Control(pDX, IDC_GUARD_CK_ALARMENABLE, m_ckAlarmEnable);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgGuard, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgGuard)\n\tON_BN_CLICKED(IDC_GUARD_BTN_GET, OnGuardBtnGet)\n\tON_BN_CLICKED(IDC_GUARD_BTN_SET, OnGuardBtnSet)\n\tON_CBN_SELCHANGE(IDC_GUARD_CMB_SCENE, OnSelchangeGuardCmbScene)\n\tON_CBN_DROPDOWN(IDC_GUARD_CMB_SCENE, OnDropdownGuardCmbScene)\n\tON_WM_DESTROY()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgGuard message handlers\nBOOL CDlgCfgGuard::OnInitDialog()\n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_GUARD);\n\n\tif (m_lLoginID == 0)\n\t{\n\t\tMessageBox(ConvertString(CString(\"we haven't login a device yet!\"), DLG_CFG_GUARD), ConvertString(\"Prompt\"));\n\t\treturn TRUE;\n\t}\n\n\tm_cmbCurrentScene.ResetContent();\n\tm_cmbCurrentScene.InsertString(-1, ConvertString(\"Unknown\", DLG_CFG_GUARD));\n\tm_cmbCurrentScene.InsertString(-1, ConvertString(\"Outdoor\", DLG_CFG_GUARD));\n\tm_cmbCurrentScene.InsertString(-1, ConvertString(\"AtHome\", DLG_CFG_GUARD));\n\tm_cmbCurrentScene.SetCurSel(0);\n\n\tm_cmbSceneName.ResetContent();\n\tm_cmbSceneName.InsertString(-1, ConvertString(\"Unknown\", DLG_CFG_GUARD));\n\tm_cmbSceneName.InsertString(-1, ConvertString(\"Outdoor\", DLG_CFG_GUARD));\n\tm_cmbSceneName.InsertString(-1, ConvertString(\"AtHome\", DLG_CFG_GUARD));\n\tm_cmbSceneName.SetCurSel(0);\n\n\tint i = 0;\n\tm_cmbScene.ResetContent();\n\tfor (i = 0; i < MAX_SCENE_NUM; ++i)\n\t{\n\t\tCString csItem;\n\t\tcsItem.Format(\"%s %02d\", ConvertString(\"Scene\", DLG_CFG_GUARD), i + 1);\n\t\tm_cmbScene.InsertString(-1, csItem);\n\t}\n\n\tm_cmbScene.SetCurSel(0);\n\tfor (i = 0; i < MAX_SCENE_NUM; ++i)\n\t{\n\t\tm_stuInfo.stuScense[i].nAlarmInChannelsCount = MAX_CHANNEL_COUNT;\n\t\tm_stuInfo.stuScense[i].pnAlarmInChannels = new int[MAX_CHANNEL_COUNT];\n\t\tif (m_stuInfo.stuScense[i].pnAlarmInChannels == NULL)\n\t\t{\n\t\t\tMessageBox(CString(\"new error!\"), ConvertString(\"Prompt\"));\n\t\t\treturn TRUE;\n\t\t}\n\t\tmemset(m_stuInfo.stuScense[i].pnAlarmInChannels, -1, sizeof(int)*8);\n\t}\n\tm_ckAlarmEnable.EnableWindow(FALSE);\n\tm_cmbCurrentScene.EnableWindow(FALSE);\n\tOnGuardBtnGet();\n\treturn TRUE; \n}\n\nBOOL CDlgCfgGuard::GetCurrentGuardState()\n{\n\tchar szJsonBuf[1024] = {0};\t\n\n\tint nErr = 0;\n\tBOOL bRet = CLIENT_GetNewDevConfig(m_lLoginID, CFG_CMD_COMMGLOBAL, -1,\n\t\tszJsonBuf, sizeof(szJsonBuf), &nErr, SDK_API_WAIT);\n\tif (!bRet)\n\t{\n\t\tCString csOut;\n\t\tcsOut.Format(\"%s %08x.\", ConvertString(\"Query CommGlobal failed:\", DLG_CFG_GUARD), CLIENT_GetLastError());\n\t\tMessageBox(csOut, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\n\tDWORD dwRetLen = 0;\n\tbRet = CLIENT_ParseData(CFG_CMD_COMMGLOBAL, szJsonBuf, (void*)&m_stuInfo, sizeof(m_stuInfo), &dwRetLen);\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Parse CommGlobal failed.\", DLG_CFG_GUARD), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\n\nvoid CDlgCfgGuard::OnGuardBtnGet() \n{\n\t// TODO: Add your control notification handler code here\n\tif (GetCurrentGuardState())\n\t{\n\t\tStuToDlg();\n\t}\n}\n\nvoid CDlgCfgGuard::OnGuardBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu(m_cmbScene.GetCurSel());\n\n\tchar szJsonBuf[1024] = {0};\n\tint nerror = 0;\n\tint nrestart = 0;\n\tBOOL bRet = CLIENT_PacketData(CFG_CMD_COMMGLOBAL, &m_stuInfo, sizeof(m_stuInfo), szJsonBuf, sizeof(szJsonBuf));\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(CString(\"packet CommGlobal error...\"), DLG_CFG_GUARD), ConvertString(\"Prompt\"));\n\t\treturn;\n\t} \n\telse\n\t{\n\t\tbRet = CLIENT_SetNewDevConfig(m_lLoginID, CFG_CMD_COMMGLOBAL, -1, szJsonBuf, 1024, &nerror, &nrestart, SDK_API_WAIT);\n\t\tif (!bRet)\n\t\t{\n\t\t\tCString csErr;\n\t\t\tcsErr.Format(\"%s %08x\", ConvertString(\"SetupConfig CommGlobal failed:\", DLG_CFG_GUARD), CLIENT_GetLastError());\n\t\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"SetConfig CommGlobal ok!\"), DLG_CFG_GUARD), ConvertString(\"Prompt\"));\n\t\t}\n\t}\n\treturn;\n}\n\nvoid CDlgCfgGuard::StuToDlg()\n{\n    int nIndex = m_cmbScene.GetCurSel();\n    if (nIndex < 0 || nIndex >= MAX_SCENE_COUNT)\n    {\n        return;\n    }\n\n\tm_ckAlarmEnable.SetCheck(m_stuInfo.bEnable ? BST_CHECKED : BST_UNCHECKED);\n\tm_cmbCurrentScene.SetCurSel(m_stuInfo.emCurrentScene);\n\n\tm_cmbSceneName.SetCurSel(m_stuInfo.stuScense[nIndex].emName);\n\tchar szRetChannelCount[10] = {0};\n\t_itoa(m_stuInfo.stuScense[nIndex].nRetAlarmInChannelsCount, szRetChannelCount, 10);\n\tm_edRetSceneCount.SetWindowText(szRetChannelCount);\n\t\n\tfor (int i = 0; i < MAX_CHANNEL_COUNT; i++)\n\t{\n\t\tCButton* pBtn = (CButton*)GetDlgItem(IDC_GUARD_CK_CHANNEL_1 + i);\n\t\tif (pBtn)\n\t\t{\n\t\t\tpBtn->SetCheck(BST_UNCHECKED);\n\t\t\tfor (int j = 0; j < __max(m_stuInfo.stuScense[nIndex].nRetAlarmInChannelsCount, m_stuInfo.stuScense[nIndex].nAlarmInChannelsCount); ++j)\n\t\t\t{\n\t\t\t\tif (i == m_stuInfo.stuScense[nIndex].pnAlarmInChannels[j])\n\t\t\t\t{\n\t\t\t\t\tpBtn->SetCheck(BST_CHECKED);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpBtn->SetCheck(BST_UNCHECKED);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid CDlgCfgGuard::DlgToStu(int nIndex)\n{\n    if (nIndex < 0 || nIndex >= MAX_SCENE_COUNT)\n    {\n        return;\n    }\n\n\tm_stuInfo.nSceneCount = MAX_SCENE_NUM;\n\tint nChannelCount = 0;\n\t\t\t\n\tmemset(m_stuInfo.stuScense[nIndex].pnAlarmInChannels, -1, sizeof(int)*MAX_CHANNEL_COUNT);\n\tfor (int i = 0; i < MAX_CHANNEL_COUNT; i++)\n\t{\n\t\tCButton* pBtn = (CButton*)GetDlgItem(IDC_GUARD_CK_CHANNEL_1 + i);\n\t\tif (pBtn)\n\t\t{\n\t\t\tif (BST_CHECKED == pBtn->GetCheck())\n\t\t\t{\n\t\t\t\tm_stuInfo.stuScense[nIndex].pnAlarmInChannels[nChannelCount] = i;\n\t\t\t\t++nChannelCount;\n\t\t\t}\n\t\t}\n\t}\n\tm_stuInfo.stuScense[nIndex].emName = (emCFG_SCENE_MODE)m_cmbSceneName.GetCurSel();\n\tm_stuInfo.stuScense[nIndex].nAlarmInChannelsCount = nChannelCount;\n}\n\nvoid CDlgCfgGuard::OnSelchangeGuardCmbScene() \n{\n\t// TODO: Add your control notification handler code here\n\tStuToDlg();\n}\n\nvoid CDlgCfgGuard::OnDropdownGuardCmbScene() \n{\n\t// TODO: Add your control notification handler code here\n\tint nIndex = m_cmbScene.GetCurSel();\n\tDlgToStu(nIndex);\n}\n\nvoid CDlgCfgGuard::OnDestroy() \n{\n\tCDialog::OnDestroy();\n\t\n\t// TODO: Add your message handler code here\n\tfor (int i = 0; i < MAX_SCENE_COUNT; i++)\n\t{\n\t\tif (m_stuInfo.stuScense[i].pnAlarmInChannels !=  NULL)\n\t\t{\n\t\t\tdelete []m_stuInfo.stuScense[i].pnAlarmInChannels;\n\t\t\tm_stuInfo.stuScense[i].pnAlarmInChannels = NULL;\n\t\t}\n\t}\n}\n","size_bytes":7258},"bin/DemoSrc/playsdkdemo/FileStreamPlayer.cpp":{"content":"// FileStreamPlayer.cpp: implementation of the CFileStreamPlayer class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"PlayDemo.h\"\n#include \"FileStreamPlayer.h\"\n#include \"dhplay.h\"\n#include \"dhplayEx.h\"\n\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\n//////////////////////////////////////////////////////////////////////\n// Construction/Destruction\n//////////////////////////////////////////////////////////////////////\n\nCFileStreamPlayer::CFileStreamPlayer()\n{\n\tm_lpPlayParam = NULL;\n\tm_hThread = NULL;\n\tm_hExit = NULL;\n\tm_bBegin = false;\n}\n\nCFileStreamPlayer::~CFileStreamPlayer()\n{\n\n}\n\nint WINAPI ThreadProc(LPVOID lpvData)\n{\n\tCFileStreamPlayer* lpPlayer = (CFileStreamPlayer*)lpvData;\n\treturn lpPlayer->OnProc();\n}\n\nvoid CALLBACK EncTypeChangeFunC(long nPort, void* nUser)\n{\n\tTRACE(_T(\"change\\n\"));\n\n\tPlayParam* lpPlayParam = (PlayParam*)nUser;\n\n\tPostMessage(lpPlayParam->hWnd, WM_USER_MSG_ENCTYPECHANGED, NULL, NULL);\n\n}\n\n__int64 SeekFile(HANDLE hf, __int64 distance, DWORD MoveMethod)\n{\n\tLARGE_INTEGER li;\n\n\tli.QuadPart = distance;\n\n\tli.LowPart = SetFilePointer(hf, li.LowPart, &li.HighPart, MoveMethod);\n\n\tif(li.LowPart == INVALID_FILE_SIZE && GetLastError() != NO_ERROR)\n\t\tli.QuadPart = -1;\n\n\treturn li.QuadPart;\n}\n\nint CFileStreamPlayer::Open(TCHAR* lpszFile, PlayParam* lpPlayParam)\n{\n\tHANDLE fDav = CreateFile(lpszFile,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_READONLY,NULL);\n\tif(fDav == INVALID_HANDLE_VALUE)\n\t\treturn -1;\n\n\t__int64 fPos = SeekFile(fDav,0,FILE_END);\n\tif(fPos == -1)\n\t\treturn -1;\n\n\tSeekFile(fDav,0,FILE_BEGIN);\n\tlpPlayParam->lpfDav = fDav;\n\tlpPlayParam->nDavSize = fPos;\n\t \n\tm_lpPlayParam = lpPlayParam;\n\t\n\tPLAY_SetEncTypeChangeCallBack(lpPlayParam->nPort, EncTypeChangeFunC, (void*)lpPlayParam);\n\tPLAY_SetStreamOpenMode(lpPlayParam->nPort, STREAME_FILE);\n\tPLAY_OpenStream(lpPlayParam->nPort, NULL, 0, 800*1024);\n\n\tm_hExit = CreateEvent(NULL, FALSE, FALSE, NULL);\n\treturn 1;\n}\n\nint CFileStreamPlayer::Close(PlayParam* lpPlayParam)\n{\n\tSetEvent(m_hExit);\n\tif(WaitForSingleObject(m_hThread, 5000) != WAIT_OBJECT_0)\n\t{\n\t\tTerminateThread(m_hThread, -1);\n\t}\n\n\tPLAY_Stop(lpPlayParam->nPort);\n\tPLAY_CloseStream(lpPlayParam->nPort);\n\n\tif(lpPlayParam->lpfDav != INVALID_HANDLE_VALUE)\n\t{\n\t\tCloseHandle(lpPlayParam->lpfDav);\n\t\tlpPlayParam->lpfDav = INVALID_HANDLE_VALUE;\n\t}\n\n\tif (NULL != m_hExit)\n\t{\n\t\tCloseHandle(m_hExit);\n\t\tm_hExit = NULL;\n\t}\n\n\tif (NULL != m_hThread)\n\t{\n\t\tCloseHandle(m_hThread);\n\t\tm_hThread = NULL;\n\t}\n\n\treturn 1;\n}\n\nint CFileStreamPlayer::Do(PlayParam* lpPlayParam)\n{\n\tTCHAR * pDes = m_lpState->Description(lpPlayParam);\n\tif(pDes && _tcscmp(pDes,_T(\"Stop\")) == 0)\n\t{\n\t\tSetEvent(m_hExit);\n\t\tif(WaitForSingleObject(m_hThread, 5000) != WAIT_OBJECT_0)\n\t\t{\n\t\t\tTerminateThread(m_hThread, -1);\n\t\t}\n\t\tCloseHandle(m_hThread);\n\t\tm_hThread = NULL;\n\t}\n\telse if(pDes && !m_hThread  && _tcscmp(pDes,_T(\"Play\")) == 0)\n\t{\n\t\tDWORD dwThreadID;\n\t\tm_hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ThreadProc, this, NULL, &dwThreadID);\n\t}\n\telse if (pDes && _tcscmp(pDes,_T(\"Begin\")) == 0)\n\t{\n\t\tm_bBegin = true;\n\t}\n\treturn m_lpState->Do(lpPlayParam);\n}\n\nint CFileStreamPlayer::OpenSound(PlayParam* lpPlayParam, BOOL bOpen)\n{\n\tlpPlayParam->bOpenAudio = bOpen;\n\tif(bOpen)\n\t\treturn PLAY_PlaySoundShare(lpPlayParam->nPort);\n\telse\n\t\treturn PLAY_StopSoundShare(lpPlayParam->nPort);\n}\n\nint CFileStreamPlayer::SetAudioVolume(PlayParam* lpPlayParam, int nVolume)\n{\n\treturn PLAY_SetVolume(lpPlayParam->nPort, nVolume);\n}\n\nint CFileStreamPlayer::SetAudioWave(PlayParam* lpPlayParam, int nWave)\n{\n\treturn PLAY_AdjustWaveAudio(lpPlayParam->nPort, nWave);\n}\n\nint CFileStreamPlayer::GetAudioVolume(PlayParam* lpPlayParam)\n{\n\treturn PLAY_GetVolume(lpPlayParam->nPort);\n}\n\nTCHAR* CFileStreamPlayer::Description(PlayParam* lpPlayParam)\n{\n\treturn m_lpState->Description(lpPlayParam);\n}\n\nint CFileStreamPlayer::ChangeState(IPlayState* lpState)\n{\n\tif(lpState==NULL)\n\t\treturn -1;\n\n\tm_lpState = lpState;\n\treturn 1;\n}\n\nint CFileStreamPlayer::GetProcess(PlayParam* lpPlayParam)\n{\n\tif (0 == lpPlayParam->nDavSize)\n\t{\n\t\treturn 0;\n\t}\n\n\t__int64 fPos = SeekFile(lpPlayParam->lpfDav,0,FILE_CURRENT);\n\treturn int(fPos*100/lpPlayParam->nDavSize);\n}\n\nint CFileStreamPlayer::Seek(PlayParam* lpPlayParam, int nPos)\n{\n\tif(nPos<0 || nPos>100)\n\t\treturn -1;\n\n\tSeekFile(lpPlayParam->lpfDav,nPos*lpPlayParam->nDavSize/100,FILE_BEGIN);\n\treturn 1;\n}\n\nint CFileStreamPlayer::SetColor(PlayParam* lpPlayParam, int nSaturation, int nBrightness, int nContrast, int nHue)\n{\n\treturn PLAY_SetColor(lpPlayParam->nPort, 0, nBrightness, nContrast, nSaturation, nHue);\n}\n\nint CFileStreamPlayer::GetColor(PlayParam* lpPlayParam, int* nSaturation, int* nBrightness, int* nContrast, int* nHue)\n{\n\treturn PLAY_GetColor(lpPlayParam->nPort, 0, nBrightness, nContrast, nSaturation, nHue);\n}\n\nint CFileStreamPlayer::GetPlayedTime(PlayParam* lpPlayParam)\n{\n\treturn 0;\n}\n\nint CFileStreamPlayer::GetTotalTime(PlayParam* lpPlayParam)\n{\n\treturn 0;\n}\n\nint CFileStreamPlayer::GetPlayedFrame(PlayParam* lpPlayParam)\n{\n\treturn 0;\n}\n\nint CFileStreamPlayer::GetTotalFrame(PlayParam* lpPlayParam)\n{\n\treturn 0;\n}\n\nint CFileStreamPlayer::GetRate(PlayParam* lpPlayParam, int* nRate)\n{\n\tDWORD dwRate = PLAY_GetCurrentFrameRate(lpPlayParam->nPort);\n\t*nRate = dwRate;\n\treturn dwRate;\n}\n\nint CFileStreamPlayer::GetBitrate(PlayParam* lpPlayParam, double* dbBitrate)\n{\n\treturn PLAY_GetRealFrameBitRate(lpPlayParam->nPort, dbBitrate);\n}\n\nBOOL CFileStreamPlayer::SnapPicture(PlayParam* lpPlayParam, char* szFileName, int nType)/*nType,0 bmp 1 jpg*/\n{\n\treturn PLAY_CatchPicEx(lpPlayParam->nPort, szFileName, tPicFormats(nType));\n}\n\nint CFileStreamPlayer::SetDisplayRegion(PlayParam* lpPlayParam, DWORD nRegionNum, DISPLAYRECT *pSrcRect, HWND hDestWnd, BOOL bEnable)\n{\n\treturn PLAY_SetDisplayRegion(lpPlayParam->nPort, nRegionNum, pSrcRect, hDestWnd, bEnable);\n}\n\nint CFileStreamPlayer::GetPicSize(PlayParam* lpPlayParam, long *width, long *height)\n{\n\treturn PLAY_GetPictureSize(lpPlayParam->nPort, width, height);\n}\n\nBOOL CFileStreamPlayer::SetVerticalSync(PlayParam *lpPlayParam, BOOL bVerticalSync)\n{\n\treturn PLAY_VerticalSyncEnable(lpPlayParam->nPort, bVerticalSync);\n}\n\n/*Receive video info. cmdType: PLAY_CMD_GetTime  Encoding time info;\n\t\t\t\t\t\t\t   PLAY_CMD_GetFileRate  Frame rate info;\n\t\t\t\t\t\t\t   PLAY_CMD_GetMediaInfo  Media info*/\nBOOL CFileStreamPlayer::GetQueryInfo(PlayParam *lpPlayParam, int cmdType, char* buf, int buflen, int* returnlen)\n{\n\treturn PLAY_QueryInfo(lpPlayParam->nPort, cmdType, buf, buflen, returnlen);\n}\n\nBOOL CFileStreamPlayer::RegistDrawCallback(PlayParam *lpPlayParam, fDrawCBFun DrawCBFun, void* nUser)\n{\n\treturn PLAY_RigisterDrawFun(lpPlayParam->nPort, DrawCBFun, nUser);\n}\n\nBOOL CFileStreamPlayer::SetPlayDirection(PlayParam* lpPlayParam, DWORD emDirection)\n{\n\treturn PLAY_SetPlayDirection(lpPlayParam->nPort, emDirection);\n}\n\nBOOL CFileStreamPlayer::RenderPrivateData(PlayParam* lpPlayParam, BOOL bTrue)\n{\n\treturn PLAY_RenderPrivateData(lpPlayParam->nPort, bTrue, 0);\n}\n\nBOOL CFileStreamPlayer::StartFisheye(PlayParam* lpPlayParam)\n{\n\treturn PLAY_StartFisheye(lpPlayParam->nPort);\n}\n\nBOOL CFileStreamPlayer::OptFisheyeParams(PlayParam* lpPlayParam, FISHEYE_OPERATETYPE operatetype, FISHEYE_OPTPARAM* pOptParam)\n{\n\treturn PLAY_OptFisheyeParams(lpPlayParam->nPort, operatetype, pOptParam);\n}\n\nBOOL CFileStreamPlayer::FisheyeEptzUpdate(PlayParam* lpPlayParam, FISHEYE_EPTZPARAM* pEptzParam, BOOL bSecondRegion)\n{\n\treturn PLAY_FisheyeEptzUpdate(lpPlayParam->nPort, pEptzParam, bSecondRegion);\n\n}\n\nBOOL CFileStreamPlayer::StopFisheye(PlayParam* lpPlayParam)\n{\n\treturn PLAY_StopFisheye(lpPlayParam->nPort);\n}\n\nBOOL CFileStreamPlayer::SetFishEyeInfoCallBack(PlayParam* lpPlayParam, fFishEyeInfoFun pFishEyeInfoFun, void* pUserData)\n{\n\treturn PLAY_SetFishEyeInfoCallBack(lpPlayParam->nPort, pFishEyeInfoFun, pUserData);\n}\n\nBOOL CFileStreamPlayer::EnableLargePicAdjustment(PlayParam* lpPlayParam, BOOL bEnable)\n{\n\treturn PLAY_EnableLargePicAdjustment(lpPlayParam->nPort, bEnable);\n}\n\nBOOL CFileStreamPlayer::SetAntiAliasing(PlayParam *lpPlayParam, BOOL bAntiAliasing)\n{\n\treturn PLAY_AntiAliasEnable(lpPlayParam->nPort, bAntiAliasing);\n}\n\nint CFileStreamPlayer::OnProc()\n{\n\tconst int READ_SIZE = 1024*128;\n\tunsigned char* lpReadBuf = new unsigned char[READ_SIZE];\n\t/*Add bInput to prevent long-time loop*/\n\tBOOL bInput = TRUE;\n\tDWORD nReadSize = 0;\n\twhile(WaitForSingleObject(m_hExit, 0) != WAIT_OBJECT_0)/*Set short time interval to prevent slow data sending during quick play*/\n\t{\n\t\tif (m_bBegin)\n\t\t{\n\t\t\tm_bBegin = false;\n\t\t\tbInput = true;\n\t\t\tSleep(500);\n\t\t}\n\n\t\tif(bInput!=FALSE)\n\t\t{\n\t\t\tnReadSize = READ_SIZE;\n\t\t\t::ReadFile(m_lpPlayParam->lpfDav, lpReadBuf, READ_SIZE,&nReadSize,NULL);\n\t\t\tif(nReadSize <= 0)\n\t\t\t{\n\t\t\t\tSleep(2);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*Continue sending data if failed*/\n\t\tbInput = PLAY_InputData(m_lpPlayParam->nPort, lpReadBuf, nReadSize);\n\t\tif(bInput==FALSE)\n\t\t{\n\t\t\tSleep(2);\n\t\t}\n\t}\n\n\tdelete []lpReadBuf;\n\n\treturn 1;\n}\n\nnamespace FileStreamState\n{\n\t/*CStop*/\n\tint CStop::Do(PlayParam* lpPlayParam)\n\t{\n\t\tPLAY_ResetBuffer(lpPlayParam->nPort, BUF_VIDEO_RENDER);\n\t\tPLAY_CleanScreen(lpPlayParam->nPort, 240, 240, 240, 0, 0);\n\t\tPLAY_Stop(lpPlayParam->nPort);\n\t\tSeekFile(lpPlayParam->lpfDav, 0, FILE_BEGIN);\n\t\treturn 1;\n\t}\n\tTCHAR* CStop::Description(PlayParam* lpPlayParam)\n\t{\n\t\treturn _T(\"Stop\");\n\t}\n\n\t/*CToBegin*/\n\tint CToBegin::Do(PlayParam* lpPlayParam)\n\t{\n\t\tPLAY_ResetBuffer(lpPlayParam->nPort, BUF_VIDEO_SRC);\n\t\tPLAY_ResetBuffer(lpPlayParam->nPort, BUF_AUDIO_SRC);\n\t\tPLAY_ResetBuffer(lpPlayParam->nPort, BUF_VIDEO_RENDER);\n\t\tPLAY_ResetBuffer(lpPlayParam->nPort, BUF_AUDIO_RENDER);\n\t\tSeekFile(lpPlayParam->lpfDav, 0, FILE_BEGIN);\n\t\treturn 1;\n\t}\n\tTCHAR* CToBegin::Description(PlayParam* lpPlayParam)\n\t{\n\t\treturn _T(\"Begin\");\n\t}\n\n\t/*CToEnd*/\n\tint CToEnd::Do(PlayParam* lpPlayParam)\n\t{\n\t\tSeekFile(lpPlayParam->lpfDav, 0, FILE_END);\n\t\treturn 1;\n\t}\n\tTCHAR* CToEnd::Description(PlayParam* lpPlayParam)\n\t{\n\t\treturn _T(\"End\");\n\t}\n}","size_bytes":10033},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgSensorInfoOfVW.cpp":{"content":"// DlgCfgSensorInfoOfVW.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgCfgSensorInfoOfVW.h\"\n#include \"SubDlgSensorInfoDescription.h\"\n#include <VECTOR>\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgSensorInfoOfVW dialog\n\n\nCDlgCfgSensorInfoOfVW::CDlgCfgSensorInfoOfVW(CWnd* pParent /* = NULL */, LLONG lLoginID /* = 0 */, int nChannel /* = 4 */)\n\t: CDialog(CDlgCfgSensorInfoOfVW::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgSensorInfoOfVW)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_lLoginID = lLoginID;\n\tm_nChannel = nChannel;\n\tmemset(&m_stuVW, 0, sizeof(m_stuVW));\n\tm_stuVW.nStructSize = sizeof(m_stuVW);\n\t// only \"stuSensorInfo\" part is usfull for AE6016\n\tfor (int i = 0; i < AV_CFG_Max_Video_Widget_Sensor_Info; i++)\n\t{\n\t\tm_stuVW.stuSensorInfo[i].nStructSize = sizeof(AV_CFG_VideoWidgetSensorInfo);\n\t\tm_stuVW.stuSensorInfo[i].stuRect.nStructSize = sizeof(AV_CFG_Rect);\n\t\tfor (int j = 0; j < AV_CFG_Max_Description_Num; j++)\n\t\t{\n\t\t\tm_stuVW.stuSensorInfo[i].stuDescription[j].nStructSize = sizeof(AV_CFG_VideoWidgetSensorInfo_Description);\n\t\t}\n\t}\n}\n\n\nvoid CDlgCfgSensorInfoOfVW::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgSensorInfoOfVW)\n\tDDX_Control(pDX, IDC_SENSORINFO_CHK_PREVIEWBLEND, m_chkPreviewBlend);\n\tDDX_Control(pDX, IDC_SENSORINFO_CHK_ENCODEBLEND, m_chkEncodeBlend);\n\tDDX_Control(pDX, IDC_SENSORINFO_CMB_CHN, m_cmbChn);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgSensorInfoOfVW, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgSensorInfoOfVW)\n\tON_CBN_SELCHANGE(IDC_SENSORINFO_CMB_CHN, OnSelchangeSensorinfoCmbChn)\n\tON_BN_CLICKED(IDC_SENSORINFO_BTN_DESCRIPTION, OnSensorinfoBtnDescription)\n\tON_BN_CLICKED(IDC_SENSORINFO_BTN_GET, OnSensorinfoBtnGet)\n\tON_BN_CLICKED(IDC_SENSORINFO_BTN_SET, OnSensorinfoBtnSet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgSensorInfoOfVW private method\n\nvoid CDlgCfgSensorInfoOfVW::InitDlg()\n{\n\tint i = 0;\n\tfor (; i < m_nChannel; i++)\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%s%02d\", ConvertString(\"Channel\", DLG_CFG_SENSORINFO), i + 1);\n\t\tm_cmbChn.InsertString(-1, csInfo);\n\t}\n\tm_cmbChn.SetCurSel(0);\n\n\t// Preview blend\n\tm_chkPreviewBlend.SetCheck(BST_UNCHECKED);\n\n\t// Encode blend\n\tm_chkEncodeBlend.SetCheck(BST_UNCHECKED);\n\n\t// Zone\n\tSetDlgItemInt(IDC_SENSORINFO_EDT_LTX, 0, FALSE);\n\tSetDlgItemInt(IDC_SENSORINFO_EDT_LTY, 0, FALSE);\n\tSetDlgItemInt(IDC_SENSORINFO_EDT_RBX, 0, FALSE);\n\tSetDlgItemInt(IDC_SENSORINFO_EDT_RBY, 0, FALSE);\n\n\t// Description...\n}\n\nvoid CDlgCfgSensorInfoOfVW::DlgToStu()\n{\n\t// only support the first one\n\tAV_CFG_VideoWidgetSensorInfo& stuInfo = m_stuVW.stuSensorInfo[0];\n\n\t// Preview blend\n\tif (m_chkPreviewBlend.GetCheck())\n\t{\n\t\tstuInfo.bPreviewBlend = TRUE;\n\t}\n\telse\n\t{\n\t\tstuInfo.bPreviewBlend = FALSE;\n\t}\n\n\t// Encode blend\n\tif (m_chkEncodeBlend.GetCheck())\n\t{\n\t\tstuInfo.bEncodeBlend = TRUE;\n\t}\n\telse\n\t{\n\t\tstuInfo.bEncodeBlend = FALSE;\n\t}\n\n\t// Zone\n\tstuInfo.stuRect.nLeft = GetDlgItemInt(IDC_SENSORINFO_EDT_LTX);\n\tstuInfo.stuRect.nTop = GetDlgItemInt(IDC_SENSORINFO_EDT_LTY);\n\tstuInfo.stuRect.nRight = GetDlgItemInt(IDC_SENSORINFO_EDT_RBX);\n\tstuInfo.stuRect.nBottom = GetDlgItemInt(IDC_SENSORINFO_EDT_RBY);\n\n\t// Description...\n}\n\nvoid CDlgCfgSensorInfoOfVW::StuToDlg()\n{\n\tconst AV_CFG_VideoWidgetSensorInfo& stuInfo = m_stuVW.stuSensorInfo[0];\n\n\t// Preview blend\n\tif (stuInfo.bPreviewBlend)\n\t{\n\t\tm_chkPreviewBlend.SetCheck(BST_CHECKED);\n\t}\n\telse\n\t{\n\t\tm_chkPreviewBlend.SetCheck(BST_UNCHECKED);\n\t}\n\t\n\t// Encode blend\n\tif (stuInfo.bEncodeBlend)\n\t{\n\t\tm_chkEncodeBlend.SetCheck(BST_CHECKED);\n\t}\n\telse\n\t{\n\t\tm_chkEncodeBlend.SetCheck(BST_UNCHECKED);\n\t}\n\t\n\t// Zone\n\tSetDlgItemInt(IDC_SENSORINFO_EDT_LTX, stuInfo.stuRect.nLeft, FALSE);\n\tSetDlgItemInt(IDC_SENSORINFO_EDT_LTY, stuInfo.stuRect.nTop, FALSE);\n\tSetDlgItemInt(IDC_SENSORINFO_EDT_RBX, stuInfo.stuRect.nRight, FALSE);\n\tSetDlgItemInt(IDC_SENSORINFO_EDT_RBY, stuInfo.stuRect.nBottom, FALSE);\t\n\t\n\t// Description...\n}\n\nBOOL CDlgCfgSensorInfoOfVW::GetConfig()\n{\n\tint nChn = m_cmbChn.GetCurSel();\n\tif (-1 == nChn)\n\t{\n\t\treturn FALSE;\n\t}\n\tchar szBuf[1024*10] = {0};\n\tint nErr = 0;\n\tBOOL bRet = CLIENT_GetNewDevConfig(m_lLoginID, CFG_CMD_VIDEOWIDGET, nChn, szBuf, sizeof(szBuf), &nErr, SDK_API_WAIT);\n\tif (!bRet)\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%s:%08x\", ConvertString(\"Get config of VideoWidget error\", DLG_CFG_SENSORINFO), CLIENT_GetLastError());\n\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\n\tint nRetLen = 0;\n\tbRet = CLIENT_ParseData(CFG_CMD_VIDEOWIDGET, szBuf, &m_stuVW, sizeof(m_stuVW), &nRetLen);\n\tif (!bRet || nRetLen != sizeof(m_stuVW))\n\t{\n\t\tMessageBox(ConvertString(\"Parse config of VideoWidget error\", DLG_CFG_SENSORINFO), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nBOOL CDlgCfgSensorInfoOfVW::SetConfig()\n{\n\tint nChn = m_cmbChn.GetCurSel();\n\tif (-1 == nChn)\n\t{\n\t\treturn FALSE;\n\t}\n\tchar szBuf[1024*10] = {0};\n\tint nErr = 0;\n\tint nRestart = 0;\n\tBOOL bRet = CLIENT_PacketData(CFG_CMD_VIDEOWIDGET, &m_stuVW, sizeof(m_stuVW), szBuf, sizeof(szBuf));\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Packet config of VideoWidget error\", DLG_CFG_SENSORINFO), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\tbRet = CLIENT_SetNewDevConfig(m_lLoginID, CFG_CMD_VIDEOWIDGET, nChn, szBuf, strlen(szBuf), &nErr, &nRestart, SDK_API_WAIT);\n\tif (!bRet)\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%s:%08x\", ConvertString(\"Set config of VideoWidget error\", DLG_CFG_SENSORINFO), CLIENT_GetLastError());\n\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\telse\n\t{\n\t\tMessageBox(ConvertString(\"Set config of VideoWidget ok\", DLG_CFG_SENSORINFO), ConvertString(\"Prompt\"));\n\t}\n\treturn TRUE;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgSensorInfoOfVW message handlers\n\nBOOL CDlgCfgSensorInfoOfVW::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_SENSORINFO);\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\tif (GetConfig())\n\t{\n\t\tStuToDlg();\n\t}\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgSensorInfoOfVW::OnSelchangeSensorinfoCmbChn() \n{\n\t// TODO: Add your control notification handler code here\n\tint nChn = m_cmbChn.GetCurSel();\n\tif (-1 == nChn)\n\t{\n\t\treturn;\n\t}\n\tif (GetConfig())\n\t{\n\t\tStuToDlg();\n\t}\t\n}\n\nvoid CDlgCfgSensorInfoOfVW::OnSensorinfoBtnDescription() \n{\n\t// TODO: Add your control notification handler code here\n\tstd::vector<int> vecChn;\n\tint i = 0;\n\tfor (; i < m_stuVW.stuSensorInfo[0].nDescriptionNum; i++)\n\t{\n\t\tvecChn.push_back(m_stuVW.stuSensorInfo[0].stuDescription[i].nSensorID);\n\t}\n\n\tCSubDlgSensorInfoDescription dlg;\n\tdlg.SetID(vecChn);\n\tif (IDOK == dlg.DoModal())\n\t{\n\t\tvecChn.clear();\n\t\tvecChn = dlg.GetID();\n\t\tstd::vector<int>::iterator it = vecChn.begin();\n\t\tfor (i = 0; i < __min(vecChn.size(), AV_CFG_Max_Description_Num) && it != vecChn.end(); i++, it++)\n\t\t{\n\t\t\tm_stuVW.stuSensorInfo[0].stuDescription[i].nSensorID = *it;\n\t\t}\n\t\tm_stuVW.stuSensorInfo[0].nDescriptionNum = __min(vecChn.size(), AV_CFG_Max_Description_Num);\n\t}\n}\n\nvoid CDlgCfgSensorInfoOfVW::OnSensorinfoBtnGet() \n{\n\t// TODO: Add your control notification handler code here\n\tif (GetConfig())\n\t{\n\t\tStuToDlg();\n\t}\t\n}\n\nvoid CDlgCfgSensorInfoOfVW::OnSensorinfoBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\tSetConfig();\n}\n","size_bytes":7612},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgIPConflict.cpp":{"content":"// DlgCfgIPConflict.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"alarmdevice.h\"\n#include \"DlgCfgIPConflict.h\"\n#include \"SubDlgCfgEventHandler.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgIPConflict dialog\n\n\nCDlgCfgIPConflict::CDlgCfgIPConflict(CWnd* pParent /* = NULL */, LLONG lLoginID /* = 0 */)\n\t: CDialog(CDlgCfgIPConflict::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgIPConflict)\n\t\t// NOTE: the ClassWizard will add member initialization here\n    //}}AFX_DATA_INIT\n    m_lLoginId = lLoginID;\n\tmemset(&m_stuInfo, 0, sizeof(CFG_IPCONFLICT_INFO));\n}\n\n\nvoid CDlgCfgIPConflict::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgIPConflict)\n\tDDX_Control(pDX, IDC_CFGIPCONFLICT_CHK_ENABLE, m_ckEnable);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgIPConflict, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgIPConflict)\n\tON_BN_CLICKED(IDC_CFGIPCONFLICT_BTN_EVENTHANDLER, OnCfgipconflictBtnEventhandler)\n\tON_BN_CLICKED(IDC_CFGIPCONFLICT_BTN_GET, OnCfgipconflictBtnGet)\n\tON_BN_CLICKED(IDC_CFGIPCONFLICT_BTN_SET, OnCfgipconflictBtnSet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgIPConflict private method\n\nBOOL CDlgCfgIPConflict::GetConfigFromDevice()\n{\n    char szJsonBuf[1024 * 40] = {0};\n    int nerror = 0;\n    int nSelChn = -1;\n    BOOL bRet = CLIENT_GetNewDevConfig(m_lLoginId, CFG_CMD_IPCONFLICT, nSelChn, szJsonBuf, sizeof(szJsonBuf), &nerror, SDK_API_WAIT);\n    \n    if (bRet)\n    {\n        DWORD dwRetLen = 0;\n        bRet = CLIENT_ParseData(CFG_CMD_IPCONFLICT, szJsonBuf, (void*)&m_stuInfo, sizeof(m_stuInfo), &dwRetLen);\n        if (!bRet)\n        {\n            MessageBox(ConvertString(CString(\"parse IPConflict error...\"), DLG_CFG_IPCONFLICT), ConvertString(\"Prompt\"));\n            return FALSE;\n        }\n    }\n    else\n    {\t\t\t\n        CString csErr;\n        csErr.Format(\"%s 0x%08x\",ConvertString(\"QueryConfig IPConflict error:\", DLG_CFG_IPCONFLICT), CLIENT_GetLastError());\n        MessageBox(csErr, ConvertString(\"Prompt\"));\n        return FALSE;\n    }\n    return TRUE;\n}\n\nBOOL CDlgCfgIPConflict::SetConfigToDevice()\n{\n    char szJsonBuf[1024 * 40] = {0};   \n    BOOL bRet = CLIENT_PacketData(CFG_CMD_IPCONFLICT, &m_stuInfo, sizeof(m_stuInfo), szJsonBuf, sizeof(szJsonBuf));\n    if (!bRet)\n    {\n        MessageBox(ConvertString(CString(\"packet IPConflict error...\"), DLG_CFG_IPCONFLICT), ConvertString(\"Prompt\"));\n        return FALSE;\n    } \n    else\n    {\n        int nerror = 0;\n        int nrestart = 0;\n        bRet = CLIENT_SetNewDevConfig(m_lLoginId, CFG_CMD_IPCONFLICT, -1, szJsonBuf, sizeof(szJsonBuf), &nerror, &nrestart, SDK_API_WAIT);\n        if (!bRet)\n        {\n            CString csErr;\n            csErr.Format(\"%s 0x%08x\", ConvertString(\"SetupConfig IPConflict failed:\", DLG_CFG_IPCONFLICT), CLIENT_GetLastError());\n            MessageBox(csErr, ConvertString(\"Prompt\"));\n            return FALSE;\n        }\n        else\n        {\n            MessageBox(ConvertString(CString(\"SetConfig IPConflict ok!\"), DLG_CFG_IPCONFLICT), ConvertString(\"Prompt\"));\n        }\n    }\n    return TRUE;\n}\n\nBOOL CDlgCfgIPConflict::showInfo()\n{\n    m_ckEnable.SetCheck(m_stuInfo.bEnable ? BST_CHECKED : BST_UNCHECKED);\n    return TRUE;\n}\n\nBOOL CDlgCfgIPConflict::getInfo()\n{\n    m_stuInfo.bEnable = m_ckEnable.GetCheck() ? TRUE : FALSE;\n    return TRUE;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgIPConflict message handlers\n\nBOOL CDlgCfgIPConflict::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n    \n\tg_SetWndStaticText(this, DLG_CFG_IPCONFLICT);\n\t// TODO: Add extra initialization here\n    \n    if (GetConfigFromDevice())\n    {\n        showInfo();\n\t}\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgIPConflict::OnCfgipconflictBtnEventhandler() \n{\n\t// TODO: Add your control notification handler code here\n    CSubDlgCfgEventHandler* pdlgEventHandler = new CSubDlgCfgEventHandler;\n    if (pdlgEventHandler != NULL)\n    {\n        pdlgEventHandler->SetEventHandler(m_stuInfo.stuEventHandler);\n        \n        if (IDOK == pdlgEventHandler->DoModal())\n        {\n            const CFG_ALARM_MSG_HANDLE& stuEventHandler = pdlgEventHandler->GetEventHandler();\n            memcpy(&m_stuInfo.stuEventHandler, &stuEventHandler, sizeof(CFG_ALARM_MSG_HANDLE));\n        }\n        \n        delete pdlgEventHandler;\n        pdlgEventHandler = NULL;\n    }\n    else\n    {\n        MessageBox(ConvertString(\"new handler dialog error!\", DLG_CFG_NETABORT), ConvertString(\"Prompt\"));\n\t}\n}\n\nvoid CDlgCfgIPConflict::OnCfgipconflictBtnGet() \n{\n\t// TODO: Add your control notification handler code here\n    if (GetConfigFromDevice())\n    {\n        showInfo();\n\t}\n}\n\nvoid CDlgCfgIPConflict::OnCfgipconflictBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n    getInfo();\n    SetConfigToDevice();\n}\n","size_bytes":5122},"bin/Demo/MfcDemo/03.Alarm/StdAfx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n//\tAlarm.pch will be the pre-compiled header\n//\tstdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":299},"bin/Demo/MfcDemo/10.AlarmDevice/DlgAlarmOutSet.cpp":{"content":"// DlgAlarmOutSet.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgAlarmOutSet.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgAlarmOutSet dialog\n\n\nCDlgAlarmOutSet::CDlgAlarmOutSet(CWnd* pParent /* = NULL */, LLONG lLoginID /* = 0 */, int nAlarmOut /* = 0 */)\n\t: CDialog(CDlgAlarmOutSet::IDD, pParent)\n    , m_nAlarmOut(0)\n{\n\t//{{AFX_DATA_INIT(CDlgAlarmOutSet)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n    m_lLoginID = lLoginID;\n    m_nAlarmOut = nAlarmOut;\n}\n\n\nvoid CDlgAlarmOutSet::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgAlarmOutSet)\n\tDDX_Control(pDX, IDC_ALARMOUTSET_CHK_MODE, m_chkAction);\n\tDDX_Control(pDX, IDC_ALARMOUTSET_CMB_CHN, m_cmbChannel);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgAlarmOutSet, CDialog)\n\t//{{AFX_MSG_MAP(CDlgAlarmOutSet)\n\tON_BN_CLICKED(IDC_ALARMOUTSET_BTN_SET, OnAlarmoutsetBtnSet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgAlarmOutSet private method\n\nvoid CDlgAlarmOutSet::InitDlg()\n{\n    for (int i = 0; i < m_nAlarmOut; i++)\n    {\n        CString csInfo;\n        csInfo.Format(\"%d\", i+1);\n        m_cmbChannel.InsertString(-1, csInfo);\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgAlarmOutSet message handlers\n\nBOOL CDlgAlarmOutSet::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_ALARMOUTSET);\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgAlarmOutSet::OnAlarmoutsetBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n    ALARMCTRL_PARAM stuParam = {sizeof(stuParam)};\n    stuParam.nAction = m_chkAction.GetCheck();\n    stuParam.nAlarmNo = m_cmbChannel.GetCurSel();\n\tBOOL bRet = CLIENT_ControlDevice(m_lLoginID, DH_TRIGGER_ALARM_OUT, &stuParam, SDK_API_WAIT);\n    if (bRet)\n    {\n        MessageBox(ConvertString(\"set alarm out ok!\", DLG_ALARMOUTSET), ConvertString(\"Prompt\"));\n    } \n    else\n    {\n        CString csInfo;\n        csInfo.Format(\"%s:0x%08x\", ConvertString(\"set alarm out failed\", DLG_ALARMOUTSET), CLIENT_GetLastError());\n        MessageBox(csInfo, ConvertString(\"Prompt\"));\n    }\n}\n","size_bytes":2530},"bin/DemoSrc/playsdkdemo/StreamPlayer.cpp":{"content":"// StreamPlayer.cpp: implementation of the CStreamPlayer class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"PlayDemo.h\"\n#include \"StreamPlayer.h\"\n\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\n//////////////////////////////////////////////////////////////////////\n// Construction/Destruction\n//////////////////////////////////////////////////////////////////////\n\nCStreamPlayer::CStreamPlayer()\n{\n\n}\n\nCStreamPlayer::~CStreamPlayer()\n{\n\n}\n","size_bytes":548},"bin/Demo/MfcDemo/09.AccessControl/DlgSubDlgInfoPassword.cpp":{"content":"// DlgSubDlgInfoPassword.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"accesscontrol.h\"\n#include \"DlgSubDlgInfoPassword.h\"\n#include \"SubDlgSensorInfoDescription.h\"\n#include <VECTOR>\n\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgSubDlgInfoPassword dialog\n\n\nCDlgSubDlgInfoPassword::CDlgSubDlgInfoPassword(CWnd* pParent /* = NULL */, NET_RECORDSET_ACCESS_CTL_PWD* p /* = NULL */, int nAccess /* = 1 */)\n\t: CDialog(CDlgSubDlgInfoPassword::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgSubDlgInfoPassword)\n\t//}}AFX_DATA_INIT\n\tmemset(&m_stuInfo, 0, sizeof(m_stuInfo));\n\tif (p != NULL)\n\t{\n\t\tmemcpy(&m_stuInfo, p, sizeof(NET_RECORDSET_ACCESS_CTL_PWD));\n\t}\n\tm_stuInfo.dwSize = sizeof(m_stuInfo);\n\t\n\tm_emOperateType = Em_Operate_Type_Show;\n    m_nAccessGroup  = nAccess;\n}\n\n\nvoid CDlgSubDlgInfoPassword::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgSubDlgInfoPassword)\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgSubDlgInfoPassword, CDialog)\n\t//{{AFX_MSG_MAP(CDlgSubDlgInfoPassword)\n\tON_BN_CLICKED(IDC_SUBDLG_INFO_PASSWORD_BTN_DOORS, OnSubdlgInfoPasswordBtnDoors)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgSubDlgInfoPassword private method\n\nvoid CDlgSubDlgInfoPassword::InitDlg()\n{\n\t\n\tif (Em_Operate_Type_Show == m_emOperateType)\n\t{\n\t\tGetDlgItem(IDC_SUBDLG_INFO_PASSWORD_EDIT_RECNO)->EnableWindow(FALSE);\n\t\tStuToDlg();\n\t}\n\telse if (Em_Operate_Type_Insert == m_emOperateType)\n\t{\n\t\tGetDlgItem(IDC_SUBDLG_INFO_PASSWORD_EDIT_RECNO)->EnableWindow(FALSE);\n\t}\n\telse if (Em_Operate_Type_Get == m_emOperateType)\n\t{\n\t\tGetDlgItem(IDC_SUBDLG_INFO_PASSWORD_EDIT_RECNO)->EnableWindow();\n\t\tGetDlgItem(IDC_SUBDLG_INFO_PASSWORD_EDIT_USERID)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_SUBDLG_INFO_PASSWORD_EDIT_DOOROPENPWD)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_SUBDLG_INFO_PASSWORD_EDIT_ALARMPWD)->EnableWindow(FALSE);\n\t}\n\telse if (Em_Operate_Type_Update == m_emOperateType)\n\t{\n\t\tStuToDlg();\n\t\tGetDlgItem(IDC_SUBDLG_INFO_PASSWORD_EDIT_RECNO)->EnableWindow(FALSE);\n\t}\n\telse if (Em_Operate_Type_Remove == m_emOperateType)\n\t{\n\t\tStuToDlg();\n\t\tGetDlgItem(IDC_SUBDLG_INFO_PASSWORD_EDIT_RECNO)->EnableWindow();\n\t\tGetDlgItem(IDC_SUBDLG_INFO_PASSWORD_EDIT_USERID)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_SUBDLG_INFO_PASSWORD_EDIT_DOOROPENPWD)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_SUBDLG_INFO_PASSWORD_EDIT_ALARMPWD)->EnableWindow(FALSE);\n\t}\n\telse if (Em_Operate_Type_Clear == m_emOperateType)\n\t{\n\t\t// ...\n\t}\n}\n\nvoid CDlgSubDlgInfoPassword::StuToDlg()\n{\n\t// RecNo\n\tSetDlgItemInt(IDC_SUBDLG_INFO_PASSWORD_EDIT_RECNO, m_stuInfo.nRecNo);\n\t\n\t// user id\n\tSetDlgItemText(IDC_SUBDLG_INFO_PASSWORD_EDIT_USERID, m_stuInfo.szUserID);\n\n\t// pwd of opening door\n\tSetDlgItemText(IDC_SUBDLG_INFO_PASSWORD_EDIT_DOOROPENPWD, m_stuInfo.szDoorOpenPwd);\n\n\t// pwd of alarm\n\tSetDlgItemText(IDC_SUBDLG_INFO_PASSWORD_EDIT_ALARMPWD, m_stuInfo.szAlarmPwd);\n\n\t// doors\n}\n\nvoid CDlgSubDlgInfoPassword::DlgToStu()\n{\t\n\t// RecNo\n\tm_stuInfo.nRecNo = GetDlgItemInt(IDC_SUBDLG_INFO_PASSWORD_EDIT_RECNO, NULL, TRUE);\n\n\t// user id\n\tGetDlgItemText(IDC_SUBDLG_INFO_PASSWORD_EDIT_USERID, m_stuInfo.szUserID, sizeof(m_stuInfo.szUserID) - 1);\n\n\t// pwd of opening door\n\tGetDlgItemText(IDC_SUBDLG_INFO_PASSWORD_EDIT_DOOROPENPWD, m_stuInfo.szDoorOpenPwd, sizeof(m_stuInfo.szDoorOpenPwd) - 1);\n\n\t// pwd of alarm\n\tGetDlgItemText(IDC_SUBDLG_INFO_PASSWORD_EDIT_ALARMPWD, m_stuInfo.szAlarmPwd, sizeof(m_stuInfo.szAlarmPwd) - 1);\n\n\t// doos\n}\n\nBOOL CDlgSubDlgInfoPassword::Get()\n{\n\tm_stuInfo.nRecNo = GetDlgItemInt(IDC_SUBDLG_INFO_PASSWORD_EDIT_RECNO, NULL, TRUE);\n\treturn TRUE;\n}\n\nBOOL CDlgSubDlgInfoPassword::Update()\n{\n\treturn TRUE;\n}\n\nBOOL CDlgSubDlgInfoPassword::Remove()\n{\n\treturn TRUE;\n}\n\nvoid CDlgSubDlgInfoPassword::Clear()\n{\n\t\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgSubDlgInfoPassword message handlers\n\nvoid CDlgSubDlgInfoPassword::OnSubdlgInfoPasswordBtnDoors() \n{\n\t// TODO: Add your control notification handler code here\n\tstd::vector<int> vecChn;\n\tint i = 0;\n\tfor (; i < __min(m_stuInfo.nDoorNum, DH_MAX_DOOR_NUM); i++)\n\t{\n\t\tvecChn.push_back(m_stuInfo.sznDoors[i]);\n\t}\n\t\n\tCSubDlgSensorInfoDescription dlg(this, m_nAccessGroup);\n\tdlg.SetID(vecChn);\n\tif (IDOK == dlg.DoModal())\n\t{\n\t\tif (Em_Operate_Type_Insert == m_emOperateType\n\t\t\t|| Em_Operate_Type_Update == m_emOperateType)\n\t\t{\n\t\t\tvecChn.clear();\n\t\t\tvecChn = dlg.GetID();\n\t\t\tstd::vector<int>::iterator it = vecChn.begin();\n\t\t\tfor (i = 0; i < __min(vecChn.size(), DH_MAX_DOOR_NUM) && it != vecChn.end(); i++, it++)\n\t\t\t{\n\t\t\t\tm_stuInfo.sznDoors[i] = *it;\n\t\t\t}\n\t\t\tm_stuInfo.nDoorNum = __min(vecChn.size(), DH_MAX_DOOR_NUM);\n\t\t}\n\t}\n}\n\nBOOL CDlgSubDlgInfoPassword::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\tg_SetWndStaticText(this, SUBDLG_INFO_PWD);\n\t// TODO: Add extra initialization here\n\tInitDlg();\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgSubDlgInfoPassword::OnOK() \n{\n\t// TODO: Add extra validation here\n\tswitch (m_emOperateType)\n\t{\n\tcase Em_Operate_Type_Show:\n\t\t{\n\t\t\tStuToDlg();\n\t\t}\n\t\tbreak;\n\tcase Em_Operate_Type_Insert:\n\t\t{\n\t\t\tDlgToStu();\n\t\t}\n\t\tbreak;\n\tcase Em_Operate_Type_Get:\n\t\t{\n\t\t\tDlgToStu();\n\t\t}\n\t\tbreak;\n\tcase Em_Operate_Type_Update:\n\t\t{\n\t\t\tDlgToStu();\n\t\t}\n\t\tbreak;\n\tcase Em_Operate_Type_Remove:\n\t\t{\n\t\t\tDlgToStu();\n\t\t}\n\t\tbreak;\n\tcase Em_Operate_Type_Clear:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tCDialog::OnOK();\n}\n","size_bytes":5623},"bin/Demo/MfcDemo/10.AlarmDevice/PlayApi.cpp":{"content":"#include \"StdAfx.h\"\n#include \"PlayApi.h\"\n\n//////////////////////////////////////////////////////////////////////////\n//\n\nCPlayAPI::CPlayAPI():\nm_hModule(NULL),\nm_APIOpenStream(NULL),\nm_APISetDisplayCallBack(NULL),\nm_APIRigisterDrawFun(NULL),\nm_APIPlay(NULL),\nm_APIInputData(NULL),\nm_APIQueryInfo(NULL),\nm_APIStop(NULL),\nm_APICloseStream(NULL)\n{\n\tLoadPlayDll();\n}\n\nCPlayAPI::~CPlayAPI()\n{\n\tif (m_hModule)\n\t{\n\t\tFreeLibrary(m_hModule);\n\t\tm_hModule = NULL;\n\n\t\tOutputDebugString(_T(\"Unload PlaySDK!\\n\"));\n\t}\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//\n\nvoid CPlayAPI::LoadPlayDll()\n{\n\tHMODULE hLib = ::LoadLibraryEx(\"dhplay.dll\", NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n\tif (hLib)\n\t{\n\t\tm_APIOpenStream = (PLAY_API_OPENSTREAM)GetProcAddress(hLib, \"PLAY_OpenStream\");;\n\t\tm_APISetDisplayCallBack = (PLAY_API_SETIVSCALLBACK)GetProcAddress(hLib, \"PLAY_SetIVSCallBack\");\n\t\tm_APIRigisterDrawFun = (PLAY_API_RIGISTERDRAWFUN)GetProcAddress(hLib, \"PLAY_RigisterDrawFun\");\n\t\tm_APIPlay = (PLAY_API_PLAY)GetProcAddress(hLib, \"PLAY_Play\");\n\t\tm_APIInputData = (PLAY_API_INPUTDATA)GetProcAddress(hLib, \"PLAY_InputData\");\n\t\tm_APIQueryInfo = (PLAY_API_QUERYINFO)GetProcAddress(hLib, \"PLAY_QueryInfo\");\n\t\tm_APIStop = (PLAY_API_STOP)GetProcAddress(hLib, \"PLAY_Stop\");\n\t\tm_APICloseStream = (PLAY_API_CLOSESTREAM)GetProcAddress(hLib, \"PLAY_CloseStream\");\n\n\t\tm_hModule = hLib;\n\t\tOutputDebugString(_T(\"Load PlaySDK Successfully!\\n\"));\n\t}\n\telse\n\t{\n\t\tOutputDebugString(_T(\"Load PlaySDK Failed!\\n\"));\n\t}\n}\n\nBOOL CPlayAPI::PLAY_OpenStream(LONG nPort,PBYTE pFileHeadBuf,DWORD nSize,DWORD nBufPoolSize)\n{\n\tif (m_APIOpenStream)\n\t{\n\t\treturn m_APIOpenStream(nPort, pFileHeadBuf, nSize, nBufPoolSize);\n\t}\n\n\treturn FALSE;\n}\n\nBOOL CPlayAPI::PLAY_SetIVSCallBack(LONG nPort, GetIVSInfoCallbackFunc pFunc, void* pUserData)\n{\n\tif (m_APISetDisplayCallBack)\n\t{\n\t\treturn m_APISetDisplayCallBack(nPort, pFunc, pUserData);\n\t}\n\n\treturn FALSE;\n}\n\nBOOL CPlayAPI::PLAY_RigisterDrawFun(LONG nPort, DrawFun DrawFuncb, void* pUserData)\n{\n\tif (m_APIRigisterDrawFun)\n\t{\n\t\treturn m_APIRigisterDrawFun(nPort, DrawFuncb, pUserData);\n\t}\n\n\treturn FALSE;\n}\n\nBOOL CPlayAPI::PLAY_Play(LONG nPort, HWND hWnd)\n{\n\tif (m_APIPlay)\n\t{\n\t\treturn m_APIPlay(nPort, hWnd);\n\t}\n\n\treturn FALSE;\n}\n\nBOOL CPlayAPI::PLAY_InputData(LONG nPort, PBYTE pBuf, DWORD nSize)\n{\n\tif (m_APIInputData)\n\t{\n\t\treturn m_APIInputData(nPort, pBuf, nSize);\n\t}\n\n\treturn FALSE;\n}\n\nBOOL CPlayAPI::PLAY_QueryInfo(LONG nPort , int cmdType, char* buf, int buflen, int* returnlen)\n{\n\tif (m_APIQueryInfo)\n\t{\n\t\treturn m_APIQueryInfo(nPort, cmdType, buf, buflen, returnlen);\n\t}\n\n\treturn FALSE;\n}\n\nBOOL CPlayAPI::PLAY_Stop(LONG nPort)\n{\n\tif (m_APIStop)\n\t{\n\t\treturn m_APIStop(nPort);\n\t}\n\n\treturn FALSE;\n}\n\nBOOL CPlayAPI::PLAY_CloseStream(LONG nPort)\n{\n\tif (m_APICloseStream)\n\t{\n\t\treturn m_APICloseStream(nPort);\n\t}\n\n\treturn FALSE;\n}\n","size_bytes":2855},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/PtzMenu.cpp":{"content":"// DHPtzMenu.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"PtzMenu.h\"\n#include \"NetSDKDemoDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CPtzMenu dialog\n\n\nCPtzMenu::CPtzMenu(CWnd* pParent /*=NULL*/)\n\t: CDialog(CPtzMenu::IDD, pParent)\n{\n\tm_DeviceID = 0;\n\tm_Channel = 0;\n\t//{{AFX_DATA_INIT(CPtzMenu)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CPtzMenu::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CPtzMenu)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CPtzMenu, CDialog)\n\t//{{AFX_MSG_MAP(CPtzMenu)\n\tON_BN_CLICKED(IDC_OPR_CANCEL, OnOprCancel)\n\tON_BN_CLICKED(IDC_OPR_CLOSEMENU, OnOprClosemenu)\n\tON_BN_CLICKED(IDC_OPR_DOWN, OnOprDown)\n\tON_BN_CLICKED(IDC_OPR_LEFT, OnOprLeft)\n\tON_BN_CLICKED(IDC_OPR_OK, OnOprOk)\n\tON_BN_CLICKED(IDC_OPR_OPENMENU, OnOprOpenmenu)\n\tON_BN_CLICKED(IDC_OPR_RIGHT, OnOprRight)\n\tON_BN_CLICKED(IDC_OPR_UP, OnOprUp)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CPtzMenu message handlers\nvoid CPtzMenu::SetPtzParam(LLONG iHandle, int iChannel)\n{\n\tm_DeviceID = iHandle;\n\tm_Channel = iChannel;\n\n}\nvoid CPtzMenu::OnOprCancel() \n{\n\tPtzMemuControl(DH_EXTPTZ_MENUCANCEL);\n}\n\nvoid CPtzMenu::OnOprClosemenu() \n{\n\tPtzMemuControl(DH_EXTPTZ_CLOSEMENU);\n}\n\nvoid CPtzMenu::OnOprDown() \n{\n\tPtzMemuControl(DH_EXTPTZ_MENUDOWN);\n}\n\nvoid CPtzMenu::OnOprLeft() \n{\n\tPtzMemuControl(DH_EXTPTZ_MENULEFT);\n}\n\nvoid CPtzMenu::OnOprOk() \n{\n\tPtzMemuControl(DH_EXTPTZ_MENUOK);\n}\n\nvoid CPtzMenu::OnOprOpenmenu() \n{\n\tPtzMemuControl(DH_EXTPTZ_OPENMENU);\n}\n\nvoid CPtzMenu::OnOprRight() \n{\n\tPtzMemuControl(DH_EXTPTZ_MENURIGHT);\n}\n\nvoid CPtzMenu::OnOprUp() \n{\n\tPtzMemuControl(DH_EXTPTZ_MENUUP);\n}\n\nvoid CPtzMenu::PtzMemuControl(DWORD dwCommand)\n{\n\tif(!m_DeviceID)\n\t{\n\t\tMessageBox(ConvertString(MSG_PTZCTRL_NOCHANNEL));\n\t}\n\tBOOL ret = CLIENT_DHPTZControl(m_DeviceID, m_Channel,dwCommand ,0,0,0,FALSE);\n\tif(!ret)\n\t{\t\n\t\t((CNetSDKDemoDlg *)GetParent())->LastError();//Zhengdh 06.11.24\n\t\tMessageBox(ConvertString(MSG_PTZCTRL_CTRLFAILED));\n\t}\n\t\n}\n\nBOOL CPtzMenu::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\treturn TRUE;\n}\n","size_bytes":2417},"bin/DemoSrc/playsdkdemo/LocateDlg.cpp":{"content":"// LocateDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"PlayDemo.h\"\n#include \"LocateDlg.h\"\n#include \"Player.h\"\n#include \"LanguageConvertor.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CLocateDlg dialog\n\n\nCLocateDlg::CLocateDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CLocateDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CLocateDlg)\n\tm_locateType = TYPEBYFRAME;\n\tm_locatevalue = 0;\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CLocateDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CLocateDlg)\n\tDDX_Text(pDX, IDC_EDIT_RANGEVALUE, m_locatevalue);\n\tDDX_Radio(pDX, IDC_RADIO_FRAME, m_locateType);\n\t//}}AFX_DATA_MAP\n\tDDV_MinMaxInt(pDX, m_locatevalue, 0, INT_MAX);\n}\n\n\nBEGIN_MESSAGE_MAP(CLocateDlg, CDialog)\n\t//{{AFX_MSG_MAP(CLocateDlg)\n\tON_BN_CLICKED(IDC_BUTTON_LOCATE, OnButtonLocate)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CLocateDlg message handlers\n\nvoid CLocateDlg::OnButtonLocate() \n{\n\t// TODO: Add your control notification handler code here\n\tif (UpdateData(TRUE) == 0)\n\t\treturn ;\n\n\tm_locateType = ((CButton*)GetDlgItem(IDC_RADIO_FRAME))->GetCheck()?TYPEBYFRAME:TYPEBYTIME;\n\tif (m_locateType == TYPEBYFRAME)\n\t{\n\t\tif ( m_locatevalue < 0 || m_locatevalue > CPlayer::Instance()->GetTotalFrame() - 1)\n\t\t{\n\t\t\tAfxMessageBox(LANG_CS(\"Input number error!\")) ;\n\t\t\treturn ;\n\t\t}\n\t\tCPlayer::Instance()->SetCurrentFrameNum(m_locatevalue);\n\t}\n\telse \n\t{\n\t\tif (m_locatevalue < 0 || m_locatevalue > CPlayer::Instance()->GetTotalTime())\n\t\t{\n\t\t\tAfxMessageBox(LANG_CS(\"Input number error!\")) ;\n\t\t\treturn ;\n\t\t}\n\t\tCPlayer::Instance()->SetPlayedTiemEx(m_locatevalue*1000);\n\t}\n}\n\nBOOL CLocateDlg::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\tLANG_SETWNDSTATICTEXT(this);\n\t// TODO: Add extra initialization here\n\tCString str ;\n\tstr.Format(_T(\"%s         0--%d\\n%s(Sec)     0--%d\"),\n\t\tLANG_CS(\"Frame Range\"), CPlayer::Instance()->GetTotalFrame() - 1,\n\t\tLANG_CS(\"Time Range\"), CPlayer::Instance()->GetTotalTime());\n\tm_locatevalue = 0;\n\tGetDlgItem(IDC_STATIC_RANGE)->SetWindowText(str);\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nBOOL CLocateDlg::PreTranslateMessage(MSG* pMsg) \n{\n\t// TODO: Add your specialized code here and/or call the base class\n\tif (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_RETURN )\n\t{\n\t\tOnButtonLocate();\n\t\treturn 1;\n\t}\n\telse if(pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_ESCAPE)\n\t\treturn 1;\n\treturn CDialog::PreTranslateMessage(pMsg);\n}\n","size_bytes":2697},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgExAlarmOutput.cpp":{"content":"// DlgCfgExAlarmOutput.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgCfgExAlarmOutput.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgExAlarmOutput dialog\n\n\nCDlgCfgExAlarmOutput::CDlgCfgExAlarmOutput(CWnd* pParent /*=NULL*/, LLONG lLoginID /*= NULL*/)\n\t: CDialog(CDlgCfgExAlarmOutput::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgExAlarmOutput)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_lLoginId = lLoginID;\n\tmemset(&m_stuInfo, 0, sizeof(CFG_EXALARMOUTPUT_INFO));\n}\n\n\nvoid CDlgCfgExAlarmOutput::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgExAlarmOutput)\n\tDDX_Control(pDX, IDC_EXALARMOUTPUT_COMBO_CHANNEL, m_cbChannel);\n\tDDX_Control(pDX, IDC_EXALARMOUTPUT_COMBO_MODE, m_cmbMode);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgExAlarmOutput, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgExAlarmOutput)\n\tON_BN_CLICKED(IDC_EXALARMOUTPUT_BTN_GET, OnExalarmoutputBtnGet)\n\tON_BN_CLICKED(IDC_EXALARMOUTPUT_BTN_SET, OnExalarmoutputBtnSet)\n\tON_CBN_SELCHANGE(IDC_EXALARMOUTPUT_COMBO_CHANNEL, OnSelchangeExalarmoutputComboChannel)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgExAlarmOutput message handlers\n\nBOOL CDlgCfgExAlarmOutput::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_EXALARMOUTPUT);\n\t\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\tif (m_lLoginId != 0)\n\t{\n// \t\tm_cbChannel.SetCurSel(0);\n// \t\tif (GetAlarmOutConfig())\n// \t\t{\n// \t\t\tStuToDlg();\n// \t\t}\n\t}\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgExAlarmOutput::InitDlg()\n{\n\tint i = 0;\n\t\n\t// channel\n\tfor (i = 0; i < MAX_EXALARM_CHANNEL_NUM; i++)\n\t{\n\t\tCString csTemp;\n\t\tcsTemp.Format(\"%s %02d\", ConvertString(\"Channel\", DLG_CFG_EXALARMOUTPUT), i + 1);\n\t\tm_cbChannel.InsertString(-1, csTemp);\n\t}\n\tm_cbChannel.SetCurSel(-1);\n\t\n\t// name\n\tSetDlgItemText(IDC_ALARMOUT_EDT_NAME, \"\");\n\t\n\t// output type\n\tSetDlgItemText(IDC_ALARMOUT_EDT_OUTTYPE, \"\");\n\t\n\t// output mode\n\tfor (i = 0; i < sizeof(DemoExOutputMode) / sizeof(DemoExOutputMode[0]); i++)\n\t{\n\t\tm_cmbMode.InsertString(-1, ConvertString(DemoExOutputMode[i].pszName, DLG_CFG_EXALARMOUTPUT));\n\t}\n\tm_cmbMode.SetCurSel(-1);\n}\n\nvoid CDlgCfgExAlarmOutput::StuToDlg()\n{\n\tSetDlgItemText(IDC_EXALARMOUTPUT_EDIT_NAME, m_stuInfo.szChnName);\n\tm_cmbMode.SetCurSel(m_stuInfo.nOutputMode);\n}\n\nvoid CDlgCfgExAlarmOutput::DlgToStu()\n{\n\tGetDlgItemText(IDC_EXALARMOUTPUT_EDIT_NAME, m_stuInfo.szChnName, sizeof(m_stuInfo.szChnName));\n\tm_stuInfo.nOutputMode = m_cmbMode.GetCurSel();\n}\n\nBOOL CDlgCfgExAlarmOutput::GetAlarmOutConfig()\n{\n\tint nerror = 0;\n\tBOOL bSuccess = FALSE;\n\tBOOL bRet = FALSE;\n\tchar *szOutBuffer = new char[1024];\n\tif (szOutBuffer == NULL)\n\t{\n\t\treturn FALSE;\t\n\t}\n\tmemset(szOutBuffer, 0, 1024);\n\t\n\tint nSelChn = m_cbChannel.GetCurSel() == -1 ? 0 : m_cbChannel.GetCurSel();\n\tbSuccess = CLIENT_GetNewDevConfig(m_lLoginId, CFG_CMD_EXALARMOUTPUT, nSelChn, szOutBuffer, 1024, &nerror, SDK_API_WAIT);\n\tif (bSuccess)\n\t{\n\t\tCFG_EXALARMOUTPUT_INFO stuInfo = {0};\n\t\tDWORD dwRet = 0;\n\t\tbRet = CLIENT_ParseData(CFG_CMD_EXALARMOUTPUT, szOutBuffer, &stuInfo, sizeof(stuInfo), &dwRet);\n\t\tif (bRet && sizeof(CFG_EXALARMOUTPUT_INFO) == dwRet)\n\t\t{\n\t\t\tmemcpy(&m_stuInfo, &stuInfo, sizeof(CFG_EXALARMOUTPUT_INFO));\n\t\t\t//MessageBox(\"Get config of AlarmOut ok!\", ConvertString(\"Prompt\"));\n\t\t} \n\t\telse\n\t\t{\n\t\t\tMessageBox(ConvertString(\"Parse AlarmOut error!\", DLG_CFG_EXALARMOUTPUT), ConvertString(\"Prompt\"));\n\t\t\t//return FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"Query config of ExAlarmOut error:\", DLG_CFG_EXALARMOUTPUT), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\t//return FALSE;\n\t}\n\n\tif (szOutBuffer)\n\t{\n\t\tdelete []szOutBuffer;\n\t\tszOutBuffer = NULL;\n\t}\n\n\treturn bRet;\n}\n\nBOOL CDlgCfgExAlarmOutput::SetAlarmOutConfig()\n{\n\tint nSelChn = m_cbChannel.GetCurSel();\n\tint nSelMode = m_cmbMode.GetCurSel();\n\tif (-1 == nSelChn || -1 == nSelMode)\n\t{\n\t\treturn FALSE;\n\t}\n\t\n\tCFG_EXALARMOUTPUT_INFO stuInfo = {0};\n\tGetDlgItemText(IDC_EXALARMOUTPUT_EDIT_NAME, stuInfo.szChnName, sizeof(stuInfo.szChnName));\n\tstuInfo.nOutputMode = nSelMode;\n\t\n\tchar szJson[1024] = {0};\n\tBOOL bRet = CLIENT_PacketData(CFG_CMD_EXALARMOUTPUT, &stuInfo, sizeof(stuInfo), szJson, sizeof(szJson));\n\tif (bRet)\n\t{\n\t\tint nerror = 0;\n\t\tint nrestart = 0;\n\t\tbRet  = CLIENT_SetNewDevConfig(m_lLoginId, CFG_CMD_EXALARMOUTPUT, nSelChn, szJson, 1024, &nerror, &nrestart, SDK_API_WAIT);\t\n\t\tif (bRet)\n\t\t{\n\t\t\tmemcpy(&m_stuInfo, &stuInfo, sizeof(CFG_EXALARMOUTPUT_INFO));\n\t\t\tMessageBox(ConvertString(\"Set config of AlarmOut successfully!\", DLG_CFG_EXALARMOUTPUT), ConvertString(\"Prompt\"));\n\t\t\n\t\t} \n\t\telse\n\t\t{\n\t\t\tCString csErr;\n\t\t\tcsErr.Format(\"%s %08x\", ConvertString(\"Set config of AlarmOut error:\", DLG_CFG_EXALARMOUTPUT), CLIENT_GetLastError());\n\t\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t} \n\telse\n\t{\n\t\tMessageBox(ConvertString(\"Packet AlarmOut error!\", DLG_CFG_EXALARMOUTPUT), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nvoid CDlgCfgExAlarmOutput::OnSelchangeExalarmoutputComboChannel() \n{\n\t// TODO: Add your control notification handler code here\n\tGetAlarmOutConfig();\n\tStuToDlg();\n}\n\nvoid CDlgCfgExAlarmOutput::OnExalarmoutputBtnGet() \n{\n\t// TODO: Add your control notification handler code here\n\tif (GetAlarmOutConfig())\n\t{\n\t\tStuToDlg();\n\t}\n}\n\nvoid CDlgCfgExAlarmOutput::OnExalarmoutputBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\tSetAlarmOutConfig();\n}\n","size_bytes":5820},"bin/Demo/MfcDemo/22.ThermalCamera/QueryItemInfoDlg.cpp":{"content":"// QueryItemInfoDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"ThermalCamera.h\"\n#include \"ThermalCameraDlg.h\"\n#include \"QueryItemInfoDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CQueryItemInfoDlg dialog\n\n\nCQueryItemInfoDlg::CQueryItemInfoDlg(CWnd* pParent /*=NULL*/,LLONG iLoginId,int nChannel)\n\t: CDialog(CQueryItemInfoDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CQueryItemInfoDlg)\n\tm_RuleID = 0;\n\tm_PresetID = 0;\n\tm_Measuretype = _T(\"unknown\");\n\tm_MaxTemp = 0.0f;\n\tm_Unit = _T(\"unknown\");\n\tm_AveTemp = 0.0f;\n\tm_MidTemp = 0.0f;\n\tm_MinTemp = 0.0f;\n\tm_StdTemp = 0.0f;\n\t//}}AFX_DATA_INIT\n    m_iLoginID = iLoginId;\n    m_nChannel = nChannel;\n}\n\n\nvoid CQueryItemInfoDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CQueryItemInfoDlg)\n\tDDX_Control(pDX, IDC_COMBO_METERTYPE, m_ComboMeterType);\n\tDDX_Text(pDX, IDC_EDIT_RULEID, m_RuleID);\n\tDDX_Text(pDX, IDC_EDIT_PRESETID, m_PresetID);\n\tDDX_Text(pDX, IDC_EDIT_MEASURETYPE, m_Measuretype);\n\tDDX_Text(pDX, IDC_EDIT_MAXTEMP, m_MaxTemp);\n\tDDX_Text(pDX, IDC_EDIT_UNIT, m_Unit);\n\tDDX_Text(pDX, IDC_EDIT_TEMP, m_AveTemp);\n\tDDX_Text(pDX, IDC_EDIT_MIDTEMP, m_MidTemp);\n\tDDX_Text(pDX, IDC_EDIT_MINTEMP, m_MinTemp);\n\tDDX_Text(pDX, IDC_EDIT_STDTEMP, m_StdTemp);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CQueryItemInfoDlg, CDialog)\n\t//{{AFX_MSG_MAP(CQueryItemInfoDlg)\n\tON_BN_CLICKED(IDC_QUERYITEMINFO, OnQueryiteminfo)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CQueryItemInfoDlg message handlers\n\nvoid CQueryItemInfoDlg::OnQueryiteminfo() \n{\n    UpdateData();\n    NET_IN_RADIOMETRY_GETTEMPER stuRadioMetryInTemper = {sizeof(stuRadioMetryInTemper)};  \n    NET_OUT_RADIOMETRY_GETTEMPER stuRadioMetryOutTemper = {sizeof(stuRadioMetryOutTemper)};\n    stuRadioMetryInTemper.stCondition.nChannel = m_nChannel;\n    stuRadioMetryInTemper.stCondition.nPresetId = m_PresetID;\n    stuRadioMetryInTemper.stCondition.nRuleId = m_RuleID;\n    int i = m_ComboMeterType.GetCurSel();    \n    if (0 == i)\n    {\n        stuRadioMetryInTemper.stCondition.nMeterType = NET_RADIOMETRY_METERTYPE_SPOT;\n    }\n    else if (1 == i)\n    {\n        stuRadioMetryInTemper.stCondition.nMeterType = NET_RADIOMETRY_METERTYPE_LINE;\n    }\n    else if (2 == i)\n    {\n        stuRadioMetryInTemper.stCondition.nMeterType = NET_RADIOMETRY_METERTYPE_AREA;\n    }\n    BOOL ret = CLIENT_QueryDevInfo(m_iLoginID,NET_QUERY_DEV_RADIOMETRY_TEMPER,&stuRadioMetryInTemper,&stuRadioMetryOutTemper,NULL,3000);\n    if (0 != ret)\n    {\n        if (NET_RADIOMETRY_METERTYPE_UNKNOWN == stuRadioMetryOutTemper.stTempInfo.nMeterType)\n        {\n            m_Measuretype = ConvertString(\"Unknown\");\n        }\n        else if (NET_RADIOMETRY_METERTYPE_SPOT == stuRadioMetryOutTemper.stTempInfo.nMeterType)\n        {\n            m_Measuretype = ConvertString(\"Spot\");\n        }\n        else if (NET_RADIOMETRY_METERTYPE_LINE == stuRadioMetryOutTemper.stTempInfo.nMeterType)\n        {\n            m_Measuretype = ConvertString(\"Line\");\n        }\n        else if (NET_RADIOMETRY_METERTYPE_AREA == stuRadioMetryOutTemper.stTempInfo.nMeterType)\n        {\n            m_Measuretype = ConvertString(\"Area\");\n        }\n        if (TEMPERATURE_UNIT_UNKNOWN == stuRadioMetryOutTemper.stTempInfo.nTemperUnit)\n        {\n            m_Unit = ConvertString(\"Unknown\");\n        }\n        else if (TEMPERATURE_UNIT_CENTIGRADE == stuRadioMetryOutTemper.stTempInfo.nTemperUnit)\n        {\n            m_Unit = ConvertString(\"Celsius\");\n        }\n        else if (TEMPERATURE_UNIT_FAHRENHEIT == stuRadioMetryOutTemper.stTempInfo.nTemperUnit)\n        {\n            m_Unit = ConvertString(\"Fahrenheit\");\n        }\n        m_AveTemp = stuRadioMetryOutTemper.stTempInfo.fTemperAver;\n        m_MaxTemp = stuRadioMetryOutTemper.stTempInfo.fTemperMax;\n        m_MinTemp = stuRadioMetryOutTemper.stTempInfo.fTemperMin;\n        m_MidTemp = stuRadioMetryOutTemper.stTempInfo.fTemperMid;\n        m_StdTemp = stuRadioMetryOutTemper.stTempInfo.fTemperStd;\n    }\n\telse\n\t{\n\t\tMessageBox(ConvertString(\"Query failed. Please check if the input information is incorrect.\"), ConvertString(\"Prompt\"));\n\t}\n    UpdateData(FALSE);\n}\n\nBOOL CQueryItemInfoDlg::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n    g_SetWndStaticText(this);\n    int nIndex = 0;\n    CString strMeterType[3] = {ConvertString(\"Spot\"),ConvertString(\"Line\"),ConvertString(\"Area\")};\n    m_ComboMeterType.ResetContent();\n    nIndex = m_ComboMeterType.AddString(strMeterType[0]);\n    m_ComboMeterType.SetItemData(nIndex,SPOT);\n    nIndex = m_ComboMeterType.AddString(strMeterType[1]);\n    m_ComboMeterType.SetItemData(nIndex,LINE);\n    nIndex = m_ComboMeterType.AddString(strMeterType[2]);\n    m_ComboMeterType.SetItemData(nIndex,AREA);\n    m_ComboMeterType.SetCurSel(0);\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n","size_bytes":5075},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/font.cpp":{"content":"// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++\n\n// NOTE: Do not modify the contents of this file.  If this class is regenerated by\n//  Microsoft Visual C++, your modifications will be overwritten.\n\n\n#include \"StdAfx.h\"\n#include \"font.h\"\n\n\n/////////////////////////////////////////////////////////////////////////////\n// COleFont properties\n\nCString COleFont::GetName()\n{\n\tCString result;\n\tGetProperty(0x0, VT_BSTR, (void*)&result);\n\treturn result;\n}\n\nvoid COleFont::SetName(LPCTSTR propVal)\n{\n\tSetProperty(0x0, VT_BSTR, propVal);\n}\n\nCY COleFont::GetSize()\n{\n\tCY result;\n\tGetProperty(0x2, VT_CY, (void*)&result);\n\treturn result;\n}\n\nvoid COleFont::SetSize(const CY& propVal)\n{\n\tSetProperty(0x2, VT_CY, &propVal);\n}\n\nBOOL COleFont::GetBold()\n{\n\tBOOL result;\n\tGetProperty(0x3, VT_BOOL, (void*)&result);\n\treturn result;\n}\n\nvoid COleFont::SetBold(BOOL propVal)\n{\n\tSetProperty(0x3, VT_BOOL, propVal);\n}\n\nBOOL COleFont::GetItalic()\n{\n\tBOOL result;\n\tGetProperty(0x4, VT_BOOL, (void*)&result);\n\treturn result;\n}\n\nvoid COleFont::SetItalic(BOOL propVal)\n{\n\tSetProperty(0x4, VT_BOOL, propVal);\n}\n\nBOOL COleFont::GetUnderline()\n{\n\tBOOL result;\n\tGetProperty(0x5, VT_BOOL, (void*)&result);\n\treturn result;\n}\n\nvoid COleFont::SetUnderline(BOOL propVal)\n{\n\tSetProperty(0x5, VT_BOOL, propVal);\n}\n\nBOOL COleFont::GetStrikethrough()\n{\n\tBOOL result;\n\tGetProperty(0x6, VT_BOOL, (void*)&result);\n\treturn result;\n}\n\nvoid COleFont::SetStrikethrough(BOOL propVal)\n{\n\tSetProperty(0x6, VT_BOOL, propVal);\n}\n\nshort COleFont::GetWeight()\n{\n\tshort result;\n\tGetProperty(0x7, VT_I2, (void*)&result);\n\treturn result;\n}\n\nvoid COleFont::SetWeight(short propVal)\n{\n\tSetProperty(0x7, VT_I2, propVal);\n}\n\nshort COleFont::GetCharset()\n{\n\tshort result;\n\tGetProperty(0x8, VT_I2, (void*)&result);\n\treturn result;\n}\n\nvoid COleFont::SetCharset(short propVal)\n{\n\tSetProperty(0x8, VT_I2, propVal);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// COleFont operations\n","size_bytes":1987},"bin/DemoSrc/playsdkdemo/HoverButton.cpp":{"content":"// ColorButton.cpp : implementation file\n//\n// Copyright (c) 2009.\n//\n\n#include \"stdafx.h\"\n#include \"HoverButton.h\"\n\n#include <afxtempl.h>\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\nBEGIN_MESSAGE_MAP(CHoverButton, CBitmapButton)\n\t//{{AFX_MSG_MAP(CHoverButton)\n\tON_WM_MOUSEMOVE()\n\tON_MESSAGE(WM_MOUSELEAVE,OnMouseLeave)\n\tON_MESSAGE(WM_MOUSEHOVER,OnMouseHover)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////\nCHoverButton::CHoverButton()\n{\n    m_bHover = FALSE;       \n    m_bTracking = FALSE;\n\tm_bButtonEnable = TRUE;\n}\n\nCHoverButton::~CHoverButton()\n{\n\n}\n\nBOOL CHoverButton::LoadBitmap(UINT bitmapid)\n{\n    //load picture\n    mybitmap.Attach(::LoadImage(::AfxGetInstanceHandle(),MAKEINTRESOURCE(bitmapid), IMAGE_BITMAP,0,0,LR_LOADMAP3DCOLORS));\n    BITMAP    bitmapbits;\n    //receive bitmap info and save it to bitmapbits struct\n    mybitmap.GetBitmap(&bitmapbits);\n    \n    //receive the height and quarter of the width of the bitmap.\n    m_ButtonSize.cy=bitmapbits.bmHeight;\n    m_ButtonSize.cx=bitmapbits.bmWidth/4;\n    \n    SetWindowPos(NULL, 0,0, m_ButtonSize.cx,m_ButtonSize.cy,SWP_NOMOVE |SWP_NOOWNERZORDER);\n    return TRUE;\n}\n\nvoid CHoverButton::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)\n{\n    //receive absolutely necessarily context saved in the DRAWITEMSTRUCT struct when drawing the button.\n    CDC* mydc=CDC::FromHandle(lpDrawItemStruct->hDC);\n\t\n    //create compatible context \n    CDC* pMemDC = new CDC;\n    pMemDC->CreateCompatibleDC(mydc);\n\t\n    //save the old object.\n    CBitmap * pOldBitmap;\n    pOldBitmap = pMemDC->SelectObject(&mybitmap);\n    \n    CPoint point(0,0);    \n    \n    //verdict whether the button is selected, and draw the right bitmap of the button,the second bitmap provided represent selected.\n    if(lpDrawItemStruct->itemState & ODS_SELECTED)\n    {\n        mydc->BitBlt(0,0,m_ButtonSize.cx,m_ButtonSize.cy,pMemDC,m_ButtonSize.cx*2,0,SRCCOPY);\n    }\n    else\n    {   //verdict whether the mouse is on or off the button,draw the right bitmap.\n        if(m_bHover)\n        {\n            mydc->BitBlt(0,0,m_ButtonSize.cx,m_ButtonSize.cy,pMemDC,m_ButtonSize.cx,0,SRCCOPY);\n        }else\n        {\n            mydc->BitBlt(0,0,m_ButtonSize.cx,m_ButtonSize.cy,pMemDC,0,0,SRCCOPY);\n        }    \n    }\n\n\tif (!m_bButtonEnable)\n\t\tmydc->BitBlt(0,0,m_ButtonSize.cx,m_ButtonSize.cy,pMemDC,m_ButtonSize.cx*3,0,SRCCOPY);\n\t\n    // clean up\n    pMemDC->SelectObject(pOldBitmap);\n    delete pMemDC;\n}\n\nvoid CHoverButton::OnMouseMove(UINT nFlags, CPoint point)\n{\n    if (!m_bTracking)\n    {\n        TRACKMOUSEEVENT tme;\n        tme.cbSize = sizeof(tme);\n        tme.hwndTrack = m_hWnd;\n        tme.dwFlags = TME_LEAVE|TME_HOVER;\n        tme.dwHoverTime = 1;\n        m_bTracking = _TrackMouseEvent(&tme);\n    }\n    CBitmapButton::OnMouseMove(nFlags, point);\n}\n\nLRESULT CHoverButton::OnMouseLeave(WPARAM wparam, LPARAM lparam)\n{\n    m_bTracking = FALSE;\n    m_bHover=FALSE;\n    //redraw the button\n    Invalidate(TRUE);\n    return 0;\n}\n\nLRESULT CHoverButton::OnMouseHover(WPARAM wparam, LPARAM lparam) \n{\t\n    m_bHover=TRUE;\n    Invalidate(TRUE);\n    return 0;\n}\n\nBOOL CHoverButton::EnableWindow(BOOL bEnable)\n{\n\tm_bButtonEnable = bEnable;\n\tInvalidate(TRUE);\n    return TRUE;\n}\n\nBOOL CHoverButton::EnableWindowEx(BOOL bEnable)\n{\n\tm_bButtonEnable = bEnable;\n\tInvalidate(TRUE);\n    return CBitmapButton::EnableWindow(bEnable);\n}","size_bytes":3495},"bin/Demo/MfcDemo/09.AccessControl/DlgCapability.cpp":{"content":"// DlgCapability.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AccessControl.h\"\n#include \"DlgCapability.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCapability dialog\n\nCDlgCapability::CDlgCapability(CWnd* pParent /* = NULL */, LLONG hLoginID /* = NULL */, AV_uint32 uiAlarmIn /* = 0 */, AV_uint32 uiAlarmOut /* = 0 */)\n\t: CDialog(CDlgCapability::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCapability)\n\tm_hLogin = hLoginID;\n\tm_uiAlarmIn = uiAlarmIn;\n\tm_uiAlarmOut = uiAlarmOut;\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CDlgCapability::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCapability)\n\tDDX_Control(pDX, IDC_DLG_CAP_LIST_ERR, m_lsErrorInfo);\n\tDDX_Control(pDX, IDC_DLG_CAP_EDT_SHOW, m_edtShow);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCapability, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCapability)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCapability message handlers\n\nBOOL CDlgCapability::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CAPABILITY);\n\t// TODO: Add extra initialization here\n\tif (!m_hLogin)\n\t{\n\t\tOutputInfo(ConvertString(CString(\"we haven't login a device yet!\"), DLG_CAPABILITY));\n\t\treturn TRUE;\n\t}\n\n\tGetCapability();\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCapability::GetCapability()\n{\n\t// string for storing all caps\n\tCString csCap;\n\t\n\t// cap of log service\n\tCString csLogService;\n\tif (GetLogServiceCap(csLogService))\n\t{\n\t\tcsCap += csLogService;\n\t}\n\n    // cap of RecordSetFinder\n    CString csRecordSetFinder;\n    if (GetRecordSetFinderCap(csRecordSetFinder))\n    {\n        csCap += csRecordSetFinder;\n    }\n\n\t// cap of access manager\n\tCString csAccessControlCap;\n\tif (GetAccessControlCap(csAccessControlCap))\n\t{\n\t\tcsCap += csAccessControlCap;\n\t}\n\n\t// show all these caps\n\t{\t\t\n\t\tm_edtShow.SetWindowText(csCap);\n\t}\n}\n\nvoid CDlgCapability::OutputInfo(const CString& csInfo)\n{\n\tSYSTEMTIME st;\n\tGetLocalTime(&st);\n\t\n\tCString csOut;\n\tcsOut.Format(\"%04d-%02d-%02d %02d:%02d:%02d: %s\",\n\t\tst.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond,\n\t\tcsInfo);\n\t\n\tm_lsErrorInfo.InsertString(0, csOut);\n}\n\nBOOL CDlgCapability::GetLogServiceCap(CString& csCap)\n{\n\tchar szBuff[1024] = {0};\n\tint nError = 0;\n\tBOOL bRet = CLIENT_QueryNewSystemInfo(m_hLogin, CFG_CAP_CMD_LOG, 0, szBuff, sizeof(szBuff), &nError, SDK_API_WAITTIME);\n\tif (bRet)\n\t{\n\t\tCFG_CAP_LOG stuInfo = {0};\n\t\tDWORD dwRet = 0;\n\t\tbRet = CLIENT_ParseData(CFG_CAP_CMD_LOG, szBuff, &stuInfo, sizeof(CFG_CAP_LOG), &dwRet);\n\t\tif (bRet && dwRet == sizeof(CFG_CAP_LOG))\n\t\t{\n\t\t\tCString csLogServiceCap;\n\t\t\tcsLogServiceCap.Format(\"%s = %d\\r\\n\\\n%s = %d\\r\\n\\\n%s = %s\\r\\n\\\n%s = %s\\r\\n\\\n%s = %s\\r\\n\",\n\t\t\t\tConvertString(\"LogMaxItem\", DLG_CAPABILITY),\n\t\t\t\tstuInfo.dwMaxLogItems,\n\t\t\t\tConvertString(\"MaxPageLogItem\", DLG_CAPABILITY),\n\t\t\t\tstuInfo.dwMaxPageItems,\n\t\t\t\tConvertString(\"IsSupportStartNo\", DLG_CAPABILITY),\n\t\t\t\tstuInfo.bSupportStartNo ? ConvertString(\"Yes\", DLG_CAPABILITY) : ConvertString(\"No\", DLG_CAPABILITY),\n\t\t\t\tConvertString(\"IsSupportTypeFilter\", DLG_CAPABILITY),\n\t\t\t\tstuInfo.bSupportTypeFilter ? ConvertString(\"Yes\", DLG_CAPABILITY) : ConvertString(\"No\", DLG_CAPABILITY),\n\t\t\t\tConvertString(\"IsSupportTimeFilter\", DLG_CAPABILITY),\n\t\t\t\tstuInfo.bSupportTimeFilter ? ConvertString(\"Yes\", DLG_CAPABILITY) : ConvertString(\"No\", DLG_CAPABILITY));\n\t\t\tcsCap += csLogServiceCap;\n\t\t\tcsCap += \"\\r\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n\n}\n\nBOOL CDlgCapability::GetRecordSetFinderCap(CString& csCap)\n{\n    char szBuff[1024] = {0};\n    int nError = 0;\n\tBOOL bRet = CLIENT_QueryNewSystemInfo(m_hLogin, CFG_CAP_CMD_RECORDFINDER, 0, szBuff, sizeof(szBuff), &nError, SDK_API_WAITTIME);\n    if (bRet)\n    {\n        CFG_CAP_RECORDFINDER_INFO stuCap = {0};\n        DWORD dwRet = 0;\n        bRet = CLIENT_ParseData(CFG_CAP_CMD_RECORDFINDER, szBuff, &stuCap, sizeof(stuCap), &dwRet);\n        if (bRet && dwRet == sizeof(CFG_CAP_RECORDFINDER_INFO))\n        {\n            csCap += ConvertString(\"RecordSetFinder Cap:\", DLG_CAPABILITY);\n            csCap += \"\\r\\n\";\n\n            CString csMaxPageSize;\n            csMaxPageSize.Format(\"%s = %d\\r\\n\",\n                ConvertString(\"MaxPageSize\", DLG_CAPABILITY),\n                stuCap.nMaxPageSize);\n            csCap += csMaxPageSize;\n            csCap += \"\\r\\n\";\n        }\n        else\n        {\n            return FALSE;\n        }\n    }\n    else\n    {\n        return FALSE;\n    }\n    return TRUE;\n}\n\nBOOL CDlgCapability::GetAccessControlCap(CString& csCap)\n{\n\tchar szBuf[1024] = {0};\n\tint nError = 0;\n\tBOOL bRet = CLIENT_QueryNewSystemInfo(m_hLogin, CFG_CAP_CMD_ACCESSCONTROLMANAGER, -1, szBuf, sizeof(szBuf), &nError, SDK_API_WAITTIME);\n\tif (bRet)\n\t{\n\t\tCFG_CAP_ACCESSCONTROL stuCap = {0};\n\t\tDWORD dwRet = 0;\n\t\tbRet = CLIENT_ParseData(CFG_CAP_CMD_ACCESSCONTROLMANAGER, szBuf, &stuCap, sizeof(stuCap), &dwRet);\n\t\tif (bRet && dwRet == sizeof(CFG_CAP_ACCESSCONTROL))\n\t\t{\t\t\t\n\t\t\tcsCap += ConvertString(\"AccessControlManager Cap:\", DLG_CAPABILITY);\n\n\t\t\tcsCap += \"\\r\\n\";\n\t\t\tCString csAccessControl;\n\t\t\tcsAccessControl.Format(\"%s = %d \\r\\n\", \n\t\t\t\tConvertString(\"support access count \", DLG_CAPABILITY),\n\t\t\t\tstuCap.nAccessControlGroups);\n\t\t\tcsCap += csAccessControl;\n\t\t\tcsCap += \"\\r\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n","size_bytes":5669},"bin/Demo/MfcDemo/00.DevInit/ShowPicture.cpp":{"content":"// ShowPicture.cpp: implementation of the CShowPicture class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"searchdevice.h\"\n#include \"ShowPicture.h\"\n#include <iostream>\n\n#pragma warning(disable:4291)\n#ifndef NEW\n#define NEW new(std::nothrow)\n#endif\n\n//////////////////////////////////////////////////////////////////////\n// Construction/Destruction\n//////////////////////////////////////////////////////////////////////\n\n\n\nCShowPicture::CShowPicture()\n{\n\tm_pictureLoaded = false;\n\tmemset(&m_picture, 0, sizeof(Pictures));\n}\n\nCShowPicture::~CShowPicture()\n{\n\tRemovePicture();\n}\n\n\nvoid CShowPicture::AddPicture(HWND hWnd, char *FileName, int PositionX, int PositionY)\n{\n\tif(m_pictureLoaded)\n\t\treturn;\n\tFILE *fp = NULL;\n\tfp = fopen(FileName, \"rb\");\n\tif( NULL == fp)\n\t{\n\t\tm_pictureLoaded = false;\n\t\treturn;\n\t}\n\t\n\tstruct stat file_stat;\n\tif( -1 ==fstat(fileno(fp), &file_stat))\n\t{\n\t\tm_pictureLoaded = false;\n\t\tfclose(fp);\n\t\treturn;\n\t}\n\tunsigned char *f_buf = NEW unsigned char[4*file_stat.st_size];\n\n\tif (NULL == f_buf)\n\t{\t\t\n\t\tm_pictureLoaded = false;\n\t\tfclose(fp);\n\t\treturn;\n\t}\n\tlong file_size = fread(f_buf, 1, file_stat.st_size, fp);\n\tfclose(fp);\n\n\tif(file_size != file_stat.st_size)\n\t{\n\t\tm_pictureLoaded = false;\n\t\tdelete[] f_buf;\n        f_buf = NULL;\n\t\treturn;\n\t}\n\n\tm_picture.Picture = LoadPicture(hWnd, f_buf, file_size, &m_picture.PictureWidth,&m_picture.PictureHeight);\n\tif(m_picture.Picture != NULL)\n\t{\n\t\tm_picture.PositionX = PositionX;\n\t\tm_picture.PositionY = PositionY;\n\t\tm_picture.hWnd = hWnd;\n\t\tm_pictureLoaded = true;\n\t}\n\n    delete[] f_buf;\n    f_buf = NULL;\n}\nIPicture *CShowPicture::LoadPicture(HWND hWnd, const unsigned char *data, size_t len, long *ret_w,long *ret_h)\n{\n\tIPicture *pic =NULL;\n\tHGLOBAL hGlobal = GlobalAlloc(GMEM_MOVEABLE, len);\n\tLPVOID pvData = GlobalLock(hGlobal);\n\tmemcpy(pvData, data, len);\n\tGlobalUnlock(hGlobal);\n\tLPSTREAM pStream = NULL;\n\tHRESULT hr = CreateStreamOnHGlobal(hGlobal, TRUE, &pStream);\n\tOleLoadPicture(pStream, 0, FALSE, IID_IPicture, (void **)&pic);\n\tpStream->Release();\n\tGlobalFree(hGlobal);\n\n\tOLE_XSIZE_HIMETRIC cx;\n\tOLE_XSIZE_HIMETRIC cy;\n\tpic->get_Width(&cx);\n\tpic->get_Height(&cy);\n\t*ret_w = MAP_LOGHIM_TO_PIX(cx, GetDeviceCaps(GetDC(hWnd), LOGPIXELSX));\n\t*ret_h = MAP_LOGHIM_TO_PIX(cy, GetDeviceCaps(GetDC(hWnd), LOGPIXELSX));\n\treturn pic;\n}\nvoid CShowPicture::RanderPicture(HDC dc, const RECT &bounds, void *pic)\n{\n\tIPicture *picture = (IPicture*)pic;\n\tOLE_XSIZE_HIMETRIC cx;\n\tOLE_XSIZE_HIMETRIC cy;\n\tpicture->get_Width(&cx);\n\tpicture->get_Height(&cy);\n\tpicture->Render(dc, bounds.left, bounds.bottom, bounds.right-bounds.left, bounds.top-bounds.bottom, 0,0, cx,cy, NULL);\n\n}\n\nvoid CShowPicture::RepaintPictures()\n{\n\tif(!m_pictureLoaded)\n\t\treturn;\n\tRECT bounds;\n\tRECT temp_rect;\n\t::GetWindowRect(m_picture.hWnd, &temp_rect);\n\tbounds.top = m_picture.PositionY;\n\tbounds.bottom = m_picture.PositionY + m_picture.PictureHeight;\n\tbounds.left = m_picture.PositionX;\n\tbounds.right = m_picture.PositionX + m_picture.PictureWidth;\n\tRanderPicture(GetDC(m_picture.hWnd), bounds, m_picture.Picture);\n}\n\nvoid CShowPicture::RemovePicture()\n{\n\tif(!m_pictureLoaded)\n\t\treturn;\n\tIPicture *freepic = (IPicture*)m_picture.Picture;\n\tfreepic->Release();\n\tmemset(&m_picture, 0, sizeof(m_picture));\n\tm_pictureLoaded = FALSE;\n}","size_bytes":3321},"bin/Demo/MfcDemo/01.RealPlayAndPTZControl/ExButton.cpp":{"content":"// ExButton.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"RealPlayAndPTZControl.h\"\n#include \"ExButton.h\"\n#include \"RealPlayAndPTZControlDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CExButton\n\nCExButton::CExButton()\n{\n\tm_dwPTZCommand = -1;\n\tm_bIsMouseDown = FALSE;\n}\n\nCExButton::~CExButton()\n{\n}\n\n\nBEGIN_MESSAGE_MAP(CExButton, CButton)\n\t//{{AFX_MSG_MAP(CExButton)\n\tON_WM_LBUTTONDOWN()\n\tON_WM_LBUTTONUP()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CExButton message handlers\n\nvoid CExButton::OnLButtonDown(UINT nFlags, CPoint point) \n{\n\t// TODO: Add your message handler code here and/or call default\n\t//Check mous has been clicked or not \n\tif(!m_bIsMouseDown)\n\t{\n\t\tm_bIsMouseDown = TRUE;\n\t\tif((int)m_dwPTZCommand < 0)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t((CRealPlayAndPTZControlDlg*)GetParent())->PtzControl(m_dwPTZCommand,FALSE);\n\t\tTRACE(\"START\\n\");\n\t}\n\t\n\tCButton::OnLButtonDown(nFlags, point);\n}\n\nvoid CExButton::OnLButtonUp(UINT nFlags, CPoint point) \n{\n\t// TODO: Add your message handler code here and/or call default\n\tif(m_bIsMouseDown)\n\t{\n\t\tm_bIsMouseDown = FALSE;\n\t\tif((int)m_dwPTZCommand < 0)\n\t\t{\n\t\t\treturn;\t\t\n\t\t}\n\t\t((CRealPlayAndPTZControlDlg*)GetParent())->PtzControl(m_dwPTZCommand,TRUE);\n\t\tTRACE(\"STOP\\n\");\n\t}\n\t\n\tCButton::OnLButtonUp(nFlags, point);\n}\n\nvoid CExButton::SetButtonCommand(DWORD dwPTZCommand)\n{\n\tm_dwPTZCommand = dwPTZCommand;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":1907},"bin/Demo/MfcDemo/10.AlarmDevice/DlgUpgrade.cpp":{"content":"// DlgUpgrade.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgUpgrade.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgUpgrade dialog\n\n\nCDlgUpgrade::CDlgUpgrade(CWnd* pParent /* = NULL */, LLONG hLoginId /* = NULL */)\n\t: CDialog(CDlgUpgrade::IDD, pParent),\n\tm_hLoginId(hLoginId),\n\tm_hUpgradeId(NULL)\n{\n\t//{{AFX_DATA_INIT(CDlgUpgrade)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CDlgUpgrade::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgUpgrade)\n\tDDX_Control(pDX, IDC_UPGRADE_LIST_INFO, m_lsInfo);\n\tDDX_Control(pDX, IDC_UPGRADE_PROGRESS, m_ctrlProgress);\n\tDDX_Control(pDX, IDC_UPGRADE_STATIC_COUNT, m_staticProgress);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgUpgrade, CDialog)\n\t//{{AFX_MSG_MAP(CDlgUpgrade)\n\tON_WM_DESTROY()\n\tON_BN_CLICKED(IDC_UPGRADE_BTN_PATH, OnUpgradeBtnPath)\n\tON_BN_CLICKED(IDC_UPGRADE_BTN_UPGRADE, OnUpgradeBtnUpgrade)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgUpgrade private handlers\n\nvoid CDlgUpgrade::StopUpgrade(LLONG lUpgradId /* = NULL */)\n{\n\tif (lUpgradId)\n\t{\n\t\tCLIENT_StopUpgrade(lUpgradId);\n\t\tlUpgradId = NULL;\n\t}\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgUpgrade message handlers\n\nBOOL CDlgUpgrade::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_UPGRADE);\n\t\n\t// TODO: Add extra initialization here\n\tif (!m_hLoginId)\n\t{\n\t\tMessageBox(ConvertString(CString(\"we haven't login a device yet!\"), DLG_UPGRADE), ConvertString(\"Prompt\"));\n\t\treturn TRUE;\n\t}\n\t\n\tm_ctrlProgress.SetRange(0, 100);\n\tm_ctrlProgress.SetPos(0);\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgUpgrade::OnDestroy() \n{\n\tCDialog::OnDestroy();\n\t\n\t// TODO: Add your message handler code here\n\tStopUpgrade(m_hUpgradeId);\t\n}\n\nvoid CDlgUpgrade::OnUpgradeBtnPath() \n{\n\t// TODO: Add your control notification handler code here\n\tCFileDialog dlg(TRUE, NULL, NULL, OFN_HIDEREADONLY | OFN_ENABLESIZING | OFN_NOCHANGEDIR, _T(\"All Types (*.*)|*.*||\"), this);\n\t\n\tif (dlg.DoModal() == IDOK)\n\t{\n\t\tSetDlgItemText(IDC_UPGRADE_EDT_PATH, dlg.GetPathName());\n\t}\t\n}\n\nvoid CDlgUpgrade::OnUpgradeBtnUpgrade() \n{\n\t// TODO: Add your control notification handler code here\n\t{\n\t\t// make sure the previous upgrading is closed before another upgrading operation\n\t\tStopUpgrade(m_hUpgradeId);\n\t}\n\n\tCString strFilePath;\n\tGetDlgItemText(IDC_UPGRADE_EDT_PATH, strFilePath);\n\tif (strFilePath.IsEmpty())\n\t{\n\t\tMessageBox(ConvertString(\"please choose a upgrade packet file.\", DLG_UPGRADE), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\t\n\tm_hUpgradeId = CLIENT_StartUpgradeEx(m_hLoginId, (EM_UPGRADE_TYPE)0, strFilePath.GetBuffer(0), UpgradeCallBack, (LLONG)this);\n\tTRACE(\"start upgrade...%s.\\n\", m_hUpgradeId ? \"succeed\" : \"fail\");\n\n\tif (m_hUpgradeId)\n\t{\n\t\tm_ctrlProgress.SetPos(0);\n\t\tint nRet = CLIENT_SendUpgrade(m_hUpgradeId);\n\t\tTRACE(\"execute upgrade...%s.\\n\", nRet ? \"succeed\" : \"fail\");\n\t}\n\telse\n\t{\n\t\tm_ctrlProgress.SetPos(0);\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"Upgrade failed with code\", DLG_UPGRADE), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t}\n}\n\nvoid WINAPI UpgradeCallBack(LLONG lLoginID, LLONG lUpgradechannel, int nTotalSize, int nSendSize, LDWORD dwUser)\n{\n\t((CDlgUpgrade*)dwUser)->UpgradeState(lLoginID, lUpgradechannel, nTotalSize, nSendSize);\n}\n\nvoid CDlgUpgrade::UpgradeState(LLONG lLoginID, LLONG lUpgradechannel, int nTotalSize, int nSendSize)\n{\n\tif (lLoginID && lLoginID == m_hLoginId && lUpgradechannel /*&& lUpgradechannel == m_hUpgradeId*/)\n\t{\n\t\tSYSTEMTIME st;\n\t\tGetLocalTime(&st);\n\t\tint nCount = m_lsInfo.GetCount();\n\t\tCString csInfo;\n\n\t\tCString csProgress = ConvertString(\"upgrade progress\", DLG_UPGRADE);\n\t\tCString csSucceed = ConvertString(\"upgrade succeed\", DLG_UPGRADE);\n\t\tCString csFailed = ConvertString(\"upgrade failed\", DLG_UPGRADE);\n\n\t\tif (nTotalSize == 0)\n\t\t{\n\t\t\tif (nSendSize == -1)\n\t\t\t{\n\t\t\t\tcsInfo.Format(\"%02d:%02d:%02d.%03d %s: %s\", \n\t\t\t\t\tst.wHour, st.wMinute, st.wSecond, st.wMilliseconds, csProgress, csSucceed);\n\t\t\t\tm_lsInfo.InsertString(nCount, csInfo);\n\t\t\t\tm_lsInfo.SetCurSel(nCount);\n\t\t\t} \n\t\t\telse if (nSendSize == -2)\n\t\t\t{\n\t\t\t\tcsInfo.Format(\"%02d:%02d:%02d.%03d %s: %s\", \n\t\t\t\t\tst.wHour, st.wMinute, st.wSecond, st.wMilliseconds, csProgress, csFailed);\n\t\t\t\tm_lsInfo.InsertString(nCount, csInfo);\n\t\t\t\tm_lsInfo.SetCurSel(nCount);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\telse if (nTotalSize > 0)\n\t\t{\n\t\t\tint nProgress = 100 * nSendSize / nTotalSize;\n\t\t\tif (nProgress <= 0)\n\t\t\t{\n\t\t\t\tnProgress = 0;\n\t\t\t}\n\t\t\tif (nProgress > 99)\n\t\t\t{\n\t\t\t\tnProgress = 100;\n\t\t\t}\n\t\t\tm_ctrlProgress.SetPos(nProgress);\n\t\t\t\n\t\t\tcsInfo.Format(\"%02d:%02d:%02d.%03d %s: %d %d/%d\", \n\t\t\t\tst.wHour, st.wMinute, st.wSecond, st.wMilliseconds, csProgress,\n\t\t\t\tnProgress, nSendSize, nTotalSize);\n\t\t\tm_lsInfo.InsertString(nCount, csInfo);\n\t\t\tm_lsInfo.SetCurSel(nCount);\n\t\t}\n\n\t\tTRACE(\"upgrade progress: totalSize = %08d, sendSize = %08d\\n\", nTotalSize, nSendSize);\n\t}\n}\n","size_bytes":5280},"bin/Demo/MfcDemo/10.AlarmDevice/DlgAlarmBell.cpp":{"content":"// DlgAlarmBell.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgAlarmBell.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgAlarmBell dialog\n\n\nCDlgAlarmBell::CDlgAlarmBell(CWnd* pParent /*=NULL*/, LLONG hLoginID /*=NULL*/)\n\t: CDialog(CDlgAlarmBell::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgAlarmBell)\n\tm_hLogin = hLoginID;\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CDlgAlarmBell::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgAlarmBell)\n\tDDX_Control(pDX, IDC_DLG_ALARMBELL_LIST_ERR, m_lsErrorInfo);\n\tDDX_Control(pDX, IDC_DLG_ALARMBELL_CMB_CHANNEL, m_cmbChannel);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgAlarmBell, CDialog)\n\t//{{AFX_MSG_MAP(CDlgAlarmBell)\n\tON_BN_CLICKED(IDC_DLG_ALARMBELL_BTN_START, OnDlgAlarmbellBtnStart)\n\tON_BN_CLICKED(IDC_DLG_ALARMBELL_BTN_STOP, OnDlgAlarmbellBtnStop)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgAlarmBell message handlers\n\nBOOL CDlgAlarmBell::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_ALARMBELL);\n\t// TODO: Add extra initialization here\n\tif (!m_hLogin)\n\t{\n\t\tOutputInfo(ConvertString(CString(\"we haven't login a device yet!\"), DLG_ALARMBELL));\n\t\tGetDlgItem(IDC_DLG_ALARMBELL_BTN_START)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_DLG_ALARMBELL_BTN_STOP)->EnableWindow(FALSE);\n\t\treturn TRUE;\n\t}\n\n\tfor (int i = 0; i < 1; i++)\n\t{\n\t\tCString csNum;\n\t\tcsNum.Format(\"%s %d\", ConvertString(\"Channel\", DLG_ALARMBELL), i + 1);\n\t\tm_cmbChannel.InsertString(-1, csNum);\n\t}\n\tm_cmbChannel.SetCurSel(0);\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgAlarmBell::OutputInfo(const CString& csInfo)\n{\n\tSYSTEMTIME st;\n\tGetLocalTime(&st);\n\t\n\tCString csOut;\n\tcsOut.Format(\"%04d-%02d-%02d %02d:%02d:%02d: %s\",\n\t\tst.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond,\n\t\tcsInfo);\n\t\n\tm_lsErrorInfo.InsertString(0, csOut);\n}\n\nvoid CDlgAlarmBell::OnDlgAlarmbellBtnStart() \n{\n\t// TODO: Add your control notification handler code here\n\tNET_CTRL_ALARMBELL stuParam = {sizeof(NET_CTRL_ALARMBELL)};\n\tstuParam.nChannelID = m_cmbChannel.GetCurSel();\n\tBOOL bRet = CLIENT_ControlDevice((LLONG)m_hLogin, DH_CTRL_START_ALARMBELL, &stuParam, SDK_API_WAIT);\n\tCString csOut;\n\tif (bRet)\n\t{\n\t\tcsOut.Format(\"%s %d %s\", ConvertString(\"channel\", DLG_ALARMBELL), m_cmbChannel.GetCurSel() + 1, ConvertString(\"alarm_bell start...\", DLG_ALARMBELL));\n\t} \n\telse\n\t{\n\t\tcsOut.Format(\"%s %d %s %08x\", ConvertString(\"channel\", DLG_ALARMBELL),\n\t\t\tm_cmbChannel.GetCurSel() + 1, ConvertString(\"alarm_bell start err:\", DLG_ALARMBELL), CLIENT_GetLastError());\n\t}\n\tOutputInfo(csOut);\n}\n\nvoid CDlgAlarmBell::OnDlgAlarmbellBtnStop() \n{\n\tNET_CTRL_ALARMBELL stuParam = {sizeof(NET_CTRL_ALARMBELL)};\n\tstuParam.nChannelID = m_cmbChannel.GetCurSel();\n\tBOOL bRet = CLIENT_ControlDevice((LLONG)m_hLogin, DH_CTRL_STOP_ALARMBELL, &stuParam, SDK_API_WAIT);\n\tCString csOut;\n\tif (bRet)\n\t{\n\t\tcsOut.Format(\"%s %d %s\", ConvertString(\"channel\", DLG_ALARMBELL), m_cmbChannel.GetCurSel() + 1, ConvertString(\"alarm_bell stop...\", DLG_ALARMBELL));\n\t} \n\telse\n\t{\n\t\tcsOut.Format(\"%s %d %s %08x\", ConvertString(\"channel\", DLG_ALARMBELL), m_cmbChannel.GetCurSel() + 1, ConvertString(\"alarm_bell stop err:\", DLG_ALARMBELL), CLIENT_GetLastError());\n\t}\n\tOutputInfo(csOut);\t\n}\n","size_bytes":3543},"bin/DemoSrc/DecCB_demo/StdAfx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n//\tDecCB_demo.pch will be the pre-compiled header\n//\tstdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n#include \"CharactorTansfer.h\"\n\nCString GetMoudlePath()\n{\n\tTCHAR szAppName[MAX_PATH];\n\tTCHAR szDir[MAX_PATH];\n\tTCHAR szDrive[MAX_PATH];\n\tGetModuleFileName(GetModuleHandle(NULL), szAppName, MAX_PATH);\n\t_tsplitpath(szAppName, szDrive, szDir, NULL, NULL);\n\t\n\tTCHAR szPath[MAX_PATH];\n\t_tmakepath(szPath, szDrive, szDir, NULL, NULL);\n\t\n\treturn szPath;\n}\n\n\n\n\n","size_bytes":553},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/dhocxsystemset.cpp":{"content":"// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++\n\n// NOTE: Do not modify the contents of this file.  If this class is regenerated by\n//  Microsoft Visual C++, your modifications will be overwritten.\n\n\n#include \"StdAfx.h\"\n#include \"dhocxsystemset.h\"\n\n// Dispatch interfaces referenced by this interface\n#include \"font.h\"\n\n/////////////////////////////////////////////////////////////////////////////\n// CDHOCXSYSTEMSET\n\nIMPLEMENT_DYNCREATE(CDHOCXSYSTEMSET, CWnd)\n\n/////////////////////////////////////////////////////////////////////////////\n// CDHOCXSYSTEMSET properties\n\n/////////////////////////////////////////////////////////////////////////////\n// CDHOCXSYSTEMSET operations\n\nBOOL CDHOCXSYSTEMSET::GetAutoScroll()\n{\n\tBOOL result;\n\tInvokeHelper(0x2, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);\n\treturn result;\n}\n\nvoid CDHOCXSYSTEMSET::SetAutoScroll(BOOL bNewValue)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_BOOL;\n\tInvokeHelper(0x2, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,\n\t\t bNewValue);\n}\n\nBOOL CDHOCXSYSTEMSET::GetAutoSize()\n{\n\tBOOL result;\n\tInvokeHelper(0x3, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);\n\treturn result;\n}\n\nvoid CDHOCXSYSTEMSET::SetAutoSize(BOOL bNewValue)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_BOOL;\n\tInvokeHelper(0x3, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,\n\t\t bNewValue);\n}\n\nlong CDHOCXSYSTEMSET::GetAxBorderStyle()\n{\n\tlong result;\n\tInvokeHelper(0x4, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);\n\treturn result;\n}\n\nvoid CDHOCXSYSTEMSET::SetAxBorderStyle(long nNewValue)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_I4;\n\tInvokeHelper(0x4, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,\n\t\t nNewValue);\n}\n\nlong CDHOCXSYSTEMSET::GetBorderWidth()\n{\n\tlong result;\n\tInvokeHelper(0x5, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);\n\treturn result;\n}\n\nvoid CDHOCXSYSTEMSET::SetBorderWidth(long nNewValue)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_I4;\n\tInvokeHelper(0x5, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,\n\t\t nNewValue);\n}\n\nCString CDHOCXSYSTEMSET::GetCaption()\n{\n\tCString result;\n\tInvokeHelper(DISPID_CAPTION, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);\n\treturn result;\n}\n\nvoid CDHOCXSYSTEMSET::SetCaption(LPCTSTR lpszNewValue)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_BSTR;\n\tInvokeHelper(DISPID_CAPTION, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,\n\t\t lpszNewValue);\n}\n\nunsigned long CDHOCXSYSTEMSET::GetColor()\n{\n\tunsigned long result;\n\tInvokeHelper(DISPID_BACKCOLOR, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);\n\treturn result;\n}\n\nvoid CDHOCXSYSTEMSET::SetColor(unsigned long newValue)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_I4;\n\tInvokeHelper(DISPID_BACKCOLOR, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,\n\t\t newValue);\n}\n\nCOleFont CDHOCXSYSTEMSET::GetFont()\n{\n\tLPDISPATCH pDispatch;\n\tInvokeHelper(DISPID_FONT, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&pDispatch, NULL);\n\treturn COleFont(pDispatch);\n}\n\nvoid CDHOCXSYSTEMSET::SetFont(LPDISPATCH newValue)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_DISPATCH;\n\tInvokeHelper(DISPID_FONT, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,\n\t\t newValue);\n}\n\nvoid CDHOCXSYSTEMSET::SetRefFont(LPDISPATCH* newValue)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_PDISPATCH;\n\tInvokeHelper(DISPID_FONT, DISPATCH_PROPERTYPUTREF, VT_EMPTY, NULL, parms,\n\t\t newValue);\n}\n\nBOOL CDHOCXSYSTEMSET::GetKeyPreview()\n{\n\tBOOL result;\n\tInvokeHelper(0x6, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);\n\treturn result;\n}\n\nvoid CDHOCXSYSTEMSET::SetKeyPreview(BOOL bNewValue)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_BOOL;\n\tInvokeHelper(0x6, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,\n\t\t bNewValue);\n}\n\nlong CDHOCXSYSTEMSET::GetPixelsPerInch()\n{\n\tlong result;\n\tInvokeHelper(0x7, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);\n\treturn result;\n}\n\nvoid CDHOCXSYSTEMSET::SetPixelsPerInch(long nNewValue)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_I4;\n\tInvokeHelper(0x7, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,\n\t\t nNewValue);\n}\n\nlong CDHOCXSYSTEMSET::GetPrintScale()\n{\n\tlong result;\n\tInvokeHelper(0x8, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);\n\treturn result;\n}\n\nvoid CDHOCXSYSTEMSET::SetPrintScale(long nNewValue)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_I4;\n\tInvokeHelper(0x8, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,\n\t\t nNewValue);\n}\n\nBOOL CDHOCXSYSTEMSET::GetScaled()\n{\n\tBOOL result;\n\tInvokeHelper(0x9, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);\n\treturn result;\n}\n\nvoid CDHOCXSYSTEMSET::SetScaled(BOOL bNewValue)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_BOOL;\n\tInvokeHelper(0x9, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,\n\t\t bNewValue);\n}\n\nvoid CDHOCXSYSTEMSET::SetDeviceShowType(long* lpDeviceInfo)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_PI4;\n\tInvokeHelper(0x11, DISPATCH_METHOD, VT_EMPTY, NULL, parms,\n\t\t lpDeviceInfo);\n}\n\nvoid CDHOCXSYSTEMSET::SetDetectWinRGB(unsigned long unRed, unsigned long unGreen, unsigned long unBlue, unsigned long unType)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_I4 VTS_I4 VTS_I4 VTS_I4;\n\tInvokeHelper(0x14, DISPATCH_METHOD, VT_EMPTY, NULL, parms,\n\t\t unRed, unGreen, unBlue, unType);\n}\n\nvoid CDHOCXSYSTEMSET::SendDeviceInfoData(long DeviceID, long lConfigType, long* lpReData, unsigned long ReDataLength)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_I4 VTS_I4 VTS_PI4 VTS_I4;\n\tInvokeHelper(0x15, DISPATCH_METHOD, VT_EMPTY, NULL, parms,\n\t\t DeviceID, lConfigType, lpReData, ReDataLength);\n}\n\nvoid CDHOCXSYSTEMSET::CreateDeviceFram(unsigned long unLagType)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_I4;\n\tInvokeHelper(0x13, DISPATCH_METHOD, VT_EMPTY, NULL, parms,\n\t\t unLagType);\n}\n\nvoid CDHOCXSYSTEMSET::SetDetectAreaHandle(long DetectParentHandle, unsigned long unDetectType)\n{\n\tstatic BYTE parms[] =\n\t\tVTS_I4 VTS_I4;\n\tInvokeHelper(0x16, DISPATCH_METHOD, VT_EMPTY, NULL, parms,\n\t\t DetectParentHandle, unDetectType);\n}\n","size_bytes":5649},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgAlarmBell.cpp":{"content":"// DlgCfgAlarmBell.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"alarmdevice.h\"\n#include \"DlgCfgAlarmBell.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgAlarmBell dialog\n\n\nCDlgCfgAlarmBell::CDlgCfgAlarmBell(CWnd* pParent /* = NULL */, LLONG lLoginID /* = NULL */)\n\t: CDialog(CDlgCfgAlarmBell::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgAlarmBell)\n\t//}}AFX_DATA_INIT\n    m_lLoginID = lLoginID;\n\n    memset(&m_stuInfo, 0, sizeof(m_stuInfo));\n}\n\n\nvoid CDlgCfgAlarmBell::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgAlarmBell)\n\tDDX_Control(pDX, IDC_CFG_ALARMBELL_CMB_CHN, m_cmbChn);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgAlarmBell, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgAlarmBell)\n\tON_BN_CLICKED(IDC_CFG_ALARMBELL_GET, OnCfgAlarmbellGet)\n\tON_BN_CLICKED(IDC_CFG_ALARMBELL_SET, OnCfgAlarmbellSet)\n\tON_CBN_SELCHANGE(IDC_CFG_ALARMBELL_CMB_CHN, OnSelchangeCfgAlarmbellCmbChn)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgAlarmBell private method\n\n\nvoid CDlgCfgAlarmBell::InitDlg()\n{\n    // channel\n    m_cmbChn.ResetContent();\n    for (int i = 0; i < 1; i++)\n    {\n        CString csChn;\n        csChn.Format(\"%s %d\", ConvertString(\"Channel\", DLG_CFG_ALARMBELL), i + 1);\n        m_cmbChn.InsertString(-1, csChn);\n    }\n    m_cmbChn.SetCurSel(0);\n\n    // persistent time\n    SetDlgItemInt(IDC_CFG_ALARMBELL_EDT_PERSISTENTTIME, 0);\n}\n\nBOOL CDlgCfgAlarmBell::SetConfigToDevice()\n{\t\n\tchar szJsonBuf[1024 * 40] = {0};\n\tBOOL bRet = CLIENT_PacketData(CFG_CMD_ALARMBELL, &m_stuInfo, sizeof(m_stuInfo), szJsonBuf, sizeof(szJsonBuf));\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(CString(\"packet AlarmBell error...\"), DLG_CFG_ALARMBELL), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t} \n\telse\n\t{\t\t\n\t\tint nSelChn = m_cmbChn.GetCurSel() == -1 ? 0 : m_cmbChn.GetCurSel();\n\t\tint nerror = 0;\n\t\tint nrestart = 0;\n\t\t\n\t\tbRet = CLIENT_SetNewDevConfig((LLONG)m_lLoginID, CFG_CMD_ALARMBELL, nSelChn, szJsonBuf, 1024*40, &nerror, &nrestart, SDK_API_WAIT);\n\t\tif (!bRet)\n\t\t{\n\t\t\tCString csErr;\n\t\t\tcsErr.Format(\"%s %08x\", ConvertString(\"SetupConfig AlarmBell failed:\", DLG_CFG_ALARMBELL), CLIENT_GetLastError());\n\t\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"SetConfig AlarmBell ok!\"), DLG_CFG_ALARMBELL), ConvertString(\"Prompt\"));\n\t\t}\n\t}\n\treturn TRUE;\n}\n\nBOOL CDlgCfgAlarmBell::GetConfigFromDevice()\n{\n\tchar szJsonBuf[1024 * 40] = {0};\n\tint nerror = 0;\n\tint nSelChn = m_cmbChn.GetCurSel() == -1 ? 0 : m_cmbChn.GetCurSel();\n\tBOOL bRet = CLIENT_GetNewDevConfig((LLONG)m_lLoginID, CFG_CMD_ALARMBELL, nSelChn, szJsonBuf, 1024*40, &nerror, SDK_API_WAIT);\n\n\tif (bRet)\n\t{\n\t\tDWORD dwRetLen = 0;\n\t\tbRet = CLIENT_ParseData(CFG_CMD_ALARMBELL, szJsonBuf, (void*)&m_stuInfo, sizeof(m_stuInfo), &dwRetLen);\n\t\tif (!bRet)\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"parse AlarmBell error...\"), DLG_CFG_ALARMBELL), ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\t\t\t\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"QueryConfig AlarmBell error:\", DLG_CFG_ALARMBELL),CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nvoid CDlgCfgAlarmBell::DlgToStu()\n{\n    m_stuInfo.nPersistentTime = GetDlgItemInt(IDC_CFG_ALARMBELL_EDT_PERSISTENTTIME);\n}\n\nvoid CDlgCfgAlarmBell::StuToDlg()\n{\n    SetDlgItemInt(IDC_CFG_ALARMBELL_EDT_PERSISTENTTIME, m_stuInfo.nPersistentTime);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgAlarmBell message handlers\n\nBOOL CDlgCfgAlarmBell::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_ALARMBELL);\n\t// TODO: Add extra initialization here\n    InitDlg();\n    if (GetConfigFromDevice())\n    {\n        StuToDlg();\n\t}\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgAlarmBell::OnCfgAlarmbellGet() \n{\n\t// TODO: Add your control notification handler code here\n    if (GetConfigFromDevice())\n    {\n        StuToDlg();\n\t}\n}\n\nvoid CDlgCfgAlarmBell::OnCfgAlarmbellSet() \n{\n\t// TODO: Add your control notification handler code here\n    DlgToStu();\n\tSetConfigToDevice();\n}\n\nvoid CDlgCfgAlarmBell::OnSelchangeCfgAlarmbellCmbChn() \n{\n\t// TODO: Add your control notification handler code here\n    int nSel = m_cmbChn.GetCurSel();\n    if (-1 == nSel)\n    {\n        return;\n    }\n    \n    if (GetConfigFromDevice())\n    {\n        StuToDlg();\n\t}\n}\n","size_bytes":4697},"services/dvrService.js":{"content":"// =================================================================\n// SERVIÇO DVR/NVR - Funções auxiliares para gerenciamento de DVRs\n// =================================================================\n\nclass DVRService {\n    constructor(db) {\n        this.db = db;\n    }\n\n    // CRUD - Dispositivos DVR/NVR\n    async criarDispositivo(dados) {\n        const { nome, loja_id, loja_nome, ip_address, porta, usuario, modelo, canais_total, observacoes } = dados;\n        \n        return new Promise((resolve, reject) => {\n            const query = `\n                INSERT INTO dvr_dispositivos \n                (nome, loja_id, loja_nome, ip_address, porta, usuario, modelo, canais_total, observacoes, status, updated_at)\n                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'offline', CURRENT_TIMESTAMP)\n            `;\n            \n            this.db.run(query, [nome, loja_id, loja_nome, ip_address, porta || 37777, usuario, modelo, canais_total || 0, observacoes], function(err) {\n                if (err) return reject(err);\n                resolve({ id: this.lastID });\n            });\n        });\n    }\n\n    async listarDispositivos(filtros = {}) {\n        return new Promise((resolve, reject) => {\n            let whereClauses = [];\n            let params = [];\n\n            if (filtros.loja_id) {\n                whereClauses.push('loja_id = ?');\n                params.push(filtros.loja_id);\n            }\n\n            if (filtros.loja_nome) {\n                whereClauses.push('loja_nome LIKE ?');\n                params.push(`%${filtros.loja_nome}%`);\n            }\n\n            if (filtros.status) {\n                whereClauses.push('status = ?');\n                params.push(filtros.status);\n            }\n\n            const whereString = whereClauses.length > 0 ? ' WHERE ' + whereClauses.join(' AND ') : '';\n            const query = `SELECT * FROM dvr_dispositivos${whereString} ORDER BY nome ASC`;\n\n            this.db.all(query, params, (err, rows) => {\n                if (err) return reject(err);\n                resolve(rows || []);\n            });\n        });\n    }\n\n    async obterDispositivo(id) {\n        return new Promise((resolve, reject) => {\n            this.db.get('SELECT * FROM dvr_dispositivos WHERE id = ?', [id], (err, row) => {\n                if (err) return reject(err);\n                resolve(row);\n            });\n        });\n    }\n\n    async atualizarDispositivo(id, dados) {\n        const { nome, loja_id, loja_nome, ip_address, porta, usuario, modelo, canais_total, status, observacoes } = dados;\n        \n        return new Promise((resolve, reject) => {\n            const query = `\n                UPDATE dvr_dispositivos \n                SET nome = ?, loja_id = ?, loja_nome = ?, ip_address = ?, porta = ?, \n                    usuario = ?, modelo = ?, canais_total = ?, status = ?, observacoes = ?,\n                    updated_at = CURRENT_TIMESTAMP\n                WHERE id = ?\n            `;\n            \n            this.db.run(query, [nome, loja_id, loja_nome, ip_address, porta, usuario, modelo, canais_total, status, observacoes, id], function(err) {\n                if (err) return reject(err);\n                if (this.changes === 0) return reject(new Error('Dispositivo não encontrado'));\n                resolve({ success: true });\n            });\n        });\n    }\n\n    async excluirDispositivo(id) {\n        return new Promise((resolve, reject) => {\n            this.db.run('DELETE FROM dvr_dispositivos WHERE id = ?', [id], function(err) {\n                if (err) return reject(err);\n                if (this.changes === 0) return reject(new Error('Dispositivo não encontrado'));\n                resolve({ success: true });\n            });\n        });\n    }\n\n    // CRUD - Logs de DVR\n    async registrarLog(dados) {\n        const { dvr_id, dvr_nome, loja_nome, tipo_evento, descricao, canal, severidade, detalhes_json } = dados;\n        \n        return new Promise((resolve, reject) => {\n            const query = `\n                INSERT INTO dvr_logs \n                (dvr_id, dvr_nome, loja_nome, tipo_evento, descricao, canal, severidade, detalhes_json, data_hora)\n                VALUES (?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)\n            `;\n            \n            this.db.run(query, [dvr_id, dvr_nome, loja_nome, tipo_evento, descricao, canal, severidade || 'info', detalhes_json], function(err) {\n                if (err) return reject(err);\n                resolve({ id: this.lastID });\n            });\n        });\n    }\n\n    async listarLogs(filtros = {}, paginacao = {}) {\n        return new Promise((resolve, reject) => {\n            let whereClauses = [];\n            let params = [];\n\n            if (filtros.dvr_id) {\n                whereClauses.push('dvr_id = ?');\n                params.push(filtros.dvr_id);\n            }\n\n            if (filtros.loja_nome) {\n                whereClauses.push('loja_nome LIKE ?');\n                params.push(`%${filtros.loja_nome}%`);\n            }\n\n            if (filtros.tipo_evento) {\n                whereClauses.push('tipo_evento = ?');\n                params.push(filtros.tipo_evento);\n            }\n\n            if (filtros.severidade) {\n                whereClauses.push('severidade = ?');\n                params.push(filtros.severidade);\n            }\n\n            if (filtros.data_inicio) {\n                whereClauses.push('data_hora >= ?');\n                params.push(filtros.data_inicio);\n            }\n\n            if (filtros.data_fim) {\n                whereClauses.push('data_hora <= ?');\n                params.push(filtros.data_fim);\n            }\n\n            const whereString = whereClauses.length > 0 ? ' WHERE ' + whereClauses.join(' AND ') : '';\n            const limit = paginacao.limit || 100;\n            const offset = paginacao.offset || 0;\n            \n            const query = `SELECT * FROM dvr_logs${whereString} ORDER BY data_hora DESC LIMIT ? OFFSET ?`;\n            params.push(limit, offset);\n\n            this.db.all(query, params, (err, rows) => {\n                if (err) return reject(err);\n                resolve(rows || []);\n            });\n        });\n    }\n\n    async excluirLog(id) {\n        return new Promise((resolve, reject) => {\n            this.db.run('DELETE FROM dvr_logs WHERE id = ?', [id], function(err) {\n                if (err) return reject(err);\n                if (this.changes === 0) return reject(new Error('Log não encontrado'));\n                resolve({ success: true });\n            });\n        });\n    }\n\n    // CRUD - Arquivos de DVR\n    async registrarArquivo(dados) {\n        const { dvr_id, dvr_nome, loja_nome, tipo_arquivo, nome_arquivo, caminho_arquivo, \n                tamanho_bytes, data_geracao, canal, inicio_gravacao, fim_gravacao, \n                descricao, uploaded_by } = dados;\n        \n        return new Promise((resolve, reject) => {\n            const query = `\n                INSERT INTO dvr_arquivos \n                (dvr_id, dvr_nome, loja_nome, tipo_arquivo, nome_arquivo, caminho_arquivo, \n                 tamanho_bytes, data_geracao, canal, inicio_gravacao, fim_gravacao, \n                 descricao, uploaded_by, uploaded_at)\n                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)\n            `;\n            \n            this.db.run(query, [dvr_id, dvr_nome, loja_nome, tipo_arquivo, nome_arquivo, caminho_arquivo,\n                                tamanho_bytes, data_geracao, canal, inicio_gravacao, fim_gravacao,\n                                descricao, uploaded_by], function(err) {\n                if (err) return reject(err);\n                resolve({ id: this.lastID });\n            });\n        });\n    }\n\n    async listarArquivos(filtros = {}, paginacao = {}) {\n        return new Promise((resolve, reject) => {\n            let whereClauses = [];\n            let params = [];\n\n            if (filtros.dvr_id) {\n                whereClauses.push('dvr_id = ?');\n                params.push(filtros.dvr_id);\n            }\n\n            if (filtros.loja_nome) {\n                whereClauses.push('loja_nome LIKE ?');\n                params.push(`%${filtros.loja_nome}%`);\n            }\n\n            if (filtros.tipo_arquivo) {\n                whereClauses.push('tipo_arquivo = ?');\n                params.push(filtros.tipo_arquivo);\n            }\n\n            if (filtros.data_inicio) {\n                whereClauses.push('data_geracao >= ?');\n                params.push(filtros.data_inicio);\n            }\n\n            if (filtros.data_fim) {\n                whereClauses.push('data_geracao <= ?');\n                params.push(filtros.data_fim);\n            }\n\n            const whereString = whereClauses.length > 0 ? ' WHERE ' + whereClauses.join(' AND ') : '';\n            const limit = paginacao.limit || 50;\n            const offset = paginacao.offset || 0;\n            \n            const query = `SELECT * FROM dvr_arquivos${whereString} ORDER BY data_geracao DESC, uploaded_at DESC LIMIT ? OFFSET ?`;\n            params.push(limit, offset);\n\n            this.db.all(query, params, (err, rows) => {\n                if (err) return reject(err);\n                resolve(rows || []);\n            });\n        });\n    }\n\n    async obterArquivo(id) {\n        return new Promise((resolve, reject) => {\n            this.db.get('SELECT * FROM dvr_arquivos WHERE id = ?', [id], (err, row) => {\n                if (err) return reject(err);\n                resolve(row);\n            });\n        });\n    }\n\n    async excluirArquivo(id) {\n        return new Promise((resolve, reject) => {\n            this.db.run('DELETE FROM dvr_arquivos WHERE id = ?', [id], function(err) {\n                if (err) return reject(err);\n                if (this.changes === 0) return reject(new Error('Arquivo não encontrado'));\n                resolve({ success: true });\n            });\n        });\n    }\n\n    // Atualizar status do dispositivo\n    async atualizarStatus(id, status) {\n        return new Promise((resolve, reject) => {\n            const query = `\n                UPDATE dvr_dispositivos \n                SET status = ?, ultima_conexao = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP\n                WHERE id = ?\n            `;\n            \n            this.db.run(query, [status, id], function(err) {\n                if (err) return reject(err);\n                if (this.changes === 0) return reject(new Error('Dispositivo não encontrado'));\n                resolve({ success: true });\n            });\n        });\n    }\n}\n\nmodule.exports = DVRService;\n","size_bytes":10516},"bin/DemoSrc/playsdkdemo/DlgOpenFile.cpp":{"content":"// DlgOpenFile.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"PlayDemo.h\"\n#include \"DlgOpenFile.h\"\n#include \"LanguageConvertor.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgOpenFile dialog\n\n\nCDlgOpenFile::CDlgOpenFile(CWnd* pParent /*=NULL*/)\n\t: CDialog(CDlgOpenFile::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgOpenFile)\n\tm_nType = 0;\n\tm_strFile = _T(\"\");\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CDlgOpenFile::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgOpenFile)\n\tDDX_Text(pDX, IDC_EDIT_FILE, m_strFile);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgOpenFile, CDialog)\n\t//{{AFX_MSG_MAP(CDlgOpenFile)\n\tON_BN_CLICKED(IDC_BUTTON_FILE, OnButtonFile)\n\tON_BN_CLICKED(IDC_RADIO_FILE, OnRadioFile)\n\tON_BN_CLICKED(IDC_RADIO_FILESTREAM, OnRadioFilestream)\n\tON_BN_CLICKED(IDC_BUTTON_OK, OnButtonOk)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgOpenFile message handlers\n\nvoid CDlgOpenFile::OnButtonFile() \n{\n\t// TODO: Add your control notification handler code here\n\t// TODO: Add your control notification handler code here\n\tCFileDialog dlgFile(TRUE, \n\t\tNULL,\n\t\tNULL, \n\t\tOFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,\n\t\t_T(\"All files(*.*)|*.*|Dav files (*.dav)|*.dav|\"));\n\t//choose file\n\tif (dlgFile.DoModal()==IDOK)\n\t{\n\t\tm_strFile = dlgFile.GetPathName();\n\t\tUpdateData(FALSE);\n\n\t\t((CButton*)GetDlgItem(IDC_RADIO_FILE))->EnableWindow(TRUE);\n\t\t((CButton*)GetDlgItem(IDC_RADIO_FILESTREAM))->EnableWindow(TRUE);\n\n\t\tint pos = -1;\n\t\tTCHAR* pbuffer = m_strFile.GetBuffer(m_strFile.GetLength());\n\t\tif ( -1 != (pos = m_strFile.ReverseFind('.')))\n\t\t{\n\t\t\tpbuffer += pos;\n\t\t}\n\t\t\n\t\t//asf,MP4 only support file mode\n\t\tif (0 == _tcscmp(pbuffer, _T(\".asf\")) || 0 == _tcscmp(pbuffer, _T(\".mp4\")))\n\t\t{\n\t\t\tm_nType = 0;\n\t\t\t((CButton*)GetDlgItem(IDC_RADIO_FILE))->SetCheck(TRUE);\n\t\t\t((CButton*)GetDlgItem(IDC_RADIO_FILESTREAM))->SetCheck(FALSE);\n\t\t\t((CButton*)GetDlgItem(IDC_RADIO_FILESTREAM))->EnableWindow(FALSE);\n\t\t}\n\t}\n}\n\nvoid CDlgOpenFile::OnRadioFile() \n{\n\t// TODO: Add your control notification handler code here\n\tm_nType = 0;\n}\n\nvoid CDlgOpenFile::OnRadioFilestream() \n{\n\t// TODO: Add your control notification handler code here\n\tm_nType = 1;\n}\n\nBOOL CDlgOpenFile::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\n\t// TODO: Add extra initialization here\n\t((CButton*)GetDlgItem(IDC_RADIO_FILE))->EnableWindow(TRUE);\n\t((CButton*)GetDlgItem(IDC_RADIO_FILESTREAM))->EnableWindow(TRUE);\n\t\n\t((CButton*)GetDlgItem(IDC_RADIO_FILE))->SetCheck(!m_nType);\n\t((CButton*)GetDlgItem(IDC_RADIO_FILESTREAM))->SetCheck(m_nType);\n\n\tif (!m_strFile.IsEmpty())\n\t{\n\t\t//ps,ts only support stream mode\n\t\tint pos = -1;\n\t\tTCHAR* pbuffer = m_strFile.GetBuffer(m_strFile.GetLength());\n\t\tif ( -1 != (pos = m_strFile.ReverseFind('.')))\n\t\t{\n\t\t\tpbuffer += pos;\n\t\t}\n\t\t\n\t\tif (0 == _tcscmp(pbuffer, _T(\".asf\")) || 0 == _tcscmp(pbuffer, _T(\".mp4\")))\n\t\t{\n\t\t\tm_nType = 0;\n\t\t\t((CButton*)GetDlgItem(IDC_RADIO_FILE))->SetCheck(TRUE);\n\t\t\t((CButton*)GetDlgItem(IDC_RADIO_FILESTREAM))->SetCheck(FALSE);\n\t\t\t((CButton*)GetDlgItem(IDC_RADIO_FILESTREAM))->EnableWindow(FALSE);\n\t\t}\n\t}\n\n\tLANG_SETWNDSTATICTEXT(this);\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgOpenFile::OnButtonOk() \n{\n\t// TODO: Add your control notification handler code here\n\tCDialog::OnOK();\n}\n","size_bytes":3543},"bin/DemoSrc/SoundCapture_demo/SoundCapture_demo.cpp":{"content":"// SoundCapture_demo.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"SoundCapture_demo.h\"\n#include \"SoundCapture_demoDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CSoundCapture_demoApp\n\nBEGIN_MESSAGE_MAP(CSoundCapture_demoApp, CWinApp)\n\t//{{AFX_MSG_MAP(CSoundCapture_demoApp)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t\t//    DO NOT EDIT what you see in these blocks of generated code!\n\t//}}AFX_MSG\n\tON_COMMAND(ID_HELP, CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CSoundCapture_demoApp construction\n\nCSoundCapture_demoApp::CSoundCapture_demoApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The one and only CSoundCapture_demoApp object\n\nCSoundCapture_demoApp theApp;\n\n/////////////////////////////////////////////////////////////////////////////\n// CSoundCapture_demoApp initialization\n\nBOOL CSoundCapture_demoApp::InitInstance()\n{\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t//  of your final executable, you should remove from the following\n\t//  the specific initialization routines you do not need.\n\n#ifdef _AFXDLL\n\tEnable3dControls();\t\t\t// Call this when using MFC in a shared DLL\n#else\n\tEnable3dControlsStatic();\t// Call this when linking to MFC statically\n#endif\n\n\tCSoundCapture_demoDlg dlg;\n\tm_pMainWnd = &dlg;\n\tint nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n","size_bytes":2143},"bin/DemoSrc/AviConvert_Demo/StdAfx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n//\tAviConvert_Demo.pch will be the pre-compiled header\n//\tstdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n#include \"CharactorTansfer.h\"\n\nCString GetMoudlePath()\n{\n\tTCHAR szAppName[MAX_PATH];\n\tTCHAR szDir[MAX_PATH];\n\tTCHAR szDrive[MAX_PATH];\n\tGetModuleFileName(GetModuleHandle(NULL), szAppName, MAX_PATH);\n\t_tsplitpath(szAppName, szDrive, szDir, NULL, NULL);\n\t\n\tTCHAR szPath[MAX_PATH];\n\t_tmakepath(szPath, szDrive, szDir, NULL, NULL);\n\t\n\treturn szPath;\n}\n\n\n\n","size_bytes":557},"bin/Demo/MfcDemo/20.MonitorWall/src/StdAfx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n//\tDemoMonitorWall.pch will be the pre-compiled header\n//\tstdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n\n\n\n","size_bytes":209},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgAlarmSlotBond.cpp":{"content":"// DlgCfgAlarmSlotBond.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"alarmdevice.h\"\n#include \"DlgCfgAlarmSlotBond.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgAlarmSlotBond dialog\n\n\nCDlgCfgAlarmSlotBond::CDlgCfgAlarmSlotBond(CWnd* pParent /* = NULL */, LLONG lLoginID /* = NULL */)\n\t: CDialog(CDlgCfgAlarmSlotBond::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgAlarmSlotBond)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_lLoginID = lLoginID;\n\tmemset(&m_stuInfo, 0, sizeof(m_stuInfo));\n}\n\n\nvoid CDlgCfgAlarmSlotBond::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgAlarmSlotBond)\n\tDDX_Control(pDX, IDC_ALARMSLOTBOND_CMB_TYPE, m_cmbType);\n\tDDX_Control(pDX, IDC_ALARMSLOTBOND_CMB_INDEX, m_cmbIndex);\n\tDDX_Control(pDX, IDC_ALARMSLOTBOND_CMB_CHN, m_cmbChannel);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgAlarmSlotBond, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgAlarmSlotBond)\n\tON_BN_CLICKED(IDC_ALARMSLOTBOND_BTN_GET, OnAlarmslotbondBtnGet)\n\tON_BN_CLICKED(IDC_ALARMSLOTBOND_BTN_SET, OnAlarmslotbondBtnSet)\n\tON_CBN_SELCHANGE(IDC_ALARMSLOTBOND_CMB_CHN, OnSelchangeAlarmslotbondCmbChn)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgAlarmSlotBond private method\n\nvoid CDlgCfgAlarmSlotBond::InitDlg()\n{\n\tint i = 0;\n\n\tm_cmbChannel.ResetContent();\n\tfor (i = 0; i < 256; i++)\n\t{\n\t\tCString csItem;\n\t\tcsItem.Format(\"%s %03d\", ConvertString(\"Channel\", DLG_CFG_ALARM), i + 1);\n\t\tm_cmbChannel.InsertString(-1, csItem);\n\t}\n\tm_cmbChannel.SetCurSel(0);\n\n\tm_cmbType.ResetContent();\n\tfor (i = 0; i < sizeof(stuDemoInterfaceType)/sizeof(stuDemoInterfaceType[0]); i++)\n\t{\n\t\tm_cmbType.InsertString(-1, ConvertString(stuDemoInterfaceType[i].szInfo, DLG_CFG_ALARMSLOTBOND));\n\t}\n\tm_cmbType.SetCurSel(0);\n\n\tm_cmbIndex.ResetContent();\n\tfor (i = 0; i < 256; i++)\n\t{\n\t\tCString csItem;\n\t\tcsItem.Format(\"%s %03d\", ConvertString(\"Index\", DLG_CFG_ALARMSLOTBOND), i + 1);\n\t\tm_cmbIndex.InsertString(-1, csItem);\n\t}\n\tm_cmbIndex.SetCurSel(0);\n}\n\nBOOL CDlgCfgAlarmSlotBond::GetConfigFromDevice()\n{\n    char szJsonBuf[1024 * 40] = {0};\n    int nerror = 0;\n    int nSelChn = m_cmbChannel.GetCurSel() == -1 ? 0 : m_cmbChannel.GetCurSel();\n    BOOL bRet = CLIENT_GetNewDevConfig(m_lLoginID, CFG_CMD_ALARM_SLOT_BOND, nSelChn, szJsonBuf, sizeof(szJsonBuf), &nerror, SDK_API_WAIT);\n    \n    if (bRet)\n    {\n        DWORD dwRetLen = 0;\n        bRet = CLIENT_ParseData(CFG_CMD_ALARM_SLOT_BOND, szJsonBuf, (void*)&m_stuInfo, sizeof(m_stuInfo), &dwRetLen);\n        if (!bRet)\n        {\n            MessageBox(ConvertString(CString(\"parse AlarmSlotBond error...\"), DLG_CFG_ALARMSLOTBOND), ConvertString(\"Prompt\"));\n            return FALSE;\n        }\n    }\n    else\n    {\t\t\t\n        CString csErr;\n        csErr.Format(\"%s 0x%08x\",ConvertString(\"QueryConfig AlarmSlotBond error:\", DLG_CFG_ALARMSLOTBOND), CLIENT_GetLastError());\n        MessageBox(csErr, ConvertString(\"Prompt\"));\n        return FALSE;\n    }\n    return TRUE;\n}\n\nBOOL CDlgCfgAlarmSlotBond::SetConfigToDevice()\n{\n    char szJsonBuf[1024 * 40] = {0};    \n    BOOL bRet = CLIENT_PacketData(CFG_CMD_ALARM_SLOT_BOND, &m_stuInfo, sizeof(m_stuInfo), szJsonBuf, sizeof(szJsonBuf));\n    if (!bRet)\n    {\n        MessageBox(ConvertString(CString(\"packet AlarmSlotBond error...\"), DLG_CFG_ALARMSLOTBOND), ConvertString(\"Prompt\"));\n        return FALSE;\n    } \n    else\n    {\n\t\tint nSelChn = m_cmbChannel.GetCurSel() == -1 ? 0 : m_cmbChannel.GetCurSel();\n        int nerror = 0;\n        int nrestart = 0;\n        bRet = CLIENT_SetNewDevConfig(m_lLoginID, CFG_CMD_ALARM_SLOT_BOND, nSelChn, szJsonBuf, sizeof(szJsonBuf), &nerror, &nrestart, SDK_API_WAIT);\n        if (!bRet)\n        {\n            CString csErr;\n            csErr.Format(\"%s 0x%08x\", ConvertString(\"SetupConfig AlarmSlotBond failed:\", DLG_CFG_ALARMSLOTBOND), CLIENT_GetLastError());\n            MessageBox(csErr, ConvertString(\"Prompt\"));\n            return FALSE;\n        }\n        else\n        {\n            MessageBox(ConvertString(CString(\"SetConfig AlarmSlotBond ok!\"), DLG_CFG_ALARMSLOTBOND), ConvertString(\"Prompt\"));\n        }\n    }\n    return TRUE;\n}\n\nBOOL CDlgCfgAlarmSlotBond::showInfo()\n{\n\t// type\n\tm_cmbType.SetCurSel((int)m_stuInfo.emType);\n\n\t// index\n\tm_cmbIndex.SetCurSel(m_stuInfo.nIndex);\n\n    return TRUE;\n}\n\nBOOL CDlgCfgAlarmSlotBond::getInfo()\n{\n\t// type\n\tm_stuInfo.emType = (EM_CFG_INTERFACE_TYPE)m_cmbType.GetCurSel();\n\n\t// index\n\tm_stuInfo.nIndex = m_cmbIndex.GetCurSel();\n\n    return TRUE;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgAlarmSlotBond message handlers\n\nBOOL CDlgCfgAlarmSlotBond::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_ALARMSLOTBOND);\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\tif (GetConfigFromDevice())\n\t{\n\t\tshowInfo();\n\t}\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgAlarmSlotBond::OnAlarmslotbondBtnGet() \n{\n\t// TODO: Add your control notification handler code here\n\tif (GetConfigFromDevice())\n    {\n        showInfo();\n\t}\n}\n\nvoid CDlgCfgAlarmSlotBond::OnAlarmslotbondBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n\tgetInfo();\n    SetConfigToDevice();\n}\n\nvoid CDlgCfgAlarmSlotBond::OnSelchangeAlarmslotbondCmbChn() \n{\n\t// TODO: Add your control notification handler code here\n\tif (GetConfigFromDevice())\n    {\n        showInfo();\n\t}\n}\n","size_bytes":5681},"bin/Demo/MfcDemo/10.AlarmDevice/DlgExAlarmChannel.cpp":{"content":"// DlgExAlarmChannel.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgExAlarmChannel.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgExAlarmChannel dialog\n\n\nCDlgExAlarmChannel::CDlgExAlarmChannel(CWnd* pParent /*=NULL*/, LLONG lLoginId /*=NULL*/)\n\t: CDialog(CDlgExAlarmChannel::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgExAlarmChannel)\n\t//}}AFX_DATA_INIT\n\tm_lLoginId = lLoginId;\n\tmemset(&m_stuInfo, 0 , sizeof(NET_EXALARMCHANNELS));\n\tm_stuInfo.dwSize = sizeof(NET_EXALARMCHANNELS);\n}\n\n\nvoid CDlgExAlarmChannel::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgExAlarmChannel)\n\tDDX_Control(pDX, IDC_EXALARMCHANNEL_LIST_OUTREPORT, m_strExAlarmChannelOutList);\n\tDDX_Control(pDX, IDC_EXALARMCHANNEL_LIST_INREPORT, m_strExAlarmChannelInList);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgExAlarmChannel, CDialog)\n\t//{{AFX_MSG_MAP(CDlgExAlarmChannel)\n\tON_WM_DESTROY()\n\tON_BN_CLICKED(IDC_EXALARMCHANNELS_BTN_GET, OnExalarmchannelsBtnGet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgExAlarmChannel message handlers\n\nBOOL CDlgExAlarmChannel::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_EXALARMCHANNEL);\n\t// TODO: Add extra initialization here\n\tif (0 == m_lLoginId)\n\t{\n\t\tMessageBox(ConvertString(CString(\"We haven't login yet!\"), DLG_EXALARMCHANNEL), ConvertString(\"Prompt\"));\n\t\t//EndDialog(0);\n\t}\n\t\n\tInitDlg();\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgExAlarmChannel::OnDestroy() \n{\n\tCDialog::OnDestroy();\n\t\n\t// TODO: Add your message handler code here\n\tif (m_stuInfo.pstuExAlarmInInfo != NULL)\n\t{\n\t\tdelete []m_stuInfo.pstuExAlarmInInfo;\n\t\tm_stuInfo.pstuExAlarmInInfo = NULL;\n\t}\n\n\tif (m_stuInfo.pstuExAlarmOutInfo != NULL)\n\t{\n\t\tdelete []m_stuInfo.pstuExAlarmOutInfo;\n\t\tm_stuInfo.pstuExAlarmOutInfo = NULL;\n\t}\n}\n\n\nvoid CDlgExAlarmChannel::OnExalarmchannelsBtnGet() \n{\n\t// TODO: Add your control notification handler code here\n\tif (!getInfo())\n\t{\n\t\tMessageBox(ConvertString(\"new error!!!\", DLG_EXALARMCHANNEL), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\tif (getInfoFromDevice())\n\t{\n\t\tshowInfo();\n\t}\n}\n\nvoid CDlgExAlarmChannel::showInfo()\n{\n\tSetDlgItemInt(IDC_EXALARMCHANNEL_EDIT_INRETCOUNT, m_stuInfo.nRetExAlarmInCount, FALSE);\n\tSetDlgItemInt(IDC_EXALARMCHANNEL_EDIT_OUTRETCOUNT, m_stuInfo.nRetExAlarmOutCount, FALSE);\n\tint i = 0, nExAlarmRptIndex = 0;\n\tint nMinCount = __min(m_stuInfo.nExAlarmInCount, m_stuInfo.nRetExAlarmInCount);\n\tm_strExAlarmChannelInList.DeleteAllItems();\n\tm_strExAlarmChannelOutList.DeleteAllItems();\n\tfor (i = 0; i < nMinCount; ++i)\n\t{\n\t\tchar szIndex[10] = {0};\n\t\tchar szExAlarmBoxNum[10] = {0};\n\t\tchar szExAlarmChannelNum[10] = {0};\n\t\t_itoa(i + 1, szIndex, 10);\n\t\t_itoa(m_stuInfo.pstuExAlarmInInfo[i].nExAlarmBoxNum, szExAlarmBoxNum, 10);\n\t\t_itoa(m_stuInfo.pstuExAlarmInInfo[i].nChannelNum, szExAlarmChannelNum, 10);\n\t\tm_strExAlarmChannelInList.InsertItem(nExAlarmRptIndex, NULL);\n\t\tm_strExAlarmChannelInList.SetItemText(nExAlarmRptIndex, 0, szIndex);\n\t\tm_strExAlarmChannelInList.SetItemText(nExAlarmRptIndex, 1, szExAlarmBoxNum);\n\t\tm_strExAlarmChannelInList.SetItemText(nExAlarmRptIndex, 2, szExAlarmChannelNum);\n\t\tm_strExAlarmChannelInList.SetItemText(nExAlarmRptIndex, 3, m_stuInfo.pstuExAlarmInInfo[i].szChannelName);\n\t\tnExAlarmRptIndex++;\n\t}\n\n\tnExAlarmRptIndex = 0;\n\tnMinCount = __min(m_stuInfo.nExAlarmOutCount, m_stuInfo.nRetExAlarmOutCount);\n\tfor (i = 0; i < nMinCount; ++i)\n\t{\n\t\tchar szIndex[10] = {0};\n\t\tm_strExAlarmChannelOutList.SetItemText(nExAlarmRptIndex, 0, szIndex);\n\t\tchar szExAlarmBoxNum[10] = {0};\n\t\tchar szExAlarmChannelNum[10] = {0};\n\t\t_itoa(i + 1, szIndex, 10);\n\t\t_itoa(m_stuInfo.pstuExAlarmOutInfo[i].nExAlarmBoxNum, szExAlarmBoxNum, 10);\n\t\t_itoa(m_stuInfo.pstuExAlarmOutInfo[i].nChannelNum, szExAlarmChannelNum, 10);\n\t\tm_strExAlarmChannelOutList.InsertItem(nExAlarmRptIndex, NULL);\n\t\tm_strExAlarmChannelOutList.SetItemText(nExAlarmRptIndex, 0, szIndex);\n\t\tm_strExAlarmChannelOutList.SetItemText(nExAlarmRptIndex, 1, szExAlarmBoxNum);\n\t\tm_strExAlarmChannelOutList.SetItemText(nExAlarmRptIndex, 2, szExAlarmChannelNum);\n\t\tm_strExAlarmChannelOutList.SetItemText(nExAlarmRptIndex, 3, m_stuInfo.pstuExAlarmOutInfo[i].szChannelName);\n\t\tnExAlarmRptIndex++;\n\t}\n}\n\nBOOL CDlgExAlarmChannel::getInfo()\n{\n\tm_stuInfo.nExAlarmInCount = GetDlgItemInt(IDC_EXALARMCHANNEL_EDIT_INCOUNT);\n\tm_stuInfo.nExAlarmOutCount = GetDlgItemInt(IDC_EXALARMCHANNEL_EDIT_OUTCOUNT);\n\tif (m_stuInfo.nExAlarmInCount > 0)\n\t{\n\t\tif (m_stuInfo.pstuExAlarmInInfo != NULL)\n\t\t{\n\t\t\tdelete []m_stuInfo.pstuExAlarmInInfo;\n\t\t\tm_stuInfo.pstuExAlarmInInfo = NULL;\n\t\t}\n\t\tm_stuInfo.pstuExAlarmInInfo = new NET_EXALARMCHANNELS_INFO[m_stuInfo.nExAlarmInCount];\n\t\tif (m_stuInfo.pstuExAlarmInInfo == NULL)\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t\tmemset(m_stuInfo.pstuExAlarmInInfo, 0, sizeof(NET_EXALARMCHANNELS_INFO) * m_stuInfo.nExAlarmInCount);\n\t}\n\n\tif (m_stuInfo.nExAlarmOutCount > 0)\n\t{\n\t\tif (m_stuInfo.pstuExAlarmOutInfo != NULL)\n\t\t{\n\t\t\tdelete []m_stuInfo.pstuExAlarmOutInfo;\n\t\t\tm_stuInfo.pstuExAlarmOutInfo = NULL;\n\t\t}\n\t\tm_stuInfo.pstuExAlarmOutInfo = new NET_EXALARMCHANNELS_INFO[m_stuInfo.nExAlarmOutCount];\n\t\tif (m_stuInfo.pstuExAlarmOutInfo == NULL)\n\t\t{\n\t\t\tif (m_stuInfo.pstuExAlarmInInfo != NULL)\n\t\t\t{\n\t\t\t\tdelete []m_stuInfo.pstuExAlarmInInfo;\n\t\t\t\tm_stuInfo.pstuExAlarmInInfo = NULL;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\t\tmemset(m_stuInfo.pstuExAlarmOutInfo, 0, sizeof(NET_EXALARMCHANNELS_INFO) * m_stuInfo.nExAlarmOutCount);\n\t}\n\treturn TRUE;\n}\n\n\nBOOL CDlgExAlarmChannel::getInfoFromDevice()\n{\n\tint nRetLen = 0;\n\tBOOL bRet = CLIENT_QueryDevState(m_lLoginId, DH_DEVSTATE_EXALARMCHANNELS, \n\t\t(char*)&m_stuInfo, sizeof(NET_EXALARMCHANNELS), &nRetLen, SDK_API_WAIT);\n\tif (!bRet)\n\t{\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"QueryExAlarmChannel failed:\", DLG_EXALARMCHANNEL), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t} \n\telse\n\t{\n// \t\tCString csErr;\n// \t\tcsErr.Format(\"QueryExAlarmChannel ok!\");\n// \t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn TRUE;\n\t}\n}\n\nvoid CDlgExAlarmChannel::InitDlg()\n{\n\tGetDlgItem(IDC_EXALARMCHANNEL_EDIT_INRETCOUNT)->EnableWindow(FALSE);\n\tGetDlgItem(IDC_EXALARMCHANNEL_EDIT_OUTRETCOUNT)->EnableWindow(FALSE);\n\tSetDlgItemInt(IDC_EXALARMCHANNEL_EDIT_INCOUNT, 64, FALSE);\n\tSetDlgItemInt(IDC_EXALARMCHANNEL_EDIT_OUTCOUNT, 64, FALSE);\n\tm_strExAlarmChannelInList.SetExtendedStyle(m_strExAlarmChannelInList.GetExtendedStyle()| LVS_EX_HEADERDRAGDROP | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES );\n\tm_strExAlarmChannelInList.InsertColumn(0, ConvertString(\"Index\", DLG_EXALARMCHANNEL), LVCFMT_LEFT, 60, -1);\n\tm_strExAlarmChannelInList.InsertColumn(1, ConvertString(\"ExAlarmBox\", DLG_EXALARMCHANNEL), LVCFMT_LEFT, 90, -1);\n\tm_strExAlarmChannelInList.InsertColumn(2, ConvertString(\"InChannel\", DLG_EXALARMCHANNEL), LVCFMT_LEFT, 120, -1);\n\tm_strExAlarmChannelInList.InsertColumn(3, ConvertString(\"Name\", DLG_EXALARMCHANNEL), LVCFMT_LEFT, 150, -1);\n\n\tm_strExAlarmChannelOutList.SetExtendedStyle(m_strExAlarmChannelInList.GetExtendedStyle()| LVS_EX_HEADERDRAGDROP | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES );\n\tm_strExAlarmChannelOutList.InsertColumn(0, ConvertString(\"Index\", DLG_EXALARMCHANNEL), LVCFMT_LEFT, 60, -1);\n\tm_strExAlarmChannelOutList.InsertColumn(1, ConvertString(\"ExAlarmBox\", DLG_EXALARMCHANNEL), LVCFMT_LEFT, 90, -1);\n\tm_strExAlarmChannelOutList.InsertColumn(2, ConvertString(\"OutChannel\", DLG_EXALARMCHANNEL), LVCFMT_LEFT, 120, -1);\n\tm_strExAlarmChannelOutList.InsertColumn(3, ConvertString(\"Name\", DLG_EXALARMCHANNEL), LVCFMT_LEFT, 150, -1);\n}\n\n","size_bytes":7839},"bin/Demo/MfcDemo/09.AccessControl/SubDlgInfoCard.cpp":{"content":"// SubDlgInfoCard.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"accesscontrol.h\"\n#include \"SubDlgInfoCard.h\"\n#include \"SubDlgSensorInfoDescription.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CSubDlgInfoCard dialog\n\n#define MAX_FINGER_PRINT_PACKET_SIZE\t(10*256)\nCSubDlgInfoCard::CSubDlgInfoCard(CWnd* pParent /* = NULL */, NET_RECORDSET_ACCESS_CTL_CARD* p /* = NULL */, int nAccessGroup /* = 1 */)\n\t: CDialog(CSubDlgInfoCard::IDD, pParent)/*, m_fingerPrintPacket(MAX_FINGER_PRINT_PACKET_SIZE)*/\n{\n\t//{{AFX_DATA_INIT(CSubDlgInfoCard)\n\tm_strTestFingerPacketData = _T(\"\");\n\t//}}AFX_DATA_INIT\n\tmemset(&m_stuInfo, 0, sizeof(m_stuInfo));\n\tif (p != NULL)\n\t{\n\t\tmemcpy(&m_stuInfo, p, sizeof(NET_RECORDSET_ACCESS_CTL_CARD));\n\t}\n\tm_stuInfo.dwSize = sizeof(m_stuInfo);\n\tm_stuInfo.stuFingerPrintInfo.dwSize = sizeof(m_stuInfo.stuFingerPrintInfo);\n\n\tm_emOperateType = Em_Operate_Type_Show;\n    m_nAccessGroup  = nAccessGroup;\n\tm_bDirty = false;\n}\n\n\nvoid CSubDlgInfoCard::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CSubDlgInfoCard)\n\tDDX_Control(pDX, IDC_RECSET_CARD_DTP_VTEND, m_dtpVTEnd);\n\tDDX_Control(pDX, IDC_RECSET_CARD_DTP_VTSTART, m_dtpVTStart);\n\tDDX_Control(pDX, IDC_RECSET_CARD_CHK_FIRSTENTER, m_chkFirstEnter);\n\tDDX_Control(pDX, IDC_RECSET_CARD_CMB_CARDTYPE, m_cmbCardType);\n\tDDX_Control(pDX, IDC_RECSET_CARD_CMB_CARDSTATUS, m_cmbCardStatus);\n\tDDX_Control(pDX, IDC_RECSET_CARD_DTP_VDSTART, m_dtpVDStart);\n\tDDX_Control(pDX, IDC_RECSET_CARD_DTP_VDEND, m_dtpVDEnd);\n\tDDX_Control(pDX, IDC_RECSET_CARD_DTP_CT_TIME, m_dtpCreateTimeTime);\n\tDDX_Control(pDX, IDC_RECSET_CARD_DTP_CT_DATE, m_dtpCreateTimeDate);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CSubDlgInfoCard, CDialog)\n\t//{{AFX_MSG_MAP(CSubDlgInfoCard)\n\tON_BN_CLICKED(IDC_RECSET_CARD_BTN_DOORS, OnRecsetCardBtnDoors)\n\tON_BN_CLICKED(IDC_RECSET_CARD_BTN_TM, OnRecsetCardBtnTm)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\nvoid CSubDlgInfoCard::InitDlg()\n{\n\tint i = 0;\n\n\t// Card Status\n\tfor (i = 0; i < sizeof(stuDemoCardStatus)/sizeof(stuDemoCardStatus[0]); i++)\n\t{\n\t\tm_cmbCardStatus.InsertString(-1, ConvertString(stuDemoCardStatus[i].szName, SUBDLG_INFO_CARD));\n\t}\n\n\t// Card Type\n\tfor (i = 0; i < sizeof(stuDemoCardType)/sizeof(stuDemoCardType[0]); i++)\n\t{\n\t\tm_cmbCardType.InsertString(-1, ConvertString(stuDemoCardType[i].szName, SUBDLG_INFO_CARD));\n\t}\n\n\t// disable Finger Print edit box for default\n\tif (Em_Operate_Type_Show == m_emOperateType)\n\t{\n\t\tGetDlgItem(IDC_RECSET_CARD_EDT_RECNO)->EnableWindow(FALSE);\n\t\tStuToDlg();\n\t}\n\telse if (Em_Operate_Type_Insert == m_emOperateType || Em_Operate_Type_InsertEX == m_emOperateType)\n\t{\n\t\tGetDlgItem(IDC_RECSET_CARD_EDT_RECNO)->EnableWindow(FALSE);\n\t}\n\telse if (Em_Operate_Type_Get == m_emOperateType)\n\t{\n\t\tGetDlgItem(IDC_RECSET_CARD_EDT_RECNO)->EnableWindow();\n\t\tm_dtpCreateTimeDate.EnableWindow(FALSE);\n\t\tm_dtpCreateTimeTime.EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_RECSET_CARD_EDT_CARDNO)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_RECSET_CARD_EDT_USERID)->EnableWindow(FALSE);\n\t\tm_cmbCardStatus.EnableWindow(FALSE);\n\t\tm_cmbCardType.EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_RECSET_CARD_EDT_PWD)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_RECSET_CARD_EDT_USETIME)->EnableWindow(FALSE);\n\t\tm_dtpVDStart.EnableWindow(FALSE);\n\t\tm_dtpVDEnd.EnableWindow(FALSE);\n        m_dtpVTStart.EnableWindow(FALSE);\n        m_dtpVTEnd.EnableWindow(FALSE);\n        m_chkFirstEnter.EnableWindow(FALSE);\n\t}\n\telse if (Em_Operate_Type_Update == m_emOperateType || Em_Operate_Type_UpdateEX == m_emOperateType)\n\t{\n\t\tStuToDlg();\n \t\tGetDlgItem(IDC_RECSET_CARD_EDT_RECNO)->EnableWindow(FALSE);\n\t}\n\telse if (Em_Operate_Type_Remove == m_emOperateType)\n\t{\n\t\tStuToDlg();\n\t\tGetDlgItem(IDC_RECSET_CARD_EDT_RECNO)->EnableWindow();\n\t\tm_dtpCreateTimeDate.EnableWindow(FALSE);\n\t\tm_dtpCreateTimeTime.EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_RECSET_CARD_EDT_CARDNO)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_RECSET_CARD_EDT_USERID)->EnableWindow(FALSE);\n\t\tm_cmbCardStatus.EnableWindow(FALSE);\n\t\tm_cmbCardType.EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_RECSET_CARD_EDT_PWD)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_RECSET_CARD_EDT_USETIME)->EnableWindow(FALSE);\n\t\tm_dtpVDStart.EnableWindow(FALSE);\n        m_dtpVDEnd.EnableWindow(FALSE);\n        m_dtpVTStart.EnableWindow(FALSE);\n        m_dtpVTEnd.EnableWindow(FALSE);\n        m_chkFirstEnter.EnableWindow(FALSE);\n\t}\n\telse if (Em_Operate_Type_Clear == m_emOperateType)\n\t{\n\t\t// ...\n\t}\n}\n\nvoid CSubDlgInfoCard::StuToDlg()\n{\n\t// RecNo\n\tSetDlgItemInt(IDC_RECSET_CARD_EDT_RECNO, m_stuInfo.nRecNo);\n\n\t// create time\n\tSYSTEMTIME st = {0};\n\tst.wYear\t= (WORD)m_stuInfo.stuCreateTime.dwYear;\n\tst.wMonth\t= (WORD)m_stuInfo.stuCreateTime.dwMonth;\n\tst.wDay\t\t= (WORD)m_stuInfo.stuCreateTime.dwDay;\n\tm_dtpCreateTimeDate.SetTime(&st);\n\tst.wHour\t= (WORD)m_stuInfo.stuCreateTime.dwHour;\n\tst.wMinute\t= (WORD)m_stuInfo.stuCreateTime.dwMinute;\n\tst.wSecond\t= (WORD)m_stuInfo.stuCreateTime.dwSecond;\n\tm_dtpCreateTimeTime.SetTime(&st);\n\t\n\t// card no\n\tSetDlgItemText(IDC_RECSET_CARD_EDT_CARDNO, m_stuInfo.szCardNo);\n\n\t// user id\n\tSetDlgItemText(IDC_RECSET_CARD_EDT_USERID, m_stuInfo.szUserID);\n\n\t// card status\n\tm_cmbCardStatus.SetCurSel(CardStatusToInt(m_stuInfo.emStatus));\n\n\t// card type\n\tm_cmbCardType.SetCurSel(CardTypeToInt(m_stuInfo.emType));\n\n\t// password\n\tSetDlgItemText(IDC_RECSET_CARD_EDT_PWD, m_stuInfo.szPsw);\n\n\t// use time\n\tSetDlgItemInt(IDC_RECSET_CARD_EDT_USETIME, m_stuInfo.nUserTime, TRUE);\n\n\t// valid time start\n\tst.wYear\t= (WORD)m_stuInfo.stuValidStartTime.dwYear;\n\tst.wMonth\t= (WORD)m_stuInfo.stuValidStartTime.dwMonth;\n\tst.wDay\t\t= (WORD)m_stuInfo.stuValidStartTime.dwDay;\n\tm_dtpVDStart.SetTime(&st);\n    st.wHour    = (WORD)m_stuInfo.stuValidStartTime.dwHour;\n    st.wMinute  = (WORD)m_stuInfo.stuValidStartTime.dwMinute;\n    st.wSecond  = (WORD)m_stuInfo.stuValidStartTime.dwSecond;\n    m_dtpVTStart.SetTime(&st);\n\n\t// valid time end\n\tst.wYear\t= (WORD)m_stuInfo.stuValidEndTime.dwYear;\n\tst.wMonth\t= (WORD)m_stuInfo.stuValidEndTime.dwMonth;\n\tst.wDay\t\t= (WORD)m_stuInfo.stuValidEndTime.dwDay;\n\tm_dtpVDEnd.SetTime(&st);\n    st.wHour    = (WORD)m_stuInfo.stuValidEndTime.dwHour;\n    st.wMinute  = (WORD)m_stuInfo.stuValidEndTime.dwMinute;\n    st.wSecond  = (WORD)m_stuInfo.stuValidEndTime.dwSecond;\n    m_dtpVTEnd.SetTime(&st);\n\n    // first enter\n    if (m_stuInfo.bFirstEnter)\n    {\n        m_chkFirstEnter.SetCheck(BST_CHECKED);\n    }\n    else\n    {\n        m_chkFirstEnter.SetCheck(BST_UNCHECKED);\n    }\n}\n\nvoid CSubDlgInfoCard::DlgToStu()\n{\n\t// RecNo\n\tm_stuInfo.nRecNo = GetDlgItemInt(IDC_RECSET_CARD_EDT_RECNO);\n\t\n\t// create time\n\tSYSTEMTIME st = {0};\n\tm_dtpCreateTimeDate.GetTime(&st);\n\tm_stuInfo.stuCreateTime.dwYear\t= st.wYear;\n\tm_stuInfo.stuCreateTime.dwMonth = st.wMonth;\n\tm_stuInfo.stuCreateTime.dwDay\t= st.wDay;\n\tm_dtpCreateTimeTime.GetTime(&st);\n\tm_stuInfo.stuCreateTime.dwHour\t= st.wHour;\n\tm_stuInfo.stuCreateTime.dwMinute = st.wMinute;\n\tm_stuInfo.stuCreateTime.dwSecond = st.wSecond;\n\t\n\t// card no\n\tGetDlgItemText(IDC_RECSET_CARD_EDT_CARDNO, m_stuInfo.szCardNo, sizeof(m_stuInfo.szCardNo) - 1);\n\t\n\t// user id\n\tGetDlgItemText(IDC_RECSET_CARD_EDT_USERID, m_stuInfo.szUserID, sizeof(m_stuInfo.szUserID) - 1);\n\t\n\t// card status\n\tm_stuInfo.emStatus = IntToCardStatus(m_cmbCardStatus.GetCurSel());\n\t\n\t// card type\n\tm_stuInfo.emType = IntToCardType(m_cmbCardType.GetCurSel());\n\t\n\t// password\n\tGetDlgItemText(IDC_RECSET_CARD_EDT_PWD, m_stuInfo.szPsw, sizeof(m_stuInfo.szPsw) - 1);\n\t\n\t// use time\n\tm_stuInfo.nUserTime = GetDlgItemInt(IDC_RECSET_CARD_EDT_USETIME, NULL, TRUE);\n\t\n\t// valid time start\n\tm_dtpVDStart.GetTime(&st);\n\tm_stuInfo.stuValidStartTime.dwYear = st.wYear;\n\tm_stuInfo.stuValidStartTime.dwMonth = st.wMonth;\n\tm_stuInfo.stuValidStartTime.dwDay = st.wDay;\n    m_dtpVTStart.GetTime(&st);\n    m_stuInfo.stuValidStartTime.dwHour = st.wHour;\n    m_stuInfo.stuValidStartTime.dwMinute = st.wMinute;\n    m_stuInfo.stuValidStartTime.dwSecond = st.wSecond;\n\t\n\t// valid time end\n\tm_dtpVDEnd.GetTime(&st);\n\tm_stuInfo.stuValidEndTime.dwYear = st.wYear;\n\tm_stuInfo.stuValidEndTime.dwMonth = st.wMonth;\n\tm_stuInfo.stuValidEndTime.dwDay = st.wDay;\n    m_dtpVTEnd.GetTime(&st);\n    m_stuInfo.stuValidEndTime.dwHour = st.wHour;\n    m_stuInfo.stuValidEndTime.dwMinute = st.wMinute;\n    m_stuInfo.stuValidEndTime.dwSecond = st.wSecond;\n\n\t// test finger print packets(single) ²âÊÔÖ¸ÎÆÊý¾Ý£¬ÔÝÊ±²»É¾³ý\n// \tif (m_emOperateType == Em_Operate_Type_UpdateEX || m_emOperateType == Em_Operate_Type_InsertEX)\n// \t{\n//  \t\tif (m_stuInfo.stuFingerPrintInfo.nLength != 256) // 256:Ò»ÌõÖ¸ÎÆÊý¾Ý°üµÄ¹Ì¶¨´óÐ¡\n//  \t\t{\n//  \t\t\tm_bDirty = true;\n//  \t\t\tMessageBox(ConvertString(\"Finger Packets Length Wrong\", SUBDLG_INFO_CARD));\n//  \t\t\treturn;\n//  \t\t}\n// \t\t\n// \t\t// ÉèÖÃ²âÊÔÖ¸ÎÆÊý¾Ý°ü\n// \t\tstatic const char pTestFingerPrint[] = {0x46, 0x50, 0x4D, 0x0D, 0x88, 0x0D, 0x25, 0xC8, 0x58, 0x58, 0x94, 0x65, 0x26, 0xD5, 0x88, 0x68, 0x93, 0xA9, 0x26, 0x56,\n// \t\t\t\t\t\t\t\t\t\t\t\t0xA8,0x80 ,0x9A ,0xE9 ,0x25 ,0x4B ,0x58 ,0x58 ,0xA4 ,0x81 ,0x26 ,0x48 ,0x88 ,0x68 ,0xAC ,0xC1 ,0x15 ,0xC6 ,0x68 ,0x50 ,\n// \t\t\t\t\t\t\t\t\t\t\t\t0xB6 ,0x21 ,0x17 ,0x40 ,0xA8 ,0x92 ,0xBC ,0x51 ,0x17 ,0x1B ,0xA8 ,0x8A ,0xC4 ,0x31 ,0x17 ,0x25 ,0xE8 ,0x79 ,0xCB ,0x9D ,\n// \t\t\t\t\t\t\t\t\t\t\t\t0x17 ,0x91 ,0x88 ,0xA0 ,0xD1 ,0x09 ,0x17 ,0x23 ,0xB8 ,0x78 ,0xDD ,0xD1 ,0x15 ,0x38 ,0x48 ,0x80 ,0xFA ,0x3D ,0x17 ,0x16 ,\n// \t\t\t\t\t\t\t\t\t\t\t\t0xA8 ,0xB8 ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n// \t\t\t\t\t\t\t\t\t\t\t\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n// \t\t\t\t\t\t\t\t\t\t\t\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n// \t\t\t\t\t\t\t\t\t\t\t\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n// \t\t\t\t\t\t\t\t\t\t\t\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n// \t\t\t\t\t\t\t\t\t\t\t\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n// \t\t\t\t\t\t\t\t\t\t\t\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n// \t\t\t\t\t\t\t\t\t\t\t\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n// \t\t\t\t\t\t\t\t\t\t\t\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n// \t\t\t\t\t\t\t\t\t\t\t\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n// \t\t\t\t\t\t\t\t\t\t\t\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n// \t\t\t\t\t\t\t\t\t\t\t\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n// \t\t\t\t\t\t\t\t\t\t\t\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n// \t\t\t\t\t\t\t\t\t\t\t\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n// \t\t\t\t\t\t\t\t\t\t\t\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n// \t\t\t\t\t\t\t\t\t\t\t\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n// \t\t\t\t\t\t\t\t\t\t\t\t0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00\n// \t\t};\n// \t\t\n// \t\tm_fingerPrintPacket.Clear();\n// \t\tfor (int i=0; i<m_stuInfo.stuFingerPrintInfo.nCount; i++)\n// \t\t{\n// \t\t\tif (!m_fingerPrintPacket.AppendBuffer((char*)pTestFingerPrint, 256))\n// \t\t\t{\n// \t\t\t\tm_bDirty = true;\n// \t\t\t\tMessageBox(ConvertString(\"Finger Packets Length Wrong\", SUBDLG_INFO_CARD));\n//  \t\t\t\treturn;\n// \t\t\t}\n// \t\t}\n// \t\tm_stuInfo.stuFingerPrintInfo.pPacketData = (char*)m_fingerPrintPacket.GetBuffer();\n// \t}\n\n    // first enter\n    if (m_chkFirstEnter.GetCheck())\n    {\n        m_stuInfo.bFirstEnter = TRUE;\n    }\n    else\n    {\n        m_stuInfo.bFirstEnter = FALSE;\n    }\n}\n\nBOOL CSubDlgInfoCard::Get()\n{\n\tm_stuInfo.nRecNo = GetDlgItemInt(IDC_RECSET_CARD_EDT_RECNO, NULL, TRUE);\n\treturn TRUE;\n}\n\nBOOL CSubDlgInfoCard::Update()\n{\n\treturn TRUE;\n}\n\nBOOL CSubDlgInfoCard::Remove()\n{\n\treturn TRUE;\n}\n\nvoid CSubDlgInfoCard::Clear()\n{\n\n}\n\nint CSubDlgInfoCard::CardStatusToInt(NET_ACCESSCTLCARD_STATE emStatus)\n{\n\tint n = -1;\n\tif (NET_ACCESSCTLCARD_STATE_UNKNOWN == emStatus)\n\t{\n\t\tn = 0;\n\t}\n\telse if (NET_ACCESSCTLCARD_STATE_NORMAL == emStatus)\n\t{\n\t\tn = 1;\n\t}\n\telse if (NET_ACCESSCTLCARD_STATE_LOSE == emStatus)\n\t{\n\t\tn = 2;\n\t}\n\telse if (NET_ACCESSCTLCARD_STATE_LOGOFF == emStatus)\n\t{\n\t\tn = 3;\n\t}\n\telse if (NET_ACCESSCTLCARD_STATE_FREEZE == emStatus)\n\t{\n\t\tn = 4;\n\t}\n\treturn n;\n}\n\nNET_ACCESSCTLCARD_STATE CSubDlgInfoCard::IntToCardStatus(int n)\n{\n\tNET_ACCESSCTLCARD_STATE emStatua = NET_ACCESSCTLCARD_STATE_UNKNOWN;\n\tif (0 == n)\n\t{\n\t}\n\telse if (1 == n)\n\t{\n\t\temStatua = NET_ACCESSCTLCARD_STATE_NORMAL;\n\t}\n\telse if (2 == n)\n\t{\n\t\temStatua = NET_ACCESSCTLCARD_STATE_LOSE;\n\t}\n\telse if (3 == n)\n\t{\n\t\temStatua = NET_ACCESSCTLCARD_STATE_LOGOFF;\n\t}\n\telse if (4 == n)\n\t{\n\t\temStatua = NET_ACCESSCTLCARD_STATE_FREEZE;\n\t}\n\treturn emStatua;\n}\n\nint CSubDlgInfoCard::CardTypeToInt(NET_ACCESSCTLCARD_TYPE emType)\n{\n\tint n = -1;\n\tif (NET_ACCESSCTLCARD_TYPE_UNKNOWN == emType)\n\t{\n\t\tn = 0;\n\t}\n\telse if (NET_ACCESSCTLCARD_TYPE_GENERAL == emType)\n\t{\n\t\tn = 1;\n\t}\n\telse if (NET_ACCESSCTLCARD_TYPE_VIP == emType)\n\t{\n\t\tn = 2;\n\t}\n\telse if (NET_ACCESSCTLCARD_TYPE_GUEST == emType)\n\t{\n\t\tn = 3;\n\t}\n\telse if (NET_ACCESSCTLCARD_TYPE_PATROL == emType)\n\t{\n\t\tn = 4;\n\t}\n\telse if (NET_ACCESSCTLCARD_TYPE_BLACKLIST == emType)\n\t{\n\t\tn = 5;\n\t}\n\telse if (NET_ACCESSCTLCARD_TYPE_CORCE == emType)\n\t{\n\t\tn = 6;\n\t}\n\telse if (NET_ACCESSCTLCARD_TYPE_MOTHERCARD == emType)\n\t{\n\t\tn = 7;\n\t}\n\treturn n;\n}\n\nNET_ACCESSCTLCARD_TYPE CSubDlgInfoCard::IntToCardType(int n)\n{\n\tNET_ACCESSCTLCARD_TYPE emType = NET_ACCESSCTLCARD_TYPE_UNKNOWN;\n\tif (0 == n)\n\t{\n\t}\n\telse if (1 == n)\n\t{\n\t\temType = NET_ACCESSCTLCARD_TYPE_GENERAL;\n\t}\n\telse if (2 == n)\n\t{\n\t\temType = NET_ACCESSCTLCARD_TYPE_VIP;\n\t}\n\telse if (3 == n)\n\t{\n\t\temType = NET_ACCESSCTLCARD_TYPE_GUEST;\n\t}\n\telse if (4 == n)\n\t{\n\t\temType = NET_ACCESSCTLCARD_TYPE_PATROL;\n\t}\n\telse if (5 == n)\n\t{\n\t\temType = NET_ACCESSCTLCARD_TYPE_BLACKLIST;\n\t}\n\telse if (6 == n)\n\t{\n\t\temType = NET_ACCESSCTLCARD_TYPE_CORCE;\n\t}\n\telse if (7 == n)\n\t{\n\t\temType = NET_ACCESSCTLCARD_TYPE_MOTHERCARD;\n\t}\n\treturn emType;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CSubDlgInfoCard message handlers\n\nBOOL CSubDlgInfoCard::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, SUBDLG_INFO_CARD);\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CSubDlgInfoCard::OnOK() \n{\n\t// TODO: Add extra validation here\n\tswitch (m_emOperateType)\n\t{\n\tcase Em_Operate_Type_Show:\n\t\t{\n\t\t\tStuToDlg();\n\t\t}\n\t\tbreak;\n\tcase Em_Operate_Type_Insert:\n\tcase Em_Operate_Type_InsertEX:\n\t\t{\n\t\t\tDlgToStu();\n\t\t}\n\t\tbreak;\n\tcase Em_Operate_Type_Get:\n\t\t{\n\t\t\tDlgToStu();\n\t\t}\n\tcase Em_Operate_Type_Update:\n\tcase Em_Operate_Type_UpdateEX:\n\t\t{\n\t\t\tDlgToStu();\n\t\t}\n\t\tbreak;\n\tcase Em_Operate_Type_Remove:\n\t\t{\n\t\t\tDlgToStu();\n\t\t}\n\t\tbreak;\n\tcase Em_Operate_Type_Clear:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tCDialog::OnOK();\n}\n\nvoid CSubDlgInfoCard::OnRecsetCardBtnDoors() \n{\n\t// TODO: Add your control notification handler code here\t\n\tstd::vector<int> vecChn;\n\tint i = 0;\n\tfor (; i < m_stuInfo.nDoorNum; i++)\n\t{\n\t\tvecChn.push_back(m_stuInfo.sznDoors[i]);\n\t}\n\t\n\tCSubDlgSensorInfoDescription dlg(this, m_nAccessGroup);\n\tdlg.SetID(vecChn);\n\tif (IDOK == dlg.DoModal())\n\t{\n\t\tif (Em_Operate_Type_Insert == m_emOperateType\n\t\t\t|| Em_Operate_Type_Update == m_emOperateType\n\t\t\t|| Em_Operate_Type_InsertEX == m_emOperateType\n\t\t\t|| Em_Operate_Type_UpdateEX == m_emOperateType)\n\t\t{\n\t\t\tvecChn.clear();\n\t\t\tvecChn = dlg.GetID();\n\t\t\tstd::vector<int>::iterator it = vecChn.begin();\n\t\t\tfor (i = 0; i < __min(vecChn.size(), DH_MAX_DOOR_NUM) && it != vecChn.end(); i++, it++)\n\t\t\t{\n\t\t\t\tm_stuInfo.sznDoors[i] = *it;\n\t\t\t}\n\t\t\tm_stuInfo.nDoorNum = __min(vecChn.size(), DH_MAX_DOOR_NUM);\n\t\t}\n\t}\n}\n\nvoid CSubDlgInfoCard::OnRecsetCardBtnTm() \n{\n\t// TODO: Add your control notification handler code here\t\n\tstd::vector<int> vecChn;\n\tint i = 0;\n\tfor (; i < m_stuInfo.nTimeSectionNum; i++)\n\t{\n\t\tvecChn.push_back(m_stuInfo.sznTimeSectionNo[i]);\n\t}\n\t\n\tCSubDlgSensorInfoDescription dlg(this, 128);\n\tdlg.SetID(vecChn);\n\tif (IDOK == dlg.DoModal())\n\t{\n\t\tif (Em_Operate_Type_Insert == m_emOperateType\n\t\t\t|| Em_Operate_Type_Update == m_emOperateType\n\t\t\t|| Em_Operate_Type_InsertEX == m_emOperateType\n\t\t\t|| Em_Operate_Type_UpdateEX == m_emOperateType)\n\t\t{\n\t\t\tvecChn.clear();\n\t\t\tvecChn = dlg.GetID();\n\t\t\tstd::vector<int>::iterator it = vecChn.begin();\n\t\t\tfor (i = 0; i < __min(vecChn.size(), DH_MAX_TIMESECTION_NUM) && it != vecChn.end(); i++, it++)\n\t\t\t{\n\t\t\t\tm_stuInfo.sznTimeSectionNo[i] = *it;\n\t\t\t}\n\t\t\tm_stuInfo.nTimeSectionNum = __min(vecChn.size(), DH_MAX_TIMESECTION_NUM);\n\t\t}\n\t}\t\n}\n","size_bytes":16281},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/AutoMaintenance.cpp":{"content":"// AutoMaintenance.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"AutoMaintenance.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CAutoMaintenance dialog\n\n\nCAutoMaintenance::CAutoMaintenance(CWnd* pParent /*=NULL*/)\n\t: CDialog(CAutoMaintenance::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CAutoMaintenance)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tmemset(&m_atC, 0, sizeof(DHDEV_AUTOMT_CFG));\n\tm_dev = NULL;\n}\n\n\nvoid CAutoMaintenance::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CAutoMaintenance)\n\tDDX_Control(pDX, IDC_COMBO_AUTOTIME, m_autotime);\n\tDDX_Control(pDX, IDC_COMBO_AUTODEL, m_autodel);\n\tDDX_Control(pDX, IDC_COMBO_AUTODAY, m_autoday);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CAutoMaintenance, CDialog)\n\t//{{AFX_MSG_MAP(CAutoMaintenance)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CAutoMaintenance message handlers\n\nBOOL CAutoMaintenance::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\tif (m_dev != NULL)\n\t{\n\t\tDWORD ret = 0;\n\t\tBOOL b = CLIENT_GetDevConfig(m_dev->LoginID, DH_DEV_AUTOMTCFG, 0, &m_atC, sizeof(DHDEV_AUTOMT_CFG), &ret, CONFIG_WAITTIME);\n\t\tif (!b || ret != sizeof(DHDEV_AUTOMT_CFG))\n\t\t{\n\t\t\tMessageBox(ConvertString(\"get auto maintenance info failed!\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_autoday.SetCurSel(m_atC.byAutoRebootDay);\n\t\t\tm_autotime.SetCurSel(m_atC.byAutoRebootTime);\n\t\t\tm_autodel.SetCurSel(m_atC.byAutoDeleteFilesTime);\n\t\t}\n\t}\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\n\nvoid CAutoMaintenance::OnOK() \n{\n\tif (m_dev != NULL)\n\t{\n\t\tm_atC.dwSize = sizeof(m_atC);\n\t\tm_atC.byAutoRebootDay = m_autoday.GetCurSel();\n\t\tm_atC.byAutoRebootTime = m_autotime.GetCurSel();\n\t\tm_atC.byAutoDeleteFilesTime = m_autodel.GetCurSel();\n\t\tBOOL b = CLIENT_SetDevConfig(m_dev->LoginID, DH_DEV_AUTOMTCFG, 0, &m_atC, sizeof(m_atC), CONFIG_WAITTIME);\n\t\tif (!b)\n\t\t{\n\t\t\tMessageBox(ConvertString(\"set auto maintenance info failed!\"));\n\t\t}\n\t}\n\tCDialog::OnOK();\n}\n","size_bytes":2270},"bin/Demo/MfcDemo/06.EncodeConfig/StdAfx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n//\tShowDemo.pch will be the pre-compiled header\n//\tstdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n\n\n\n","size_bytes":202},"bin/Demo/MfcDemo/21.PassengerFlow/stdafx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n// PassengerFlow.pch will be the pre-compiled header\n// stdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n\n\n","size_bytes":206},"bin/Demo/MfcDemo/09.AccessControl/DlgDoorControl.cpp":{"content":"// DlgDoorControl.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AccessControl.h\"\n#include \"DlgDoorControl.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgDoorControl dialog\n\n\nCDlgDoorControl::CDlgDoorControl(CWnd* pParent /* = NULL */, LLONG lLoginID /* = 0 */)\n\t: CDialog(CDlgDoorControl::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgDoorControl)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_lLoginID = lLoginID;\n}\n\n\nvoid CDlgDoorControl::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgDoorControl)\n\tDDX_Control(pDX, IDC_DOORCTL_CMB_STATUS, m_cmbDoorStatus);\n\tDDX_Control(pDX, IDC_DOORCTL_CMB_CHN, m_cmbChannel);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgDoorControl, CDialog)\n\t//{{AFX_MSG_MAP(CDlgDoorControl)\n\tON_BN_CLICKED(IDC_DOORCTL_BTN_OPEN, OnDoorctlBtnOpen)\n\tON_BN_CLICKED(IDC_DOORCTL_BTN_CLOSE, OnDoorctlBtnClose)\n\tON_BN_CLICKED(IDC_DOORCTL_BTN_QUERY, OnDoorctlBtnQuery)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgDoorControl private method\n\nvoid CDlgDoorControl::InitDlg()\n{\n\tint i = 0;\n\n\tm_cmbChannel.ResetContent();\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%s%d\", ConvertString(\"Channel\", DLG_DOOR_CONTROL), i + 1);\n\t\tm_cmbChannel.InsertString(-1, csInfo);\n\t}\n\tm_cmbChannel.SetCurSel(0);\n\n\tm_cmbDoorStatus.ResetContent();\n\tfor (i = 0; i < sizeof(stuDemoDoorStatus)/sizeof(stuDemoDoorStatus[0]); i++)\n\t{\n\t\tm_cmbDoorStatus.InsertString(-1, ConvertString(stuDemoDoorStatus[i].szInfo, DLG_DOOR_CONTROL));\n\t}\n\tm_cmbDoorStatus.SetCurSel(-1);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgDoorControl message handlers\n\nBOOL CDlgDoorControl::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_DOOR_CONTROL);\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgDoorControl::OnDoorctlBtnOpen() \n{\n\t// TODO: Add your control notification handler code here\n\tNET_CTRL_ACCESS_OPEN stuParam = {sizeof(stuParam)};\n\tstuParam.nChannelID = m_cmbChannel.GetCurSel();\n\tBOOL bRet = CLIENT_ControlDevice(m_lLoginID, DH_CTRL_ACCESS_OPEN, &stuParam, 3000);\n\tif (bRet)\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%s %d ok\", ConvertString(\"Open door\", DLG_DOOR_CONTROL), stuParam.nChannelID + 1);\n\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t}\n\telse\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%s %d failed:0x%08x\", ConvertString(\"Open door\", DLG_DOOR_CONTROL), stuParam.nChannelID + 1, CLIENT_GetLastError());\n\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t}\n}\n\nvoid CDlgDoorControl::OnDoorctlBtnClose() \n{\n\t// TODO: Add your control notification handler code here\n\tNET_CTRL_ACCESS_CLOSE stuParam = {sizeof(stuParam)};\n\tstuParam.nChannelID = m_cmbChannel.GetCurSel();\n\tBOOL bRet = CLIENT_ControlDevice(m_lLoginID, DH_CTRL_ACCESS_CLOSE, &stuParam, 3000);\n\tif (bRet)\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%s %d ok\", ConvertString(\"Close door\", DLG_DOOR_CONTROL), stuParam.nChannelID + 1);\n\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t}\n\telse\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%s %d failed:0x%08x\", ConvertString(\"Close door\", DLG_DOOR_CONTROL), stuParam.nChannelID + 1, CLIENT_GetLastError());\n\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t}\t\n}\n\nvoid CDlgDoorControl::OnDoorctlBtnQuery() \n{\n\t// TODO: Add your control notification handler code here\n\tNET_DOOR_STATUS_INFO stuParam = {sizeof(stuParam)};\n\tstuParam.nChannel = m_cmbChannel.GetCurSel();\n\tint nRetLen = 0;\n\tBOOL bRet = CLIENT_QueryDevState(m_lLoginID, DH_DEVSTATE_DOOR_STATE, (char*)&stuParam, sizeof(stuParam), &nRetLen, 3000);\n\tif (bRet)\n\t{\n\t\tm_cmbDoorStatus.SetCurSel((int)stuParam.emStateType);\n\t} \n\telse\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%s:0x%08x\", ConvertString(\"Query door status failed\", DLG_DOOR_CONTROL), CLIENT_GetLastError());\n\t\tMessageBox(csInfo, ConvertString(\"Prompt\"));\n\t}\n}\n","size_bytes":4188},"bin/Demo/MfcDemo/17.IntelligentTraffic/PictureCtrl.cpp":{"content":"// PictureCtrl.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"PictureCtrl.h\"\n\n#define\tPICTURE_BACK_COLOR\tRGB(105,105,105)\nconst static COLORREF RESERVED_COLOR = RGB(255, 255, 255);\n\n// PictureCtrl\nIMPLEMENT_DYNAMIC(PictureCtrl, CStatic)\n\nPictureCtrl::PictureCtrl() : m_pPicture(NULL)\n{\n\n}\n\nPictureCtrl::~PictureCtrl()\n{\n\tif (m_pPicture != NULL)\n\t{\n\t\tm_pPicture->Release();\n\t\tm_pPicture = NULL;\n\t}\n}\n\nvoid PictureCtrl::SetImageDate(const BYTE* pBuf, int nBufSize)\n{\n\tUSES_CONVERSION;\n\n\tRECT rect;\n\tthis->GetWindowRect(&rect);\n\n\tCDC* pDC = NULL;\n\tpDC = this->GetWindowDC();\n\tif (NULL == pDC)\n\t{\n\t\treturn;\n\t}\n\n\tif (m_pPicture != NULL)\n\t{\n\t\tm_pPicture->Release();\n\t\tm_pPicture = NULL;\n\t}\n\n    HGLOBAL hMem  = GlobalAlloc(GMEM_MOVEABLE, nBufSize);\n    BYTE *pTmpBuf = (BYTE *)GlobalLock(hMem);\n    memcpy(pTmpBuf, pBuf, nBufSize);\n    GlobalUnlock(hMem);\n\n    if (m_pPicture != NULL)\n    {\n        m_pPicture->Release();\n        m_pPicture = NULL;\n    }\n\n    IStream* pStream = NULL;\n    CreateStreamOnHGlobal(hMem, false, &pStream);\n\n\t// Load Picture from stream\n\tHRESULT hr = S_FALSE;\n\thr = OleLoadPictureEx(pStream, nBufSize, TRUE, IID_IPicture, LP_DEFAULT, LP_DEFAULT, LP_DEFAULT,(LPVOID*)&m_pPicture);\n\tif (NULL == m_pPicture)\n\t{\n\t\tthis->ReleaseDC(pDC);\n\t\treturn;\n\t}\n\n\t// Show Picture\n\tOLE_XSIZE_HIMETRIC hmWidth; \n\tOLE_YSIZE_HIMETRIC hmHeight; \n\tm_pPicture->get_Width(&hmWidth); \n\tm_pPicture->get_Height(&hmHeight); \n\n\thr = m_pPicture->Render(*pDC, 0, 0, rect.right - rect.left, rect.bottom - rect.top, 0, hmHeight, hmWidth, -hmHeight, NULL);\n\tthis->ReleaseDC(pDC);\n\n    GlobalFree(hMem);\n    pStream->Release();\n}\n\n\nvoid PictureCtrl::SetImageFile(LPCSTR szImagePath)\n{\n    USES_CONVERSION;\n\n    RECT rect;\n    this->GetWindowRect(&rect);\n\n    CDC* pDC = NULL;\n    pDC = this->GetWindowDC();\n    if (NULL == pDC)\n    {\n        return;\n    }\n\n    if (m_pPicture != NULL)\n    {\n        m_pPicture->Release();\n        m_pPicture = NULL;\n    }\n\n    // Load Picture from path\n    HRESULT hr = S_FALSE;\n    hr = OleLoadPicturePath(T2OLE(szImagePath), NULL, 0, RESERVED_COLOR, IID_IPicture, (LPVOID*)&m_pPicture);\n    if (NULL == m_pPicture)\n    {\n        this->ReleaseDC(pDC);\n        return;\n    }\n\n    // Show Picture\n    OLE_XSIZE_HIMETRIC hmWidth; \n    OLE_YSIZE_HIMETRIC hmHeight; \n    m_pPicture->get_Width(&hmWidth); \n    m_pPicture->get_Height(&hmHeight); \n\n    hr = m_pPicture->Render(*pDC, 0, 0, rect.right - rect.left, rect.bottom - rect.top, 0, hmHeight, hmWidth, -hmHeight, NULL);\n    this->ReleaseDC(pDC);\n}\n\n\nBEGIN_MESSAGE_MAP(PictureCtrl, CStatic)\n\tON_WM_PAINT()\nEND_MESSAGE_MAP()\n\nvoid PictureCtrl::OnPaint()\n{\n\tif (NULL != m_pPicture)\n\t{\n\t\tCPaintDC dc(this);\n\n\t\tRECT rect;\n\t\tthis->GetWindowRect(&rect);\n\t\tOLE_XSIZE_HIMETRIC hmWidth; \n\t\tOLE_YSIZE_HIMETRIC hmHeight; \n\t\tm_pPicture->get_Width(&hmWidth); \n\t\tm_pPicture->get_Height(&hmHeight); \n\t\tm_pPicture->Render(dc.m_hDC, 0, 0, rect.right - rect.left, rect.bottom - rect.top, 0, hmHeight, hmWidth, -hmHeight, NULL);\t\n\t}\n\telse\n\t{\n\t\tCDC* cdc = this->GetDC();\n\t\tif (NULL == cdc)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tRECT rect;\n\t\tthis->GetClientRect(&rect);\n\t\tCBrush brush(PICTURE_BACK_COLOR);\n\t\tcdc->FillRect(&rect, &brush);\n\t\tthis->ReleaseDC(cdc);\n\t}\n\n\tCWnd::OnPaint();\n}\n\n","size_bytes":3231},"bin/Demo/MfcDemo/03.Alarm/Alarm.cpp":{"content":"// Alarm.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"Alarm.h\"\n#include \"AlarmDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CAlarmApp\n\nBEGIN_MESSAGE_MAP(CAlarmApp, CWinApp)\n\t//{{AFX_MSG_MAP(CAlarmApp)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t\t//    DO NOT EDIT what you see in these blocks of generated code!\n\t//}}AFX_MSG\n\tON_COMMAND(ID_HELP, CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CAlarmApp construction\n\nCString ConvertString(CString strText)\n{\n\tchar *val = new char[200];\n\tCString strIniPath,strRet;\n\t\n\tmemset(val,0,200);\n\tGetPrivateProfileString(\"String\",strText,\"\",\n\t\tval,200,\"./langchn.ini\");\n\tstrRet = val;\n\tif(strRet.GetLength()==0)\n\t{\n\t\t//If there is no corresponding string in the ini file. Set it to the default value.(English).\n\t\tstrRet=strText;\n\t}\n\tdelete val;\n\treturn strRet;\n}\n//Set static text in the dialogue box(English->current language) \nvoid g_SetWndStaticText(CWnd * pWnd)\n{\n\tCString strCaption,strText;\n\t\n\t//Set main window title \n\tpWnd->GetWindowText(strCaption);\n\tif(strCaption.GetLength()>0)\n\t{\n\t\tstrText=ConvertString(strCaption);\n\t\tpWnd->SetWindowText(strText);\n\t}\n\t\n\t//Set sub-window title \n\tCWnd * pChild=pWnd->GetWindow(GW_CHILD);\n\tCString strClassName;\n\twhile(pChild)\n\t{\n\t\t//////////////////////////////////////////////////////////////////////////\t\t\n\t\t//Added by Jackbin 2005-03-11\n\t\tstrClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n\t\tif(strClassName == \"CEdit\")\n\t\t{\n\t\t\t//The next sub-window \n\t\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t//////////////////////////////////////////////////////////////////////////\t\n\t\t\n\t\t//Set current language text in the sub-window \n\t\tpChild->GetWindowText(strCaption);\n\t\tstrText=ConvertString(strCaption);\n\t\tpChild->SetWindowText(strText);\n\t\t\n\t\t//The next sub-window \n\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t}\n}\n\n\n\nCAlarmApp::CAlarmApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The one and only CAlarmApp object\nCAlarmApp theApp;\n\n/////////////////////////////////////////////////////////////////////////////\n// CAlarmApp initialization\n\nBOOL CAlarmApp::InitInstance()\n{\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t//  of your final executable, you should remove from the following\n\t//  the specific initialization routines you do not need.\n\n\tCAlarmDlg dlg;\n\tm_pMainWnd = &dlg;\n\tINT_PTR nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":3335},"bin/Demo/MfcDemo/10.AlarmDevice/DlgSetBypass.cpp":{"content":"// DlgSetBypass.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgSetBypass.h\"\n#include \"DlgLocalBypass.h\"\n#include \"DlgExtendedBypass.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgSetBypass dialog\n\n\nCDlgSetBypass::CDlgSetBypass(CWnd* pParent /* = NULL */, LLONG lLoginId /* = 0 */)\n\t: CDialog(CDlgSetBypass::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgSetBypass)\n\tm_edExtendedCount = 0;\n\tm_edLocalCount = 16;\n\tm_edExtendedCountForGet = 0;\n\tm_edLocalCountForGet = 16;\n\t//}}AFX_DATA_INIT\n\tm_lLoginId = lLoginId;\n\tmemset(&m_stuSetBypass, 0, sizeof(NET_CTRL_SET_BYPASS));\n\tm_stuSetBypass.dwSize = sizeof(NET_CTRL_SET_BYPASS);\n\tmemset(&m_stuGetBypass, 0, sizeof(NET_DEVSTATE_GET_BYPASS));\n\tm_stuGetBypass.dwSize = sizeof(NET_DEVSTATE_GET_BYPASS);\n\tm_bNeedMode = FALSE;\n\tm_nLastLocalCount = 0;\n\tm_nLastExtendedCount = 0;\n}\n\n\nvoid CDlgSetBypass::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgSetBypass)\n\tDDX_Control(pDX, IDC_SETBYPASS_EDIT_PASSWORD, m_edPassword);\n\tDDX_Control(pDX, IDC_SETBYPASS_CHECK_MODE, m_ckMode);\n\tDDX_Text(pDX, IDC_SETBYPASS_EDIT_EXTENDEDCOUNT, m_edExtendedCount);\n\tDDV_MinMaxUInt(pDX, m_edExtendedCount, 0, 256);\n\tDDX_Text(pDX, IDC_SETBYPASS_EDIT_LOCALCOUNT, m_edLocalCount);\n\tDDV_MinMaxUInt(pDX, m_edLocalCount, 0, 16);\n\tDDX_Text(pDX, IDC_SETBYPASS_EDIT_EXTENDEDCOUNT_FORGET, m_edExtendedCountForGet);\n\tDDV_MinMaxUInt(pDX, m_edExtendedCountForGet, 0, 256);\n\tDDX_Text(pDX, IDC_SETBYPASS_EDIT_LOCALCOUNT_FORGET, m_edLocalCountForGet);\n\tDDV_MinMaxUInt(pDX, m_edLocalCountForGet, 0, 16);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgSetBypass, CDialog)\n\t//{{AFX_MSG_MAP(CDlgSetBypass)\n\tON_BN_CLICKED(IDC_SETBYPASS_BUTTON_LOCAL, OnSetbypassButtonLocal)\n\tON_BN_CLICKED(IDC_SETBYPASS_BUTTON_EXTENDED, OnSetbypassButtonExtended)\n\tON_WM_DESTROY()\n\tON_BN_CLICKED(IDC_SETBYPASS_BUTTON_SET, OnSetbypassButtonSet)\n\tON_BN_CLICKED(IDC_SETBYPASS_BUTTON_EXTENDED_FORGET, OnSetbypassButtonExtendedForget)\n\tON_BN_CLICKED(IDC_SETBYPASS_BUTTON_GET, OnSetbypassButtonGet)\n\tON_BN_CLICKED(IDC_SETBYPASS_BUTTON_LOCAL_FORGET, OnSetbypassButtonLocalForget)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgSetBypass message handlers\n\nBOOL CDlgSetBypass::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_BYPASS);\n\t// TODO: Add extra initialization here\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t// EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgSetBypass::OnSetbypassButtonLocal() \n{\n\t// TODO: Add your control notification handler code here\n\tUpdateData(TRUE);\n\tif (m_edLocalCount <= 0)\n\t{\n\t\tMessageBox(ConvertString(\"please input LocalCount first!\",DLG_BYPASS), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\tif (m_edLocalCount > 16)\n\t{\n\t\treturn;\n\t}\n\tif (m_stuSetBypass.pnLocal != NULL)\n\t{\n\t\tdelete[] m_stuSetBypass.pnLocal;\n\t\tm_stuSetBypass.pnLocal = NULL;\n\t}\n\tm_stuSetBypass.pnLocal = new int[m_edLocalCount];\n\tif (m_stuSetBypass.pnLocal == NULL)\n\t{\n\t\tMessageBox(ConvertString(\"new extended channel error!\", DLG_BYPASS), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\tmemset(m_stuSetBypass.pnLocal, 0, m_edLocalCount * sizeof(int));\n\n\tCDlgLocalBypass CDlg(this, FALSE, m_edLocalCount);\n\n\tif (IDOK == CDlg.DoModal())\n\t{\n\t\tCDlg.GetLocalChannel(m_stuSetBypass.pnLocal);\n\t\tm_stuSetBypass.nLocalCount = CDlg.GetActualCount();\n\t}\n}\n\nvoid CDlgSetBypass::OnSetbypassButtonExtended() \n{\n\t// TODO: Add your control notification handler code here\n\tUpdateData(TRUE);\n\tif (m_edExtendedCount <= 0)\n\t{\n\t\tMessageBox(ConvertString(\"please input extendedCount first!\", DLG_BYPASS), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\tif (m_edExtendedCount > 256)\n\t{\n\t\treturn;\n\t}\n\tif (m_stuSetBypass.pnExtended != NULL)\n\t{\n\t\tdelete[] m_stuSetBypass.pnExtended;\n\t\tm_stuSetBypass.pnExtended = NULL;\n\t}\n\tm_stuSetBypass.pnExtended = new int[m_edExtendedCount];\n\tif (m_stuSetBypass.pnExtended == NULL)\n\t{\n\t\tMessageBox(ConvertString(\"new extended channel error!\", DLG_BYPASS), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\tmemset(m_stuSetBypass.pnExtended, 0, m_edExtendedCount * sizeof(int));\n\n\tCDlgExtendedBypass CDlg(this, FALSE, m_edExtendedCount);\n\n\tif (IDOK == CDlg.DoModal())\n\t{\n\t\tCDlg.GetExtendedChannnel(m_stuSetBypass.pnExtended);\n\t\tm_stuSetBypass.nExtendedCount = CDlg.GetActualCount();\n\t}\n}\n\nvoid CDlgSetBypass::OnDestroy() \n{\n\tCDialog::OnDestroy();\n\t\n\t// TODO: Add your message handler code here\n\tif (m_stuSetBypass.pnLocal != NULL)\n\t{\n\t\tdelete[] m_stuSetBypass.pnLocal;\n\t\tm_stuSetBypass.pnLocal = NULL;\n\t}\n\n\tif (m_stuSetBypass.pnExtended != NULL)\n\t{\n\t\tdelete[] m_stuSetBypass.pnExtended;\n\t\tm_stuSetBypass.pnExtended = NULL;\n\t}\n\n\tif (m_stuGetBypass.pnLocal != NULL)\n\t{\n\t\tdelete[] m_stuGetBypass.pnLocal;\n\t\tm_stuGetBypass.pnLocal = NULL;\n\t}\n\t\n\tif (m_stuGetBypass.pnExtended != NULL)\n\t{\n\t\tdelete[] m_stuGetBypass.pnExtended;\n\t\tm_stuGetBypass.pnExtended = NULL;\n\t}\n}\n\nvoid CDlgSetBypass::OnSetbypassButtonSet() \n{\n\t// TODO: Add your control notification handler code here\n\tUpdateData(TRUE);\n\tif (m_lLoginId <= 0)\n\t{\n\t\tMessageBox(ConvertString(\"Please login first!\", DLG_BYPASS), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tif (m_edLocalCount <= 0 && m_edExtendedCount <= 0)\n\t{\n\t\tMessageBox(ConvertString(\"please input Count first!\", DLG_BYPASS), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\n\tCString csPsw;\n\tGetDlgItemText(IDC_SETBYPASS_EDIT_PASSWORD, csPsw);\n\tm_stuSetBypass.szDevPwd = csPsw.GetBuffer(0);\n\tm_stuSetBypass.emMode = m_ckMode.GetCheck() ? NET_BYPASS_MODE_BYPASS : NET_BYPASS_MODE_NORMAL;\n\tBOOL bRet = CLIENT_ControlDevice(m_lLoginId, DH_CTRL_SET_BYPASS, &m_stuSetBypass, SDK_API_WAIT);\n\tif (bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Set bypass ok!\", DLG_BYPASS), ConvertString(\"Prompt\"));\n\t} \n\telse\n\t{\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"set bypass failed:\", DLG_BYPASS), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t}\n}\n\nvoid CDlgSetBypass::OnSetbypassButtonExtendedForget() \n{\n\t// TODO: Add your control notification handler code here\n\tUpdateData(TRUE);\n\tif (m_edExtendedCountForGet <= 0)\n\t{\n\t\tMessageBox(ConvertString(\"please input extendedCount first!\", DLG_BYPASS), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tif (m_edExtendedCountForGet > 256)\n\t{\n\t\treturn;\n\t}\n\n\n\tint nTempChannel[256] = {0};\n\tif (m_stuGetBypass.pnExtended != NULL)\n\t{\n\t\tfor (unsigned int i = 0; i < __min((unsigned)m_nLastExtendedCount, m_edExtendedCountForGet); ++i)\n\t\t{\n\t\t\tnTempChannel[i] = m_stuGetBypass.pnExtended[i];\n\t\t}\n\t\tdelete[] m_stuGetBypass.pnExtended;\n\t\tm_stuGetBypass.pnExtended = NULL;\n\t}\n\tNET_BYPASS_MODE emTempMode[256] = {NET_BYPASS_MODE_UNKNOW};\n\tif (m_stuGetBypass.pemExtended != NULL)\n\t{\n\t\tfor (unsigned int i = 0; i < __min((unsigned)m_nLastExtendedCount, m_edExtendedCountForGet); ++i)\n\t\t{\n\t\t\temTempMode[i] = m_stuGetBypass.pemExtended[i];\n\t\t}\n\t\tdelete[] m_stuGetBypass.pemExtended;\n\t\tm_stuGetBypass.pemExtended = NULL;\n\t}\n\tm_stuGetBypass.pnExtended = new int[m_edExtendedCountForGet];\n\tm_stuGetBypass.pemExtended = new NET_BYPASS_MODE[m_edExtendedCountForGet];\n\tif (m_stuGetBypass.pnExtended == NULL || m_stuGetBypass.pemExtended == NULL)\n\t{\n\t\tMessageBox(ConvertString(\"new extended channel error!\", DLG_BYPASS), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\tmemset(m_stuGetBypass.pnExtended, 0, m_edExtendedCountForGet * sizeof(int));\n\tfor (unsigned int i = 0; i < m_edExtendedCountForGet; ++i)\n\t{\t\n\t\tm_stuGetBypass.pemExtended[i] = NET_BYPASS_MODE_UNKNOW;\n\t}\n\n\tCDlgExtendedBypass CDlg(this, TRUE, m_edExtendedCountForGet);\n\tCDlg.SetLastCount(m_nLastExtendedCount);\n\tCDlg.SetExtendedChannel(nTempChannel);\n\n\tif (m_bNeedMode)\n\t{\n\t\tCDlg.SetExtendedMode(emTempMode);\n\t}\n\n\tif (IDOK == CDlg.DoModal())\n\t{\n\t\tCDlg.GetExtendedChannnel(m_stuGetBypass.pnExtended);\n\t\tm_stuGetBypass.nExtendedCount = CDlg.GetActualCount();\n\t\tm_nLastExtendedCount = __min(m_edExtendedCountForGet, m_stuGetBypass.nExtendedCount);\n\t}\n\telse\n\t{\n\t\tm_nLastExtendedCount = 0;\n\t}\n}\n\nvoid CDlgSetBypass::OnSetbypassButtonLocalForget() \n{\n\t// TODO: Add your control notification handler code here\n\tUpdateData(TRUE);\n\tif (m_edLocalCountForGet <= 0)\n\t{\n\t\tMessageBox(ConvertString(\"please input localCount first!\", DLG_BYPASS), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tif (m_edLocalCountForGet > 16)\n\t{\n\t\treturn;\n\t}\n\n\tint nTempLocalChannel[16] = {0};\n\tif (m_stuGetBypass.pnLocal != NULL)\n\t{\n\t\tfor (unsigned int i = 0; i < __min((unsigned)m_nLastLocalCount, m_edLocalCountForGet); ++i)\n\t\t{\n\t\t\tnTempLocalChannel[i] = m_stuGetBypass.pnLocal[i];\n\t\t}\n\t\tdelete[] m_stuGetBypass.pnLocal;\n\t\tm_stuGetBypass.pnLocal = NULL;\n\t}\n\tNET_BYPASS_MODE emTempLocalMode[16] = {NET_BYPASS_MODE_UNKNOW};\n\tif (m_stuGetBypass.pemLocal != NULL)\n\t{\n\t\tfor (unsigned int i = 0; i < __min((unsigned)m_nLastLocalCount, m_edLocalCountForGet); ++i)\n\t\t{\n\t\t\temTempLocalMode[i] = m_stuGetBypass.pemLocal[i];\n\t\t}\n\n\t\tdelete[] m_stuGetBypass.pemLocal;\n\t\tm_stuGetBypass.pemLocal = NULL;\n\t}\n\n\tm_stuGetBypass.pnLocal = new int[m_edLocalCountForGet];\n\tm_stuGetBypass.pemLocal = new NET_BYPASS_MODE[m_edLocalCountForGet];\n\tif (m_stuGetBypass.pnLocal == NULL || m_stuGetBypass.pemLocal == NULL)\n\t{\n\t\tMessageBox(ConvertString(\"new Local channel error!\", DLG_BYPASS), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\tmemset(m_stuGetBypass.pnLocal, 0, m_edLocalCountForGet * sizeof(int));\n\tfor (unsigned int i = 0; i < m_edLocalCountForGet; ++i)\n\t{\t\n\t\tm_stuGetBypass.pemLocal[i] = NET_BYPASS_MODE_UNKNOW;\n\t}\n\n\tCDlgLocalBypass CDlg(this, TRUE, m_edLocalCountForGet);\n\tCDlg.SetLastCount(m_nLastLocalCount);\n\tCDlg.SetLocalChannel(nTempLocalChannel);\n\n\tif (m_bNeedMode)\n\t{\n\t\tCDlg.SetLocalMode(emTempLocalMode);\n\t}\n\n\tif (IDOK == CDlg.DoModal())\n\t{\n\t\tCDlg.GetLocalChannel(m_stuGetBypass.pnLocal);\n\t\tm_stuGetBypass.nLocalCount = CDlg.GetActualCount();\n\t\tm_nLastLocalCount = __min(m_edLocalCountForGet, m_stuGetBypass.nLocalCount);\n\t}\n\telse\n\t{\n\t\tm_nLastLocalCount = 0;\n\t}\n}\n\nvoid CDlgSetBypass::OnSetbypassButtonGet() \n{\n\t// TODO: Add your control notification handler code here\n\tif (m_lLoginId <= 0)\n\t{\n\t\tMessageBox(ConvertString(\"Please login first!\", DLG_BYPASS), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\tif (m_edExtendedCountForGet <= 0 && m_edLocalCountForGet <= 0)\n\t{\n\t\tMessageBox(ConvertString(\"please input extendedCount first!\", DLG_BYPASS), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tint nRetLen = 0;\n\tBOOL bRet = CLIENT_QueryDevState(m_lLoginId, DH_DEVSTATE_GET_BYPASS, \n\t\t(char*)&m_stuGetBypass, sizeof(NET_DEVSTATE_GET_BYPASS), &nRetLen, SDK_API_WAIT);\n\tif (!bRet)\n\t{\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"QueryChannelMode failed:\", DLG_BYPASS), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn;\n\t} \n\telse\n\t{\n\t\tm_bNeedMode = TRUE;\n\t\tMessageBox(ConvertString(\"QueryChannelMode bypass ok!\", DLG_BYPASS), ConvertString(\"Prompt\"));\t\n\t}\n}\n\n","size_bytes":10934},"bin/Demo/MfcDemo/10.AlarmDevice/ExButton.cpp":{"content":"// ExButton.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"ExButton.h\"\n#include \"AlarmDeviceDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CExButton\n\nCExButton::CExButton()\n{\n\tm_dwPTZCommand = -1;\n\tm_bIsMouseDown = FALSE;\n}\n\nCExButton::~CExButton()\n{\n}\n\n\nBEGIN_MESSAGE_MAP(CExButton, CButton)\n\t//{{AFX_MSG_MAP(CExButton)\n\tON_WM_LBUTTONDOWN()\n\tON_WM_LBUTTONUP()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CExButton message handlers\n\nvoid CExButton::OnLButtonDown(UINT nFlags, CPoint point) \n{\n\t// TODO: Add your message handler code here and/or call default\n\t//Check mous has been clicked or not \n\tif(!m_bIsMouseDown)\n\t{\n\t\tm_bIsMouseDown = TRUE;\n\t\tif((int)m_dwPTZCommand < 0)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t((CAlarmDeviceDlg*)GetParent())->PtzControl(m_dwPTZCommand,FALSE);\n\t\tTRACE(\"START\\n\");\n\t}\n\t\n\tCButton::OnLButtonDown(nFlags, point);\n}\n\nvoid CExButton::OnLButtonUp(UINT nFlags, CPoint point) \n{\n\t// TODO: Add your message handler code here and/or call default\n\tif(m_bIsMouseDown)\n\t{\n\t\tm_bIsMouseDown = FALSE;\n\t\tif((int)m_dwPTZCommand < 0)\n\t\t{\n\t\t\treturn;\t\t\n\t\t}\n\t\t((CAlarmDeviceDlg*)GetParent())->PtzControl(m_dwPTZCommand,TRUE);\n\t\tTRACE(\"STOP\\n\");\n\t}\n\t\n\tCButton::OnLButtonUp(nFlags, point);\n}\n\nvoid CExButton::SetButtonCommand(DWORD dwPTZCommand)\n{\n\tm_dwPTZCommand = dwPTZCommand;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":1867},"bin/Demo/MfcDemo/20.MonitorWall/src/DemoMonitorWall.cpp":{"content":"// DemoMonitorWall.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"DemoMonitorWall.h\"\n#include \"DemoMonitorWallDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\nCString CDemoMonitorWallApp::m_strModuleDir;\n\n/////////////////////////////////////////////////////////////////////////////\n// CDemoMonitorWallApp\n\nBEGIN_MESSAGE_MAP(CDemoMonitorWallApp, CWinApp)\n\t//{{AFX_MSG_MAP(CDemoMonitorWallApp)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t\t//    DO NOT EDIT what you see in these blocks of generated code!\n\t//}}AFX_MSG\n\tON_COMMAND(ID_HELP, CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDemoMonitorWallApp construction\n\nCDemoMonitorWallApp::CDemoMonitorWallApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The one and only CDemoMonitorWallApp object\n\nCDemoMonitorWallApp theApp;\n\n/////////////////////////////////////////////////////////////////////////////\n// CDemoMonitorWallApp initialization\n\nBOOL CDemoMonitorWallApp::InitInstance()\n{\n\tAfxEnableControlContainer();\n\n\t//\n\tGetModuleFileName(NULL, m_strModuleDir.GetBuffer(_MAX_PATH), _MAX_PATH);\n\tm_strModuleDir.ReleaseBuffer();\n\tint nPos = m_strModuleDir.ReverseFind('\\\\');\n\tif (nPos >= 0)\n\t{\n\t\tm_strModuleDir.Delete(nPos + 1, m_strModuleDir.GetLength() - nPos - 1);\n\t}\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t//  of your final executable, you should remove from the following\n\t//  the specific initialization routines you do not need.\n\n#ifdef _AFXDLL\n\tEnable3dControls();\t\t\t// Call this when using MFC in a shared DLL\n#else\n\tEnable3dControlsStatic();\t// Call this when linking to MFC statically\n#endif\n\n\tCDemoMonitorWallDlg dlg;\n\tm_pMainWnd = &dlg;\n\tint nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n","size_bytes":2415},"bin/DemoSrc/SoundCapture_demo/CharactorTansfer.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n//\tPlayDemo.pch will be the pre-compiled header\n//\tstdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n\n#include \"CharactorTansfer.h\"\n//gbk转UTF-8\nstd::string GbkToUtf8(const std::string& strGbk)//传入的strGbk是GBK编码\n{\n\t//gbk转unicode\n\tint len = MultiByteToWideChar(CHINESE_CODE_PAGE, 0, strGbk.c_str(), -1, NULL, 0);\n\twchar_t *strUnicode = new wchar_t[len];\n\twmemset(strUnicode, 0, len);\n\tMultiByteToWideChar(CHINESE_CODE_PAGE, 0, strGbk.c_str(), -1, strUnicode, len);\n\n\t//unicode转UTF-8\n\tlen = WideCharToMultiByte(CP_UTF8, 0, strUnicode, -1, NULL, 0, NULL, NULL);\n\tchar * strUtf8 = new char[len];\n\tWideCharToMultiByte(CP_UTF8, 0, strUnicode, -1, strUtf8, len, NULL, NULL);\n\n\tstd::string strTemp(strUtf8);//此时的strTemp是UTF-8编码\n\tdelete[]strUnicode;\n\tdelete[]strUtf8;\n\tstrUnicode = NULL;\n\tstrUtf8 = NULL;\n\treturn strTemp;\n}\n\n//UTF-8转gbk\nstd::string Utf8ToGbk(const std::string& strUtf8)//传入的strUtf8是UTF-8编码\n{\n\t//UTF-8转unicode\n\tint len = MultiByteToWideChar(CP_UTF8, 0, strUtf8.c_str(), -1, NULL, 0);\n\twchar_t * strUnicode = new wchar_t[len];//len = 2\n\twmemset(strUnicode, 0, len);\n\tMultiByteToWideChar(CP_UTF8, 0, strUtf8.c_str(), -1, strUnicode, len);\n\n\t//unicode转gbk\n\tlen = WideCharToMultiByte(CHINESE_CODE_PAGE, 0, strUnicode, -1, NULL, 0, NULL, NULL);\n\tchar *strGbk = new char[len];//len=3 本来为2，但是char*后面自动加上了\\0\n\tmemset(strGbk, 0, len);\n\tWideCharToMultiByte(CHINESE_CODE_PAGE,0, strUnicode, -1, strGbk, len, NULL, NULL);\n\n\tstd::string strTemp(strGbk);//此时的strTemp是GBK编码\n\tdelete[]strUnicode;\n\tdelete[]strGbk;\n\tstrUnicode = NULL;\n\tstrGbk = NULL;\n\treturn strTemp;\n}\n\n//gbk转unicode (下面的例子没用到)\nstd::wstring GbkToUnicode(const std::string& strGbk)//返回值是wstring\n{\n\tint len = MultiByteToWideChar(CHINESE_CODE_PAGE, 0, strGbk.c_str(), -1, NULL, 0);\n\twchar_t *strUnicode = new wchar_t[len];\n\twmemset(strUnicode, 0, len);\n\tMultiByteToWideChar(CHINESE_CODE_PAGE, 0, strGbk.c_str(), -1, strUnicode, len);\n\n\tstd::wstring strTemp(strUnicode);//此时的strTemp是Unicode编码\n\tdelete[]strUnicode;\n\tstrUnicode = NULL;\n\treturn strTemp;\n}\n\n//Unicode转gbk\nstd::string UnicodeToGbk (const std::wstring& strUnicode)//参数是wstring\n{\n\tint len = WideCharToMultiByte(CHINESE_CODE_PAGE, 0, strUnicode.c_str(), -1, NULL, 0, NULL, NULL);\n\tchar *strGbk = new char[len];//len=3 本来为2，但是char*后面自动加上了\\0\n\tmemset(strGbk, 0, len);\n\tWideCharToMultiByte(CHINESE_CODE_PAGE,0,strUnicode.c_str(), -1, strGbk, len, NULL, NULL);\n\t\n\tstd::string strTemp(strGbk);\n\tdelete []strGbk;\n\tstrGbk = NULL;\n\treturn strTemp;\n}\n","size_bytes":2706},"bin/Demo/MfcDemo/10.AlarmDevice/PtzScreen.cpp":{"content":"// PtzScreen.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"PtzScreen.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CPtzScreen\n\nCPtzScreen::CPtzScreen()\n{\n\tm_pMessageProc = NULL;\n\tm_dwMessageUser = 0;\n\tm_pGetParams = NULL;\n\tm_dwGetParams = 0;\n\tm_pSetParams = NULL;\n\tm_dwSetParams = 0;\n\tm_pRectEventFunc = NULL;\n\tm_dwRectEvent = 0;\n}\n\nCPtzScreen::~CPtzScreen()\n{\n\t\n}\nvoid  CPtzScreen::SetActiveWnd(int nIndex,BOOL bRepaint)\n{\n\tif(nIndex >= 0 && nIndex < DH_MAX_CHANNUM)\n\t{\n\t\tSetActivePage(&m_wndVideo[nIndex],bRepaint);\n\t}\n}\nCWnd* CPtzScreen::GetPage(int nIndex)\n{\n\tif (nIndex >= 0 && nIndex < DH_MAX_CHANNUM)\n\t{\n\t\treturn &m_wndVideo[nIndex];\n\t}\n\t\n\treturn NULL;\n}\nint CPtzScreen::SetShowPlayWin(int nMain, int nSub)\n{\n\tif (nSub < 0 || nSub > DH_MAX_CHANNUM)\n\t{\n\t\tnSub = 0;\n\t}\n\n\tint nNum = 16;\n\tint nBegin = 0;\n\tswitch(nMain) \n\t{\n\tcase SPLIT1:\n\t\tnNum = 1;\n\t\tnBegin = nSub;\n\t\tbreak;\n\tcase SPLIT4:\n\t\tnNum = 4;\n\t\tif (nSub >= 12)\n\t\t{\n\t\t\tnBegin = 12;\n\t\t}\n\t\telse if (nSub >= 8)\n\t\t{\n\t\t\tnBegin = 8;\n\t\t}\n\t\telse if (nSub >= 4)\n\t\t{\n\t\t\tnBegin = 4;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnBegin = 0;\n\t\t}\n\n\t\tbreak;\n\tcase SPLIT9:\n\t\tnNum = 9;\n\t\tif (nSub >= 10)\n\t\t{\n\t\t\tnBegin = 7;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnBegin = 0;\n\t\t}\n\t\tbreak;\n\tcase SPLIT16:\n\t\tnNum = 16;\n\t\tnBegin = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tm_bMultiScreen = TRUE;\n\tCList<CWnd*, CWnd*> templist;\n\n\tPOSITION pos = m_PageList.GetHeadPosition();\n\twhile(pos != NULL)\n\t{\n\t\tCWnd* pWnd = m_PageList.GetNext(pos);\n\t\tif (pWnd)\n\t\t{\n\t\t\ttemplist.AddTail(pWnd);\n\t\t}\n\t}\n\n\tm_PageList.RemoveAll();\n\n\t/*\n\twhile(m_PageList.GetCount())\n\t{\n\t\tDelPage(GetTailPage());\n\t}\n\t*/\n\t\n\tfor(int i=nBegin; i < (nBegin+nNum); i++)\n\t{\n\t\tAddPage(&m_wndVideo[i], TRUE);\n\t}\n\n\tSetActivePage(&m_wndVideo[nSub], TRUE);\n\n\tpos = templist.GetHeadPosition();\n\twhile(pos != NULL)\n\t{\n\t\tCWnd* pWnd = templist.GetNext(pos);\n\t\tif (pWnd)\n\t\t{\n\t\t\tpWnd->ShowWindow(SW_HIDE);\n\t\t}\n\t}\n\n\ttemplist.RemoveAll();\n\n\treturn m_PageList.GetCount();\n}\nvoid CPtzScreen::SetCallBack(OnMessageProcFunc cbMessageProc, LDWORD dwMessageUser,\n\t\t\t\t\t\t\t OnGetParamsFunc cbGetParams, LDWORD dwGetParams, \n\t\t\t\t\t\t\t OnSetParamsFunc cbSetParams, LDWORD dwSetParmas,\n\t\t\t\t\t\t\t OnRectEventFunc cbEventParams,LDWORD dwRectEventParams)\n{\n\tm_pMessageProc = cbMessageProc;\n\tm_dwMessageUser = dwMessageUser;\n\tm_pGetParams = cbGetParams;\n\tm_dwGetParams = dwGetParams;\n\tm_pSetParams = cbSetParams;\n\tm_dwSetParams = dwSetParmas;\n\tm_pRectEventFunc = cbEventParams;\n\tm_dwRectEvent = dwRectEventParams;\n}\nBEGIN_MESSAGE_MAP(CPtzScreen, CWnd)\n\t//{{AFX_MSG_MAP(CPtzScreen)\n\tON_WM_LBUTTONDOWN()\n\tON_WM_LBUTTONUP()\n\tON_WM_ACTIVATE()\n\tON_WM_CREATE()\n\tON_WM_DESTROY()\n//\tON_WM_ACTIVATEAPP()\n\tON_WM_ICONERASEBKGND()\n\tON_WM_ASKCBFORMATNAME()\n\tON_WM_ERASEBKGND()\n\tON_WM_CANCELMODE()\n\tON_WM_PAINT()\n\tON_WM_CAPTURECHANGED()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n\n/////////////////////////////////////////////////////////////////////////////\n// CPtzScreen message handlers\n\nvoid CPtzScreen::OnLButtonDown(UINT nFlags, CPoint point) \n{\n\t// TODO: Add your message handler code here and/or call default\n\tCWnd::OnLButtonDown(nFlags, point);\n}\n\nvoid CPtzScreen::OnLButtonUp(UINT nFlags, CPoint point) \n{\n\t// TODO: Add your message handler code here and/or call default\n\t\n\tCWnd::OnLButtonUp(nFlags, point);\n}\n\nvoid CPtzScreen::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized) \n{\n\tCWnd::OnActivate(nState, pWndOther, bMinimized);\n\t\n\t// TODO: Add your message handler code here\n\t\n}\n\nint CPtzScreen::OnCreate(LPCREATESTRUCT lpCreateStruct) \n{\n\tif (CWnd::OnCreate(lpCreateStruct) == -1)\n\t\treturn -1;\n\t\n\t// TODO: Add your specialized creation code here\n\tfor(int i = 0; i < DH_MAX_CHANNUM; i++)\n\t{\n\t\tm_wndVideo[i].Create(\n\t\t\tNULL, \n\t\t\tNULL, \n\t\t\tWS_VISIBLE | WS_CHILD,\n\t\t\tCRect(0, 0, 0, 0),\n\t\t\tthis,\n\t\t\t1979,\n\t\t\tNULL);\n\t\t\n\t\tm_wndVideo[i].SetWinID(i);\n\t\t\n\t\tAddPage(&m_wndVideo[i]);\n\t}\n\t\n\tSetActivePage(&m_wndVideo[0], TRUE);\n\tSetDrawActivePage(TRUE, RGB(248,5,182), RGB(248,5,182));\n\t\n\treturn 0;\t\n\treturn 0;\n}\n\nvoid CPtzScreen::OnDestroy() \n{\n\tCWnd::OnDestroy();\n\t\n\t// TODO: Add your message handler code here\n\tfor(int i=0; i < DH_MAX_CHANNUM; i++)\n\t{\n\t\tm_wndVideo[0].DestroyWindow();\n\t}\n}\n\nvoid CPtzScreen::OnActivateApp(BOOL bActive, HTASK hTask) \n{\n//\tCWnd::OnActivateApp(bActive, hTask);\n\t\n\t// TODO: Add your message handler code here\n\t\n}\n\nvoid CPtzScreen::OnIconEraseBkgnd(CDC* pDC) \n{\n\t// TODO: Add your message handler code here and/or call default\n\t\n\tCWnd::OnIconEraseBkgnd(pDC);\n}\n\nvoid CPtzScreen::OnAskCbFormatName(UINT nMaxCount, LPTSTR lpszString) \n{\n\t// TODO: Add your message handler code here and/or call default\n\n\tCWnd::OnAskCbFormatName(nMaxCount, lpszString);\n}\n\nBOOL CPtzScreen::OnEraseBkgnd(CDC* pDC) \n{\n\t// TODO: Add your message handler code here and/or call default\n\tCRect rt;\n\tGetClientRect(&rt);\n\tCBrush br;\n\tbr.CreateSolidBrush(RGB(192,192,192));\n\tpDC->FillRect(&rt,&br);\n\t\n\treturn TRUE;\n//\treturn CWnd::OnEraseBkgnd(pDC);\n}\n\nvoid CPtzScreen::OnCancelMode() \n{\n\tCWnd::OnCancelMode();\n\t\n\t// TODO: Add your message handler code here\n\t\n}\n\nvoid CPtzScreen::OnPaint() \n{\n\tCPaintDC dc(this); // device context for painting\n\t\n\t// TODO: Add your message handler code here\n\tUpdateWnd();\n\t// Do not call CWnd::OnPaint() for painting messages\n}\n\nvoid CPtzScreen::OnCaptureChanged(CWnd *pWnd) \n{\n\t// TODO: Add your message handler code here\n\t\n\tCWnd::OnCaptureChanged(pWnd);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":5807},"bin/Demo/MfcDemo/09.AccessControl/DlgCfgTimeSchedule.cpp":{"content":"// DlgCfgTimeSchedule.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"accesscontrol.h\"\n#include \"DlgCfgTimeSchedule.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgTimeSchedule dialog\n\n\nCDlgCfgTimeSchedule::CDlgCfgTimeSchedule(CWnd* pParent /* = NULL */, LLONG lLoginID /* = 0 */)\n\t: CDialog(CDlgCfgTimeSchedule::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgTimeSchedule)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_lLoginID = lLoginID;\n\tmemset(&m_stuInfo, 0, sizeof(m_stuInfo));\n}\n\n\nvoid CDlgCfgTimeSchedule::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgTimeSchedule)\n\tDDX_Control(pDX, IDC_TIMESCHEDULE_DTP4_START, m_dtp4Start);\n\tDDX_Control(pDX, IDC_TIMESCHEDULE_DTP3_START, m_dtp3Start);\n\tDDX_Control(pDX, IDC_TIMESCHEDULE_DTP2_START, m_dtp2Start);\n\tDDX_Control(pDX, IDC_TIMESCHEDULE_DTP1_START, m_dtp1Start);\n\tDDX_Control(pDX, IDC_TIMESCHEDULE_DTP4_END, m_dtp4End);\n\tDDX_Control(pDX, IDC_TIMESCHEDULE_DTP3_END, m_dtp3End);\n\tDDX_Control(pDX, IDC_TIMESCHEDULE_DTP2_END, m_dtp2End);\n\tDDX_Control(pDX, IDC_TIMESCHEDULE_DTP1_END, m_dtp1End);\n\tDDX_Control(pDX, IDC_TIMESCHEDULE_CMB_WEEKDAY, m_cmbWeekDay);\n\tDDX_Control(pDX, IDC_TIMESCHEDULE_CMB_INDEX, m_cmbIndex);\n\tDDX_Control(pDX, IDC_TIMESCHEDULE_CHK_SEG4_ENABLE, m_chkSeg4);\n\tDDX_Control(pDX, IDC_TIMESCHEDULE_CHK_SEG3_ENABLE, m_chkSeg3);\n\tDDX_Control(pDX, IDC_TIMESCHEDULE_CHK_SEG2_ENABLE, m_chkSeg2);\n\tDDX_Control(pDX, IDC_TIMESCHEDULE_CHK_SEG1_ENABLE, m_chkSeg1);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgTimeSchedule, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgTimeSchedule)\n\tON_BN_CLICKED(IDC_TIMESCHEDULE_BTN_GET, OnTimescheduleBtnGet)\n\tON_BN_CLICKED(IDC_TIMESCHEDULE_BTN_SET, OnTimescheduleBtnSet)\n\tON_CBN_SELCHANGE(IDC_TIMESCHEDULE_CMB_INDEX, OnSelchangeTimescheduleCmbIndex)\n\tON_CBN_SELCHANGE(IDC_TIMESCHEDULE_CMB_WEEKDAY, OnSelchangeTimescheduleCmbWeekday)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_TIMESCHEDULE_DTP1_START, OnDatetimechangeTimescheduleDtp1Start)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_TIMESCHEDULE_DTP1_END, OnDatetimechangeTimescheduleDtp1End)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_TIMESCHEDULE_DTP2_START, OnDatetimechangeTimescheduleDtp2Start)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_TIMESCHEDULE_DTP2_END, OnDatetimechangeTimescheduleDtp2End)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_TIMESCHEDULE_DTP3_START, OnDatetimechangeTimescheduleDtp3Start)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_TIMESCHEDULE_DTP3_END, OnDatetimechangeTimescheduleDtp3End)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_TIMESCHEDULE_DTP4_START, OnDatetimechangeTimescheduleDtp4Start)\n\tON_NOTIFY(DTN_DATETIMECHANGE, IDC_TIMESCHEDULE_DTP4_END, OnDatetimechangeTimescheduleDtp4End)\n\tON_BN_CLICKED(IDC_TIMESCHEDULE_CHK_SEG1_ENABLE, OnTimescheduleChkSeg1Enable)\n\tON_BN_CLICKED(IDC_TIMESCHEDULE_CHK_SEG2_ENABLE, OnTimescheduleChkSeg2Enable)\n\tON_BN_CLICKED(IDC_TIMESCHEDULE_CHK_SEG3_ENABLE, OnTimescheduleChkSeg3Enable)\n\tON_BN_CLICKED(IDC_TIMESCHEDULE_CHK_SEG4_ENABLE, OnTimescheduleChkSeg4Enable)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgTimeSchedule private method\n\nvoid CDlgCfgTimeSchedule::InitDlg()\n{\n\tunsigned int i = 0;\n\n\t// Index\n\tm_cmbIndex.ResetContent();\n\tfor (i = 0; i < 128; i++)\n\t{\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%d\", i + 1);\n\t\tm_cmbIndex.InsertString(-1, csInfo);\n\t}\n\tm_cmbIndex.SetCurSel(0);\n\t\n\t// WeekDay\n\tm_cmbWeekDay.ResetContent();\n\tfor (i = 0; i < sizeof(stuDemoWeekDay) / sizeof(stuDemoWeekDay[0]); i++)\n\t{\n\t\tm_cmbWeekDay.InsertString(-1, ConvertString(stuDemoWeekDay[i].pszName));\n\t}\n\tm_cmbWeekDay.SetCurSel(0);\n\t\n\t// DateTimePickers...\n\tSYSTEMTIME stStart = {2000,1,1,1}, stEnd = {2000,1,1,1,23,59,59,0};\n\tm_dtp1Start.SetTime(&stStart);\n\tm_dtp1End.SetTime(&stEnd);\n\tm_dtp2Start.SetTime(&stStart);\n\tm_dtp2End.SetTime(&stEnd);\n\tm_dtp3Start.SetTime(&stStart);\n\tm_dtp3End.SetTime(&stEnd);\n\tm_dtp4Start.SetTime(&stStart);\n\tm_dtp4End.SetTime(&stEnd);\n\tm_chkSeg1.SetCheck(BST_UNCHECKED);\n\tm_chkSeg2.SetCheck(BST_UNCHECKED);\n\tm_chkSeg3.SetCheck(BST_UNCHECKED);\n\tm_chkSeg4.SetCheck(BST_UNCHECKED);\n}\n\nvoid CDlgCfgTimeSchedule::StuToDlg()\n{\n\tOnSelchangeTimescheduleCmbWeekday();\n}\n\nvoid CDlgCfgTimeSchedule::DlgToStu()\n{\n\tGetTimeSectionFromDlg();\n}\n\nBOOL CDlgCfgTimeSchedule::GetConfigFromDevice()\n{\n\tint nChn = m_cmbIndex.GetCurSel();\n\tif (-1 == nChn)\n\t{\n\t\treturn FALSE;\n\t}\n\t\n\tchar szJsonBuf[1024 * 40] = {0};\n\tint nerror = 0;\n\tBOOL bRet = CLIENT_GetNewDevConfig((LLONG)m_lLoginID, CFG_CMD_ACCESSTIMESCHEDULE, nChn, szJsonBuf, 1024*40, &nerror, 3000);\n\t\n\tif (bRet)\n\t{\n\t\tDWORD dwRetLen = 0;\n\t\tbRet = CLIENT_ParseData(CFG_CMD_ACCESSTIMESCHEDULE, szJsonBuf, (void*)&m_stuInfo, sizeof(m_stuInfo), &dwRetLen);\n\t\tif (!bRet)\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"parse TimeSchedule error...\"), DLG_CFG_TIME_SCHEDULE), ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\t\t\t\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x...\\r\\n\\r\\n%s\", ConvertString(\"QueryConfig TimeSchedule error:\", DLG_CFG_TIME_SCHEDULE),\n\t\t\tCLIENT_GetLastError(), szJsonBuf);\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nBOOL CDlgCfgTimeSchedule::SetConfigToDevice()\n{\n\tint nChn = m_cmbIndex.GetCurSel();\n\tif (-1 == nChn)\n\t{\n\t\treturn FALSE;\n\t}\n\t\n\tchar szJsonBuf[1024 * 40] = {0};\n\tBOOL bRet = CLIENT_PacketData(CFG_CMD_ACCESSTIMESCHEDULE, &m_stuInfo, sizeof(m_stuInfo), szJsonBuf, sizeof(szJsonBuf));\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(CString(\"packet TimeSchedule error...\"), DLG_CFG_TIME_SCHEDULE), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t} \n\telse\n\t{\t\t\n\t\tint nerror = 0;\n\t\tint nrestart = 0;\n\t\t\n\t\tbRet = CLIENT_SetNewDevConfig((LLONG)m_lLoginID, CFG_CMD_ACCESSTIMESCHEDULE, nChn, szJsonBuf, 1024*40, &nerror, &nrestart, 0);\n\t\tif (!bRet)\n\t\t{\n\t\t\tCString csErr;\n\t\t\tcsErr.Format(\"%s %08x...\", ConvertString(\"SetupConfig Alarm failed:\", DLG_CFG_TIME_SCHEDULE), CLIENT_GetLastError());\n\t\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"SetConfig Alarm ok!\"), DLG_CFG_TIME_SCHEDULE), ConvertString(\"Prompt\"));\n\t\t}\n\t}\n\treturn TRUE;\n}\n\nvoid CDlgCfgTimeSchedule::ShowTimeSection(int nSeg, const CFG_TIME_SECTION& stuTimeSection)\n{\n\tSYSTEMTIME stBegin = {2000, 1, 1, 1}, stEnd = {2000, 1, 1, 1};\n\tCfgTimeSectionToDTP(stuTimeSection, stBegin, stEnd);\n\t\n\tswitch (nSeg)\n\t{\n\tcase 0:\n\t\tm_dtp1Start.SetTime(&stBegin);\n\t\tm_dtp1End.SetTime(&stEnd);\n\t\tm_chkSeg1.SetCheck(stuTimeSection.dwRecordMask ? BST_CHECKED : BST_UNCHECKED);\n\t\tbreak;\n\tcase 1:\n\t\tm_dtp2Start.SetTime(&stBegin);\n\t\tm_dtp2End.SetTime(&stEnd);\n\t\tm_chkSeg2.SetCheck(stuTimeSection.dwRecordMask ? BST_CHECKED : BST_UNCHECKED);\n\t\tbreak;\n\tcase 2:\n\t\tm_dtp3Start.SetTime(&stBegin);\n\t\tm_dtp3End.SetTime(&stEnd);\n\t\tm_chkSeg3.SetCheck(stuTimeSection.dwRecordMask ? BST_CHECKED : BST_UNCHECKED);\n\t\tbreak;\n\tcase 3:\n\t\tm_dtp4Start.SetTime(&stBegin);\n\t\tm_dtp4End.SetTime(&stEnd);\n\t\tm_chkSeg4.SetCheck(stuTimeSection.dwRecordMask ? BST_CHECKED : BST_UNCHECKED);\n\t\tbreak;\n\t}\n}\n\nvoid CDlgCfgTimeSchedule::GetTimeSectionFromDlg()\n{\n\tint nSel = m_cmbWeekDay.GetCurSel();\n\tSYSTEMTIME stBegin = {0}, stEnd = {0};\n\tfor (int i = 0; i < MAX_DOOR_TIME_SECTION; i++)\n\t{\n\t\tCFG_TIME_SECTION& stuTimeSection = m_stuInfo.stuTime[(em_WeekDay)nSel][i];\n\t\tswitch (i)\n\t\t{\n\t\tcase 0:\n\t\t\tstuTimeSection.dwRecordMask = m_chkSeg1.GetCheck();\n\t\t\tm_dtp1Start.GetTime(&stBegin);\n\t\t\tm_dtp1End.GetTime(&stEnd);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tstuTimeSection.dwRecordMask = m_chkSeg2.GetCheck();\n\t\t\tm_dtp2Start.GetTime(&stBegin);\n\t\t\tm_dtp2End.GetTime(&stEnd);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstuTimeSection.dwRecordMask = m_chkSeg3.GetCheck();\n\t\t\tm_dtp3Start.GetTime(&stBegin);\n\t\t\tm_dtp3End.GetTime(&stEnd);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tstuTimeSection.dwRecordMask = m_chkSeg4.GetCheck();\n\t\t\tm_dtp4Start.GetTime(&stBegin);\n\t\t\tm_dtp4End.GetTime(&stEnd);\n\t\t\tbreak;\n\t\t}\n\t\tDTPToCfgTimeSection(stBegin, stEnd, stuTimeSection);\n\t}\n}\n\nvoid CDlgCfgTimeSchedule::CfgTimeSectionToDTP(const CFG_TIME_SECTION& stuTimeSection, SYSTEMTIME& stBegin, SYSTEMTIME& stEnd)\n{\n\tstBegin.wHour = stuTimeSection.nBeginHour;\n\tstBegin.wMinute = stuTimeSection.nBeginMin;\n\tstBegin.wSecond = stuTimeSection.nBeginSec;\n\tstEnd.wHour = stuTimeSection.nEndHour;\n\tstEnd.wMinute = stuTimeSection.nEndMin;\n\tstEnd.wSecond = stuTimeSection.nEndSec;\n}\n\nvoid CDlgCfgTimeSchedule::DTPToCfgTimeSection(const SYSTEMTIME& stBegin, const SYSTEMTIME& stEnd, CFG_TIME_SECTION& stuTimeSection)\n{\n\tstuTimeSection.nBeginHour = stBegin.wHour;\n\tstuTimeSection.nBeginMin = stBegin.wMinute;\n\tstuTimeSection.nBeginSec = stBegin.wSecond;\n\tstuTimeSection.nEndHour = stEnd.wHour;\n\tstuTimeSection.nEndMin = stEnd.wMinute;\n\tstuTimeSection.nEndSec = stEnd.wSecond;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgTimeSchedule message handlers\n\nBOOL CDlgCfgTimeSchedule::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_TIME_SCHEDULE);\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\tOnTimescheduleBtnGet();\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgTimeSchedule::OnTimescheduleBtnGet() \n{\n\t// TODO: Add your control notification handler code here\n\tif (GetConfigFromDevice())\n\t{\n\t\tStuToDlg();\n\t}\n}\n\nvoid CDlgCfgTimeSchedule::OnTimescheduleBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\tSetConfigToDevice();\n}\n\nvoid CDlgCfgTimeSchedule::OnSelchangeTimescheduleCmbIndex() \n{\n\t// TODO: Add your control notification handler code here\n\tOnTimescheduleBtnGet();\n}\n\nvoid CDlgCfgTimeSchedule::OnSelchangeTimescheduleCmbWeekday() \n{\n\t// TODO: Add your control notification handler code here\n\tint nSel = m_cmbWeekDay.GetCurSel();\n\tif (-1 == nSel)\n\t{\n\t\treturn;\n\t}\n\t\n\tfor (int i = 0; i < MAX_DOOR_TIME_SECTION; i++)\n\t{\n\t\tShowTimeSection(i, m_stuInfo.stuTime[nSel][i]);\n\t}\n}\n\nvoid CDlgCfgTimeSchedule::OnDatetimechangeTimescheduleDtp1Start(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\t*pResult = 0;\n}\n\nvoid CDlgCfgTimeSchedule::OnDatetimechangeTimescheduleDtp1End(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\t*pResult = 0;\n}\n\nvoid CDlgCfgTimeSchedule::OnDatetimechangeTimescheduleDtp2Start(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\t*pResult = 0;\n}\n\nvoid CDlgCfgTimeSchedule::OnDatetimechangeTimescheduleDtp2End(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\t*pResult = 0;\n}\n\nvoid CDlgCfgTimeSchedule::OnDatetimechangeTimescheduleDtp3Start(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\t*pResult = 0;\n}\n\nvoid CDlgCfgTimeSchedule::OnDatetimechangeTimescheduleDtp3End(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\t*pResult = 0;\n}\n\nvoid CDlgCfgTimeSchedule::OnDatetimechangeTimescheduleDtp4Start(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\t*pResult = 0;\n}\n\nvoid CDlgCfgTimeSchedule::OnDatetimechangeTimescheduleDtp4End(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\t*pResult = 0;\n}\n\nvoid CDlgCfgTimeSchedule::OnTimescheduleChkSeg1Enable() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n}\n\nvoid CDlgCfgTimeSchedule::OnTimescheduleChkSeg2Enable() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n}\n\nvoid CDlgCfgTimeSchedule::OnTimescheduleChkSeg3Enable() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n}\n\nvoid CDlgCfgTimeSchedule::OnTimescheduleChkSeg4Enable() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n}\n","size_bytes":12065},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgExAlarmInput.cpp":{"content":"// DlgCfgExAlarmInput.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgCfgExAlarmInput.h\"\n#include \"SubDlgCfgEventHandler.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgExAlarmInput dialog\n\n\nCDlgCfgExAlarmInput::CDlgCfgExAlarmInput(CWnd* pParent /* = NULL */, LLONG lLoginID /* = NULL */)\n\t: CDialog(CDlgCfgExAlarmInput::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgExAlarmInput)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_lLoginID = lLoginID;\n\tmemset(&m_stuInfo.stuAlarmIn, 0, sizeof(CFG_EXALARMINPUT_INFO));\n}\n\n\nvoid CDlgCfgExAlarmInput::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgExAlarmInput)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\tDDX_Control(pDX, IDC_CFG_EXALARMINPUT_EDT_NAME, m_edtName);\n\tDDX_Control(pDX, IDC_CFG_EXALARMINPUT_CMB_SENSORMETHOD, m_cmbSensorMethod);\n\tDDX_Control(pDX, IDC_CFG_EXALARMINPUT_CMB_CHN, m_cmbChn);\n\tDDX_Control(pDX, IDC_CFG_EXALARMINPUT_CHK_BYPASS, m_chkByPass);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgExAlarmInput, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgExAlarmInput)\n\t\t// NOTE: the ClassWizard will add message map macros here\n\tON_BN_CLICKED(IDC_CFG_EXALARMINPUT_BTN_EVENTHANDLER, OnCfgAlarmBtnEventhandler)\n\tON_BN_CLICKED(IDC_CFG_EXALARMINPUT_BTN_GET, OnCfgAlarmBtnGet)\n\tON_BN_CLICKED(IDC_CFG_EXALARMINPUT_BTN_SET, OnCfgAlarmBtnSet)\n\tON_CBN_SELCHANGE(IDC_CFG_EXALARMINPUT_CMB_CHN, OnSelchangeCfgAlarmCmbChn)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgExAlarmInput message handlers\n\nBOOL CDlgCfgExAlarmInput::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_EXALARMINPUT);\n\t// TODO: Add extra initialization here\n\tif (!m_lLoginID)\n\t{\n\t\tMessageBox(ConvertString(CString(\"We haven't login yet!\"), DLG_CFG_EXALARMINPUT), ConvertString(\"Prompt\"));\n\t\t//EndDialog(0);\n\t}\n\t\n\tGetConfigFromDevice();\n\tInitDlg();\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgExAlarmInput::OnCfgAlarmBtnEventhandler() \n{\n\t// TODO: Add your control notification handler code here\n\tCSubDlgCfgEventHandler* pdlgEventHandler = new CSubDlgCfgEventHandler;\n\tif (pdlgEventHandler != NULL)\n\t{\n\t\tpdlgEventHandler->SetEventHandler(m_stuInfo.stuAlarmIn.stuEventHandler);\n\t\tpdlgEventHandler->SetConfigType(emConfigType_AlarmExAlarmInput);\n\t\t\n\t\tif (IDOK == pdlgEventHandler->DoModal())\n\t\t{\n\t\t\tconst CFG_ALARM_MSG_HANDLE& stuEventHandler = pdlgEventHandler->GetEventHandler();\n\t\t\tmemcpy(&m_stuInfo.stuAlarmIn.stuEventHandler, &stuEventHandler, sizeof(CFG_ALARM_MSG_HANDLE));\n\t\t}\n\t\tdelete pdlgEventHandler;\n\t\tpdlgEventHandler = NULL;\n\t}\n\telse\n\t{\n\t\tMessageBox(ConvertString(\"new handler dialog error!\", DLG_CFG_EXALARMINPUT), ConvertString(\"Prompt\"));\n\t}\n\t\n}\n\nvoid CDlgCfgExAlarmInput::OnCfgAlarmBtnGet() \n{\n\t// TODO: Add your control notification handler code here\t\n\tif (GetConfigFromDevice())\n\t{\n\t\tStuToDlg();\n\t}\n}\n\nvoid CDlgCfgExAlarmInput::OnCfgAlarmBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\tSetConfigToDevice();\t\t\n}\n\n//////////////////////////////////////////////////////////////////////////\n// Private method\n\nvoid CDlgCfgExAlarmInput::InitDlg(BOOL bShow /* = TRUE */)\n{\n\tif (!bShow)\n\t{\n\t\tmemset(&m_stuInfo.stuAlarmIn, 0, sizeof(m_stuInfo.stuAlarmIn));\n\t}\n\n\tint i = 0;\n\n\t// channel\n\tm_cmbChn.ResetContent();\n\tfor (i = 0; i < MAX_EXALARM_CHANNEL_NUM; i++)\n\t{\n\t\tCString csItem;\n\t\tcsItem.Format(\"%s %03d\", ConvertString(\"Channel\", DLG_CFG_EXALARMINPUT), i + 1);\n\t\tm_cmbChn.InsertString(-1, csItem);\n\t}\n\tm_cmbChn.SetCurSel(m_stuInfo.stuAlarmIn.nChannelID);\n\n\t// bypass\n\tm_chkByPass.SetCheck(m_stuInfo.stuAlarmIn.bEnable ? BST_UNCHECKED : BST_CHECKED);\n\n\t// name\n\tSetDlgItemText(IDC_CFG_EXALARMINPUT_EDT_NAME, m_stuInfo.stuAlarmIn.szChnName);\n\n\t// sensor method...to be\n\tm_cmbSensorMethod.ResetContent();\n\tfor (i = 0; i < sizeof(stuDemoExAlarmSenseMethod) / sizeof(stuDemoExAlarmSenseMethod[0]); i++)\n\t{\n\t\tm_cmbSensorMethod.InsertString(-1, ConvertString(stuDemoExAlarmSenseMethod[i].pszName, DLG_CFG_EXALARMINPUT));\n\t}\n\tm_cmbSensorMethod.SetCurSel(int(m_stuInfo.stuAlarmIn.emSense));\n}\n\nBOOL CDlgCfgExAlarmInput::SetConfigToDevice()\n{\t\n\tchar szJsonBuf[1024 * 40] = {0};\n\tBOOL bRet = CLIENT_PacketData(CFG_CMD_EXALARMINPUT, &m_stuInfo.stuAlarmIn, sizeof(m_stuInfo.stuAlarmIn), szJsonBuf, sizeof(szJsonBuf));\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(CString(\"packet ExAlarmInput error...\"), DLG_CFG_EXALARMINPUT), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t} \n\telse\n\t{\n#if 0\n\t\tWriteLog(szJsonBuf);\n#endif\t// 0\n\n\t\tint nerror = 0;\n\t\tint nrestart = 0;\n\t\tbRet = CLIENT_SetNewDevConfig((LLONG)m_lLoginID, CFG_CMD_EXALARMINPUT, m_stuInfo.stuAlarmIn.nChannelID, szJsonBuf, 1024*40, &nerror, &nrestart, SDK_API_WAIT);\n\t\tif (!bRet)\n\t\t{\n\t\t\tCString csErr;\n\t\t\tcsErr.Format(\"%s %08x\", ConvertString(\"SetupConfig ExAlarmInput failed:\", DLG_CFG_EXALARMINPUT), CLIENT_GetLastError());\n\t\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"SetConfig ExAlarmInput ok!\"), DLG_CFG_EXALARMINPUT), ConvertString(\"Prompt\"));\n\t\t}\n\t}\n\treturn TRUE;\n}\n\nBOOL CDlgCfgExAlarmInput::GetConfigFromDevice()\n{\n\tchar szJsonBuf[1024 * 40] = {0};\n\tint nerror = 0;\n\tint nSelChn = m_cmbChn.GetCurSel() == -1 ? 0 : m_cmbChn.GetCurSel();\n\tBOOL bRet = CLIENT_GetNewDevConfig((LLONG)m_lLoginID, CFG_CMD_EXALARMINPUT, nSelChn, szJsonBuf, 1024*40, &nerror, SDK_API_WAIT);\n\n\tif (bRet)\n\t{\n\t\tDWORD dwRetLen = 0;\n\t\tbRet = CLIENT_ParseData(CFG_CMD_EXALARMINPUT, szJsonBuf, (void*)&m_stuInfo.stuAlarmIn, sizeof(m_stuInfo.stuAlarmIn), &dwRetLen);\n\t\tif (!bRet)\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"parse ExAlarmInput error...\"), DLG_CFG_EXALARMINPUT), ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// MessageBox(CString(\"GetConfig ExAlarmInput ok!\"), ConvertString(\"Prompt\"));\n\t\t}\n\t}\n\telse\n\t{\t\t\t\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"QueryConfig ExAlarmInput error:\", DLG_CFG_EXALARMINPUT), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nvoid CDlgCfgExAlarmInput::DlgToStu()\n{\n\tm_stuInfo.stuAlarmIn.nChannelID = m_cmbChn.GetCurSel() == -1 ? 0 : m_cmbChn.GetCurSel();\n\tm_stuInfo.stuAlarmIn.bEnable = m_chkByPass.GetCheck() ? FALSE : TRUE;\n\tGetDlgItemText(IDC_CFG_EXALARMINPUT_EDT_NAME, m_stuInfo.stuAlarmIn.szChnName, sizeof(m_stuInfo.stuAlarmIn.szChnName));\n\tm_stuInfo.stuAlarmIn.emSense = (EM_SENSE_METHOD)m_cmbSensorMethod.GetCurSel();\n}\n\nvoid CDlgCfgExAlarmInput::StuToDlg()\n{\n\tm_cmbChn.SetCurSel(m_stuInfo.stuAlarmIn.nChannelID);\n\tm_chkByPass.SetCheck(m_stuInfo.stuAlarmIn.bEnable ? BST_UNCHECKED : BST_CHECKED);\n\tSetDlgItemText(IDC_CFG_EXALARMINPUT_EDT_NAME, m_stuInfo.stuAlarmIn.szChnName);\n\tm_cmbSensorMethod.SetCurSel((int)m_stuInfo.stuAlarmIn.emSense);\n}\n\nvoid CDlgCfgExAlarmInput::OnSelchangeCfgAlarmCmbChn() \n{\n\t// TODO: Add your control notification handler code here\n\tint nSel = m_cmbChn.GetCurSel();\n\tif (-1 == nSel)\n\t{\n\t\treturn;\n\t}\n\n\tif (GetConfigFromDevice())\n\t{\n\t\tStuToDlg();\n\t}\n}\n","size_bytes":7351},"bin/DemoSrc/playsdkdemo/DlgSetColor.cpp":{"content":"// DlgSetColor.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"PlayDemo.h\"\n#include \"DlgSetColor.h\"\n#include \"Player.h\"\n#include \"LanguageConvertor.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgSetColor dialog\n\n\nCDlgSetColor::CDlgSetColor(CWnd* pParent /*=NULL*/)\n\t: CDialog(CDlgSetColor::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgSetColor)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CDlgSetColor::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgSetColor)\n\tDDX_Control(pDX, IDC_SLIDER_SATURATION, m_procSaturation);\n\tDDX_Control(pDX, IDC_SLIDER_HUE, m_procHue);\n\tDDX_Control(pDX, IDC_SLIDER_CONTRAST, m_procContrast);\n\tDDX_Control(pDX, IDC_SLIDER_BRIGHTNESS, m_procBrightness);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgSetColor, CDialog)\n\t//{{AFX_MSG_MAP(CDlgSetColor)\n\tON_WM_HSCROLL()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgSetColor message handlers\n\nBOOL CDlgSetColor::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tLANG_SETWNDSTATICTEXT(this);\n\t// TODO: Add extra initialization here\n\tm_procSaturation.SetRange(0, 128);\n\tm_procHue.SetRange(0, 128);\n\tm_procContrast.SetRange(0, 128);\n\tm_procBrightness.SetRange(0, 128);\n\n\tint nBrightness = 0;\n\tint nContrast = 0;\n\tint nSaturation = 0;\n\tint nHue = 0;\n\tCPlayer::Instance()->GetColor(&nSaturation, &nBrightness, &nContrast, &nHue);\n\t\t\t\n\tm_procSaturation.SetPos(nSaturation);\n\tm_procHue.SetPos(nHue);\n\tm_procContrast.SetPos(nContrast);\n\tm_procBrightness.SetPos(nBrightness);\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgSetColor::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) \n{\n\t// TODO: Add your message handler code here and/or call default\n\tswitch(GetWindowLong(pScrollBar->m_hWnd, GWL_ID))\n\t{\n\tcase IDC_SLIDER_SATURATION:\n\tcase IDC_SLIDER_CONTRAST:\n\tcase IDC_SLIDER_BRIGHTNESS:\n\tcase IDC_SLIDER_HUE:\n\t\t{\n\t\t\tint nBrightness = m_procBrightness.GetPos();\n\t\t\tint nContrast = m_procContrast.GetPos();\n\t\t\tint nSaturation = m_procSaturation.GetPos();\n\t\t\tint nHue = m_procHue.GetPos();\t\n\t\t\t\n\t\t\tCPlayer::Instance()->SetColor(nSaturation, nBrightness, nContrast, nHue);\n\t\t}\n\t\tbreak ;\n\t}\n\t\n\tCDialog::OnHScroll(nSBCode, nPos, pScrollBar);\t\n}\n\nBOOL CDlgSetColor::PreTranslateMessage(MSG* pMsg) \n{\n\t// TODO: Add your specialized code here and/or call the base class\n\tif (pMsg->wParam == VK_RETURN && pMsg->message == WM_KEYDOWN)\n\t\treturn 1;\n\telse if(pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_ESCAPE)\n\t\treturn 1;\n\treturn CDialog::PreTranslateMessage(pMsg);\n}\n","size_bytes":2844},"bin/Demo/MfcDemo/17.IntelligentTraffic/TrafficFlowDlg.cpp":{"content":"// TrafficFlowDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"IntelligentTraffic.h\"\n#include \"TrafficFlowDlg.h\"\n#include <cmath>\n\n\n#define WM_TRAFFIC_FLOW         (WM_USER + 20)   \n\n// CTrafficFlowDlg Dialog\n\nIMPLEMENT_DYNAMIC(CTrafficFlowDlg, CDialog)\n\nCTrafficFlowDlg::CTrafficFlowDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CTrafficFlowDlg::IDD, pParent)\n{\n    m_nTotalPage = 0;\n    m_nCurPage = 0;\n    m_nIndexOfSubscribeTrafficFlow = 0;\n    m_nTotalCountOfTrafficFlow = 0;\n    m_nIndexOfQueryTrafficFlow = 0;\n\n    m_lLoginHandle = 0;\n    m_lSubscribeTrafficFlowHandle = 0;\n    m_lQueryTrafficFlowHandle = 0;\n}\n\nCTrafficFlowDlg::~CTrafficFlowDlg()\n{\n}\n\nvoid CTrafficFlowDlg::DoDataExchange(CDataExchange* pDX)\n{\n    CDialog::DoDataExchange(pDX);\n    DDX_Control(pDX, IDC_BTN_SUNSCIRBE_AND_UNSUBSCRIBE, m_btnSubscribe);\n    DDX_Control(pDX, IDC_BTN_QUERY, m_btnQuery);\n    DDX_Control(pDX, IDC_LIST_TRAFFIC_FLOW, m_ctrTrafficFlow);\n    DDX_Control(pDX, IDC_CMB_CHANNEL, m_cmbChannel);\n    DDX_Control(pDX, IDC_CMB_LANE, m_cmbLane);\n    DDX_Control(pDX, IDC_LIST_QUERY_TRAFFIC_FLOW, m_ctrQueryTrafficFlow);\n    DDX_Control(pDX, IDC_BTN_PREVIOUS_PAGE, m_btnPreviousPage);\n    DDX_Control(pDX, IDC_BTN_NEXT_PAGE, m_btnNextPage);\n}\n\n\nBEGIN_MESSAGE_MAP(CTrafficFlowDlg, CDialog)\n    ON_BN_CLICKED(IDC_BTN_SUNSCIRBE_AND_UNSUBSCRIBE, &CTrafficFlowDlg::OnBnClickedBtnSunscirbeAndUnsubscribe)\n    ON_MESSAGE(WM_TRAFFIC_FLOW, &CTrafficFlowDlg::OnTrafficFlowDate)\n    ON_CBN_SELCHANGE(IDC_CMB_LANE, &CTrafficFlowDlg::OnCbnSelchangeCmbLane)\n    ON_BN_CLICKED(IDC_BTN_QUERY, &CTrafficFlowDlg::OnBnClickedBtnQuery)\n    ON_BN_CLICKED(IDC_BTN_PREVIOUS_PAGE, &CTrafficFlowDlg::OnBnClickedBtnPreviousPage)\n    ON_BN_CLICKED(IDC_BTN_NEXT_PAGE, &CTrafficFlowDlg::OnBnClickedBtnNextPage)\n    ON_NOTIFY(DTN_DATETIMECHANGE, IDC_DATETIMEPICKER_START_DATE, &CTrafficFlowDlg::OnDtnDatetimechangeDatetimepickerStartDate)\n    ON_NOTIFY(DTN_DATETIMECHANGE, IDC_DATETIMEPICKER_END_DATE, &CTrafficFlowDlg::OnDtnDatetimechangeDatetimepickerEndDate)\nEND_MESSAGE_MAP()\n\n\n// CTrafficFlowDlg message handlers\n\nBOOL CTrafficFlowDlg::PreTranslateMessage(MSG* pMsg)\n{\n    // Enter key\n    if(pMsg->message == WM_KEYDOWN &&\n        pMsg->wParam == VK_RETURN)\n    {\n        return TRUE;\n    }\n\n    // Escape key\n    if(pMsg->message == WM_KEYDOWN &&\n        pMsg->wParam == VK_ESCAPE)\n    {\n        return TRUE;\n    }\n    return CDialog::PreTranslateMessage(pMsg);\n}\n\nBOOL CTrafficFlowDlg::OnInitDialog()\n{\n    CDialog::OnInitDialog();\n    g_SetWndStaticText(this);\n\n    m_btnQuery.EnableWindow(FALSE);\n    m_btnSubscribe.EnableWindow(FALSE);\n    m_btnPreviousPage.EnableWindow(FALSE);\n    m_btnNextPage.EnableWindow(FALSE);\n\n    m_ctrTrafficFlow.SetExtendedStyle(m_ctrTrafficFlow.GetExtendedStyle() | LVS_EX_HEADERDRAGDROP | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);\n    m_ctrTrafficFlow.InsertColumn(0, ConvertString(\"Index\"), LVCFMT_LEFT, 60);\n    m_ctrTrafficFlow.InsertColumn(1, ConvertString(\"Start Time\"), LVCFMT_LEFT, 120);\n    m_ctrTrafficFlow.InsertColumn(2, ConvertString(\"Period(Second)\"), LVCFMT_LEFT, 90);\n    m_ctrTrafficFlow.InsertColumn(3, ConvertString(\"Flow Count\"), LVCFMT_LEFT, 90);\n    m_ctrTrafficFlow.InsertColumn(4, ConvertString(\"Avg Speed(km/h)\"), LVCFMT_LEFT, 110);\n    m_ctrTrafficFlow.InsertColumn(5, ConvertString(\"Time Percentage\"), LVCFMT_LEFT, 120);\n    m_ctrTrafficFlow.InsertColumn(6, ConvertString(\"Space Occupy Rate\"), LVCFMT_LEFT, 120);\n    \n    m_ctrQueryTrafficFlow.SetExtendedStyle(m_ctrTrafficFlow.GetExtendedStyle() | LVS_EX_HEADERDRAGDROP | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);\n    m_ctrQueryTrafficFlow.InsertColumn(0, ConvertString(\"Index\"), LVCFMT_LEFT, 60);\n    m_ctrQueryTrafficFlow.InsertColumn(1, ConvertString(\"Lane\"), LVCFMT_LEFT, 70);\n    m_ctrQueryTrafficFlow.InsertColumn(2, ConvertString(\"Flow Count\"), LVCFMT_LEFT, 90);\n    m_ctrQueryTrafficFlow.InsertColumn(3, ConvertString(\"Avg Speed(km/h)\"), LVCFMT_LEFT, 120);\n    m_ctrQueryTrafficFlow.InsertColumn(4, ConvertString(\"Time Percentage\"), LVCFMT_LEFT, 120);\n    m_ctrQueryTrafficFlow.InsertColumn(5, ConvertString(\"Space Occupy Rate\"), LVCFMT_LEFT, 130);\n    \n    return TRUE;  // return TRUE unless you set the focus to a control\n}\n\nvoid CTrafficFlowDlg::Init(unsigned int nChannel, LLONG lLoginHandle)\n{\n    if (0 == nChannel || 0 == lLoginHandle)\n    {\n        return;\n    }\n    for (unsigned int i = 0 ;i < nChannel; i++)\n    {\n        CString csChannel;\n        csChannel.Format(\"%d\", i+1);\n        m_cmbChannel.InsertString(i, csChannel);\n    }\n    m_cmbChannel.SetCurSel(0);\n\n    for (int i =0; i < DH_MAX_LANE_NUM; i++)\n    {\n        CString strLane;\n        strLane.Format(\"%d\", i+1);\n        m_cmbLane.InsertString(i, strLane);\n    }\n    m_cmbLane.SetCurSel(0);\n\n    m_lLoginHandle = lLoginHandle;\n    m_btnSubscribe.EnableWindow(TRUE);\n    m_btnQuery.EnableWindow(TRUE);\n}\n\nvoid CTrafficFlowDlg::CleanUp()\n{\n    if (m_lQueryTrafficFlowHandle)\n    {\n        // Stop query traffic flow\n        CLIENT_FindRecordClose(m_lQueryTrafficFlowHandle);\n    }\n    if (m_lSubscribeTrafficFlowHandle)\n    {\n        // Unsubscribe traffic flow\n        OnBnClickedBtnSunscirbeAndUnsubscribe();\n    }\n\n    for (unsigned int i =0; i < m_vecTrafficFlow.size(); i++)\n    {\n        NET_RECORD_TRAFFIC_FLOW_STATE* pTrafficFlow = m_vecTrafficFlow[i];\n        if (NULL != pTrafficFlow)\n        {\n            delete pTrafficFlow;\n            pTrafficFlow = NULL;\n        }\n    }\n    m_vecTrafficFlow.clear();\n\n    m_cmbChannel.ResetContent();\n    m_btnQuery.EnableWindow(FALSE);\n    m_btnSubscribe.EnableWindow(FALSE);\n    m_ctrQueryTrafficFlow.DeleteAllItems();\n    SetDlgItemText(IDC_EDIT_RECORD_COUNT, \"\");\n    SetDlgItemText(IDC_EDIT_RECORD_CURRENT_PAGE, \"\");\n}\n\nint CALLBACK cbTrafficFlowCallBack(LLONG lAnalyzerHandle, DWORD dwAlarmType, void* pAlarmInfo, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser, int nSequence, void *reserved)\n{\n    if (EVENT_IVS_TRAFFIC_FLOWSTATE != dwAlarmType || dwUser == NULL)\n    {\n        return -1;\n    }\n    DEV_EVENT_TRAFFIC_FLOW_STATE* pInfo =  new DEV_EVENT_TRAFFIC_FLOW_STATE;\n    memcpy(pInfo, (DEV_EVENT_TRAFFIC_FLOW_STATE*)pAlarmInfo, sizeof(DEV_EVENT_TRAFFIC_FLOW_STATE));\n    PostMessage(((CTrafficFlowDlg *)dwUser)->GetSafeHwnd(), WM_TRAFFIC_FLOW, (WPARAM)pInfo, (LPARAM)lAnalyzerHandle);\n\n    return 0;\n}\n\n// Show traffic flow info in List control\nLRESULT CTrafficFlowDlg::OnTrafficFlowDate(WPARAM wParam, LPARAM lParam)\n{\n    if (0 == wParam || lParam == 0)\n    {\n        return 0;\n    }\n    if (m_lSubscribeTrafficFlowHandle != (LLONG)lParam)\n    {\n        return 0;\n    }\n    if (m_ctrTrafficFlow.GetItemCount() > MAX_EVENT_IN_LIST_CONTROL)\n    {\n        m_ctrTrafficFlow.DeleteItem(MAX_EVENT_IN_LIST_CONTROL);\n    }\n\n    DEV_EVENT_TRAFFIC_FLOW_STATE* pInfo = (DEV_EVENT_TRAFFIC_FLOW_STATE*)wParam;\n    int nLane = m_cmbLane.GetCurSel();\n    \n    for (int i =0; i < DH_MAX_LANE_NUM; i++)\n    {\n        if ((nLane + 1 )== pInfo->stuStates[i].nLane)\n        {\n            CString strIndex;\n            CString strTime;\n            CString strPeriod;\n            CString strFlow;\n            CString strAvgSpeed;\n            CString strTimePercentage;\n            CString strSpaceOccupyRate;\n\n            strIndex.Format(\"%d\",++m_nIndexOfSubscribeTrafficFlow);\t\n            strTime.Format(\"%04d-%02d-%02d %02d:%02d:%02d\", pInfo->UTC.dwYear, pInfo->UTC.dwMonth,\n                pInfo->UTC.dwDay, pInfo->UTC.dwHour, pInfo->UTC.dwMinute, pInfo->UTC.dwSecond);\n            strPeriod.Format(\"%d\", pInfo->stuStates[i].dwPeriod*60+ (pInfo->stuStates[i].dwPeriodByMili)/1000);// dwPeriodByMili\n            strFlow.Format(\"%d\", pInfo->stuStates[i].dwFlow); \n            if (pInfo->stuStates[i].fAverageSpeed < 0)\n            {\n                strAvgSpeed.Format(\"-\"); \n            }\n            else\n            {\n                strAvgSpeed.Format(\"%.1f\", pInfo->stuStates[i].fAverageSpeed); \n            }\n            strTimePercentage.Format(\"%.1f\", pInfo->stuStates[i].fTimeOccupyRatio);\n            strSpaceOccupyRate.Format(\"%.1f\", pInfo->stuStates[i].fSpaceOccupyRatio);\n\n\n            LV_ITEM lvi;\n            lvi.mask=LVIF_TEXT|LVIF_IMAGE|LVIF_PARAM;\n            lvi.iSubItem = 0;\n            lvi.pszText = _T(\"\");\n            lvi.iImage = 0;\n            lvi.iItem = 0;\n            m_ctrTrafficFlow.InsertItem(&lvi);\n            m_ctrTrafficFlow.SetItemText(0,0, strIndex);\n            m_ctrTrafficFlow.SetItemText(0,1, strTime);\n            m_ctrTrafficFlow.SetItemText(0,2, strPeriod);\n            m_ctrTrafficFlow.SetItemText(0,3, strFlow);\n            m_ctrTrafficFlow.SetItemText(0,4, strAvgSpeed);\n            m_ctrTrafficFlow.SetItemText(0,5, strTimePercentage);\n            m_ctrTrafficFlow.SetItemText(0,6, strSpaceOccupyRate);\n            break;\n        }\n    }\n\n    delete pInfo;\n    pInfo = NULL;\n    return 0;\n}\n\nvoid CTrafficFlowDlg::OnBnClickedBtnSunscirbeAndUnsubscribe()\n{\n    if (0 != m_lSubscribeTrafficFlowHandle)\n    {\n        CLIENT_StopLoadPic(m_lSubscribeTrafficFlowHandle);\n        m_lSubscribeTrafficFlowHandle = 0;\n        m_btnSubscribe.SetWindowText(ConvertString(\"Subscribe\"));\n        m_ctrTrafficFlow.DeleteAllItems();\n    }\n    else\n    { \n        int nChannel = m_cmbChannel.GetCurSel();\n        m_nIndexOfSubscribeTrafficFlow = 0;\n        m_lSubscribeTrafficFlowHandle = CLIENT_RealLoadPictureEx(m_lLoginHandle, 0, EVENT_IVS_TRAFFIC_FLOWSTATE, TRUE, cbTrafficFlowCallBack, (LDWORD)this, NULL);\n        if (m_lSubscribeTrafficFlowHandle == 0)\n        {\t\t\n            MessageBox(ConvertString(\"Subscribe intelligent failed!\"), ConvertString(\"Prompt\"));\n            return;\n        }\n        else\n        {\n            m_btnSubscribe.SetWindowText(ConvertString(\"Unsubscribe\"));\n        }\n    }\n}\n\nvoid CTrafficFlowDlg::OnCbnSelchangeCmbLane()\n{\n    m_nIndexOfSubscribeTrafficFlow = 0;\n    m_ctrTrafficFlow.DeleteAllItems();\n}\n\nvoid CTrafficFlowDlg::OnBnClickedBtnQuery()\n{\n    // Whether the begin time is less than end time\n    bool bRet = IsTimeCorrent();\n    if (!bRet)\n    {\n        MessageBox(ConvertString(\"The begin time is bigger than end time, please input again!\"), ConvertString(\"Prompt\"));\n        return;\n    }\n\n    CleanUpResultOfLastTimeQuery();\n\n    // Start querying records\n    m_lQueryTrafficFlowHandle = StartFindTrafficFlow();\n    if (0 == m_lQueryTrafficFlowHandle)\n    {\n        return;\n    }\n\n    // Get total count of traffic flow\n    m_nTotalCountOfTrafficFlow = FindTotalCountOfTrafficFlow();\n    if (m_nTotalCountOfTrafficFlow <= 0)\n    {\n        return;\n    }\n\n    m_nCurPage = 1;\n    SetDlgItemInt(IDC_EDIT_RECORD_COUNT, m_nTotalCountOfTrafficFlow);\n    SetDlgItemInt(IDC_EDIT_RECORD_CURRENT_PAGE, m_nCurPage);\n\n    int nQueryCount = SINGLE_QUERY_COUNT;\n    if (m_nTotalCountOfTrafficFlow <= SINGLE_QUERY_COUNT)\n    {\n        nQueryCount = m_nTotalCountOfTrafficFlow ;\n        m_nTotalPage = 1;\n    }\n    else\n    {\n        m_btnNextPage.EnableWindow(TRUE);\n        m_nTotalPage = (int)ceil(m_nTotalCountOfTrafficFlow / (float)nQueryCount);\n    }\n\n    // Do find N number of traffic flow\n    if (!DoFindTrafficFolw(nQueryCount))\n    {\n        m_btnNextPage.EnableWindow(FALSE);\n        return;\n    }\n\n}\n\nvoid CTrafficFlowDlg::CleanUpResultOfLastTimeQuery()\n{\n    m_nCurPage = 0;\n    m_nTotalPage = 0;\n    m_nTotalCountOfTrafficFlow = 0;\n    m_nIndexOfQueryTrafficFlow = 0;\n\n    m_btnNextPage.EnableWindow(FALSE);\n    m_btnPreviousPage.EnableWindow(FALSE);\n    m_ctrQueryTrafficFlow.DeleteAllItems();\n\n    SetDlgItemText(IDC_EDIT_RECORD_COUNT, \"\");\n    SetDlgItemText(IDC_EDIT_RECORD_CURRENT_PAGE, \"\");\n\n    for (unsigned int i =0; i < m_vecTrafficFlow.size(); i++)\n    {\n        NET_RECORD_TRAFFIC_FLOW_STATE* pTrafficFlow = m_vecTrafficFlow[i];\n        if (NULL != pTrafficFlow)\n        {\n            delete pTrafficFlow;\n            pTrafficFlow = NULL;\n        }\n    }\n    m_vecTrafficFlow.clear();\n\n    if (0 != m_lSubscribeTrafficFlowHandle)\n    {\n        CLIENT_FindRecordClose(m_lSubscribeTrafficFlowHandle);\n    }\n}\n\nLLONG CTrafficFlowDlg::StartFindTrafficFlow()\n{\n    FIND_RECORD_TRAFFICFLOW_CONDITION stTrafficFlow = {sizeof(FIND_RECORD_TRAFFICFLOW_CONDITION)};\n    stTrafficFlow.abChannelId =TRUE;\n    stTrafficFlow.nChannelId = 0;\n    stTrafficFlow.abLane = FALSE;\n    stTrafficFlow.bStartTime= TRUE;\n    stTrafficFlow.bEndTime= TRUE;\n    CDateTimeCtrl* pCtrBeginDate = (CDateTimeCtrl*)GetDlgItem(IDC_DATETIMEPICKER_START_DATE);\n    CDateTimeCtrl* pCtrBeginTime = (CDateTimeCtrl*)GetDlgItem(IDC_DATETIMEPICKER_START_TIME);\n    CDateTimeCtrl* pCtrEndtDate = (CDateTimeCtrl*)GetDlgItem(IDC_DATETIMEPICKER_END_DATE);\n    CDateTimeCtrl* pCtrEndTime = (CDateTimeCtrl*)GetDlgItem(IDC_DATETIMEPICKER_END_TIME);\n    GetTimeFromTimeCtr(stTrafficFlow.stStartTime, pCtrBeginDate, pCtrBeginTime);\n    GetTimeFromTimeCtr(stTrafficFlow.stEndTime, pCtrEndtDate, pCtrEndTime);    \n    stTrafficFlow.bStatisticsTime = TRUE;\n\n    NET_IN_FIND_RECORD_PARAM stuFindInParam = {sizeof(NET_IN_FIND_RECORD_PARAM)};\n    stuFindInParam.emType = NET_RECORD_TRAFFICFLOW_STATE;\n    stuFindInParam.pQueryCondition = &stTrafficFlow;\n\n\n    NET_OUT_FIND_RECORD_PARAM stuFindOutParam = {sizeof(NET_OUT_FIND_RECORD_PARAM)};\n    BOOL bRet = CLIENT_FindRecord(m_lLoginHandle, &stuFindInParam, &stuFindOutParam, MAX_TIMEOUT);\n    if (!bRet)\n    {\n        MessageBox(ConvertString(\"Start query record failed!\"), ConvertString(\"Prompt\"));\n        return 0;\n    }\n    return stuFindOutParam.lFindeHandle;\n}\n\n\nint CTrafficFlowDlg::FindTotalCountOfTrafficFlow()\n{\n    NET_IN_QUEYT_RECORD_COUNT_PARAM inQueryCountParam = { sizeof(NET_IN_QUEYT_RECORD_COUNT_PARAM)};\n    inQueryCountParam.lFindeHandle =  m_lQueryTrafficFlowHandle;\n    NET_OUT_QUEYT_RECORD_COUNT_PARAM outQueryCountParam  = { sizeof(NET_OUT_QUEYT_RECORD_COUNT_PARAM) };\n\n    BOOL bRet = CLIENT_QueryRecordCount(&inQueryCountParam, &outQueryCountParam , MAX_TIMEOUT);\n    if (!bRet)\n    {\n        MessageBox(ConvertString(\"Query record count failed!\"), ConvertString(\"Prompt\"));\n        return -1;\n    }\n    if (0 == outQueryCountParam.nRecordCount)\n    {\n        MessageBox(ConvertString(\"Query zero!\"), ConvertString(\"Prompt\"));\n        return 0;\n    }\n    return outQueryCountParam.nRecordCount;\n}\n\nbool CTrafficFlowDlg::DoFindTrafficFolw( int nQueryCount )\n{\n    NET_RECORD_TRAFFIC_FLOW_STATE* pRecordList = new NET_RECORD_TRAFFIC_FLOW_STATE[nQueryCount];\n    memset(pRecordList, 0, sizeof(NET_RECORD_TRAFFIC_FLOW_STATE) * nQueryCount);\n    for (int unIndex = 0; unIndex < nQueryCount; ++unIndex)\n    {\n        pRecordList[unIndex].dwSize = sizeof(NET_RECORD_TRAFFIC_FLOW_STATE);\n    }\n\n    NET_IN_FIND_NEXT_RECORD_PARAM stuFindNextInParam =  {sizeof(NET_IN_FIND_NEXT_RECORD_PARAM)};\n    stuFindNextInParam.lFindeHandle = m_lQueryTrafficFlowHandle;\n    stuFindNextInParam.nFileCount = nQueryCount;\n\n    NET_OUT_FIND_NEXT_RECORD_PARAM stuFindNextOutParam = {sizeof(NET_OUT_FIND_NEXT_RECORD_PARAM)};\n    stuFindNextOutParam.pRecordList = pRecordList;\n    stuFindNextOutParam.nMaxRecordNum = nQueryCount;\n    BOOL bRet = CLIENT_FindNextRecord(&stuFindNextInParam, &stuFindNextOutParam, MAX_TIMEOUT);\n    if (!bRet)\n    {\n        MessageBox(ConvertString(\"Query record failed!\"), ConvertString(\"Prompt\"));\n        delete[] pRecordList;\n        return false;\n    }\n    if (0 == stuFindNextOutParam.nRetRecordNum)\n    {\n        MessageBox(ConvertString(\"Query record over!\"), ConvertString(\"Prompt\"));\n        delete[] pRecordList;\n        return false;\n    }\n\n    for (int i = 0; i < stuFindNextOutParam.nRetRecordNum; i++)\n    { \n        m_nIndexOfQueryTrafficFlow++;\n        ShowTrafficFlow(pRecordList+i, m_nIndexOfQueryTrafficFlow); \n\n        NET_RECORD_TRAFFIC_FLOW_STATE* pTrafficListInfo = new NET_RECORD_TRAFFIC_FLOW_STATE;\n        memcpy(pTrafficListInfo, pRecordList+i, sizeof(NET_RECORD_TRAFFIC_FLOW_STATE));        \n        m_vecTrafficFlow.push_back(pTrafficListInfo);\n    }\n    delete[] pRecordList;\n    return true;\n}\n\nvoid CTrafficFlowDlg::ShowTrafficFlow(NET_RECORD_TRAFFIC_FLOW_STATE* pRecordList, int nCurrnetIndex)\n{\n    if (NULL == pRecordList)\n    {\n        return;\n    }\n    CString strIndex;\n    CString strLane;\n    CString strFlow;\n    CString strAvgSpeed;\n    CString strTimePercentage;\n    CString strSpaceOccupyRate;\n\n    strIndex.Format(\"%d\", nCurrnetIndex);\n    strLane.Format(\"%d\", pRecordList->nLane);\n    strFlow.Format(\"%d\", pRecordList->nVehicles);\n    strTimePercentage.Format(\"%.1f\", pRecordList->fTimeOccupyRatio);\n    strSpaceOccupyRate.Format(\"%.1f\", pRecordList->fSpaceOccupyRatio);\n    if (pRecordList->fAverageSpeed < 0)\n    {\n        strAvgSpeed.Format(\"-\"); \n    }\n    else\n    {\n        strAvgSpeed.Format(\"%.1f\", pRecordList->fAverageSpeed);\n    }\n\n    int nCount =  m_ctrQueryTrafficFlow.GetItemCount();\n    m_ctrQueryTrafficFlow.InsertItem(LVIF_TEXT|LVIF_STATE,nCount,strIndex,0,LVIS_SELECTED,0,0);\n    m_ctrQueryTrafficFlow.SetItemText(nCount,0, strIndex);\n    m_ctrQueryTrafficFlow.SetItemText(nCount,1, strLane);\n    m_ctrQueryTrafficFlow.SetItemText(nCount,2, strFlow);\n    m_ctrQueryTrafficFlow.SetItemText(nCount,3, strAvgSpeed);\n    m_ctrQueryTrafficFlow.SetItemText(nCount,4, strTimePercentage);\n    m_ctrQueryTrafficFlow.SetItemText(nCount,5, strSpaceOccupyRate);\n}\n\nvoid CTrafficFlowDlg::OnBnClickedBtnPreviousPage()\n{\n    if(1 >= m_nCurPage)\n    {\n        return;\n    }\n\n    m_ctrQueryTrafficFlow.DeleteAllItems();\n    for (int i = 0; i < SINGLE_QUERY_COUNT; i++)\n    {\n        ShowTrafficFlow(m_vecTrafficFlow[(m_nCurPage-2)*SINGLE_QUERY_COUNT+i], (m_nCurPage-2)*SINGLE_QUERY_COUNT+i+1);\n    }\n    m_nCurPage--;\n    SetDlgItemInt(IDC_EDIT_RECORD_CURRENT_PAGE, m_nCurPage);\n    if (m_nCurPage <= 1)\n    {\n        m_btnPreviousPage.EnableWindow(FALSE);\n    }\n\n    m_btnNextPage.EnableWindow(TRUE);\n}\n\nvoid CTrafficFlowDlg::OnBnClickedBtnNextPage()\n{\n    if(0 >= m_nCurPage || m_nCurPage >= m_nTotalPage)\n    {\n        return;\n    }\n    m_ctrQueryTrafficFlow.DeleteAllItems();\n    if (m_vecTrafficFlow.size() > m_nCurPage*SINGLE_QUERY_COUNT)\n    {\n        int nRemainCount = m_vecTrafficFlow.size() - m_nCurPage*SINGLE_QUERY_COUNT;\n        int nQueryCount = nRemainCount > SINGLE_QUERY_COUNT?SINGLE_QUERY_COUNT:nRemainCount;\n        for (int i = 0; i < nQueryCount; i++)\n        {\n            ShowTrafficFlow(m_vecTrafficFlow[m_nCurPage*SINGLE_QUERY_COUNT+i], m_nCurPage*SINGLE_QUERY_COUNT+i+1);\n        }\n    }\n    else\n    {\n        int nRemainCount = m_nTotalCountOfTrafficFlow - m_nCurPage*SINGLE_QUERY_COUNT;\n        int nQueryCount = nRemainCount > SINGLE_QUERY_COUNT?SINGLE_QUERY_COUNT:nRemainCount;\n        if (!DoFindTrafficFolw(nQueryCount))\n        {\n            return;\n        }\n    } \n    m_nCurPage++;\n    SetDlgItemInt(IDC_EDIT_RECORD_CURRENT_PAGE, m_nCurPage);\n    if (m_nCurPage >= m_nTotalPage)\n    {\n        m_btnNextPage.EnableWindow(FALSE);\n    }\n    m_btnPreviousPage.EnableWindow(TRUE);\n}\n\nvoid CTrafficFlowDlg::GetTimeFromTimeCtr(NET_TIME& stTime, CDateTimeCtrl* pCtrDate, CDateTimeCtrl* pCtrTime)\n{\n    if (NULL == pCtrDate || NULL == pCtrTime)\n    {\n        return;\n    }\n\n    COleDateTime tmDate;\n    COleDateTime tmTime;\n    pCtrDate->GetTime(tmDate);\n    pCtrTime->GetTime(tmTime);\n\n    stTime.dwYear = tmDate.GetYear();\n    stTime.dwMonth = tmDate.GetMonth();\n    stTime.dwDay = tmDate.GetDay();\n    stTime.dwHour = tmTime.GetHour();\n    stTime.dwMinute = tmTime.GetMinute();\n    stTime.dwSecond = tmTime.GetSecond();\n}\n\n\n\nbool CTrafficFlowDlg::IsTimeCorrent()\n{\n    CDateTimeCtrl* pCtrBeginDate = (CDateTimeCtrl*)GetDlgItem(IDC_DATETIMEPICKER_START_DATE);\n    CDateTimeCtrl* pCtrBeginTime = (CDateTimeCtrl*)GetDlgItem(IDC_DATETIMEPICKER_START_TIME);\n    CDateTimeCtrl* pCtrEndtDate = (CDateTimeCtrl*)GetDlgItem(IDC_DATETIMEPICKER_END_DATE);\n    CDateTimeCtrl* pCtrEndTime = (CDateTimeCtrl*)GetDlgItem(IDC_DATETIMEPICKER_END_TIME);\n\n    COleDateTime beginDate;\n    COleDateTime beginTime;\n    COleDateTime endDate;\n    COleDateTime endTime;\n    pCtrBeginDate->GetTime(beginDate);\n    pCtrBeginTime->GetTime(beginTime);\n    pCtrEndtDate->GetTime(endDate);\n    pCtrEndTime->GetTime(endTime);\n\n    if (endDate >= beginDate)\n    {\n        if (endDate == beginDate)\n        {\n            if (endTime < beginTime)\n            {\n                return false;\n            }\n        }\n    }\n    else\n    {\n        return false;\n    }\n    return true;\n}\n\nvoid CTrafficFlowDlg::OnDtnDatetimechangeDatetimepickerStartDate(NMHDR *pNMHDR, LRESULT *pResult)\n{\n    LPNMDATETIMECHANGE pDTChange = reinterpret_cast<LPNMDATETIMECHANGE>(pNMHDR);\n    if (2000 > pDTChange->st.wYear || 2038 < pDTChange->st.wYear)\n    {\n        MessageBox(ConvertString(\"The time range is from 2000 to 2038.Please input again!\"), ConvertString(\"Prompt\"));\n        COleDateTime tmDate  = COleDateTime::GetCurrentTime();\n        ((CDateTimeCtrl*)GetDlgItem(IDC_DATETIMEPICKER_START_DATE))->SetTime(tmDate);\n\n    }   \n    *pResult = 0;\n}\n\nvoid CTrafficFlowDlg::OnDtnDatetimechangeDatetimepickerEndDate(NMHDR *pNMHDR, LRESULT *pResult)\n{\n    LPNMDATETIMECHANGE pDTChange = reinterpret_cast<LPNMDATETIMECHANGE>(pNMHDR);\n    if (2000 > pDTChange->st.wYear || 2038 < pDTChange->st.wYear)\n    {\n        MessageBox(ConvertString(\"The time range is from 2000 to 2038.Please input again!\"), ConvertString(\"Prompt\"));\n        COleDateTime tmDate  = COleDateTime::GetCurrentTime();\n        ((CDateTimeCtrl*)GetDlgItem(IDC_DATETIMEPICKER_END_DATE))->SetTime(tmDate);\n\n    }   \n    *pResult = 0;\n}\n","size_bytes":21453},"public/js/pages/dvr-monitor.js":{"content":"// =================================================================\n// DVR/NVR MONITOR - Interface de monitoramento de dispositivos\n// =================================================================\n\nlet dispositivosCache = [];\nlet logsOffset = 0;\nconst logsLimit = 100;\n\nexport function initDVRMonitorPage() {\n    carregarLojas();\n    carregarDispositivos();\n    \n    document.getElementById('btn-add-dispositivo').addEventListener('click', () => {\n        limparFormularioDispositivo();\n        new bootstrap.Modal(document.getElementById('modal-dispositivo')).show();\n    });\n    \n    document.getElementById('btn-salvar-dispositivo').addEventListener('click', salvarDispositivo);\n    \n    document.getElementById('btn-filtrar-dispositivos').addEventListener('click', () => carregarDispositivos(true));\n    document.getElementById('btn-limpar-filtros-dispositivos').addEventListener('click', () => {\n        document.getElementById('filtro-loja-dispositivos').value = '';\n        document.getElementById('filtro-status-dispositivos').value = '';\n        carregarDispositivos();\n    });\n    \n    document.getElementById('logs-tab').addEventListener('click', () => {\n        carregarDispositivos();\n        logsOffset = 0;\n        carregarLogs();\n    });\n    \n    document.getElementById('arquivos-tab').addEventListener('click', () => {\n        carregarDispositivos();\n        carregarArquivos();\n    });\n    \n    document.getElementById('btn-filtrar-logs').addEventListener('click', () => {\n        logsOffset = 0;\n        carregarLogs();\n    });\n    \n    document.getElementById('btn-prev-logs').addEventListener('click', () => {\n        if (logsOffset >= logsLimit) {\n            logsOffset -= logsLimit;\n            carregarLogs();\n        }\n    });\n    \n    document.getElementById('btn-next-logs').addEventListener('click', () => {\n        logsOffset += logsLimit;\n        carregarLogs();\n    });\n    \n    document.getElementById('btn-filtrar-arquivos').addEventListener('click', carregarArquivos);\n    \n    document.getElementById('btn-upload-arquivo').addEventListener('click', () => {\n        carregarDispositivos();\n        new bootstrap.Modal(document.getElementById('modal-upload')).show();\n    });\n    \n    document.getElementById('btn-confirmar-upload').addEventListener('click', fazerUpload);\n}\n\nasync function carregarLojas() {\n    try {\n        const response = await fetch('/api/lojas');\n        if (!response.ok) return;\n        \n        const lojas = await response.json();\n        const selects = [\n            document.getElementById('dispositivo-loja'),\n            document.getElementById('filtro-dvr-logs'),\n            document.getElementById('filtro-dvr-arquivos'),\n            document.getElementById('upload-dvr')\n        ];\n        \n        selects.forEach(select => {\n            if (select && select.id === 'dispositivo-loja') {\n                select.innerHTML = '<option value=\"\">Selecione uma loja</option>';\n                lojas.forEach(loja => {\n                    const option = document.createElement('option');\n                    option.value = loja.id;\n                    option.textContent = loja.nome;\n                    option.dataset.lojaNome = loja.nome;\n                    select.appendChild(option);\n                });\n            }\n        });\n    } catch (error) {\n        console.error('Erro ao carregar lojas:', error);\n    }\n}\n\nasync function carregarDispositivos(aplicarFiltros = false) {\n    try {\n        let url = '/api/dvr/dispositivos';\n        \n        if (aplicarFiltros) {\n            const params = new URLSearchParams();\n            const loja = document.getElementById('filtro-loja-dispositivos').value.trim();\n            const status = document.getElementById('filtro-status-dispositivos').value;\n            \n            if (loja) params.append('loja_nome', loja);\n            if (status) params.append('status', status);\n            \n            if (params.toString()) {\n                url += '?' + params.toString();\n            }\n        }\n        \n        const response = await fetch(url);\n        if (!response.ok) throw new Error('Erro ao carregar dispositivos');\n        \n        const data = await response.json();\n        dispositivosCache = data.data || [];\n        \n        renderizarDispositivos(dispositivosCache);\n        atualizarSelectsDispositivos(dispositivosCache);\n    } catch (error) {\n        console.error('Erro ao carregar dispositivos:', error);\n        mostrarAlerta('Erro ao carregar dispositivos', 'danger');\n    }\n}\n\nfunction renderizarDispositivos(dispositivos) {\n    const tbody = document.getElementById('tabela-dispositivos');\n    \n    if (dispositivos.length === 0) {\n        tbody.innerHTML = '<tr><td colspan=\"8\" class=\"text-center\">Nenhum dispositivo cadastrado</td></tr>';\n        return;\n    }\n    \n    tbody.innerHTML = dispositivos.map(d => {\n        const statusClass = d.status === 'online' ? 'success' : 'secondary';\n        const statusIcon = d.status === 'online' ? 'circle-fill' : 'circle';\n        const ultimaConexao = d.ultima_conexao ? new Date(d.ultima_conexao).toLocaleString('pt-BR') : 'Nunca';\n        \n        return `\n            <tr>\n                <td>${escapeHtml(d.nome)}</td>\n                <td>${escapeHtml(d.loja_nome || '-')}</td>\n                <td>${escapeHtml(d.ip_address)}:${d.porta}</td>\n                <td>${escapeHtml(d.modelo || '-')}</td>\n                <td>${d.canais_total}</td>\n                <td><span class=\"badge bg-${statusClass}\"><i class=\"bi bi-${statusIcon}\"></i> ${d.status}</span></td>\n                <td>${ultimaConexao}</td>\n                <td>\n                    <button class=\"btn btn-sm btn-primary\" onclick=\"editarDispositivo(${d.id})\">\n                        <i class=\"bi bi-pencil\"></i> Editar\n                    </button>\n                    <button class=\"btn btn-sm btn-danger\" onclick=\"excluirDispositivo(${d.id}, '${escapeHtml(d.nome)}')\">\n                        <i class=\"bi bi-trash\"></i> Excluir\n                    </button>\n                </td>\n            </tr>\n        `;\n    }).join('');\n}\n\nfunction atualizarSelectsDispositivos(dispositivos) {\n    const selectLogs = document.getElementById('filtro-dvr-logs');\n    const selectArquivos = document.getElementById('filtro-dvr-arquivos');\n    const selectUpload = document.getElementById('upload-dvr');\n    \n    [selectLogs, selectArquivos, selectUpload].forEach(select => {\n        if (!select) return;\n        \n        const valorAtual = select.value;\n        const isUpload = select.id === 'upload-dvr';\n        \n        select.innerHTML = isUpload ? '<option value=\"\">Selecione um dispositivo</option>' : '<option value=\"\">Todos os dispositivos</option>';\n        \n        dispositivos.forEach(d => {\n            const option = document.createElement('option');\n            option.value = d.id;\n            option.textContent = `${d.nome} - ${d.loja_nome || 'Sem loja'}`;\n            option.dataset.dvrNome = d.nome;\n            option.dataset.lojaNome = d.loja_nome || '';\n            select.appendChild(option);\n        });\n        \n        if (valorAtual) select.value = valorAtual;\n    });\n}\n\nfunction limparFormularioDispositivo() {\n    document.getElementById('dispositivo-id').value = '';\n    document.getElementById('dispositivo-nome').value = '';\n    document.getElementById('dispositivo-loja').value = '';\n    document.getElementById('dispositivo-ip').value = '';\n    document.getElementById('dispositivo-porta').value = '37777';\n    document.getElementById('dispositivo-usuario').value = '';\n    document.getElementById('dispositivo-modelo').value = '';\n    document.getElementById('dispositivo-canais').value = '0';\n    document.getElementById('dispositivo-status').value = 'offline';\n    document.getElementById('dispositivo-observacoes').value = '';\n}\n\nwindow.editarDispositivo = async function(id) {\n    try {\n        const response = await fetch(`/api/dvr/dispositivos/${id}`);\n        if (!response.ok) throw new Error('Dispositivo não encontrado');\n        \n        const data = await response.json();\n        const d = data.data;\n        \n        document.getElementById('dispositivo-id').value = d.id;\n        document.getElementById('dispositivo-nome').value = d.nome;\n        document.getElementById('dispositivo-loja').value = d.loja_id || '';\n        document.getElementById('dispositivo-ip').value = d.ip_address;\n        document.getElementById('dispositivo-porta').value = d.porta;\n        document.getElementById('dispositivo-usuario').value = d.usuario || '';\n        document.getElementById('dispositivo-modelo').value = d.modelo || '';\n        document.getElementById('dispositivo-canais').value = d.canais_total;\n        document.getElementById('dispositivo-status').value = d.status;\n        document.getElementById('dispositivo-observacoes').value = d.observacoes || '';\n        \n        new bootstrap.Modal(document.getElementById('modal-dispositivo')).show();\n    } catch (error) {\n        console.error('Erro ao carregar dispositivo:', error);\n        mostrarAlerta('Erro ao carregar dispositivo', 'danger');\n    }\n};\n\nasync function salvarDispositivo() {\n    const id = document.getElementById('dispositivo-id').value;\n    const lojaSelect = document.getElementById('dispositivo-loja');\n    const lojaOption = lojaSelect.options[lojaSelect.selectedIndex];\n    \n    const dados = {\n        nome: document.getElementById('dispositivo-nome').value.trim(),\n        loja_id: lojaSelect.value || null,\n        loja_nome: lojaOption ? lojaOption.dataset.lojaNome : null,\n        ip_address: document.getElementById('dispositivo-ip').value.trim(),\n        porta: parseInt(document.getElementById('dispositivo-porta').value) || 37777,\n        usuario: document.getElementById('dispositivo-usuario').value.trim(),\n        modelo: document.getElementById('dispositivo-modelo').value.trim(),\n        canais_total: parseInt(document.getElementById('dispositivo-canais').value) || 0,\n        status: document.getElementById('dispositivo-status').value,\n        observacoes: document.getElementById('dispositivo-observacoes').value.trim()\n    };\n    \n    if (!dados.nome || !dados.ip_address) {\n        mostrarAlerta('Nome e IP são obrigatórios', 'warning');\n        return;\n    }\n    \n    try {\n        const url = id ? `/api/dvr/dispositivos/${id}` : '/api/dvr/dispositivos';\n        const method = id ? 'PUT' : 'POST';\n        \n        const response = await fetch(url, {\n            method,\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(dados)\n        });\n        \n        if (!response.ok) {\n            const error = await response.json();\n            throw new Error(error.error || 'Erro ao salvar');\n        }\n        \n        bootstrap.Modal.getInstance(document.getElementById('modal-dispositivo')).hide();\n        mostrarAlerta(id ? 'Dispositivo atualizado com sucesso' : 'Dispositivo criado com sucesso', 'success');\n        carregarDispositivos();\n    } catch (error) {\n        console.error('Erro ao salvar dispositivo:', error);\n        mostrarAlerta(error.message || 'Erro ao salvar dispositivo', 'danger');\n    }\n}\n\nwindow.excluirDispositivo = async function(id, nome) {\n    if (!confirm(`Deseja realmente excluir o dispositivo \"${nome}\"?\\n\\nIsso também excluirá todos os logs e arquivos associados.`)) {\n        return;\n    }\n    \n    try {\n        const response = await fetch(`/api/dvr/dispositivos/${id}`, {\n            method: 'DELETE'\n        });\n        \n        if (!response.ok) throw new Error('Erro ao excluir');\n        \n        mostrarAlerta('Dispositivo excluído com sucesso', 'success');\n        carregarDispositivos();\n    } catch (error) {\n        console.error('Erro ao excluir dispositivo:', error);\n        mostrarAlerta('Erro ao excluir dispositivo', 'danger');\n    }\n};\n\nasync function carregarLogs() {\n    try {\n        const params = new URLSearchParams();\n        \n        const dvrId = document.getElementById('filtro-dvr-logs').value;\n        const tipoEvento = document.getElementById('filtro-tipo-evento').value;\n        const severidade = document.getElementById('filtro-severidade').value;\n        const dataInicio = document.getElementById('filtro-data-inicio-logs').value;\n        const dataFim = document.getElementById('filtro-data-fim-logs').value;\n        \n        if (dvrId) params.append('dvr_id', dvrId);\n        if (tipoEvento) params.append('tipo_evento', tipoEvento);\n        if (severidade) params.append('severidade', severidade);\n        if (dataInicio) params.append('data_inicio', dataInicio);\n        if (dataFim) params.append('data_fim', dataFim);\n        params.append('limit', logsLimit);\n        params.append('offset', logsOffset);\n        \n        const response = await fetch(`/api/dvr/logs?${params.toString()}`);\n        if (!response.ok) throw new Error('Erro ao carregar logs');\n        \n        const data = await response.json();\n        renderizarLogs(data.data || []);\n        \n        document.getElementById('btn-prev-logs').disabled = logsOffset === 0;\n        document.getElementById('btn-next-logs').disabled = (data.data || []).length < logsLimit;\n        \n        const inicio = logsOffset + 1;\n        const fim = logsOffset + (data.data || []).length;\n        document.getElementById('info-paginacao-logs').textContent = `Mostrando ${inicio}-${fim} logs`;\n    } catch (error) {\n        console.error('Erro ao carregar logs:', error);\n        mostrarAlerta('Erro ao carregar logs', 'danger');\n    }\n}\n\nfunction renderizarLogs(logs) {\n    const tbody = document.getElementById('tabela-logs');\n    \n    if (logs.length === 0) {\n        tbody.innerHTML = '<tr><td colspan=\"8\" class=\"text-center\">Nenhum log encontrado</td></tr>';\n        return;\n    }\n    \n    tbody.innerHTML = logs.map(log => {\n        const dataHora = new Date(log.data_hora).toLocaleString('pt-BR');\n        const severidadeClass = {\n            'info': 'info',\n            'warning': 'warning',\n            'error': 'danger',\n            'critical': 'danger'\n        }[log.severidade] || 'secondary';\n        \n        return `\n            <tr>\n                <td>${dataHora}</td>\n                <td>${escapeHtml(log.dvr_nome || '-')}</td>\n                <td>${escapeHtml(log.loja_nome || '-')}</td>\n                <td><span class=\"badge bg-secondary\">${escapeHtml(log.tipo_evento)}</span></td>\n                <td>${escapeHtml(log.descricao || '-')}</td>\n                <td>${log.canal || '-'}</td>\n                <td><span class=\"badge bg-${severidadeClass}\">${log.severidade}</span></td>\n                <td>\n                    <button class=\"btn btn-sm btn-outline-danger\" onclick=\"excluirLog(${log.id})\">\n                        <i class=\"bi bi-trash\"></i>\n                    </button>\n                </td>\n            </tr>\n        `;\n    }).join('');\n}\n\nwindow.excluirLog = async function(id) {\n    if (!confirm('Deseja realmente excluir este log?')) return;\n    \n    try {\n        const response = await fetch(`/api/dvr/logs/${id}`, { method: 'DELETE' });\n        if (!response.ok) throw new Error('Erro ao excluir');\n        \n        mostrarAlerta('Log excluído com sucesso', 'success');\n        carregarLogs();\n    } catch (error) {\n        console.error('Erro ao excluir log:', error);\n        mostrarAlerta('Erro ao excluir log', 'danger');\n    }\n};\n\nasync function carregarArquivos() {\n    try {\n        const params = new URLSearchParams();\n        \n        const dvrId = document.getElementById('filtro-dvr-arquivos').value;\n        const tipoArquivo = document.getElementById('filtro-tipo-arquivo').value;\n        const dataInicio = document.getElementById('filtro-data-inicio-arquivos').value;\n        const dataFim = document.getElementById('filtro-data-fim-arquivos').value;\n        \n        if (dvrId) params.append('dvr_id', dvrId);\n        if (tipoArquivo) params.append('tipo_arquivo', tipoArquivo);\n        if (dataInicio) params.append('data_inicio', dataInicio);\n        if (dataFim) params.append('data_fim', dataFim);\n        \n        const response = await fetch(`/api/dvr/arquivos?${params.toString()}`);\n        if (!response.ok) throw new Error('Erro ao carregar arquivos');\n        \n        const data = await response.json();\n        renderizarArquivos(data.data || []);\n    } catch (error) {\n        console.error('Erro ao carregar arquivos:', error);\n        mostrarAlerta('Erro ao carregar arquivos', 'danger');\n    }\n}\n\nfunction renderizarArquivos(arquivos) {\n    const tbody = document.getElementById('tabela-arquivos');\n    \n    if (arquivos.length === 0) {\n        tbody.innerHTML = '<tr><td colspan=\"8\" class=\"text-center\">Nenhum arquivo encontrado</td></tr>';\n        return;\n    }\n    \n    tbody.innerHTML = arquivos.map(arq => {\n        const dataGeracao = arq.data_geracao ? new Date(arq.data_geracao).toLocaleString('pt-BR') : '-';\n        const tamanho = formatarTamanho(arq.tamanho_bytes);\n        \n        return `\n            <tr>\n                <td>${escapeHtml(arq.nome_arquivo)}</td>\n                <td>${escapeHtml(arq.dvr_nome || '-')}</td>\n                <td>${escapeHtml(arq.loja_nome || '-')}</td>\n                <td><span class=\"badge bg-info\">${escapeHtml(arq.tipo_arquivo)}</span></td>\n                <td>${tamanho}</td>\n                <td>${dataGeracao}</td>\n                <td>${escapeHtml(arq.uploaded_by || '-')}</td>\n                <td>\n                    <button class=\"btn btn-sm btn-success\" onclick=\"downloadArquivo(${arq.id}, '${escapeHtml(arq.nome_arquivo)}')\">\n                        <i class=\"bi bi-download\"></i> Download\n                    </button>\n                    <button class=\"btn btn-sm btn-outline-danger\" onclick=\"excluirArquivo(${arq.id}, '${escapeHtml(arq.nome_arquivo)}')\">\n                        <i class=\"bi bi-trash\"></i>\n                    </button>\n                </td>\n            </tr>\n        `;\n    }).join('');\n}\n\nwindow.downloadArquivo = function(id, nome) {\n    window.location.href = `/api/dvr/arquivos/${id}/download`;\n    mostrarAlerta(`Iniciando download de \"${nome}\"...`, 'info');\n};\n\nwindow.excluirArquivo = async function(id, nome) {\n    if (!confirm(`Deseja realmente excluir o arquivo \"${nome}\"?`)) return;\n    \n    try {\n        const response = await fetch(`/api/dvr/arquivos/${id}`, { method: 'DELETE' });\n        if (!response.ok) throw new Error('Erro ao excluir');\n        \n        mostrarAlerta('Arquivo excluído com sucesso', 'success');\n        carregarArquivos();\n    } catch (error) {\n        console.error('Erro ao excluir arquivo:', error);\n        mostrarAlerta('Erro ao excluir arquivo', 'danger');\n    }\n};\n\nasync function fazerUpload() {\n    const dvrSelect = document.getElementById('upload-dvr');\n    const dvrOption = dvrSelect.options[dvrSelect.selectedIndex];\n    const arquivoInput = document.getElementById('upload-arquivo');\n    \n    if (!dvrSelect.value || !arquivoInput.files[0]) {\n        mostrarAlerta('Dispositivo e arquivo são obrigatórios', 'warning');\n        return;\n    }\n    \n    const formData = new FormData();\n    formData.append('arquivo', arquivoInput.files[0]);\n    formData.append('dvr_id', dvrSelect.value);\n    formData.append('dvr_nome', dvrOption.dataset.dvrNome);\n    formData.append('loja_nome', dvrOption.dataset.lojaNome);\n    \n    const canal = document.getElementById('upload-canal').value;\n    const descricao = document.getElementById('upload-descricao').value;\n    \n    if (canal) formData.append('canal', canal);\n    if (descricao) formData.append('descricao', descricao);\n    \n    try {\n        const btnUpload = document.getElementById('btn-confirmar-upload');\n        btnUpload.disabled = true;\n        btnUpload.innerHTML = '<span class=\"spinner-border spinner-border-sm\"></span> Enviando...';\n        \n        const response = await fetch('/api/dvr/arquivos', {\n            method: 'POST',\n            body: formData\n        });\n        \n        if (!response.ok) {\n            const error = await response.json();\n            throw new Error(error.error || 'Erro ao fazer upload');\n        }\n        \n        bootstrap.Modal.getInstance(document.getElementById('modal-upload')).hide();\n        mostrarAlerta('Arquivo enviado com sucesso', 'success');\n        carregarArquivos();\n        \n        document.getElementById('form-upload').reset();\n    } catch (error) {\n        console.error('Erro ao fazer upload:', error);\n        mostrarAlerta(error.message || 'Erro ao fazer upload', 'danger');\n    } finally {\n        const btnUpload = document.getElementById('btn-confirmar-upload');\n        btnUpload.disabled = false;\n        btnUpload.innerHTML = '<i class=\"bi bi-cloud-upload\"></i> Fazer Upload';\n    }\n}\n\nfunction formatarTamanho(bytes) {\n    if (!bytes) return '0 B';\n    const k = 1024;\n    const sizes = ['B', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n}\n\nfunction escapeHtml(text) {\n    if (!text) return '';\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n}\n\nfunction mostrarAlerta(mensagem, tipo = 'info') {\n    const alertaDiv = document.createElement('div');\n    alertaDiv.className = `alert alert-${tipo} alert-dismissible fade show position-fixed top-0 start-50 translate-middle-x mt-3`;\n    alertaDiv.style.zIndex = '9999';\n    alertaDiv.innerHTML = `\n        ${mensagem}\n        <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\"></button>\n    `;\n    document.body.appendChild(alertaDiv);\n    \n    setTimeout(() => {\n        alertaDiv.remove();\n    }, 5000);\n}\n","size_bytes":21648},"bin/Demo/MfcDemo/19.MasterSlaveSensor/PtzScreen.cpp":{"content":"// PtzScreen.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"MasterSlaverSensor.h\"\n#include \"PtzScreen.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CPtzScreen\n\nCPtzScreen::CPtzScreen()\n{\n\tm_pMessageProc = NULL;\n\tm_dwMessageUser = 0;\n\tm_pGetParams = NULL;\n\tm_dwGetParams = 0;\n\tm_pSetParams = NULL;\n\tm_dwSetParams = 0;\n\tm_pRectEventFunc = NULL;\n\tm_dwRectEvent = 0;\n\tm_nID = 0;\n}\n\nCPtzScreen::~CPtzScreen()\n{\n\t\n}\nvoid  CPtzScreen::SetActiveWnd(int nIndex,BOOL bRepaint)\n{\n\tif(nIndex >= 0 && nIndex < PRIVATE_MAX_CHANNUM)\n\t{\n\t\tSetActivePage(&m_wndVideo[nIndex],bRepaint);\n\t}\n}\nCWnd* CPtzScreen::GetPage(int nIndex)\n{\n\tif (nIndex >= 0 && nIndex < PRIVATE_MAX_CHANNUM)\n\t{\n\t\treturn &m_wndVideo[nIndex];\n\t}\n\t\n\treturn NULL;\n}\nint CPtzScreen::SetShowPlayWin(int nMain, int nSub)\n{\n\tif (nSub < 0 || nSub > PRIVATE_MAX_CHANNUM)\n\t{\n\t\tnSub = 0;\n\t}\n\n\tint nNum = 16;\n\tint nBegin = 0;\n\tswitch(nMain) \n\t{\n\tcase SPLIT1:\n\t\tnNum = 1;\n\t\tnBegin = nSub;\n\t\tbreak;\n\tcase SPLIT4:\n\t\tnNum = 4;\n\t\tif (nSub >= 12)\n\t\t{\n\t\t\tnBegin = 12;\n\t\t}\n\t\telse if (nSub >= 8)\n\t\t{\n\t\t\tnBegin = 8;\n\t\t}\n\t\telse if (nSub >= 4)\n\t\t{\n\t\t\tnBegin = 4;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnBegin = 0;\n\t\t}\n\n\t\tbreak;\n\tcase SPLIT9:\n\t\tnNum = 9;\n\t\tif (nSub >= 10)\n\t\t{\n\t\t\tnBegin = 7;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnBegin = 0;\n\t\t}\n\t\tbreak;\n\tcase SPLIT16:\n\t\tnNum = 16;\n\t\tnBegin = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tm_bMultiScreen = TRUE;\n\tCList<CWnd*, CWnd*> templist;\n\n\tPOSITION pos = m_PageList.GetHeadPosition();\n\twhile(pos != NULL)\n\t{\n\t\tCWnd* pWnd = m_PageList.GetNext(pos);\n\t\tif (pWnd)\n\t\t{\n\t\t\ttemplist.AddTail(pWnd);\n\t\t}\n\t}\n\n\tm_PageList.RemoveAll();\n\t\n\tfor(int i=nBegin; i < (nBegin+nNum); i++)\n\t{\n\t\tAddPage(&m_wndVideo[i], TRUE);\n\t}\n\n\tSetActivePage(&m_wndVideo[nSub], TRUE);\n\n\tpos = templist.GetHeadPosition();\n\twhile(pos != NULL)\n\t{\n\t\tCWnd* pWnd = templist.GetNext(pos);\n\t\tif (pWnd)\n\t\t{\n\t\t\tpWnd->ShowWindow(SW_HIDE);\n\t\t}\n\t}\n\n\ttemplist.RemoveAll();\n\n\treturn m_PageList.GetCount();\n}\nvoid CPtzScreen::SetCallBack(OnRectEventFunc cbEventParams,DWORD dwRectEventParams,int nID)\n{\n\tm_pRectEventFunc = cbEventParams;\n\tm_dwRectEvent = dwRectEventParams;\n\tm_nID = nID;\n}\nBEGIN_MESSAGE_MAP(CPtzScreen, CWnd)\n\t//{{AFX_MSG_MAP(CPtzScreen)\n\tON_WM_LBUTTONDOWN()\n\tON_WM_LBUTTONUP()\n\tON_WM_ACTIVATE()\n\tON_WM_CREATE()\n\tON_WM_DESTROY()\n\tON_WM_ACTIVATEAPP()\n\tON_WM_ICONERASEBKGND()\n\tON_WM_ASKCBFORMATNAME()\n\tON_WM_ERASEBKGND()\n\tON_WM_CANCELMODE()\n\tON_WM_PAINT()\n\tON_WM_CAPTURECHANGED()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n\n/////////////////////////////////////////////////////////////////////////////\n// CPtzScreen message handlers\n\nvoid CPtzScreen::OnLButtonDown(UINT nFlags, CPoint point) \n{\n\t// TODO: Add your message handler code here and/or call default\n\tCWnd::OnLButtonDown(nFlags, point);\n}\n\nvoid CPtzScreen::OnLButtonUp(UINT nFlags, CPoint point) \n{\n\t// TODO: Add your message handler code here and/or call default\n\t\n\tCWnd::OnLButtonUp(nFlags, point);\n}\n\nvoid CPtzScreen::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized) \n{\n\tCWnd::OnActivate(nState, pWndOther, bMinimized);\n\t\n\t// TODO: Add your message handler code here\n\t\n}\n\nint CPtzScreen::OnCreate(LPCREATESTRUCT lpCreateStruct) \n{\n\tif (CWnd::OnCreate(lpCreateStruct) == -1)\n\t\treturn -1;\n\t\n\t// TODO: Add your specialized creation code here\n\tfor(int i = 0; i < PRIVATE_MAX_CHANNUM; i++)\n\t{\n\t\tm_wndVideo[i].Create(\n\t\t\tNULL, \n\t\t\tNULL, \n\t\t\tWS_VISIBLE | WS_CHILD,\n\t\t\tCRect(0, 0, 0, 0),\n\t\t\tthis,\n\t\t\t1979,\n\t\t\tNULL);\n\t\t\n\t\tm_wndVideo[i].SetWinID(i);\n\t\t\n\t\tAddPage(&m_wndVideo[i]);\n\t}\n\t\n\tSetActivePage(&m_wndVideo[0], TRUE);\n\tSetDrawActivePage(TRUE, RGB(248,5,182), RGB(248,5,182));\n\t\n\treturn 0;\t\n\treturn 0;\n}\n\nvoid CPtzScreen::OnDestroy() \n{\n\tCWnd::OnDestroy();\n\t\n\t// TODO: Add your message handler code here\n\tfor(int i=0; i < PRIVATE_MAX_CHANNUM; i++)\n\t{\n\t\tm_wndVideo[0].DestroyWindow();\n\t}\n}\n#if _MSC_VER > 1300\nvoid CPtzScreen::OnActivateApp(BOOL bActive, DWORD hTask) \n#else\nvoid CPtzScreen::OnActivateApp(BOOL bActive, HTASK hTask)\n#endif\n{\n\tCWnd::OnActivateApp(bActive, hTask);\n\t\n\t// TODO: Add your message handler code here\n\t\n}\n\nvoid CPtzScreen::OnIconEraseBkgnd(CDC* pDC) \n{\n\t// TODO: Add your message handler code here and/or call default\n\t\n\tCWnd::OnIconEraseBkgnd(pDC);\n}\n\nvoid CPtzScreen::OnAskCbFormatName(UINT nMaxCount, LPTSTR lpszString) \n{\n\t// TODO: Add your message handler code here and/or call default\n\n\tCWnd::OnAskCbFormatName(nMaxCount, lpszString);\n}\n\nBOOL CPtzScreen::OnEraseBkgnd(CDC* pDC) \n{\n\t// TODO: Add your message handler code here and/or call default\n\tCRect rt;\n\tGetClientRect(&rt);\n\tCBrush br;\n\tbr.CreateSolidBrush(RGB(192,192,192));\n\tpDC->FillRect(&rt,&br);\n\t\n\treturn TRUE;\n\t//return CWnd::OnEraseBkgnd(pDC);\n}\n\nvoid CPtzScreen::OnCancelMode() \n{\n\tCWnd::OnCancelMode();\n\t\n\t// TODO: Add your message handler code here\n\t\n}\n\nvoid CPtzScreen::OnPaint() \n{\n\tCPaintDC dc(this); // device context for painting\n\t\n\t// TODO: Add your message handler code here\n\tUpdateWnd();\n\t// Do not call CWnd::OnPaint() for painting messages\n}\n\nvoid CPtzScreen::OnCaptureChanged(CWnd *pWnd) \n{\n\t// TODO: Add your message handler code here\n\t\n\tCWnd::OnCaptureChanged(pWnd);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":5524},"bin/Demo/MfcDemo/00.DevInit/LibQREncode/split.c":{"content":"/*\n * qrencode - QR Code encoder\n *\n * Input data splitter.\n * Copyright (C) 2006-2011 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * The following data / specifications are taken from\n * \"Two dimensional symbol -- QR-code -- Basic Specification\" (JIS X0510:2004)\n *  or\n * \"Automatic identification and data capture techniques --\n *  QR Code 2005 bar code symbology specification\" (ISO/IEC 18004:2006)\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#if HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include \"qrencode.h\"\n#include \"qrinput.h\"\n#include \"qrspec.h\"\n#include \"split.h\"\n\n#define isdigit(__c__) ((unsigned char)((signed char)(__c__) - '0') < 10)\n#define isalnum(__c__) (QRinput_lookAnTable(__c__) >= 0)\n\n#if !HAVE_STRDUP\n#undef strdup\nchar *strdup(const char *s)\n{\n\tsize_t len = strlen(s) + 1;\n\tvoid *new = malloc(len);\n\tif(new == NULL) return NULL;\n\treturn (char *)memcpy(new, s, len);\n}\n#endif\n\nstatic QRencodeMode Split_identifyMode(const char *string, QRencodeMode hint)\n{\n\tunsigned char c, d;\n\tunsigned int word;\n\n\tc = string[0];\n\n\tif(c == '\\0') return QR_MODE_NUL;\n\tif(isdigit(c)) {\n\t\treturn QR_MODE_NUM;\n\t} else if(isalnum(c)) {\n\t\treturn QR_MODE_AN;\n\t} else if(hint == QR_MODE_KANJI) {\n\t\td = string[1];\n\t\tif(d != '\\0') {\n\t\t\tword = ((unsigned int)c << 8) | d;\n\t\t\tif((word >= 0x8140 && word <= 0x9ffc) || (word >= 0xe040 && word <= 0xebbf)) {\n\t\t\t\treturn QR_MODE_KANJI;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn QR_MODE_8;\n}\n\nstatic int Split_eatNum(const char *string, QRinput *input, QRencodeMode hint);\nstatic int Split_eatAn(const char *string, QRinput *input, QRencodeMode hint);\nstatic int Split_eat8(const char *string, QRinput *input, QRencodeMode hint);\nstatic int Split_eatKanji(const char *string, QRinput *input, QRencodeMode hint);\n\nstatic int Split_eatNum(const char *string, QRinput *input,QRencodeMode hint)\n{\n\tconst char *p;\n\tint ret;\n\tint run;\n\tint dif;\n\tint ln;\n\tQRencodeMode mode;\n\n\tln = QRspec_lengthIndicator(QR_MODE_NUM, input->version);\n\n\tp = string;\n\twhile(isdigit(*p)) {\n\t\tp++;\n\t}\n\trun = p - string;\n\tmode = Split_identifyMode(p, hint);\n\tif(mode == QR_MODE_8) {\n\t\tdif = QRinput_estimateBitsModeNum(run) + 4 + ln\n\t\t\t+ QRinput_estimateBitsMode8(1) /* + 4 + l8 */\n\t\t\t- QRinput_estimateBitsMode8(run + 1) /* - 4 - l8 */;\n\t\tif(dif > 0) {\n\t\t\treturn Split_eat8(string, input, hint);\n\t\t}\n\t}\n\tif(mode == QR_MODE_AN) {\n\t\tdif = QRinput_estimateBitsModeNum(run) + 4 + ln\n\t\t\t+ QRinput_estimateBitsModeAn(1) /* + 4 + la */\n\t\t\t- QRinput_estimateBitsModeAn(run + 1) /* - 4 - la */;\n\t\tif(dif > 0) {\n\t\t\treturn Split_eatAn(string, input, hint);\n\t\t}\n\t}\n\n\tret = QRinput_append(input, QR_MODE_NUM, run, (unsigned char *)string);\n\tif(ret < 0) return -1;\n\n\treturn run;\n}\n\nstatic int Split_eatAn(const char *string, QRinput *input, QRencodeMode hint)\n{\n\tconst char *p, *q;\n\tint ret;\n\tint run;\n\tint dif;\n\tint la, ln;\n\n\tla = QRspec_lengthIndicator(QR_MODE_AN, input->version);\n\tln = QRspec_lengthIndicator(QR_MODE_NUM, input->version);\n\n\tp = string;\n\twhile(isalnum(*p)) {\n\t\tif(isdigit(*p)) {\n\t\t\tq = p;\n\t\t\twhile(isdigit(*q)) {\n\t\t\t\tq++;\n\t\t\t}\n\t\t\tdif = QRinput_estimateBitsModeAn(p - string) /* + 4 + la */\n\t\t\t\t+ QRinput_estimateBitsModeNum(q - p) + 4 + ln\n\t\t\t\t- QRinput_estimateBitsModeAn(q - string) /* - 4 - la */;\n\t\t\tif(dif < 0) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tp = q;\n\t\t\t}\n\t\t} else {\n\t\t\tp++;\n\t\t}\n\t}\n\n\trun = p - string;\n\n\tif(*p && !isalnum(*p)) {\n\t\tdif = QRinput_estimateBitsModeAn(run) + 4 + la\n\t\t\t+ QRinput_estimateBitsMode8(1) /* + 4 + l8 */\n\t\t\t- QRinput_estimateBitsMode8(run + 1) /* - 4 - l8 */;\n\t\tif(dif > 0) {\n\t\t\treturn Split_eat8(string, input, hint);\n\t\t}\n\t}\n\n\tret = QRinput_append(input, QR_MODE_AN, run, (unsigned char *)string);\n\tif(ret < 0) return -1;\n\n\treturn run;\n}\n\nstatic int Split_eatKanji(const char *string, QRinput *input, QRencodeMode hint)\n{\n\tconst char *p;\n\tint ret;\n\tint run;\n\n\tp = string;\n\twhile(Split_identifyMode(p, hint) == QR_MODE_KANJI) {\n\t\tp += 2;\n\t}\n\trun = p - string;\n\tret = QRinput_append(input, QR_MODE_KANJI, run, (unsigned char *)string);\n\tif(ret < 0) return -1;\n\n\treturn run;\n}\n\nstatic int Split_eat8(const char *string, QRinput *input, QRencodeMode hint)\n{\n\tconst char *p, *q;\n\tQRencodeMode mode;\n\tint ret;\n\tint run;\n\tint dif;\n\tint la, ln;\n\n\tla = QRspec_lengthIndicator(QR_MODE_AN, input->version);\n\tln = QRspec_lengthIndicator(QR_MODE_NUM, input->version);\n\n\tp = string + 1;\n\twhile(*p != '\\0') {\n\t\tmode = Split_identifyMode(p, hint);\n\t\tif(mode == QR_MODE_KANJI) {\n\t\t\tbreak;\n\t\t}\n\t\tif(mode == QR_MODE_NUM) {\n\t\t\tq = p;\n\t\t\twhile(isdigit(*q)) {\n\t\t\t\tq++;\n\t\t\t}\n\t\t\tdif = QRinput_estimateBitsMode8(p - string) /* + 4 + l8 */\n\t\t\t\t+ QRinput_estimateBitsModeNum(q - p) + 4 + ln\n\t\t\t\t- QRinput_estimateBitsMode8(q - string) /* - 4 - l8 */;\n\t\t\tif(dif < 0) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tp = q;\n\t\t\t}\n\t\t} else if(mode == QR_MODE_AN) {\n\t\t\tq = p;\n\t\t\twhile(isalnum(*q)) {\n\t\t\t\tq++;\n\t\t\t}\n\t\t\tdif = QRinput_estimateBitsMode8(p - string) /* + 4 + l8 */\n\t\t\t\t+ QRinput_estimateBitsModeAn(q - p) + 4 + la\n\t\t\t\t- QRinput_estimateBitsMode8(q - string) /* - 4 - l8 */;\n\t\t\tif(dif < 0) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tp = q;\n\t\t\t}\n\t\t} else {\n\t\t\tp++;\n\t\t}\n\t}\n\n\trun = p - string;\n\tret = QRinput_append(input, QR_MODE_8, run, (unsigned char *)string);\n\tif(ret < 0) return -1;\n\n\treturn run;\n}\n\nstatic int Split_splitString(const char *string, QRinput *input,\n\t\tQRencodeMode hint)\n{\n\tint length;\n\tQRencodeMode mode;\n\n\tif(*string == '\\0') return 0;\n\n\tmode = Split_identifyMode(string, hint);\n\tif(mode == QR_MODE_NUM) {\n\t\tlength = Split_eatNum(string, input, hint);\n\t} else if(mode == QR_MODE_AN) {\n\t\tlength = Split_eatAn(string, input, hint);\n\t} else if(mode == QR_MODE_KANJI && hint == QR_MODE_KANJI) {\n\t\tlength = Split_eatKanji(string, input, hint);\n\t} else {\n\t\tlength = Split_eat8(string, input, hint);\n\t}\n\tif(length == 0) return 0;\n\tif(length < 0) return -1;\n\treturn Split_splitString(&string[length], input, hint);\n}\n\nstatic char *dupAndToUpper(const char *str, QRencodeMode hint)\n{\n\tchar *newstr, *p;\n\tQRencodeMode mode;\n\n\tnewstr = _strdup(str);\n\tif(newstr == NULL) return NULL;\n\n\tp = newstr;\n\twhile(*p != '\\0') {\n\t\tmode = Split_identifyMode(p, hint);\n\t\tif(mode == QR_MODE_KANJI) {\n\t\t\tp += 2;\n\t\t} else {\n\t\t\tif (*p >= 'a' && *p <= 'z') {\n\t\t\t\t*p = (char)((int)*p - 32);\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t}\n\n\treturn newstr;\n}\n\nint Split_splitStringToQRinput(const char *string, QRinput *input,\n\t\tQRencodeMode hint, int casesensitive)\n{\n\tchar *newstr;\n\tint ret;\n\n\tif(string == NULL || *string == '\\0') {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tif(!casesensitive) {\n\t\tnewstr = dupAndToUpper(string, hint);\n\t\tif(newstr == NULL) return -1;\n\t\tret = Split_splitString(newstr, input, hint);\n\t\tfree(newstr);\n\t} else {\n\t\tret = Split_splitString(string, input, hint);\n\t}\n\n\treturn ret;\n}\n","size_bytes":7371},"bin/Demo/MfcDemo/10.AlarmDevice/DlgAlarmChannel.cpp":{"content":"// DlgAlarmChannel.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgAlarmChannel.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgAlarmChannel dialog\n\n\nCDlgAlarmChannel::CDlgAlarmChannel(CWnd* pParent /* = NULL */, LLONG lLoginID /* = 0 */)\n\t: CDialog(CDlgAlarmChannel::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgAlarmChannel)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_lLoginId = lLoginID;\n\tmemset(&m_stuInfo, 0, sizeof(NET_ALARM_CHANNELS));\n\tm_stuInfo.dwSize = sizeof(NET_ALARM_CHANNELS);\n}\n\n\nvoid CDlgAlarmChannel::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgAlarmChannel)\n\tDDX_Control(pDX, IDC_ALARMCHANNELS_LIST_IN, m_lstAlarmInChannel);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgAlarmChannel, CDialog)\n\t//{{AFX_MSG_MAP(CDlgAlarmChannel)\n\tON_BN_CLICKED(IDC_ALARMCHANNELS_BTN_QUERY, OnAlarmchannelsBtnQuery)\n\tON_WM_DESTROY()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgAlarmChannel private method\n\nvoid CDlgAlarmChannel::InitDlg()\n{\n\tGetDlgItem(IDC_ALARMCHANNELS_EDT_INRETCOUNT)->EnableWindow(FALSE);\n\tSetDlgItemInt(IDC_ALARMCHANNELS_EDT_INCOUNT, 64, FALSE);\n\tm_lstAlarmInChannel.SetExtendedStyle(m_lstAlarmInChannel.GetExtendedStyle()| LVS_EX_HEADERDRAGDROP | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES );\n\tm_lstAlarmInChannel.InsertColumn(0, ConvertString(\"Index\", DLG_ALARM_CHANNELS), LVCFMT_LEFT, 60, -1);\n\tm_lstAlarmInChannel.InsertColumn(1, ConvertString(\"Slot\", DLG_ALARM_CHANNELS), LVCFMT_LEFT, 90, -1);\n\tm_lstAlarmInChannel.InsertColumn(2, ConvertString(\"Channel\", DLG_ALARM_CHANNELS), LVCFMT_LEFT, 120, -1);\n\tm_lstAlarmInChannel.InsertColumn(3, ConvertString(\"Name\", DLG_ALARM_CHANNELS), LVCFMT_LEFT, 150, -1);\n}\n\nBOOL CDlgAlarmChannel::getInfoFromDevice()\n{\n\tint nMaxCount = GetDlgItemInt(IDC_ALARMCHANNELS_EDT_INCOUNT);\n\tif (nMaxCount <= 0)\n\t{\n\t\tMessageBox(ConvertString(\"Error param\", DLG_ALARM_CHANNELS), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\tif (m_stuInfo.pstuChannelInfo != NULL)\n\t{\n\t\tdelete[] m_stuInfo.pstuChannelInfo;\n\t\tm_stuInfo.pstuChannelInfo = NULL;\n\t}\n\tm_stuInfo.pstuChannelInfo = new NET_ALARM_CHANNEL_INFO[nMaxCount];\n\tif (NULL == m_stuInfo.pstuChannelInfo)\n\t{\n\t\tMessageBox(ConvertString(\"new error\", DLG_ALARM_CHANNELS), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\tmemset(m_stuInfo.pstuChannelInfo, 0, sizeof(NET_ALARM_CHANNEL_INFO) * nMaxCount);\n\tfor (int i = 0; i < nMaxCount; i++)\n\t{\n\t\tm_stuInfo.pstuChannelInfo[i].dwSize = sizeof(NET_ALARM_CHANNEL_INFO);\n\t}\n\tm_stuInfo.nMaxAlarmChannels = nMaxCount;\n\n\tint nRetLen = 0;\n\tBOOL bRet = CLIENT_QueryDevState(m_lLoginId, DH_DEVSTATE_ALARM_CHANNELS, \n\t\t(char*)&m_stuInfo, sizeof(NET_ALARM_CHANNELS), &nRetLen, SDK_API_WAIT);\n\tif (!bRet)\n\t{\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"Query AlarmChannel failed:\", DLG_ALARM_CHANNELS), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t} \n\telse\n\t{\n\t\treturn TRUE;\n\t}\n}\n\nvoid CDlgAlarmChannel::showInfo()\n{\n\tSetDlgItemInt(IDC_ALARMCHANNELS_EDT_INRETCOUNT, m_stuInfo.nRetAlarmChannels, FALSE);\n\n\tint nIndex\t\t= 0;\n\tint nMinCount\t= __min(m_stuInfo.nMaxAlarmChannels, m_stuInfo.nRetAlarmChannels);\n\tm_lstAlarmInChannel.DeleteAllItems();\n\tm_lstAlarmInChannel.DeleteAllItems();\n\n\tfor (int i = 0; i < nMinCount; ++i)\n\t{\n\t\tchar szIndex[10] = {0};\n\t\tchar szSlot[10] = {0};\n\t\tchar szChannel[10] = {0};\n\t\t_itoa(i + 1, szIndex, 10);\n\t\t_itoa(m_stuInfo.pstuChannelInfo[i].nSlot, szSlot, 10);\n\t\t_itoa(m_stuInfo.pstuChannelInfo[i].nChannel, szChannel, 10);\n\t\tm_lstAlarmInChannel.InsertItem(nIndex, NULL);\n\t\tm_lstAlarmInChannel.SetItemText(nIndex, 0, szIndex);\n\t\tm_lstAlarmInChannel.SetItemText(nIndex, 1, szSlot);\n\t\tm_lstAlarmInChannel.SetItemText(nIndex, 2, szChannel);\n\t\tm_lstAlarmInChannel.SetItemText(nIndex, 3, m_stuInfo.pstuChannelInfo[i].szName);\n\t\tnIndex++;\n\t}\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgAlarmChannel message handlers\n\nBOOL CDlgAlarmChannel::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_ALARM_CHANNELS);\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgAlarmChannel::OnAlarmchannelsBtnQuery() \n{\n\t// TODO: Add your control notification handler code here\n\tif (getInfoFromDevice())\n\t{\n\t\tshowInfo();\n\t}\n}\n\nvoid CDlgAlarmChannel::OnDestroy() \n{\n\tCDialog::OnDestroy();\n\t\n\t// TODO: Add your message handler code here\n\tif (NULL != m_stuInfo.pstuChannelInfo)\n\t{\n\t\tdelete[] m_stuInfo.pstuChannelInfo;\n\t\tm_stuInfo.pstuChannelInfo = NULL;\n\t}\n}\n","size_bytes":4887},"bin/DemoSrc/playsdkdemo/DlgPicSetting.cpp":{"content":"// DlgPicSetting.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"PlayDemo.h\"\n#include \"DlgPicSetting.h\"\n#include \"LanguageConvertor.h\"\n#include <shlwapi.h>\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgPicSetting dialog\n\n#pragma comment(lib, \"shlwapi.lib\")\n\nCDlgPicSetting::CDlgPicSetting(CWnd* pParent /*=NULL*/)\n\t: CDialog(CDlgPicSetting::IDD, pParent)\n{\n\t/* get the whole process name */\n\tm_strPath.Format(_T(\"%s%s\"), GetMoudlePath(), _T(\"picture\"));\n\tif(!PathFileExists(m_strPath))\n\t\tCreateDirectory(m_strPath, NULL);\n\tm_nType = 0;\n}\n\n\nvoid CDlgPicSetting::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgPicSetting)\n\tDDX_Text(pDX, IDC_EDIT_PICPATH, m_strPath);\n\tif(!PathFileExists(m_strPath))\n\t\tCreateDirectory(m_strPath, NULL);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgPicSetting, CDialog)\n\t//{{AFX_MSG_MAP(CDlgPicSetting)\n\tON_BN_CLICKED(IDC_BUTTON_PATH, OnButtonPath)\n\tON_BN_CLICKED(IDC_RADIO_BMP, OnRadioBmp)\n\tON_BN_CLICKED(IDC_RADIO_JPG, OnRadioJpg)\n\tON_WM_CLOSE()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgPicSetting message handlers\n\nvoid CDlgPicSetting::OnOK() \n{\n\t// TODO: Add extra validation here\n\tCDialog::OnOK();\n}\n\n\nCString OpenFolder() \n{\n\tCString strPath;\n\tLPMALLOC   pMalloc;  \n\tif(SHGetMalloc(&pMalloc) == NOERROR)   \n\t{   \n\t\tBROWSEINFO bi;   \n\t\tTCHAR pszBuffer[MAX_PATH];   \n\t\tLPITEMIDLIST pidl;   \n\t\tbi.hwndOwner = NULL;   \n\t\tbi.pidlRoot = NULL;   \n\t\tbi.pszDisplayName = pszBuffer;   \n\t\tbi.lpszTitle = _T(\"\");  \n\t\tbi.ulFlags = BIF_RETURNFSANCESTORS   |   BIF_RETURNONLYFSDIRS;   \n\t\tbi.lpfn = NULL;   \n\t\tbi.lParam = 0;   \n\t\tbi.iImage = 0;   \n\t\tif((pidl=SHBrowseForFolder(&bi)) != NULL)   \n\t\t{   \n\t\t\tif(SHGetPathFromIDList(pidl, pszBuffer))   \n\t\t\t{\n\t\t\t\tstrPath = pszBuffer;  \n\t\t\t}\n\t\t\tpMalloc->Free(pidl);   \n\t\t}   \n\t\tpMalloc->Release();   \n\t} \n\t\n\treturn strPath;\n}\n\n\nvoid CDlgPicSetting::OnButtonPath() \n{\n\t// TODO: Add your control notification handler code here\n\tCString strPath = OpenFolder();\n\tif(PathFileExists(strPath))\n\t\tm_strPath = strPath;\n\t\n\tUpdateData(FALSE);\n}\n\nvoid CDlgPicSetting::OnRadioBmp() \n{\n\t// TODO: Add your control notification handler code here\n\tm_nType = 0;\n}\n\nvoid CDlgPicSetting::OnRadioJpg() \n{\n\t// TODO: Add your control notification handler code here\n\tm_nType = 1;\n}\n\nBOOL CDlgPicSetting::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\t// TODO: Add extra initialization here\n\t((CButton*)GetDlgItem(IDC_RADIO_BMP))->SetCheck(!m_nType);\n\t((CButton*)GetDlgItem(IDC_RADIO_JPG))->SetCheck(m_nType);\n\n\tUpdateData(FALSE);\n\n\tLANG_SETWNDSTATICTEXT(this);\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgPicSetting::OnClose() \n{\n\t// TODO: Add your message handler code here and/or call default\n\tCDialog::OnClose();\n}\n","size_bytes":3033},"bin/Demo/MfcDemo/09.AccessControl/DlgUpgrade.cpp":{"content":"// DlgUpgrade.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AccessControl.h\"\n#include \"DlgUpgrade.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgUpgrade dialog\n\n\nCDlgUpgrade::CDlgUpgrade(CWnd* pParent /* = NULL */, LLONG hLoginId /* = NULL */)\n\t: CDialog(CDlgUpgrade::IDD, pParent),\n\tm_hLoginId(hLoginId),\n\tm_hUpgradeId(NULL)\n{\n\t//{{AFX_DATA_INIT(CDlgUpgrade)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CDlgUpgrade::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgUpgrade)\n\tDDX_Control(pDX, IDC_UPGRADE_LIST_INFO, m_lsInfo);\n\tDDX_Control(pDX, IDC_UPGRADE_PROGRESS, m_ctrlProgress);\n\tDDX_Control(pDX, IDC_UPGRADE_STATIC_COUNT, m_staticProgress);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgUpgrade, CDialog)\n\t//{{AFX_MSG_MAP(CDlgUpgrade)\n\tON_WM_DESTROY()\n\tON_BN_CLICKED(IDC_UPGRADE_BTN_PATH, OnUpgradeBtnPath)\n\tON_BN_CLICKED(IDC_UPGRADE_BTN_UPGRADE, OnUpgradeBtnUpgrade)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgUpgrade private handlers\n\nvoid CDlgUpgrade::StopUpgrade(LLONG lUpgradId /* = NULL */)\n{\n\tif (lUpgradId)\n\t{\n\t\tCLIENT_StopUpgrade(lUpgradId);\n\t\tlUpgradId = NULL;\n\t}\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgUpgrade message handlers\n\nBOOL CDlgUpgrade::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_UPGRADE);\n\t\n\t// TODO: Add extra initialization here\n\tif (!m_hLoginId)\n\t{\n\t\tMessageBox(ConvertString(CString(\"we haven't login a device yet!\"), DLG_UPGRADE), ConvertString(\"Prompt\"));\n\t\treturn TRUE;\n\t}\n\t\n\tm_ctrlProgress.SetRange(0, 100);\n\tm_ctrlProgress.SetPos(0);\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgUpgrade::OnDestroy() \n{\n\tCDialog::OnDestroy();\n\t\n\t// TODO: Add your message handler code here\n\tStopUpgrade(m_hUpgradeId);\t\n}\n\nvoid CDlgUpgrade::OnUpgradeBtnPath() \n{\n\t// TODO: Add your control notification handler code here\n\tCFileDialog dlg(TRUE, NULL, NULL, OFN_HIDEREADONLY | OFN_ENABLESIZING | OFN_NOCHANGEDIR, _T(\"All Types (*.*)|*.*||\"), this);\n\t\n\tif (dlg.DoModal() == IDOK)\n\t{\n\t\tSetDlgItemText(IDC_UPGRADE_EDT_PATH, dlg.GetPathName());\n\t}\t\n}\n\nvoid CDlgUpgrade::OnUpgradeBtnUpgrade() \n{\n\t// TODO: Add your control notification handler code here\n\t{\n\t\t// make sure the previous upgrading is closed before another upgrading operation\n\t\tStopUpgrade(m_hUpgradeId);\n\t}\n\n\tCString strFilePath;\n\tGetDlgItemText(IDC_UPGRADE_EDT_PATH, strFilePath);\n\tif (strFilePath.IsEmpty())\n\t{\n\t\tMessageBox(ConvertString(\"please choose a upgrade packet file.\", DLG_UPGRADE), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\t\n\tm_hUpgradeId = CLIENT_StartUpgradeEx(m_hLoginId, (EM_UPGRADE_TYPE)0, strFilePath.GetBuffer(0), UpgradeCallBack, (LLONG)this);\n\tTRACE(\"start upgrade...%s.\\n\", m_hUpgradeId ? \"succeed\" : \"fail\");\n\n\tif (m_hUpgradeId)\n\t{\n\t\tm_ctrlProgress.SetPos(0);\n\t\tint nRet = CLIENT_SendUpgrade(m_hUpgradeId);\n\t\tTRACE(\"execute upgrade...%s.\\n\", nRet ? \"succeed\" : \"fail\");\n\t}\n\telse\n\t{\n\t\tm_ctrlProgress.SetPos(0);\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"Upgrade failed with code\", DLG_UPGRADE), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t}\n}\n\nvoid WINAPI UpgradeCallBack(LLONG lLoginID, LLONG lUpgradechannel, int nTotalSize, int nSendSize, LDWORD dwUser)\n{\n\t((CDlgUpgrade*)dwUser)->UpgradeState(lLoginID, lUpgradechannel, nTotalSize, nSendSize);\n}\n\nvoid CDlgUpgrade::UpgradeState(LLONG lLoginID, LLONG lUpgradechannel, int nTotalSize, int nSendSize)\n{\n\tif (lLoginID && lLoginID == m_hLoginId && lUpgradechannel /*&& lUpgradechannel == m_hUpgradeId*/)\n\t{\n\t\tSYSTEMTIME st;\n\t\tGetLocalTime(&st);\n\t\tint nCount = m_lsInfo.GetCount();\n\t\tCString csInfo;\n\n\t\tCString csProgress = ConvertString(\"upgrade progress\", DLG_UPGRADE);\n\t\tCString csSucceed = ConvertString(\"upgrade succeed\", DLG_UPGRADE);\n\t\tCString csFailed = ConvertString(\"upgrade failed\", DLG_UPGRADE);\n\n\t\tif (nTotalSize == 0)\n\t\t{\n\t\t\tif (nSendSize == -1)\n\t\t\t{\n\t\t\t\tcsInfo.Format(\"%02d:%02d:%02d.%03d %s: %s\", \n\t\t\t\t\tst.wHour, st.wMinute, st.wSecond, st.wMilliseconds, csProgress, csSucceed);\n\t\t\t\tm_lsInfo.InsertString(nCount, csInfo);\n\t\t\t\tm_lsInfo.SetCurSel(nCount);\n\t\t\t} \n\t\t\telse if (nSendSize == -2)\n\t\t\t{\n\t\t\t\tcsInfo.Format(\"%02d:%02d:%02d.%03d %s: %s\", \n\t\t\t\t\tst.wHour, st.wMinute, st.wSecond, st.wMilliseconds, csProgress, csFailed);\n\t\t\t\tm_lsInfo.InsertString(nCount, csInfo);\n\t\t\t\tm_lsInfo.SetCurSel(nCount);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\telse if (nTotalSize > 0)\n\t\t{\n\t\t\tint nProgress = 100 * nSendSize / nTotalSize;\n\t\t\tif (nProgress <= 0)\n\t\t\t{\n\t\t\t\tnProgress = 0;\n\t\t\t}\n\t\t\tif (nProgress > 99)\n\t\t\t{\n\t\t\t\tnProgress = 100;\n\t\t\t}\n\t\t\tm_ctrlProgress.SetPos(nProgress);\n\t\t\t\n\t\t\tcsInfo.Format(\"%02d:%02d:%02d.%03d %s: %d %d/%d\", \n\t\t\t\tst.wHour, st.wMinute, st.wSecond, st.wMilliseconds, csProgress,\n\t\t\t\tnProgress, nSendSize, nTotalSize);\n\t\t\tm_lsInfo.InsertString(nCount, csInfo);\n\t\t\tm_lsInfo.SetCurSel(nCount);\n\t\t}\n\n\t\tTRACE(\"upgrade progress: totalSize = %08d, sendSize = %08d\\n\", nTotalSize, nSendSize);\n\t}\n}\n","size_bytes":5282},"bin/Demo/MfcDemo/10.AlarmDevice/DlgFileList.cpp":{"content":"// DlgFileList.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgFileList.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n#define MAX_FILE_COUNT\t128\n/////////////////////////////////////////////////////////////////////////////\n// CDlgFileList dialog\n\n\nCDlgFileList::CDlgFileList(CWnd* pParent /* = NULL */, LLONG hLoginId /* = NULL */)\n\t: CDialog(CDlgFileList::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgFileList)\n\tm_hLoginId = hLoginId;\n\tm_uiRetCount = 0;\n\tm_uiMaxCount = 0;\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CDlgFileList::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgFileList)\n\tDDX_Control(pDX, IDC_FILENAME_LIST_FILENAME, m_lsFileList);\n\tDDX_Text(pDX, IDC_FILENAME_EDT_RETNUMBER, m_uiRetCount);\n\tDDX_Text(pDX, IDC_FILENAME_EDT_MAXNUMBER, m_uiMaxCount);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgFileList, CDialog)\n\t//{{AFX_MSG_MAP(CDlgFileList)\n\tON_BN_CLICKED(IDC_FILENAME_BTN_GET, OnFilenameBtnGet)\n\tON_BN_CLICKED(IDC_FILENAME_BTN_REMOVE, OnFilenameBtnRemove)\n\tON_WM_DESTROY()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// Private method\n\nvoid CDlgFileList::InitDlg()\n{\n\tSetDlgItemInt(IDC_FILENAME_EDT_MAXNUMBER, 16, FALSE);\n\tSetDlgItemInt(IDC_FILENAME_EDT_RETNUMBER, 0, FALSE);\n\t\n\tm_lsFileList.SetExtendedStyle(m_lsFileList.GetExtendedStyle() \n\t\t| LVS_EX_GRIDLINES | LVS_EX_CHECKBOXES);\n\tm_lsFileList.DeleteAllItems();\n\tm_lsFileList.InsertColumn(0, ConvertString(\"Seq\", DLG_FILENAME), LVCFMT_LEFT, 50);\n\tm_lsFileList.InsertColumn(1, ConvertString(\"FileName\", DLG_FILENAME), LVCFMT_LEFT, 180);\n\n\tCString csPath = ConvertString(CString(\"DefaultPath\"), DLG_FILENAME);\n\tif (csPath == \"DefaultPath\")\n\t{\n\t\tSetDlgItemText(IDC_FILENAME_EDT_PATH, \"/audio\");\n\t} \n\telse\n\t{\n\t\tSetDlgItemText(IDC_FILENAME_EDT_PATH, csPath);\n\t}\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgFileList message handlers\n\nBOOL CDlgFileList::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_FILENAME);\n\t\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\tOnFilenameBtnGet();\n\n// \tchar szSeq[8] = {0};\n// \titoa(1, szSeq, 10);\n// \tm_lsFileList.InsertItem(0, \"\", 0);\n// \tm_lsFileList.SetItemText(0, 0, szSeq);\n// \tm_lsFileList.SetItemText(0, 1, \"abc\");\n// \n// \titoa(2, szSeq, 10);\n// \tm_lsFileList.InsertItem(1, \"\", 0);\n// \tm_lsFileList.SetItemText(1, 0, szSeq);\n// \tm_lsFileList.SetItemText(1, 1, \"123\");\n// \t\n// \titoa(3, szSeq, 10);\n// \tm_lsFileList.InsertItem(2, \"\", 0);\n// \tm_lsFileList.SetItemText(2, 0, szSeq);\n// \tm_lsFileList.SetItemText(2, 1, \"456\");\n// \n// \tchar* szTemp1 = \"abc\";\n// \tchar* szTemp2 = \"123\";\n// \tchar* szTemp3 = \"456\";\n// \tm_listInfo.push_back(szTemp1);\n// \tm_listInfo.push_back(szTemp2);\n// \tm_listInfo.push_back(szTemp3);\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t// EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgFileList::OnFilenameBtnGet() \n{\n\t// TODO: Add your control notification handler code here\n\tif (0 == m_hLoginId)\n\t{\n\t\tMessageBox(ConvertString(CString(\"we haven't login a device yet!\"), DLG_FILENAME), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tm_lsFileList.DeleteAllItems();\n\n\tDH_IN_LIST_REMOTE_FILE stuIn = {sizeof(stuIn)};\n\t\n\tCString csPath;\n\tGetDlgItemText(IDC_FILENAME_EDT_PATH, csPath);\n\tstuIn.bFileNameOnly = TRUE;\n\tstuIn.pszPath = csPath.GetBuffer(0);\n\n\tDH_OUT_LIST_REMOTE_FILE stuOut = {sizeof(stuOut)};\n\t\n\tint nCount = GetDlgItemInt(IDC_FILENAME_EDT_MAXNUMBER, NULL, FALSE);\n\tif (nCount <= 0)\n\t{\n\t\tnCount = 16;\n\t\tSetDlgItemInt(IDC_FILENAME_EDT_MAXNUMBER, 16, FALSE);\n\t}\n\tDH_REMOTE_FILE_INFO* pFile = new DH_REMOTE_FILE_INFO[nCount];\n\tif (!pFile)\n\t{\n\t\treturn;\n\t}\n\tmemset(pFile, 0, sizeof(DH_REMOTE_FILE_INFO) * nCount);\n\n\tfor (int i = 0; i < nCount; i++)\n\t{\n\t\tpFile[i].dwSize = sizeof(DH_REMOTE_FILE_INFO);\n\t}\n\tstuOut.nMaxFileCount = nCount;\n\tstuOut.pstuFiles = pFile;\n\n\tBOOL bRet = CLIENT_ListRemoteFile(m_hLoginId, &stuIn, &stuOut, SDK_API_WAIT);\n\tSetDlgItemInt(IDC_FILENAME_EDT_RETNUMBER, stuOut.nRetFileCount, FALSE);\n\tif (bRet)\n\t{\n\t\tfor (int j = 0; j < stuOut.nRetFileCount; j++)\n\t\t{\n\t\t\tm_lsFileList.InsertItem(j, \"\", 0);\n\t\t\t\n\t\t\tchar szSeq[8] = {0};\n\t\t\t_itoa(j + 1, szSeq, 10);\n\t\t\tm_lsFileList.SetItemText(j, 0, szSeq);\n\t\t\tm_lsFileList.SetItemText(j, 1, pFile[j].szPath);\n\t\t\tm_listInfo.push_back(pFile[j].szPath);\n\t\t}\n\t} \n\telse\n\t{\n\t\tif (NET_INSUFFICIENT_BUFFER == CLIENT_GetLastError())\n\t\t{\n\t\t\tSetDlgItemInt(IDC_FILENAME_EDT_RETNUMBER, stuOut.nRetFileCount, TRUE);\n\t\t}\n\t\tCString csOut;\n\t\tcsOut.Format(\"%s %08x\", ConvertString(\"Get file_list err:\", DLG_FILENAME), CLIENT_GetLastError());\n\t\tMessageBox(csOut, ConvertString(\"Prompt\"));\n\t}\n\t\n\tif (pFile)\n\t{\n\t\tdelete []pFile;\n\t\tpFile = NULL;\n\t}\n}\n\nvoid CDlgFileList::OnFilenameBtnRemove() \n{\n\t// TODO: Add your control notification handler code here\n\tif (0 == m_hLoginId)\n\t{\n\t\tMessageBox(ConvertString(CString(\"we haven't login a device yet!\"), DLG_FILENAME), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\n\tint nDeleteCount = 0;\n\tchar *pszPath[MAX_FILE_COUNT] = {0};\n\tchar szPath[MAX_FILE_COUNT][MAX_PATH] = {0};\n\tfor (int i = 0; i < m_lsFileList.GetItemCount() && nDeleteCount < MAX_FILE_COUNT; ++i)\n\t{\n\t\tif (m_lsFileList.GetCheck(i))\n\t\t{\n\t\t\tm_lsFileList.GetItemText(i, 1, szPath[nDeleteCount], MAX_PATH);\n\t\t\tpszPath[nDeleteCount] = szPath[nDeleteCount];\n\t\t\t++nDeleteCount;\n//\t\t\tstd::list<char*>::iterator it = m_listInfo.begin();\n\n// \t\t\tfor (; it != m_listInfo.end(); ++it)\n// \t\t\t{\n// \t\t\t\tif (strcmp(*it, szPath[nDeleteCount]) == 0)\n// \t\t\t\t{\n// \t\t\t\t\tm_listInfo.erase(it++);\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t}\n\t\t}\n\t}\n\t\n\tDH_IN_REMOVE_REMOTE_FILES pInParam = {sizeof(DH_IN_REMOVE_REMOTE_FILES), (const char**)pszPath, nDeleteCount};\n\tDH_OUT_REMOVE_REMOTE_FILES pOutParam = {sizeof(DH_OUT_REMOVE_REMOTE_FILES)};\n\n\tBOOL bRet = CLIENT_RemoveRemoteFiles(m_hLoginId, &pInParam, &pOutParam, SDK_API_WAIT);\n\tif (!bRet)\n\t{\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"RemoveFiles failed:\", DLG_FILENAME), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tSleep(500);\n\t\tOnFilenameBtnGet();\n\t}\n}\n\n","size_bytes":6209},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgMacConflict.cpp":{"content":"// DlgCfgMacConflict.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"alarmdevice.h\"\n#include \"DlgCfgMacConflict.h\"\n#include \"SubDlgCfgEventHandler.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgMacConflict dialog\n\n\nCDlgCfgMacConflict::CDlgCfgMacConflict(CWnd* pParent /* = NULL */, LLONG lLoginID /* = 0 */)\n\t: CDialog(CDlgCfgMacConflict::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgMacConflict)\n\t\t// NOTE: the ClassWizard will add member initialization here\n    //}}AFX_DATA_INIT\n    m_lLoginId = lLoginID;\n\tmemset(&m_stuInfo, 0, sizeof(CFG_MACCONFLICT_INFO));\n}\n\n\nvoid CDlgCfgMacConflict::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgMacConflict)\n\tDDX_Control(pDX, IDC_CFGMACCONFLICT_CHK_ENABLE, m_ckEnable);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgMacConflict, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgMacConflict)\n\tON_BN_CLICKED(IDC_CFGMACCONFLICT_BTN_EVENTHANDLER, OnCfgmacconflictBtnEventhandler)\n\tON_BN_CLICKED(IDC_CFGMACCONFLICT_BTN_GET, OnCfgmacconflictBtnGet)\n\tON_BN_CLICKED(IDC_CFGMACCONFLICT_BTN_SET, OnCfgmacconflictBtnSet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgMacConflict private method\n\nBOOL CDlgCfgMacConflict::GetConfigFromDevice()\n{\n    char szJsonBuf[1024 * 40] = {0};\n    int nerror = 0;\n    int nSelChn = -1;\n    BOOL bRet = CLIENT_GetNewDevConfig(m_lLoginId, CFG_CMD_MACCONFLICT, nSelChn, szJsonBuf, sizeof(szJsonBuf), &nerror, SDK_API_WAIT);\n    \n    if (bRet)\n    {\n        DWORD dwRetLen = 0;\n        bRet = CLIENT_ParseData(CFG_CMD_MACCONFLICT, szJsonBuf, (void*)&m_stuInfo, sizeof(m_stuInfo), &dwRetLen);\n        if (!bRet)\n        {\n            MessageBox(ConvertString(CString(\"parse MacConflict error...\"), DLG_CFG_MACONFLICT), ConvertString(\"Prompt\"));\n            return FALSE;\n        }\n    }\n    else\n    {\t\t\t\n        CString csErr;\n        csErr.Format(\"%s 0x%08x\",ConvertString(\"QueryConfig MacConflict error:\", DLG_CFG_MACONFLICT), CLIENT_GetLastError());\n        MessageBox(csErr, ConvertString(\"Prompt\"));\n        return FALSE;\n    }\n    return TRUE;\n}\n\nBOOL CDlgCfgMacConflict::SetConfigToDevice()\n{\n    char szJsonBuf[1024 * 40] = {0};   \n    BOOL bRet = CLIENT_PacketData(CFG_CMD_MACCONFLICT, &m_stuInfo, sizeof(m_stuInfo), szJsonBuf, sizeof(szJsonBuf));\n    if (!bRet)\n    {\n        MessageBox(ConvertString(CString(\"packet MacConflict error...\"), DLG_CFG_MACONFLICT), ConvertString(\"Prompt\"));\n        return FALSE;\n    } \n    else\n    {\n        int nerror = 0;\n        int nrestart = 0;\n        bRet = CLIENT_SetNewDevConfig(m_lLoginId, CFG_CMD_MACCONFLICT, -1, szJsonBuf, sizeof(szJsonBuf), &nerror, &nrestart, SDK_API_WAIT);\n        if (!bRet)\n        {\n            CString csErr;\n            csErr.Format(\"%s 0x%08x\", ConvertString(\"SetupConfig MacConflict failed:\", DLG_CFG_MACONFLICT), CLIENT_GetLastError());\n            MessageBox(csErr, ConvertString(\"Prompt\"));\n            return FALSE;\n        }\n        else\n        {\n            MessageBox(ConvertString(CString(\"SetConfig MacConflict ok!\"), DLG_CFG_MACONFLICT), ConvertString(\"Prompt\"));\n        }\n    }\n    return TRUE;\n}\n\nBOOL CDlgCfgMacConflict::showInfo()\n{\n    m_ckEnable.SetCheck(m_stuInfo.bEnable ? BST_CHECKED : BST_UNCHECKED);\n    return TRUE;\n}\n\nBOOL CDlgCfgMacConflict::getInfo()\n{\n    m_stuInfo.bEnable = m_ckEnable.GetCheck() ? TRUE : FALSE;\n    return TRUE;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgMacConflict message handlers\n\nBOOL CDlgCfgMacConflict::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n    \n\tg_SetWndStaticText(this, DLG_CFG_MACONFLICT);\n\t// TODO: Add extra initialization here\n    \n    if (GetConfigFromDevice())\n    {\n        showInfo();\n\t}\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgMacConflict::OnCfgmacconflictBtnEventhandler() \n{\n\t// TODO: Add your control notification handler code here\n    CSubDlgCfgEventHandler* pdlgEventHandler = new CSubDlgCfgEventHandler;\n    if (pdlgEventHandler != NULL)\n    {\n        pdlgEventHandler->SetEventHandler(m_stuInfo.stuEventHandler);\n        \n        if (IDOK == pdlgEventHandler->DoModal())\n        {\n            const CFG_ALARM_MSG_HANDLE& stuEventHandler = pdlgEventHandler->GetEventHandler();\n            memcpy(&m_stuInfo.stuEventHandler, &stuEventHandler, sizeof(CFG_ALARM_MSG_HANDLE));\n        }\n        \n        delete pdlgEventHandler;\n        pdlgEventHandler = NULL;\n    }\n    else\n    {\n        MessageBox(ConvertString(\"new handler dialog error!\", DLG_CFG_NETABORT), ConvertString(\"Prompt\"));\n\t}\n}\n\nvoid CDlgCfgMacConflict::OnCfgmacconflictBtnGet() \n{\n\t// TODO: Add your control notification handler code here\n    if (GetConfigFromDevice())\n    {\n        showInfo();\n\t}\n}\n\nvoid CDlgCfgMacConflict::OnCfgmacconflictBtnSet() \n{\n\t// TODO: Add your control notification handler code here\n    getInfo();\n    SetConfigToDevice();\n}\n","size_bytes":5163},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/AdvanceBtnPannel.cpp":{"content":"// AdvanceBtnPannel.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"AdvanceBtnPannel.h\"\n#include \"NetSDKDemoDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CAdvanceBtnPannel dialog\n\n\nCAdvanceBtnPannel::CAdvanceBtnPannel(CWnd* pParent /*=NULL*/)\n\t: CDialog(CAdvanceBtnPannel::IDD, pParent)\n{\n\tm_myBrush.CreateSolidBrush(RGB(170,170,255));\n\t//{{AFX_DATA_INIT(CAdvanceBtnPannel)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CAdvanceBtnPannel::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CAdvanceBtnPannel)\n\tDDX_Control(pDX, IDC_OPEN_TALK, m_isTalkOpen);\n\tDDX_Control(pDX, IDC_OPEN_SOUND, m_isSoundOpen);\n\t//}}AFX_DATA_MAP\n\tDDX_Control(pDX, IDC_SAVE_REALDATA2, m_IsSaveRealData);\n\tDDX_Control(pDX, IDC_SAVECBDATARAW, m_IsSaveDataRaw);\n}\n\n\nBEGIN_MESSAGE_MAP(CAdvanceBtnPannel, CDialog)\n\t//{{AFX_MSG_MAP(CAdvanceBtnPannel)\n\tON_BN_CLICKED(IDC_OPEN_SOUND, OnOpenSound)\n\tON_BN_CLICKED(IDC_OPEN_TALK, OnOpenTalk)\n\tON_BN_CLICKED(IDC_UPDATE_DEVICE, OnUpdateDevice)\n\tON_BN_CLICKED(IDC_RECORDSTATE, OnRecordstate)\n\tON_BN_CLICKED(IDC_REBOOT_DEVICE, OnRebootDevice)\n\tON_BN_CLICKED(IDC_SHUTDOWN_DEVICE, OnShutdownDevice)\n\tON_BN_CLICKED(IDC_ALARM_IO_CONTROL, OnAlarmIoControl)\n\tON_BN_CLICKED(IDC_DEVICE_STATE, OnDeviceState)\n\tON_BN_CLICKED(IDC_CAPTURE_SCREEN, OnCaptureScreen)\n\tON_BN_CLICKED(IDC_SET_I_FRAME, OnSetIFrame)\n\tON_BN_CLICKED(IDC_SHOW_FLUX, OnShowFlux)\n\tON_BN_CLICKED(IDC_TRANSCOM, OnTranscom)\n\tON_BN_CLICKED(IDC_DDNS_QUERY_IP, OnDdnsQueryIp)\n\tON_WM_CTLCOLOR()\n\tON_BN_CLICKED(IDC_DEVICE_WORKSTATE, OnDeviceWorkstate)\n\tON_BN_CLICKED(IDC_DEVICE_CONTROLDISK, OnDeviceControldisk)\n\tON_BN_CLICKED(IDC_DEVICE_USERINFO, OnDeviceUserinfo)\n\tON_BN_CLICKED(IDC_TEST, OnTest)\n\tON_BN_CLICKED(IDC_AUDIOBROADCAST, OnAudioBroadcast)\n\tON_BN_CLICKED(IDC_CYCLE_MONITOR, OnCycleMonitor)\n\tON_BN_CLICKED(IDC_SAVE_REALDATA2, OnBnClickedSaveRealdata)\n\tON_BN_CLICKED(IDC_SAVECBDATARAW, OnBnClickedSavecbdataraw)\n\t//}}AFX_MSG_MAP\t\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CAdvanceBtnPannel message handlers\n\nBOOL CAdvanceBtnPannel::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\tg_SetWndStaticText(this);\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CAdvanceBtnPannel::OnOpenSound() \n{\n\tBOOL bOpen = m_isSoundOpen.GetCheck() > 0 ? TRUE : FALSE;\n\t((CNetSDKDemoDlg *)GetParent())->OpenSound(bOpen);\n}\n\nvoid CAdvanceBtnPannel::OnOpenTalk() \n{\n\tBOOL bOpen = m_isTalkOpen.GetCheck() > 0 ? TRUE : FALSE;\n\tBOOL ret = ((CNetSDKDemoDlg *)GetParent())->OpenTalk(bOpen);\n\tif (!ret)\n\t{\n\t\tm_isTalkOpen.SetCheck(!bOpen);\t\t\n\t}\n}\n\nvoid CAdvanceBtnPannel::EnableTalk(BOOL bEnable)\n{\n\n}\n\nvoid CAdvanceBtnPannel::SetCheckSound(int nCheck)\n{\n\tm_isSoundOpen.SetCheck(nCheck);\n}\n\nvoid CAdvanceBtnPannel::SetCheckTalk(int nCheck)\n{\n\tm_isTalkOpen.SetCheck(nCheck);\n}\n\nBOOL CAdvanceBtnPannel::IsTalkOpen(void)\n{\n\treturn m_isTalkOpen.GetCheck() > 0 ? TRUE : FALSE;\n}\n\nvoid CAdvanceBtnPannel::OnUpdateDevice() \n{\n\t((CNetSDKDemoDlg *)GetParent())->UpdateDevice();\n}\n\nvoid CAdvanceBtnPannel::OnRecordstate() \n{\n\t((CNetSDKDemoDlg *)GetParent())->Recordstate();\n}\n\nvoid CAdvanceBtnPannel::OnRebootDevice() \n{\n\t((CNetSDKDemoDlg *)GetParent())->RebootDevice();\n}\n\nvoid CAdvanceBtnPannel::OnShutdownDevice() \n{\n\t((CNetSDKDemoDlg *)GetParent())->ShutdownDevice();\n}\n\nvoid CAdvanceBtnPannel::OnAlarmIoControl() \n{\n\t((CNetSDKDemoDlg *)GetParent())->AlarmIOctrl();\n}\n\nvoid CAdvanceBtnPannel::OnDeviceState() \n{\n\n}\n\nvoid CAdvanceBtnPannel::OnCaptureScreen() \n{\n\t((CNetSDKDemoDlg *)GetParent())->CaptureScreen();\n}\n\nvoid CAdvanceBtnPannel::OnSetIFrame() \n{\n\t((CNetSDKDemoDlg *)GetParent())->SetIframe();\n}\n\nvoid CAdvanceBtnPannel::OnShowFlux() \n{\n\t((CNetSDKDemoDlg *)GetParent())->ShowFluxInfo();\n}\n\nvoid CAdvanceBtnPannel::OnTranscom() \n{\n\t((CNetSDKDemoDlg *)GetParent())->Transcom();\n}\n\nvoid CAdvanceBtnPannel::OnDdnsQueryIp() \n{\n\t((CNetSDKDemoDlg *)GetParent())->DDNS_QueryIP();\n}\n\nHBRUSH CAdvanceBtnPannel::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) \n{\n\tHBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);\n\t\n\treturn m_myBrush;\n}\n\nBOOL CAdvanceBtnPannel::PreTranslateMessage(MSG* pMsg) \n{\n\tif (WM_KEYDOWN == pMsg->message && \n\t\t(VK_ESCAPE == pMsg->wParam || VK_RETURN == pMsg->wParam))\n\t{\n\t\treturn TRUE;\n\t}\n\t\n\treturn CDialog::PreTranslateMessage(pMsg);\n}\n\nvoid CAdvanceBtnPannel::OnDeviceWorkstate() \n{\n\t((CNetSDKDemoDlg *)GetParent())->GetDeviceWorkstate();\n}\n\n\nvoid CAdvanceBtnPannel::OnDeviceControldisk() \n{\n}\n\n\nvoid CAdvanceBtnPannel::OnDeviceUserinfo() \n{\n\t((CNetSDKDemoDlg *)GetParent())->DeviceUserinfo();\n}\n\nvoid CAdvanceBtnPannel::OnTest() \n{\n\t((CNetSDKDemoDlg *)GetParent())->TestProc();\n}\n\nvoid CAdvanceBtnPannel::OnAudioBroadcast() \n{\n\t// TODO: Add your control notification handler code here\n\t((CNetSDKDemoDlg *)GetParent())->OpenAudioBroadcastDlg();\n}\n\nvoid CAdvanceBtnPannel::OnCycleMonitor() \n{\n\t((CNetSDKDemoDlg *)GetParent())->CycleMonitor();\n}\n\nvoid CAdvanceBtnPannel::OnBnClickedSaveRealdata()\n{\n\tint nCheck = m_IsSaveRealData.GetCheck();\n\t((CNetSDKDemoDlg *)GetParent())->SaveRealdata(nCheck);\n}\n\nvoid CAdvanceBtnPannel::OnBnClickedSavecbdataraw()\n{\t\n\tint nCheck = m_IsSaveDataRaw.GetCheck();\n\t((CNetSDKDemoDlg *)GetParent())->SavecbdataRaw(nCheck);\n}","size_bytes":5535},"bin/Demo/MfcDemo/05.Talk/StdAfx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n//\tTalk.pch will be the pre-compiled header\n//\tstdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":240},"bin/Demo/MfcDemo/12.DeviceControlAndTimeSynchronization/DeviceControlAndTimeSynchronization.cpp":{"content":"// DeviceControlAndTimeSynchronization.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"DeviceControlAndTimeSynchronization.h\"\n#include \"DeviceControlAndTimeSynchronizationDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDeviceControlAndTimeSynchronizationApp\n\nBEGIN_MESSAGE_MAP(CDeviceControlAndTimeSynchronizationApp, CWinApp)\n\t//{{AFX_MSG_MAP(CDeviceControlAndTimeSynchronizationApp)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t\t//    DO NOT EDIT what you see in these blocks of generated code!\n\t//}}AFX_MSG\n\tON_COMMAND(ID_HELP, CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDeviceControlAndTimeSynchronizationApp construction\nCString ConvertString(CString strText)\n{\n\tchar *val = new char[200];\n\tCString strIniPath,strRet;\n\t\n\tmemset(val,0,200);\n\tGetPrivateProfileString(\"String\",strText,\"\",\n\t\tval,200,\"./langchn.ini\");\n\tstrRet = val;\n\tif(strRet.GetLength()==0)\n\t{\n\t\t//If there is no corresponding string in ini file then set it to be default value(English).\n\t\tstrRet=strText;\n\t}\n\tdelete val;\n\treturn strRet;\n}\n//Set static text in dialogue box (English->current language)\nvoid g_SetWndStaticText(CWnd * pWnd)\n{\n\tCString strCaption,strText;\n\t\n\t//Set main window title\n\tpWnd->GetWindowText(strCaption);\n\tif(strCaption.GetLength()>0)\n\t{\n\t\tstrText=ConvertString(strCaption);\n\t\tpWnd->SetWindowText(strText);\n\t}\n\t\n\t//Set small window title\n\tCWnd * pChild=pWnd->GetWindow(GW_CHILD);\n\tCString strClassName;\n\twhile(pChild)\n\t{\n\t\t//////////////////////////////////////////////////////////////////////////\t\t\n\t\t//Added by Jackbin 2005-03-11\n\t\tstrClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n\t\tif(strClassName == \"CEdit\")\n\t\t{\n\t\t\t//Next small window \n\t\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t//////////////////////////////////////////////////////////////////////////\t\n\t\t\n\t\t//Set current language text in small window.\n\t\tpChild->GetWindowText(strCaption);\n\t\tstrText=ConvertString(strCaption);\n\t\tpChild->SetWindowText(strText);\n\t\t\n\t\t//Next small window \n\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t}\n}\n\n\n\nCDeviceControlAndTimeSynchronizationApp::CDeviceControlAndTimeSynchronizationApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The one and only CDeviceControlAndTimeSynchronizationApp object\n\nCDeviceControlAndTimeSynchronizationApp theApp;\n\n/////////////////////////////////////////////////////////////////////////////\n// CDeviceControlAndTimeSynchronizationApp initialization\n\nBOOL CDeviceControlAndTimeSynchronizationApp::InitInstance()\n{\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t//  of your final executable, you should remove from the following\n\t//  the specific initialization routines you do not need.\n\n#ifdef _AFXDLL\n\tEnable3dControls();\t\t\t// Call this when using MFC in a shared DLL\n#else\n\tEnable3dControlsStatic();\t// Call this when linking to MFC statically\n#endif\n\n\tCDeviceControlAndTimeSynchronizationDlg dlg;\n\tm_pMainWnd = &dlg;\n\tint nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":3868},"bin/Demo/MfcDemo/13.FaceRecognition/FaceDbOpreate.cpp":{"content":"// FaceDbOpreate.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"FaceRecognition.h\"\n#include \"FaceDbOpreate.h\"\n#include \"AddGroupDlg.h\"\n#include \"PersonOpreateDlg.h\"\n#include \"DispatchGroupDlg.h\"\n#include \"SearchByPic.h\"\n#include \"DispatchGroupChannelDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CFaceDbOpreate dialog\nCFaceDbOpreate::CFaceDbOpreate(LLONG lLoginID, const int nChnCount, char *pSoftPath /*=NULL*/, CWnd* pParent /*=NULL*/)\n\t: CDialog(CFaceDbOpreate::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CFaceDbOpreate)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_lLoginID = lLoginID;\n\tm_nChnCount = nChnCount;\n\tm_pstSelectGroup = NULL;\n\tm_pSoftPath = NULL;\n\tif (pSoftPath)\n\t{\n\t\tm_pSoftPath = pSoftPath;\n\t}\n\tm_nSelectId = 0;\n\tm_nGroupCnt = 0;\n\tm_nGroupPos = 0;\n}\n\nCFaceDbOpreate::~CFaceDbOpreate()\n{\n\tCleanGroupList();\n\n\tif (m_pstSelectGroup)\n\t{\n\t\tdelete m_pstSelectGroup;\n\t\tm_pstSelectGroup = NULL;\n\t}\n}\n\nBOOL CFaceDbOpreate::GetGroupInfos()\n{\n\tunsigned int i = 0;\n\tBOOL bRet = TRUE;\n\tNET_IN_FIND_GROUP_INFO stuInParam = {sizeof(stuInParam)};\n\tNET_OUT_FIND_GROUP_INFO stuOutParam = {sizeof(stuOutParam)};\n\tstuOutParam.nMaxGroupNum = 50;\n\tNET_FACERECONGNITION_GROUP_INFO *pGroupInfo = NULL;\n\tstuOutParam.pGroupInfos = new NET_FACERECONGNITION_GROUP_INFO[stuOutParam.nMaxGroupNum];\n\tif (NULL == stuOutParam.pGroupInfos)\n\t{\n\t\tMessageBox(ConvertString(\"Memory error\"), \"\");\n\t\tbRet = FALSE;\n\t\tgoto e_clear;\n\t}\n\tmemset(stuOutParam.pGroupInfos, 0, sizeof(NET_FACERECONGNITION_GROUP_INFO)*stuOutParam.nMaxGroupNum);\n\tfor (i = 0; i < stuOutParam.nMaxGroupNum; i++)\n\t{\n\t\tpGroupInfo = stuOutParam.pGroupInfos + i;\n\t\tpGroupInfo->dwSize = sizeof(*pGroupInfo);\n\t}\n\n\tbRet = CLIENT_FindGroupInfo(m_lLoginID, &stuInParam, &stuOutParam, DEFAULT_WAIT_TIME);\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Failed to find group infos!\"), \"\");\n\t\tbRet = FALSE;\n\t\tgoto e_clear;\n\t}\n\n\tfor (i = 0; i < stuOutParam.nRetGroupNum; i++)\n\t{\n\t\tpGroupInfo = stuOutParam.pGroupInfos + i;\n\t\tNET_GROUP_INFO *pGroupInfoTmp = new NET_GROUP_INFO;\n\t\tif (NULL == pGroupInfoTmp)\n\t\t{\n\t\t\tMessageBox(ConvertString(\"Memory error\"), \"\");\n\t\t\tbRet = FALSE;\n\t\t\tgoto e_clear;\n\t\t}\n\t\tmemset(pGroupInfoTmp, 0, sizeof(*pGroupInfoTmp));\n\t\tpGroupInfoTmp->stuGroupInfo.dwSize = sizeof(pGroupInfoTmp->stuGroupInfo);\n\t\tmemcpy(&(pGroupInfoTmp->stuGroupInfo), pGroupInfo, sizeof(pGroupInfoTmp->stuGroupInfo));\n\t\tpGroupInfoTmp->nIndex = IDC_RADIO_group1 + i;\n\t\tm_lstGroupInfo.push_back(pGroupInfoTmp);\n\t}\n\n\tm_nGroupCnt = stuOutParam.nRetGroupNum; // total number of face libraries\n\ne_clear:\n\tif (stuOutParam.pGroupInfos)\n\t{\n\t\tdelete[] stuOutParam.pGroupInfos;\n\t\tstuOutParam.pGroupInfos = NULL;\n\t}\n\treturn bRet;\n}\n\nvoid CFaceDbOpreate::ShowGroupInfo()\n{\n\tunsigned int nIndex = 0;\n\tint i = IDC_RADIO_group1 + m_nGroupPos;\n\tint nMaxIndex = i + 10;\n\tCString str;\n\tstd::list<NET_GROUP_INFO*>::iterator it = m_lstGroupInfo.begin();\n\tfor(; (it != m_lstGroupInfo.end()) && (i < nMaxIndex); ++it)\n\t{\n\t\tif (*it)\n\t\t{\n\n\t\t\tNET_GROUP_INFO *pstGroupInfo = (*it);\n\t\t\tif (pstGroupInfo && (pstGroupInfo->nIndex == i))\n\t\t\t{\n\t\t\t\tint nId = IDC_DB_NAME1+nIndex;\n\t\t\t\tstr.Format(\"%s\", pstGroupInfo->stuGroupInfo.szGroupName);\n\t\t\t\tSetDlgItemText(nId, str);\n\n\t\t\t\tnId = IDC_GROUP_ID1+nIndex;\n\t\t\t\tstr.Format(\"%s\", pstGroupInfo->stuGroupInfo.szGroupId);\n\t\t\t\tSetDlgItemText(nId, str);\n\n\t\t\t\tnId = IDC_PERSON_NUM1 + nIndex;\n\t\t\t\tstr.Format(\"%d\", pstGroupInfo->stuGroupInfo.nGroupSize);\n\t\t\t\tSetDlgItemText(nId, str);\n\n\t\t\t\tnId = IDC_RADIO_group1 + nIndex;\n\t\t\t\tGetDlgItem(nId)->EnableWindow(TRUE);\n\n\t\t\t\tnIndex++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\t\n\t}\n}\n\nBOOL CFaceDbOpreate::OnInitDialog()\n{\n\tBOOL bRet = FALSE;\n\tCDialog::OnInitDialog();\n\n\tg_SetWndStaticText(this);\n\n\tGetDlgItem(IDC_group_PerPage)->EnableWindow(FALSE);\n\tGetDlgItem(IDC_group_NextPage)->EnableWindow(FALSE);\n\n\tClearShowGroupInfo();\n\tif (bRet = GetGroupInfos())\n\t{\n\t\tif (m_nGroupCnt > PERPAGE_INDEX_COUNT)\n\t\t{\n\t\t\tGetDlgItem(IDC_group_NextPage)->EnableWindow(TRUE);\n\t\t}\n\t\tm_nGroupPos = 0;\n\t\tShowGroupInfo();\n\n\t\t((CButton*)GetDlgItem(IDC_RADIO_group1))->SetCheck(1);\n\n\t\tOnSelectGroup();\n\t}\n\n\tCComboBox* ComboChannel = NULL;\n\tfor(int i = 0; i < m_nChnCount; i++)\n\t{\n\t\tComboChannel = (CComboBox*)GetDlgItem(IDC_COMBO_DISPATCH_CHANNEL);\n\t\tCString str = \"\";\n\t\tstr.Format(\"%d\", i + 1);\n\t\tComboChannel->AddString(str);\n\t}\n\n\treturn bRet;  // return TRUE  unless you set the focus to a control\n}\n\nvoid CFaceDbOpreate::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CFaceDbOpreate)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CFaceDbOpreate, CDialog)\n\t//{{AFX_MSG_MAP(CFaceDbOpreate)\n\tON_BN_CLICKED(IDC_BUTTON_DELETE, OnButtonDelete)\n\tON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)\n\tON_BN_CLICKED(IDC_BUTTON_REFRESH, OnButtonRefresh)\n\tON_BN_CLICKED(IDC_BUTTON_Edit, OnBUTTONEdit)\n\tON_BN_CLICKED(IDC_BUTTON_SEARCH, OnButtonPersonOpreate)\n\tON_BN_CLICKED(IDC_BUTTON_DISPATCH, OnButtonDispatch)\n\tON_BN_CLICKED(IDC_RADIO_group1, OnSelectGroup)\n\n\tON_BN_CLICKED(IDC_group_PerPage, OngroupPerPage)\n\tON_BN_CLICKED(IDC_RADIO_group2, OnSelectGroup)\n\tON_BN_CLICKED(IDC_RADIO_group3, OnSelectGroup)\n\tON_BN_CLICKED(IDC_RADIO_group4, OnSelectGroup)\n\tON_BN_CLICKED(IDC_RADIO_group5, OnSelectGroup)\n\tON_BN_CLICKED(IDC_RADIO_group6, OnSelectGroup)\n\tON_BN_CLICKED(IDC_RADIO_group7, OnSelectGroup)\n\tON_BN_CLICKED(IDC_RADIO_group8, OnSelectGroup)\n\tON_BN_CLICKED(IDC_RADIO_group9, OnSelectGroup)\n\tON_BN_CLICKED(IDC_RADIO_group10, OnSelectGroup)\n\tON_BN_CLICKED(IDC_group_NextPage, OngroupNextPage)\n\t//}}AFX_MSG_MAP\n\tON_BN_CLICKED(IDC_BUTTON_DISPATCH_CHANNEL, &CFaceDbOpreate::OnBnClickedButtonDispatchChannel)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CFaceDbOpreate message handlers\n\nvoid CFaceDbOpreate::OnButtonDelete() \n{\n\tif (NULL == m_pstSelectGroup)\n\t{\n\t\tMessageBox(ConvertString(\"Please select a group!\"), \"\");\n\t\treturn;\n\t}\n\n\tNET_FACERECONGNITION_GROUP_INFO *pstGroupInfo = &(m_pstSelectGroup->stuGroupInfo);\n\n\tNET_IN_OPERATE_FACERECONGNITION_GROUP stuInParam = {sizeof(stuInParam)};\n\tNET_OUT_OPERATE_FACERECONGNITION_GROUP stuOutParam = {sizeof(stuOutParam)};\n\tstuInParam.emOperateType = NET_FACERECONGNITION_GROUP_DELETE;\n\tNET_DELETE_FACERECONGNITION_GROUP_INFO stuDeleteInfo = {sizeof(stuDeleteInfo)};\n\tstrncpy(stuDeleteInfo.szGroupId, pstGroupInfo->szGroupId, sizeof(stuDeleteInfo.szGroupId)-1);\n\tstuInParam.pOPerateInfo = &stuDeleteInfo;\n\tBOOL bRet = CLIENT_OperateFaceRecognitionGroup(m_lLoginID, &stuInParam, &stuOutParam, DEFAULT_WAIT_TIME);\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Failed to delete this group!\"), \"\");\n\t\treturn;\n\t}\n\n\tdelete m_pstSelectGroup;\n\tm_pstSelectGroup = NULL;\n\tpstGroupInfo = NULL;\n\n\tCleanGroupList();\n\tif (GetGroupInfos())\n\t{\n\t\tClearShowGroupInfo();\n\t\tShowGroupInfo();\n\t}\n}\n\nvoid CFaceDbOpreate::OnButtonAdd() \n{\n\tCAddGroupDlg AddGroupDlg(m_lLoginID, 1);\n\tint nResponse = AddGroupDlg.DoModal();\n\n\tCleanGroupList();\n\tif (GetGroupInfos())\n\t{\n\t\tClearShowGroupInfo();\n\t\tShowGroupInfo();\n\t}\n}\n\nvoid CFaceDbOpreate::CleanGroupList()\n{\n\tstd::list<NET_GROUP_INFO*>::iterator it = m_lstGroupInfo.begin();\n\twhile(it != m_lstGroupInfo.end())\n\t{\n\t\tNET_GROUP_INFO *pstGroupInfo = *it;\n\t\tif (pstGroupInfo)\n\t\t{\n\t\t\tm_lstGroupInfo.erase(it++);\n\t\t\tdelete pstGroupInfo;\n\t\t\tpstGroupInfo = NULL;\n\t\t}\n\t}\n}\n\nvoid CFaceDbOpreate::ClearShowGroupInfo()\n{\n\tCString str;\n\tfor(int i =0; i < PERPAGE_INDEX_COUNT; i++)\n\t{\n\t\tint nId = IDC_GROUP_ID1+i;\n\t\tSetDlgItemText(nId, \"\");\n\n\t\tnId = IDC_DB_NAME1+i;\n\t\tSetDlgItemText(nId, \"\");\n\t\t\t\n\t\tnId = IDC_PERSON_NUM1 + i;\n\t\tSetDlgItemText(nId, \"\");\n\n\t\tnId = IDC_RADIO_group1 + i;\n\t\t((CButton*)GetDlgItem(nId))->SetCheck(0);\n\t\tGetDlgItem(nId)->EnableWindow(FALSE);\n\t}\n}\n\nvoid CFaceDbOpreate::OnButtonRefresh() \n{\n\tCleanGroupList();\n\tm_nGroupPos = 0;\n\tif (GetGroupInfos())\n\t{\n\t\tClearShowGroupInfo();\n\t\tShowGroupInfo();\n\n\t\tGetDlgItem(IDC_group_PerPage)->EnableWindow(FALSE);\n\t\tGetDlgItem(IDC_group_NextPage)->EnableWindow(TRUE);\n\t\tif (m_nGroupCnt <= PERPAGE_INDEX_COUNT)\n\t\t{\n\t\t\tGetDlgItem(IDC_group_NextPage)->EnableWindow(FALSE);\n\t\t}\n\t\t\n\t\t((CButton*)GetDlgItem(IDC_RADIO_group1))->SetCheck(1);\n\t\tOnSelectGroup();\n\t}\n}\n\nvoid CFaceDbOpreate::OnBUTTONEdit() \n{\n\tif (NULL == m_pstSelectGroup)\n\t{\n\t\tMessageBox(ConvertString(\"Please select a group!\"), \"\");\n\t\treturn;\n\t}\n\n\tNET_FACERECONGNITION_GROUP_INFO *pstGroupInfo = &(m_pstSelectGroup->stuGroupInfo);\n\tCAddGroupDlg EditGroupDlg(m_lLoginID, 2, pstGroupInfo);\n\tint nResponse = EditGroupDlg.DoModal();\n\n\t//  refresh update info \n\tchar *pGroupName = EditGroupDlg.GetEditGroupName();\n\tif (NULL != pGroupName)\n\t{\n\t\tstrncpy(m_pstSelectGroup->stuGroupInfo.szGroupName, pGroupName, sizeof(m_pstSelectGroup->stuGroupInfo.szGroupName)-1);\n\n\t\tint nId = m_nSelectId - IDC_RADIO_group1;\n\t\tCString str;\n\t\tstr.Format(\"%s\", pGroupName);\n\t\tSetDlgItemText(IDC_DB_NAME1+nId, str);\n\t}\n}\n\nvoid CFaceDbOpreate::OnButtonPersonOpreate() \n{\n\tif (NULL == m_pstSelectGroup)\n\t{\n\t\tMessageBox(ConvertString(\"Please select a group!\"), \"\");\n\t\treturn;\n\t}\n\n\tNET_FACERECONGNITION_GROUP_INFO *pstGroupInfo = &(m_pstSelectGroup->stuGroupInfo);\n\t\n\tCPersonOpreateGlg PersonOpreateGlg(m_lLoginID, pstGroupInfo->szGroupId, pstGroupInfo->szGroupName, m_pSoftPath);\n\tPersonOpreateGlg.DoModal();\n}\n\nvoid CFaceDbOpreate::RsetGroupInfo()\n{\n\tif (NULL == m_pstSelectGroup)\n\t{\n\t\treturn;\n\t}\n\n\tint nIndex = 0;\n\tm_pstSelectGroup->stuGroupInfo.nRetChnCount = 0;\n\tm_pstSelectGroup->stuGroupInfo.nRetSimilarityCount = 0;\n\n\tstd::list<NET_GROUP_INFO*>::iterator it = m_lstGroupInfo.begin();\n\tfor (; (it != m_lstGroupInfo.end()); ++it)\n\t{\n\t\tif (*it)\n\t\t{\n\t\t\tNET_GROUP_INFO *pstGroupInfo = *it;\n\t\t\tif (m_pstSelectGroup->nIndex == pstGroupInfo->nIndex)\n\t\t\t{\n\t\t\t\tmemcpy(pstGroupInfo, m_pstSelectGroup, sizeof(*pstGroupInfo));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nvoid CFaceDbOpreate::OnButtonDispatch() \n{\n\tif (NULL == m_pstSelectGroup)\n\t{\n\t\tMessageBox(ConvertString(\"Please select a group!\"), \"\");\n\t\treturn;\n\t}\n\n\tNET_FACERECONGNITION_GROUP_INFO *pstGroupInfo = &(m_pstSelectGroup->stuGroupInfo);\n\tCDispatchGroupDlg DispatchGroupDlg(m_lLoginID, m_nChnCount, pstGroupInfo);\n\tDispatchGroupDlg.DoModal();\n\n\tNET_FACERECONGNITION_GROUP_INFO *pstDispatchGroupInfo = DispatchGroupDlg.GetDispatchGroupInfo();\n\tmemcpy(pstGroupInfo, pstDispatchGroupInfo, sizeof(*pstGroupInfo));\n\n\tstd::list<NET_GROUP_INFO*>::iterator it = m_lstGroupInfo.begin();\n\tfor (; it != m_lstGroupInfo.end(); ++it)\n\t{\n\t\tNET_GROUP_INFO *pstInfo = *it;\n\t\tif (pstInfo)\n\t\t{\n\t\t\tif (0 == strcmp(pstInfo->stuGroupInfo.szGroupId, pstGroupInfo->szGroupId))\n\t\t\t{\n\t\t\t\tmemcpy(&(pstInfo->stuGroupInfo), pstGroupInfo, sizeof(pstInfo->stuGroupInfo));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid CFaceDbOpreate::OnSelectGroup() \n{\n\tint nIndex = m_nGroupPos;\n\tint nId = IDC_RADIO_group1;\n\n\tfor (nIndex = m_nGroupPos+IDC_RADIO_group1; nIndex < (nIndex+PERPAGE_INDEX_COUNT); nIndex++)\n\t{\n\t\tif (((CButton *)GetDlgItem(nId))->GetCheck())\n\t\t{\n\t\t\tm_nSelectId = nId;\n\t\t\tstd::list<NET_GROUP_INFO*>::iterator it = m_lstGroupInfo.begin();\n\t\t\tfor (; it != m_lstGroupInfo.end(); ++it)\n\t\t\t{\n\t\t\t\tNET_GROUP_INFO *pstGroupInfo = *it;\n\t\t\t\tif ((NULL != pstGroupInfo) && (nIndex == pstGroupInfo->nIndex))\n\t\t\t\t{\n\t\t\t\t\tif (NULL == m_pstSelectGroup)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_pstSelectGroup = new NET_GROUP_INFO;\n\t\t\t\t\t}\n\t\t\t\t\tif (NULL == m_pstSelectGroup)\n\t\t\t\t\t{\n\t\t\t\t\t\tMessageBox(ConvertString(\"Memory error\"), \"\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tmemset(m_pstSelectGroup, 0, sizeof(*m_pstSelectGroup));\n\t\t\t\t\tmemcpy(m_pstSelectGroup, pstGroupInfo, sizeof(*m_pstSelectGroup));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t\tnId++;\n\t}\n\n\tif (NULL == m_pstSelectGroup)\n\t{\n\t\treturn;\n\t}\n\n\tNET_FACERECONGNITION_GROUP_INFO *pstSelectInfo = &(m_pstSelectGroup->stuGroupInfo);\n\tCString str;\n\tstr.Format(\"%s\", pstSelectInfo->szGroupName);\n\tSetDlgItemText(IDC_DB_NAME, str);\n}\n\n\nvoid CFaceDbOpreate::OngroupPerPage() \n{\n\tClearShowGroupInfo();\n\tm_nGroupPos -= PERPAGE_INDEX_COUNT;\n\tGetDlgItem(IDC_group_NextPage)->EnableWindow(TRUE);\n\tif (0 == m_nGroupPos)\n\t{\n\t\tGetDlgItem(IDC_group_PerPage)->EnableWindow(FALSE);\n\t}\n\tShowGroupInfo();\n}\n\nvoid CFaceDbOpreate::OngroupNextPage() \n{\n\tClearShowGroupInfo();\n\tm_nGroupPos += PERPAGE_INDEX_COUNT;\n\tGetDlgItem(IDC_group_PerPage)->EnableWindow(TRUE);\n\tif (m_nGroupPos+PERPAGE_INDEX_COUNT >= m_nGroupCnt)\n\t{\n\t\tGetDlgItem(IDC_group_NextPage)->EnableWindow(FALSE);\n\t}\n\tShowGroupInfo();\n}\n\nvoid CFaceDbOpreate::OnBnClickedButtonDispatchChannel()\n{\n\tCComboBox *ComboxChannel = (CComboBox *)GetDlgItem(IDC_COMBO_DISPATCH_CHANNEL);\n\tint nSel = ComboxChannel->GetCurSel();\n\tif (CB_ERR == ComboxChannel->GetCurSel())\n\t{\n\t\tMessageBox(ConvertString(\"Please select a channel!\"), \"\");\n\t\treturn;\n\t}\n\n\tCDispatchGroupChannelDlg dlg(m_lLoginID, nSel + 1);\n\tdlg.DoModal();\n}\n\nBOOL CFaceDbOpreate::PreTranslateMessage(MSG* pMsg)\n{\n\tif(pMsg->message == WM_KEYDOWN &&\n\t\tpMsg->wParam == VK_RETURN)\n\t{\n\t\treturn TRUE;\n\t}\n\n\treturn CDialog::PreTranslateMessage(pMsg);\n}\n","size_bytes":13026},"bin/Demo/MfcDemo/10.AlarmDevice/DlgLocalBypass.cpp":{"content":"// DlgLocalBypass.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgLocalBypass.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgLocalBypass dialog\n\n\nCDlgLocalBypass::CDlgLocalBypass(CWnd* pParent /*=NULL*/, BOOL bNeedMode, int nWantToSetChannelCount)\n\t: CDialog(CDlgLocalBypass::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgLocalBypass)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_bNeedMode = bNeedMode;\n\tm_nWantToSetChannelCount = nWantToSetChannelCount;\n\tfor (int i = 0; i < 16; ++i)\n\t{\t\n\t\tm_pemLocalMode[i] = NET_BYPASS_MODE_UNKNOW;\n\t}\n\tmemset(m_pnLocalChannel, 0, sizeof(m_pnLocalChannel));\n\n\tm_nLastCount = 0;\n\tm_nActualCount = 0;\n}\n\n\nvoid CDlgLocalBypass::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgLocalBypass)\n\tDDX_Control(pDX, IDOK, m_btnOk);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgLocalBypass, CDialog)\n\t//{{AFX_MSG_MAP(CDlgLocalBypass)\n\tON_WM_DESTROY()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgLocalBypass message handlers\nBOOL CDlgLocalBypass::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_LOCAL_BYPASS);\n\t// TODO: Add extra initialization here\n\tif (m_bNeedMode)\n\t{\n\t\tCreateWithModeDialog();\n\t\tStuToDlg();\n\t} \n\telse\n\t{\n\t\tCreateWithoutModeDialog();\n\t}\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t// EXCEPTION: OCX Property Pages should return FALSE\n}\nvoid CDlgLocalBypass::CreateWithModeDialog()\n{\n\tint i = 0, j = 0, k = 0;\n\tfor (i = 0; i < 16; ++i)\n\t{\n\t\tif (i%8 == 0)\n\t\t{\n\t\t\tk = 0;\n\t\t\t++j;\n\t\t}\n\t\tchar szIndex[32] = {0};\n\t\t_itoa(i + 1, szIndex, 10);\n\t\tcBtnChannel[i].Create(szIndex, WS_CHILD|WS_VISIBLE|BS_AUTOCHECKBOX|BS_DEFPUSHBUTTON, CRect(10+50*k, 30*j+30*j, 60+50*k, 30+30*j+30*j), this, 100+i);\n\t\tcBtnMode[i].Create(\"\", WS_CHILD|WS_VISIBLE|BS_AUTOCHECKBOX|BS_DEFPUSHBUTTON, CRect(10+50*k, 30*j+30*j+30, 60+50*k, 60+30*j+30*j), this, 300+i);\n\n\t\t++k;\n\t}\n\tMoveWindow(0, 0, 420, 200+30*j);\n\tCenterWindow();\n\tCRect cRectTemp;\n\tGetDlgItem(IDOK)->GetClientRect(cRectTemp);\n\tGetDlgItem(IDOK)->MoveWindow(100, 120+30*j, cRectTemp.Width(), cRectTemp.Height());\n\tGetDlgItem(IDCANCEL)->GetClientRect(cRectTemp);\n\tGetDlgItem(IDCANCEL)->MoveWindow(220, 120+30*j, cRectTemp.Width(), cRectTemp.Height());\n}\n\t\nvoid CDlgLocalBypass::CreateWithoutModeDialog()\n{\n\tint i = 0, j = 0, k = 0;\n\tfor (i = 0; i < 16; ++i)\n\t{\n\t\tif (i%8 == 0)\n\t\t{\n\t\t\tk = 0;\n\t\t\t++j;\n\t\t}\n\t\tchar szIndex[32] = {0};\n\t\t_itoa(i + 1, szIndex, 10);\n\t\tcBtnChannel[i].Create(szIndex, WS_CHILD|WS_VISIBLE|BS_AUTOCHECKBOX|BS_DEFPUSHBUTTON, CRect(10+50*k, 30*j, 60+50*k, 30+30*j), this, 100+i);\n\t\t++k;\n\t}\n\tMoveWindow(0, 0, 420, 130+30*j);\n\tCenterWindow();\n\tCRect cRectTemp;\n\tGetDlgItem(IDOK)->GetClientRect(cRectTemp);\n\tGetDlgItem(IDOK)->MoveWindow(100, 50+30*j, cRectTemp.Width(), cRectTemp.Height());\n\tGetDlgItem(IDCANCEL)->GetClientRect(cRectTemp);\n\tGetDlgItem(IDCANCEL)->MoveWindow(220, 50+30*j, cRectTemp.Width(), cRectTemp.Height());\n}\n\nvoid CDlgLocalBypass::OnOK() \n{\n\t// TODO: Add extra validation here\n\tfor (int i = 0; i < 16; ++i)\n\t{\n\t\tif (BST_CHECKED == cBtnChannel[i].GetCheck())\n\t\t{\n\t\t\tm_pnLocalChannel[m_nActualCount] = i;\n\t\t\t++m_nActualCount;\n\t\t\tif (m_nActualCount >= m_nWantToSetChannelCount)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tCDialog::OnOK();\n}\n\nvoid CDlgLocalBypass::OnDestroy() \n{\n\tCDialog::OnDestroy();\n\t\n}\n\nvoid CDlgLocalBypass::StuToDlg()\n{\n\tint nTempChannel = 0;\n\tfor (int i = 0; i < m_nLastCount; ++i)\n\t{\n\t\tnTempChannel = m_pnLocalChannel[i];\n\t\tcBtnChannel[nTempChannel].SetCheck(BST_CHECKED);\n\t\tif (m_pemLocalMode[i] == NET_BYPASS_MODE_BYPASS)\n\t\t{\t\t\n\t\t\tcBtnMode[nTempChannel].SetCheck(BST_CHECKED);\n\t\t}\n\t}\n}","size_bytes":3882},"bin/Demo/MfcDemo/10.AlarmDevice/DlgStateBattery.cpp":{"content":"// DlgStateBattery.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgStateBattery.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgStateBattery dialog\n\n\nCDlgStateBattery::CDlgStateBattery(CWnd* pParent /*=NULL*/, LLONG hLoginID)\n\t: CDialog(CDlgStateBattery::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgStateBattery)\n\tm_csPercent = _T(\"\");\n\tm_hLoginID = hLoginID;\n\tm_nBatteryNum = 0;\n\n\tmemset(m_bPowerState, 0, sizeof(m_bPowerState));\n\tmemset(m_bBatteryState, 0, sizeof(m_bBatteryState));\n\tmemset(m_nBatteryPercent, 0, sizeof(m_nBatteryPercent));\t\n\tm_nPowerNum = 0;\n\tm_nBatteryNum = 0;\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CDlgStateBattery::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgStateBattery)\n\tDDX_Control(pDX, IDC_CHK_CHARGE, m_chkIsCharging);\n\tDDX_Control(pDX, IDC_PGS_PERCENT, m_prgPercent);\n\tDDX_Control(pDX, IDC_CMB_POWER_INDEX, m_cbPowerIndex);\n\tDDX_Control(pDX, IDC_CMB_BATTERY_INDEX, m_cbBatteryIndex);\n\tDDX_Control(pDX, IDC_CMB_STATE, m_cbState);\n\tDDX_Text(pDX, IDC_BATTERY_EDT_PERCENT, m_csPercent);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgStateBattery, CDialog)\n\t//{{AFX_MSG_MAP(CDlgStateBattery)\n\tON_BN_CLICKED(IDC_BATTERY_BTN_GET, OnBtnGet)\n\tON_CBN_SELCHANGE(IDC_CMB_BATTERY_INDEX, OnSelchangeCmbBatteryIndex)\n\tON_CBN_SELCHANGE(IDC_CMB_POWER_INDEX, OnSelchangeCmbPowerIndex)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgStateBattery message handlers\n\nBOOL CDlgStateBattery::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_STATE_BATTERY);\n\t\n\tif (!m_hLoginID)\n\t{\n\t\tMessageBox(ConvertString(\"we haven't login a device yet!\", DLG_STATE_BATTERY), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\n\t// TODO: Add extra initialization here\n\tm_nPowerNum = 0;\n\tm_nBatteryNum = 0;\n\tmemset(m_bPowerState, 0, sizeof(m_bPowerState));\n\tmemset(m_bBatteryState, 0, sizeof(m_bBatteryState));\n\tmemset(m_nBatteryPercent, 0, sizeof(m_nBatteryPercent));\n\n\tm_cbState.InsertString(-1, ConvertString(\"Off\", DLG_STATE_BATTERY));\n\tm_cbState.InsertString(-1, ConvertString(\"On\", DLG_STATE_BATTERY));\n\tm_cbState.SetCurSel(0);\n\tm_cbState.EnableWindow(FALSE);\n\n\tm_chkIsCharging.EnableWindow(FALSE);\n\n\tBOOL bRet = GetPowerState();\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Query power state failed.\", DLG_STATE_BATTERY), ConvertString(\"Prompt\"));\n\t}\n\n\tUpdateData(FALSE);\n\treturn TRUE;  \n\t// return TRUE unless you set the focus to a control\n    // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgStateBattery::OnBtnGet() \n{\n\t// TODO: Add your control notification handler code here\n\tBOOL bRet = GetPowerState();\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(\"Query power state failed.\", DLG_STATE_BATTERY), ConvertString(\"Prompt\"));\n\t}\n\telse\n\t{\n\t\tMessageBox(ConvertString(\"Query power state successfully.\", DLG_STATE_BATTERY), ConvertString(\"Prompt\"));\n\t}\n}\n\nvoid CDlgStateBattery::OnSelchangeCmbBatteryIndex() \n{\n\t// TODO: Add your control notification handler code here\n\tint nIndex = m_cbBatteryIndex.GetCurSel();\n\tif (nIndex >= 0 && nIndex < 16)\n\t{\n\t\tm_chkIsCharging.SetCheck(m_bBatteryState[nIndex]);\n\t\tif (m_nBatteryPercent[nIndex]<=100 && m_nBatteryPercent[nIndex]>=0)\n\t\t{\n\t\t\tm_prgPercent.SetPos(m_nBatteryPercent[nIndex]);\n\t\t\tm_csPercent.Empty();\n\t\t\tm_csPercent.Format(\"%d\", m_nBatteryPercent[nIndex]);\n\t\t}\n\t}\n\tUpdateData(TRUE);\n\n}\n\nvoid CDlgStateBattery::OnSelchangeCmbPowerIndex() \n{\n\t// TODO: Add your control notification handler code here\n\tint nIndex = m_cbPowerIndex.GetCurSel();\n\tif (nIndex >= 0 && nIndex < 16)\n\t{\n\t\tm_cbState.SetCurSel(m_bPowerState[nIndex]);\n\t}\n}\n\nBOOL CDlgStateBattery::GetPowerState()\n{\n\tint nRetLen = 0;\n\tDH_POWER_STATUS stuPowerStatus = { sizeof(DH_POWER_STATUS) };\n\tBOOL bRet = CLIENT_QueryDevState((LLONG)m_hLoginID, DH_DEVSTATE_POWER_STATE, (char*)&stuPowerStatus, sizeof(DH_POWER_STATUS), &nRetLen, SDK_API_WAIT);\n\tif (bRet)\n\t{\n\t\tm_nPowerNum = stuPowerStatus.nCount;\n\t\tm_nBatteryNum = stuPowerStatus.nBatteryNum;\n\t\tInitPower(m_nPowerNum, &stuPowerStatus);\n\t\tInitBattery(m_nBatteryNum, &stuPowerStatus);\n\t}\n\telse\n\t{\n\t\tCString csOut;\n\t\tcsOut.Format(\"%s %08x\", ConvertString(\"Query power state failed:\", DLG_STATE_BATTERY), CLIENT_GetLastError());\n\t\tMessageBox(csOut, ConvertString(\"Prompt\"));\n\t}\n\treturn bRet;\n}\n\nvoid CDlgStateBattery::InitPower(INT nNum, DH_POWER_STATUS *pstuInpara)\n{\n\tif (nNum > 0 && nNum <= DH_MAX_POWER_NUM)\n\t{\n\t\tm_cbPowerIndex.ResetContent();\n\t\tfor (int i=0; i<nNum; i++)\n\t\t{\n\t\t\tCString csStr;\n\t\t\tcsStr.Format(\"%s %d\", ConvertString(\"Power\", DLG_STATE_BATTERY), i+1);\n\t\t\tm_cbPowerIndex.InsertString(-1, csStr);\n\t\t\tm_bPowerState[i] = pstuInpara->stuPowers[i].bPowerOn;\n\t\t}\n\t\tm_cbPowerIndex.SetCurSel(0);\n\t\tm_cbState.SetCurSel(m_bPowerState[0]);\n\t}\n}\n\nvoid CDlgStateBattery::InitBattery(INT nNum, DH_POWER_STATUS *pstuInpara)\n{\n\tif (nNum >0 && nNum <= DH_MAX_BATTERY_NUM)\n\t{\n\t\tm_cbBatteryIndex.ResetContent();\n\t\tfor (int i=0; i<nNum; i++)\n\t\t{\n\t\t\tCString csStr;\n\t\t\tcsStr.Format(\"%s %d\",ConvertString(\"Battery\", DLG_STATE_BATTERY), i+1);\n\t\t\tm_cbBatteryIndex.InsertString(-1, csStr);\n\t\t\tm_bBatteryState[i] = pstuInpara->stuBatteries[i].bCharging;\n\t\t\tm_nBatteryPercent[i] = pstuInpara->stuBatteries[i].nPercent;\n\t\t}\n\t\tm_cbBatteryIndex.SetCurSel(0);\n\t\tm_prgPercent.SetPos(m_nBatteryPercent[0]);\n\t\tm_csPercent.Empty();\n\t\tm_csPercent.Format(\"%d\", m_nBatteryPercent[0]);\n\t\tm_chkIsCharging.SetCheck(m_bBatteryState[0]);\n\t}\n}\n\n\n","size_bytes":5584},"bin/DemoSrc/playsdkdemo/LanguageConvertor.cpp":{"content":"// LanguageConvertor.cpp: implementation of the CLanguageConvertor class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"PlayDemo.h\"\n#include \"LanguageConvertor.h\"\n\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\n//////////////////////////////////////////////////////////////////////\n// Construction/Destruction\n//////////////////////////////////////////////////////////////////////\nTCHAR CLanguageConvertor::m_szIniFile[MAX_PATH] = {0};\n\n\nint CLanguageConvertor::Init()\n{\n\t_stprintf(m_szIniFile, _T(\"%s%s\"), GetMoudlePath(), _T(\"lang.ini\"));\n\treturn 1;\n}\n\nCString CLanguageConvertor::ConvertString(CString strText)\n{\n\tif(strText.GetLength())\n\t{\n\t\t/*find the value of the variable whose keyword is strText in the translation file*/\n\t\tTCHAR val[300];\n\t\tGetPrivateProfileString(_T(\"String\"), strText, strText, val, sizeof(val), m_szIniFile);\n\t\treturn val;\n\t}\n\n\treturn strText;\n}\n\nvoid CLanguageConvertor::SetWndStaticText(CWnd * pWnd)\n{\n\tCString strCaption,strText;\n\n\tpWnd->GetWindowText(strCaption);\n\tif(strCaption.GetLength()>0)\n\t{\n\t\tstrText=ConvertString(strCaption);\n\t\tpWnd->SetWindowText(strText);\n\t}\n\n\tCWnd * pChild=pWnd->GetWindow(GW_CHILD);\n\tCString strClassName;\n\twhile(pChild)\n\t{\n\t\tstrClassName = ((CRuntimeClass*)pChild->GetRuntimeClass())->m_lpszClassName;\n\t\tif(strClassName == \"CEdit\")\n\t\t{\n\t\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t\t\tcontinue;\n\t\t}\n\t\t//////////////////////////////////////////////////////////////////////////\n\t\tpChild->GetWindowText(strCaption);\n\t\tstrText=ConvertString(strCaption);\n\t\tpChild->SetWindowText(strText);\n\t\tpChild=pChild->GetWindow(GW_HWNDNEXT);\n\t}\n}\n\nvoid CLanguageConvertor::SetMenuStaticText(CMenu* pMenu)\n{\n\tCString strCaption,strText;\n\t\n\tint MenuItemNum = pMenu->GetMenuItemCount() ;\n\t\n\tfor (int i = 0 ; i < MenuItemNum ; i++)\n\t{\t\t\n\t\tMENUITEMINFO info;\n\t\tmemset(&info, 0 , sizeof(MENUITEMINFO)) ;\n\t\tinfo.cbSize = sizeof (MENUITEMINFO); // must fill up this field\n\t\tinfo.fMask = MIIM_STATE;             // get the state of the menu item\n\t\t\n\t\tpMenu->GetMenuString(i, strCaption, MF_BYPOSITION);\n\t\t\n\t\tstrText=ConvertString(strCaption);\n\t\t\n\t\tUINT ID = pMenu->GetMenuItemID(i) ;\n\t\t\n\t\tif (ID != -1)\n\t\t{\n\t\t\tpMenu->GetMenuItemInfo(ID, &info) ;\n\t\t\tpMenu->ModifyMenu(ID, MF_BYCOMMAND|MF_STRING, ID, strText);\n\t\t\tSetMenuItemInfo(pMenu->m_hMenu, ID, FALSE, &info) ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpMenu->ModifyMenu(i, MF_BYPOSITION| MF_STRING, 0, strText);\n\t\t\tif (strCaption == \"Fisheye View\")\n\t\t\t{\n\t\t\t\tpMenu->EnableMenuItem(i, MF_BYPOSITION| MF_GRAYED);\n\t\t\t}\n\t\t}\n\t\t\n\t\tCMenu* subMenu = pMenu->GetSubMenu(i) ;\n\t\t\n\t\tif (subMenu != NULL)\n\t\t{\t\t\t\n\t\t\tSetMenuStaticText(subMenu) ;\n\t\t}\n\t}\n}","size_bytes":2707},"bin/Demo/MfcDemo/01.RealPlayAndPTZControl/MultiPlay.cpp":{"content":"// MultiPlay.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"RealPlayAndPTZControl.h\"\n#include \"MultiPlay.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CMultiPlay dialog\n\n\nCMultiPlay::CMultiPlay(CWnd* pParent /*=NULL*/)\n\t: CDialog(CMultiPlay::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CMultiPlay)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_nMultiPlay = 0;\n\tm_nChannel = 0;\n\tm_nChannelCount = 0;\n}\n\n\nvoid CMultiPlay::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CMultiPlay)\n\tDDX_Control(pDX, IDC_COMBO_BEGINCHANNEL, m_comboChannel);\n\tDDX_Control(pDX, IDC_COMBO_MULTI, m_comboMulti);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CMultiPlay, CDialog)\n\t//{{AFX_MSG_MAP(CMultiPlay)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CMultiPlay message handlers\n\nvoid CMultiPlay::OnOK() \n{\n\t// TODO: Add extra validation here\n\tint nIndex = m_comboMulti.GetCurSel();\n\tif(CB_ERR != nIndex)\n\t{\n\t\tm_nMultiPlay = m_comboMulti.GetItemData(nIndex);\n\t}\n\tnIndex = m_comboChannel.GetCurSel();\n\tif(CB_ERR != nIndex)\n\t{\n\t\tm_nChannel = m_comboChannel.GetItemData(nIndex);\n\t}\n\tCDialog::OnOK();\n}\n\n//Set dropdown menu \nvoid CMultiPlay::SetMultiPlayDlgInfo(int nChannelCount)\n{\n\tm_nChannelCount = nChannelCount;\n}\n\nBOOL CMultiPlay::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\t// TODO: Add extra initialization here\n\t//Channel dropdown menu \n\tm_comboChannel.ResetContent();\n\tint i = 0;\n\tint nIndex = 0;\n\tfor(i=0;i<m_nChannelCount;i++)\n\t{\n\t\tCString str;\n\t\tstr.Format(\"%d\",i);\n\t\tnIndex = m_comboChannel.AddString(str);\n\t\tm_comboChannel.SetItemData(nIndex,i);\n\t}\n\tif(0 < m_comboChannel.GetCount())\n\t{\n\t\tm_comboChannel.SetCurSel(0);\n\t}\n\t//Video amount dropdown menu \n\tm_comboMulti.ResetContent();\n\tnIndex = m_comboMulti.AddString(ConvertString(\"Single\"));\n\tm_comboMulti.SetItemData(nIndex,1);\n\tnIndex = m_comboMulti.AddString(ConvertString(\"Split-4\"));\n\tm_comboMulti.SetItemData(nIndex,4);\n\tnIndex = m_comboMulti.AddString(ConvertString(\"Split-8\"));\n\tm_comboMulti.SetItemData(nIndex,8);\n\tnIndex = m_comboMulti.AddString(ConvertString(\"Split-9\"));\n\tm_comboMulti.SetItemData(nIndex,9);\n\tnIndex = m_comboMulti.AddString(ConvertString(\"Split-16\"));\n\tm_comboMulti.SetItemData(nIndex,16);\n\tif(0 < m_comboMulti.GetCount())\n\t{\n\t\tm_comboMulti.SetCurSel(0);\n\t}\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":3015},"bin/Demo/MfcDemo/01.RealPlayAndPTZControl/PtzMenu.cpp":{"content":"// DHPtzMenu.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"RealPlayAndPTZControl.h\"\n#include \"PtzMenu.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CPtzMenu dialog\n\n\nCPtzMenu::CPtzMenu(CWnd* pParent /*=NULL*/)\n\t: CDialog(CPtzMenu::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CPtzMenu)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_Channel=-1;\n\tm_DeviceID=0;\n}\n\n\nvoid CPtzMenu::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CPtzMenu)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CPtzMenu, CDialog)\n\t//{{AFX_MSG_MAP(CPtzMenu)\n\tON_BN_CLICKED(IDC_OPR_UP, OnOprUp)\n\tON_BN_CLICKED(IDC_OPR_DOWN, OnOprDown)\n\tON_BN_CLICKED(IDC_OPR_LEFT, OnOprLeft)\n\tON_BN_CLICKED(IDC_OPR_RIGHT, OnOprRight)\n\tON_BN_CLICKED(IDC_OPR_OPENMENU, OnOprOpenmenu)\n\tON_BN_CLICKED(IDC_OPR_CLOSEMENU, OnOprClosemenu)\n\tON_BN_CLICKED(IDC_OPR_OK, OnOprOk)\n\tON_BN_CLICKED(IDC_OPR_CANCEL, OnOprCancel)\n\tON_WM_CANCELMODE()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CPtzMenu message handlers\n\nvoid CPtzMenu::SetPtzParam(LLONG iHandle, int iChannel)\n{\n\tm_DeviceID = iHandle;\n\tm_Channel = iChannel;\n}\n\nvoid CPtzMenu::PtzMemuControl(DWORD dwCommand)\n{\n\tif(0 != m_DeviceID)\n\t{\n\t\tBOOL bRet = CLIENT_DHPTZControl(m_DeviceID, m_Channel,dwCommand ,0,0,0,FALSE);\n\t\tif(!bRet)\n\t\t{\t\n\t\t\tMessageBox(ConvertString(\"operate PTZ menu \"), ConvertString(\"Prompt\"));\n\t\t}\n\t}\n}\n\n//Move up \nvoid CPtzMenu::OnOprUp() \n{\n\t// TODO: Add your control notification handler code here\n\tPtzMemuControl(DH_EXTPTZ_MENUUP);\n}\n\n//Move down \nvoid CPtzMenu::OnOprDown() \n{\n\t// TODO: Add your control notification handler code here\n\tPtzMemuControl(DH_EXTPTZ_MENUDOWN);\n}\n\n//Move left \nvoid CPtzMenu::OnOprLeft() \n{\n\t// TODO: Add your control notification handler code here\n\tPtzMemuControl(DH_EXTPTZ_MENULEFT);\n}\n\n//Move right \nvoid CPtzMenu::OnOprRight() \n{\n\t// TODO: Add your control notification handler code here\n\tPtzMemuControl(DH_EXTPTZ_MENURIGHT);\n}\n\n//Open menu \nvoid CPtzMenu::OnOprOpenmenu() \n{\n\t// TODO: Add your control notification handler code here\n\tPtzMemuControl(DH_EXTPTZ_OPENMENU);\n}\n\n//Close menu \nvoid CPtzMenu::OnOprClosemenu() \n{\n\t// TODO: Add your control notification handler code here\n\tPtzMemuControl(DH_EXTPTZ_CLOSEMENU);\n}\n\n//Confirm \nvoid CPtzMenu::OnOprOk() \n{\n\t// TODO: Add your control notification handler code here\n\tPtzMemuControl(DH_EXTPTZ_MENUOK);\n}\n\n//Cancel \nvoid CPtzMenu::OnOprCancel() \n{\n\t// TODO: Add your control notification handler code here\n\tPtzMemuControl(DH_EXTPTZ_MENUCANCEL);\n}\n\nBOOL CPtzMenu::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\t// TODO: Add extra initialization here\n\tg_SetWndStaticText(this);\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CPtzMenu::OnCancelMode() \n{\n\tCDialog::OnCancelMode();\n\t\n\t// TODO: Add your message handler code here\n\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":3510},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/SelectPannel.cpp":{"content":"// SelectPannel.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"SelectPannel.h\"\n#include \"NetSDKDemoDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CSelectPannel dialog\n\n\nCSelectPannel::CSelectPannel(CWnd* pParent /*=NULL*/)\n\t: CDialog(CSelectPannel::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CSelectPannel)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CSelectPannel::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CSelectPannel)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CSelectPannel, CDialog)\n\t//{{AFX_MSG_MAP(CSelectPannel)\n\tON_BN_CLICKED(IDC_BTN_SEL_DEVLIST, OnBtnSelDevlist)\n\tON_BN_CLICKED(IDC_BTN_SEL_PTZ, OnBtnSelPtz)\n\tON_BN_CLICKED(IDC_BTN_SEL_COLOR, OnBtnSelColor)\n\tON_BN_CLICKED(IDC_BTN_SEL_PLAYCTRL, OnBtnSelPlayctrl)\n\tON_BN_CLICKED(IDC_BTN_SEL_NORMAL, OnBtnSelNormal)\n\tON_BN_CLICKED(IDC_BTN_SEL_ADVANCE, OnBtnSelAdvance)\n\tON_BN_CLICKED(IDC_BTN_SEL_DATA, OnBtnSelData)\n\tON_WM_DRAWITEM()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CSelectPannel message handlers\n\nvoid CSelectPannel::OnBtnSelDevlist() \n{\n\t((CNetSDKDemoDlg *)GetParent())->SeleteDevListPannel();\n}\n\nvoid CSelectPannel::OnBtnSelPtz() \n{\n\t((CNetSDKDemoDlg *)GetParent())->SeletePTZPannel();\n}\n\nvoid CSelectPannel::OnBtnSelColor() \n{\n\t((CNetSDKDemoDlg *)GetParent())->SeleteColorPannel();\n}\n\nvoid CSelectPannel::OnBtnSelPlayctrl() \n{\n\t((CNetSDKDemoDlg *)GetParent())->SeletePlayCtrlPannel();\n}\n\nvoid CSelectPannel::OnBtnSelNormal() \n{\n\t((CNetSDKDemoDlg *)GetParent())->SeleteNormalPannel();\n}\n\nvoid CSelectPannel::OnBtnSelAdvance() \n{\n\t((CNetSDKDemoDlg *)GetParent())->SeleteAdvancePannel();\n}\n\nvoid CSelectPannel::OnBtnSelData() \n{\n\t\n}\n\nBOOL CSelectPannel::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\tg_SetWndStaticText(this);\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nBOOL CSelectPannel::PreTranslateMessage(MSG* pMsg) \n{\n\tif (WM_KEYDOWN == pMsg->message && \n\t\t(VK_ESCAPE == pMsg->wParam || VK_RETURN == pMsg->wParam))\n\t{\n\t\treturn TRUE;\n\t}\n\t\n\treturn CDialog::PreTranslateMessage(pMsg);\n}\n\nvoid CSelectPannel::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct) \n{\n\tCDC dc;\n\tBOOL b = dc.Attach(lpDrawItemStruct->hDC);\n\n\tif (b)\n\t{\n\t\tswitch(nIDCtl)\n\t\t{\n\t\tcase IDC_BTN_SEL_NORMAL:\n\t\t\t{\t\n\t\t\t\tCRect rect;\n\t\t\t\tGetDlgItem(nIDCtl)->GetClientRect(&rect);\n\t\t\t\tCBrush brush;\n\t\t\t\tbrush.CreateSolidBrush(RGB(200,200,255));\n\t\t\t\tdc.FillRect(&rect, &brush);\n\t\t\t\t\n\t\t\t\trect.DeflateRect(1,1);\n\t\t\t\tdc.DrawFocusRect(&rect);\n\t\t\t\t\n\t\t\t\trect.DeflateRect(10,3);\n\t\t\t\tint mode = dc.SetBkMode(TRANSPARENT);\n\t\t\t\tdc.DrawText(ConvertString(NAME_BTN_NORMAL), &rect, 0);\n\t\t\t\tdc.SetBkMode(mode);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase IDC_BTN_SEL_ADVANCE:\n\t\t\t{\n\t\t\t\tCRect rect;\n\t\t\t\tGetDlgItem(nIDCtl)->GetClientRect(&rect);\n\t\t\t\t\n\t\t\t\tCBrush brush;\n\t\t\t\tbrush.CreateSolidBrush(RGB(170,170,255));\n\t\t\t\tdc.FillRect(&rect, &brush);\n\t\t\t\t\n\t\t\t\trect.DeflateRect(1,1);\n\t\t\t\tdc.DrawFocusRect(&rect);\n\t\t\t\t\n\t\t\t\trect.DeflateRect(10,3);\n\t\t\t\tint mode = dc.SetBkMode(TRANSPARENT);\n\t\t\t\tdc.DrawText(ConvertString(NAME_BTN_ADVANCE), &rect, 0);\n\t\t\t\tdc.SetBkMode(mode);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase IDC_BTN_SEL_PTZ:\n\t\t\t{\t\n\t\t\t\tCRect rect;\n\t\t\t\tGetDlgItem(nIDCtl)->GetClientRect(&rect);\n\t\t\t\tCBrush brush;\n\t\t\t\tbrush.CreateSolidBrush(RGB(140,140, 255));\n\t\t\t\tdc.FillRect(&rect, &brush);\n\t\t\t\t\n\t\t\t\trect.DeflateRect(1,1);\n\t\t\t\tdc.DrawFocusRect(&rect);\n\t\t\t\t\n\t\t\t\trect.DeflateRect(12,3);\n\t\t\t\tint mode = dc.SetBkMode(TRANSPARENT);\n\t\t\t\tdc.DrawText(ConvertString(NAME_BTN_PTZ), &rect, 0);\n\t\t\t\tdc.SetBkMode(mode);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase IDC_BTN_SEL_DEVLIST:\n\t\t\t{\n\t\t\t\tCRect rect;\n\t\t\t\tGetDlgItem(nIDCtl)->GetClientRect(&rect);\n\t\t\t\t\n\t\t\t\tCBrush brush;\n\t\t\t\tbrush.CreateSolidBrush(RGB(255,255,255));\n\t\t\t\tdc.FillRect(&rect, &brush);\n\t\t\t\t\n\t\t\t\trect.DeflateRect(1,1);\n\t\t\t\tdc.DrawFocusRect(&rect);\n\t\t\t\t\n\t\t\t\trect.DeflateRect(3,3);\n\t\t\t\tint mode = dc.SetBkMode(TRANSPARENT);\n\t\t\t\tdc.DrawText(ConvertString(NAME_BTN_DEVLIST), &rect, 0);\n\t\t\t\tdc.SetBkMode(mode);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase IDC_BTN_SEL_COLOR:\n\t\t\t{\t\n\t\t\t\tCRect rect;\n\t\t\t\tGetDlgItem(nIDCtl)->GetClientRect(&rect);\n\t\t\t\tCBrush brush;\n\t\t\t\tbrush.CreateSolidBrush(RGB(220,220,220));\n\t\t\t\tdc.FillRect(&rect, &brush);\n\t\t\t\t\n\t\t\t\trect.DeflateRect(1,1);\n\t\t\t\tdc.DrawFocusRect(&rect);\n\t\t\t\t\n\t\t\t\trect.DeflateRect(5,3);\n\t\t\t\tint mode = dc.SetBkMode(TRANSPARENT);\n\t\t\t\tdc.DrawText(ConvertString(NAME_BTN_COLOR), &rect, 0);\n\t\t\t\tdc.SetBkMode(mode);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase IDC_BTN_SEL_DATA:\n\t\t\t{\n\t\t\t\tCRect rect;\n\t\t\t\tGetDlgItem(nIDCtl)->GetClientRect(&rect);\n\t\t\t\t\n\t\t\t\tCBrush brush;\n\t\t\t\tbrush.CreateSolidBrush(RGB(195,195,195));\n\t\t\t\tdc.FillRect(&rect, &brush);\n\t\t\t\t\n\t\t\t\trect.DeflateRect(1,1);\n\t\t\t\tdc.DrawFocusRect(&rect);\n\t\t\t\t\n\t\t\t\trect.DeflateRect(5,3);\n\t\t\t\tint mode = dc.SetBkMode(TRANSPARENT);\n\t\t\t\tdc.DrawText(ConvertString(NAME_BTN_CBDATA), &rect, 0);\n\t\t\t\tdc.SetBkMode(mode);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase IDC_BTN_SEL_PLAYCTRL:\n\t\t\t{\n\t\t\t\tCRect rect;\n\t\t\t\tGetDlgItem(nIDCtl)->GetClientRect(&rect);\n\t\t\t\t\n\t\t\t\tCBrush brush;\n\t\t\t\tbrush.CreateSolidBrush(RGB(170,170,170));\n\t\t\t\tdc.FillRect(&rect, &brush);\n\t\t\t\t\n\t\t\t\trect.DeflateRect(1,1);\n\t\t\t\tdc.DrawFocusRect(&rect);\n\t\t\t\t\n\t\t\t\trect.DeflateRect(5,3);\n\t\t\t\tint mode = dc.SetBkMode(TRANSPARENT);\n\t\t\t\tdc.DrawText(ConvertString(NAME_BTN_PBCTRL), &rect, 0);\n\t\t\t\tdc.SetBkMode(mode);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\t\n\t\t}\n\t}\n\t\n\tCDialog::OnDrawItem(nIDCtl, lpDrawItemStruct);\n}\n","size_bytes":5689},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgSTP.cpp":{"content":"// DlgCfgSTP.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgCfgSTP.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgSTP dialog\n\n\nCDlgCfgSTP::CDlgCfgSTP(CWnd* pParent /*=NULL*/, LLONG lLoginId)\n\t: CDialog(CDlgCfgSTP::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgCfgSTP)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_lLoginId = lLoginId;\n\tmemset(&m_stuInfo, 0, sizeof(m_stuInfo));\n}\n\n\nvoid CDlgCfgSTP::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgCfgSTP)\n\tDDX_Control(pDX, IDC_STP_CHECK_ENABLE, m_ckEnable);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgCfgSTP, CDialog)\n\t//{{AFX_MSG_MAP(CDlgCfgSTP)\n\tON_BN_CLICKED(IDC_STP_BUTTON_GET, OnStpButtonGet)\n\tON_BN_CLICKED(IDC_STP_BUTTON_SET, OnStpButtonSet)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgCfgSTP message handlers\n\nBOOL CDlgCfgSTP::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_STP);\n\t// TODO: Add extra initialization here\n\tif (m_lLoginId == 0)\n\t{\n\t\tMessageBox(ConvertString(\"Please login first!\", DLG_CFG_STP), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\n\tif (getCfgFromDevice())\n\t{\n\t\tStuToDlg();\n\t}\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgCfgSTP::OnStpButtonGet() \n{\n\t// TODO: Add your control notification handler code here\n\tif (getCfgFromDevice())\n\t{\n\t\tStuToDlg();\n\t}\n}\n\nvoid CDlgCfgSTP::OnStpButtonSet() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\tsetCfgToDevice();\n}\n\nvoid CDlgCfgSTP::DlgToStu()\n{\n\tm_stuInfo.bEnable = m_ckEnable.GetCheck() ? TRUE : FALSE;\n}\n\nvoid CDlgCfgSTP::StuToDlg()\n{\n\tm_ckEnable.SetCheck(m_stuInfo.bEnable ? BST_CHECKED : BST_UNCHECKED);\n}\n\nBOOL CDlgCfgSTP::getCfgFromDevice()\n{\n\tif (m_lLoginId == 0)\n\t{\n\t\tMessageBox(ConvertString(\"Please login first!\", DLG_CFG_STP), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\tchar szOutBuffer[1024] = {0};\n\tint nerror = 0;\n\n\tBOOL bRet = CLIENT_GetNewDevConfig(m_lLoginId, CFG_CMD_STP, -1, szOutBuffer, 1024, &nerror, SDK_API_WAIT);\n\tif (bRet)\n\t{\n\t\tDWORD dwRetLen = 0;\t\t\n\t\tbRet = CLIENT_ParseData(CFG_CMD_STP, szOutBuffer, (void*)&m_stuInfo, sizeof(m_stuInfo), &dwRetLen);\n\t\tif (!bRet)\n\t\t{\n\t\t\tMessageBox(ConvertString(CString(\"parse STP error...\"), DLG_CFG_STP), ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\t\t\t\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"get Config STP error:\", DLG_CFG_STP), CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nBOOL CDlgCfgSTP::setCfgToDevice()\n{\n\tif (m_lLoginId == 0)\n\t{\n\t\tMessageBox(ConvertString(\"Please login first!\", DLG_CFG_STP), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\n\tchar szJsonBuf[1024] = {0};\n\tBOOL bRet = CLIENT_PacketData(CFG_CMD_STP, (void*)&m_stuInfo, sizeof(m_stuInfo), szJsonBuf, sizeof(szJsonBuf));\n\tif (!bRet)\n\t{\n\t\tMessageBox(ConvertString(CString(\"packet STP error...\"), DLG_CFG_STP), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t} \n\telse\n\t{\n\t\tint nerror = 0;\n\t\tint nrestart = 0;\n\t\tbRet = CLIENT_SetNewDevConfig(m_lLoginId, CFG_CMD_STP, -1, szJsonBuf, sizeof(szJsonBuf), &nerror, &nrestart, SDK_API_WAIT);\n\t\tif (!bRet)\n\t\t{\n\t\t\tCString csErr;\n\t\t\tcsErr.Format(\"%s %08x\", ConvertString(\"SetupConfig STP failed:\", DLG_CFG_STP), CLIENT_GetLastError());\n\t\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n","size_bytes":3703},"bin/Demo/MfcIntegratedDemo/NetSDKDemo/ConfigComm.cpp":{"content":"// ConfigComm.cpp : implementation file\n//\n\n#include \"StdAfx.h\"\n#include \"netsdkdemo.h\"\n#include \"ConfigComm.h\"\n#include \"NetSDKDemoDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CConfigComm dialog\n\n\nCConfigComm::CConfigComm(CWnd* pParent /*=NULL*/)\n\t: CDialog(CConfigComm::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CConfigComm)\n\t//}}AFX_DATA_INIT\n\tm_pDev = 0;\n\tmemset(&m_comCFG, 0, sizeof(DHDEV_COMM_CFG));\n\tm_bInited = FALSE;\n\n\tm_232Index = -1;\n\tm_485Index = -1;\n}\n\t\n\nvoid CConfigComm::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CConfigComm)\n\tDDX_Control(pDX, IDC_COMBO_STOPBIT485, m_stopbit485sel);\n\tDDX_Control(pDX, IDC_COMBO_STOPBIT232, m_stopbit232sel);\n\tDDX_Control(pDX, IDC_COMBO_PROTOCOL485, m_protocol485sel);\n\tDDX_Control(pDX, IDC_COMBO_PARITY485, m_parity485sel);\n\tDDX_Control(pDX, IDC_COMBO_PARITY232, m_parity232sel);\n\tDDX_Control(pDX, IDC_COMBO_FUNCTION232, m_function232sel);\n\tDDX_Control(pDX, IDC_COMBO_485COM, m_485comsel);\n\tDDX_Control(pDX, IDC_COMBO_232COM, m_232comsel);\n\tDDX_Control(pDX, IDC_COMBO_DATABIT485, m_databit485sel);\n\tDDX_Control(pDX, IDC_COMBO_DATABIT232, m_databit232sel);\n\tDDX_Control(pDX, IDC_COMBO_BAUD485, m_baud485sel);\n\tDDX_Control(pDX, IDC_COMBO_BAUD232, m_baud232sel);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CConfigComm, CDialog)\n\t//{{AFX_MSG_MAP(CConfigComm)\n\tON_CBN_SELCHANGE(IDC_COMBO_232COM, OnSelchangeCombo232com)\n\tON_CBN_SELCHANGE(IDC_COMBO_485COM, OnSelchangeCombo485com)\n\tON_WM_SHOWWINDOW()\n\tON_BN_CLICKED(IDC_UNDO_ALL, OnUndoAll)\n\tON_BN_CLICKED(IDC_APPLY, OnApply)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\nvoid CConfigComm::GetConfig()\n{\n\tif (!m_pDev || m_bInited)\n\t{\n\t\treturn;\n\t}\n\n\twhile(m_function232sel.GetCount() > 0)\n\t{\n\t\tm_function232sel.DeleteString(0);\n\t}\n\twhile(m_protocol485sel.GetCount() > 0)\n\t{\n\t\tm_protocol485sel.DeleteString(0);\n\t}\n\n\tDWORD retlen = 0;\n\tBOOL bRet = CLIENT_GetDevConfig(m_pDev->LoginID, DH_DEV_COMMCFG, 0,\n\t\t\t\t\t\t\t\t&m_comCFG, sizeof(DHDEV_COMM_CFG), &retlen, CONFIG_WAITTIME);\n\tint aaa = sizeof(DHDEV_COMM_CFG);\n\tif (!bRet || retlen != sizeof(DHDEV_COMM_CFG))\n\t{\n\t\t((CNetSDKDemoDlg*)AfxGetMainWnd())->LastError();\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tm_bInited = TRUE;\n\t}\n\t\n\t//show config information\n\tfor (int i = 0; i < m_comCFG.dw232FuncNameNum; i++)\n\t{\n\t\tm_function232sel.InsertString(i, (char *)m_comCFG.s232FuncName[i]);\n\t}\n\tfor (int j = 0; j < m_comCFG.dwDecProListNum; j++)\n\t{\n\t\tm_protocol485sel.InsertString(j, (char *)m_comCFG.DecProName[j]);\n\t}\n\tif (m_232comsel.GetCount() > 0)\n\t{\n\t\tm_232comsel.SetCurSel(0);\n\t\tOnSelchangeCombo232com();\n\t}\n\tif (m_485comsel.GetCount() > 0)\n\t{\n\t\tm_485comsel.SetCurSel(0);\n\t\tOnSelchangeCombo485com();\n\t}\n}\nvoid CConfigComm::SetDevice(DeviceNode *pDev)\n{\n\tm_pDev = pDev;\n}\n\nBOOL CConfigComm::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\tg_SetWndStaticText(this);\n\t\n\tif (!m_pDev)\n\t{\n\t\treturn TRUE;\n\t}\n\t\n\tDWORD retlen = 0;\n\tDHDEV_SYSTEM_ATTR_CFG sysCFG = {0};\n\tBOOL bRet = CLIENT_GetDevConfig(m_pDev->LoginID, DH_DEV_DEVICECFG, 0,\n\t\t\t\t\t\t\t\t&sysCFG, sizeof(DHDEV_SYSTEM_ATTR_CFG), &retlen, CONFIG_WAITTIME);\n\tif (!bRet || retlen != sizeof(DHDEV_SYSTEM_ATTR_CFG))\n\t{\n\t\treturn TRUE;\n\t}\n\n\tCString strCom;\n\tfor (int i = 0; i < sysCFG.byComIONum; i++)\n\t{\n\t\tstrCom.Format(ConvertString(\"COM %d\"), i+1);\n\t\tm_232comsel.InsertString(i, strCom);\n\t}\n\tCString strDecoder;\n\tfor (int j = 0; j < m_pDev->Info.byChanNum; j++)\n\t{\n\t\tstrDecoder.Format(ConvertString(\"Decoder %d\"), j+1);\n\t\tm_485comsel.InsertString(j, strDecoder);\n\t}\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CConfigComm::OnSelchangeCombo232com() \n{\n\tif (!m_bInited)\n\t{\n\t\treturn;\n\t}\n\t//store current selection\n\tif (m_232Index >= 0)\n\t{\n\t\tm_comCFG.st232[m_232Index].byFunction = m_function232sel.GetCurSel();\n\t\tm_comCFG.st232[m_232Index].struComm.byDataBit = m_databit232sel.GetCurSel();\n\t\tm_comCFG.st232[m_232Index].struComm.byStopBit = m_stopbit232sel.GetCurSel();\n\t\tm_comCFG.st232[m_232Index].struComm.byBaudRate = m_baud232sel.GetCurSel();\n\t\tm_comCFG.st232[m_232Index].struComm.byParity = m_parity232sel.GetCurSel();\n\t}\n\n\t//show new ones\n\tint Idx232 = m_232comsel.GetCurSel();\n\tif (Idx232 < 0 || Idx232 >= DH_MAX_232_NUM) \n\t{\n\t\treturn;\n\t}\n\t\n\tm_function232sel.SetCurSel(m_comCFG.st232[Idx232].byFunction);\n\tm_databit232sel.SetCurSel(m_comCFG.st232[Idx232].struComm.byDataBit);\n\tm_stopbit232sel.SetCurSel(m_comCFG.st232[Idx232].struComm.byStopBit);\n\tm_baud232sel.SetCurSel(m_comCFG.st232[Idx232].struComm.byBaudRate);\n\tm_parity232sel.SetCurSel(m_comCFG.st232[Idx232].struComm.byParity);\n\n\tm_232Index = Idx232;\n}\n\nvoid CConfigComm::OnSelchangeCombo485com() \n{\n\tif (!m_bInited)\n\t{\n\t\treturn;\n\t}\n\tif (m_485Index >= 0)\n\t{\n\t\tm_comCFG.stDecoder[m_485Index].wProtocol = m_protocol485sel.GetCurSel();\n\t\tm_comCFG.stDecoder[m_485Index].struComm.byDataBit = m_databit485sel.GetCurSel();\n\t\tm_comCFG.stDecoder[m_485Index].struComm.byStopBit = m_stopbit485sel.GetCurSel();\n\t\tm_comCFG.stDecoder[m_485Index].struComm.byBaudRate = m_baud485sel.GetCurSel();\n\t\tm_comCFG.stDecoder[m_485Index].struComm.byParity = m_parity485sel.GetCurSel();\n\t\tm_comCFG.stDecoder[m_485Index].wDecoderAddress = GetDlgItemInt(IDC_EDIT_ADDR485);\n\t}\n\n\tint Idx485 = m_485comsel.GetCurSel();\n\tif (Idx485 < 0 || Idx485 >= DH_MAX_DECODER_NUM) \n\t{\n\t\treturn;\n\t}\n\t\n\tm_protocol485sel.SetCurSel(m_comCFG.stDecoder[Idx485].wProtocol);\n\tm_databit485sel.SetCurSel(m_comCFG.stDecoder[Idx485].struComm.byDataBit);\n\tm_stopbit485sel.SetCurSel(m_comCFG.stDecoder[Idx485].struComm.byStopBit);\n\tm_baud485sel.SetCurSel(m_comCFG.stDecoder[Idx485].struComm.byBaudRate);\n\tm_parity485sel.SetCurSel(m_comCFG.stDecoder[Idx485].struComm.byParity);\n\tSetDlgItemInt(IDC_EDIT_ADDR485, m_comCFG.stDecoder[Idx485].wDecoderAddress);\n\n\tm_485Index = Idx485;\n}\n\nvoid CConfigComm::OnShowWindow(BOOL bShow, UINT nStatus) \n{\n\tCDialog::OnShowWindow(bShow, nStatus);\n\t\n\tif (bShow)\n\t{\n\t\tGetConfig();\n\t}\n}\n\nvoid CConfigComm::OnUndoAll() \n{\n\tm_bInited = FALSE;\n\tm_232Index = -1;\n\tm_485Index = -1;\n\tGetConfig();\n}\n\nvoid CConfigComm::OnApply() \n{\n\tif (!m_bInited)\n\t{\n\t\treturn;\n\t}\n\n\tint Idx232 = m_232comsel.GetCurSel();\n\tif (Idx232 < 0)\n\t{\n\t\treturn;\n\t}\n\tm_comCFG.st232[Idx232].byFunction = m_function232sel.GetCurSel();\n\tm_comCFG.st232[Idx232].struComm.byDataBit = m_databit232sel.GetCurSel();\n\tm_comCFG.st232[Idx232].struComm.byStopBit = m_stopbit232sel.GetCurSel();\n\tm_comCFG.st232[Idx232].struComm.byBaudRate = m_baud232sel.GetCurSel();\n\tm_comCFG.st232[Idx232].struComm.byParity = m_parity232sel.GetCurSel();\n\n\tint Idx485 = m_485comsel.GetCurSel();\n\tif (Idx485 < 0)\n\t{\n\t\treturn;\n\t}\n\tm_comCFG.stDecoder[Idx485].wProtocol = m_protocol485sel.GetCurSel();\n\tm_comCFG.stDecoder[Idx485].struComm.byDataBit = m_databit485sel.GetCurSel();\n\tm_comCFG.stDecoder[Idx485].struComm.byStopBit = m_stopbit485sel.GetCurSel();\n\tm_comCFG.stDecoder[Idx485].struComm.byBaudRate = m_baud485sel.GetCurSel();\n\tm_comCFG.stDecoder[Idx485].struComm.byParity = m_parity485sel.GetCurSel();\n\tm_comCFG.stDecoder[Idx485].wDecoderAddress = GetDlgItemInt(IDC_EDIT_ADDR485);\n\n\tBOOL bRet = CLIENT_SetDevConfig(m_pDev->LoginID, DH_DEV_COMMCFG, 0,\n\t\t\t\t\t\t\t\t&m_comCFG, 16*sizeof(DHDEV_COMM_CFG), CONFIG_WAITTIME);\n\tif (!bRet)\n\t{\n\t\t((CNetSDKDemoDlg*)AfxGetMainWnd())->LastError();\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tMessageBox(ConvertString(MSG_CONFIG_SUCCESS), \"OK\");\n\t}\n}\n","size_bytes":7462},"bin/Demo/MfcDemo/09.AccessControl/StdAfx.cpp":{"content":"// stdafx.cpp : source file that includes just the standard includes\n//\tAccessControl.pch will be the pre-compiled header\n//\tstdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n\n\n\n","size_bytes":207},"bin/Demo/MfcDemo/09.AccessControl/SubDlgSensorInfoDescription.cpp":{"content":"// SubDlgSensorInfoDescription.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AccessControl.h\"\n#include \"SubDlgSensorInfoDescription.h\"\n#include <algorithm>\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CSubDlgSensorInfoDescription dialog\n\n\nCSubDlgSensorInfoDescription::CSubDlgSensorInfoDescription(CWnd* pParent /* = NULL */, int nMaxSensor /* = 72 */)\n\t: CDialog(CSubDlgSensorInfoDescription::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CSubDlgSensorInfoDescription)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tnMaxSensor <= 0 ? (m_nMaxSensor = 72) : (m_nMaxSensor = nMaxSensor);\n\tm_pbtnCheck = NULL;\n}\n\n\nvoid CSubDlgSensorInfoDescription::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CSubDlgSensorInfoDescription)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CSubDlgSensorInfoDescription, CDialog)\n\t//{{AFX_MSG_MAP(CSubDlgSensorInfoDescription)\n\tON_WM_DESTROY()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CSubDlgSensorInfoDescription private method\n\nvoid CSubDlgSensorInfoDescription::InitDlg()\n{\n\tint nCfgCount = m_nMaxSensor;\n\tint nColumnMaxCount = 4;\n\tint nRowMaxCount = (nCfgCount%nColumnMaxCount == 0 ? nCfgCount/nColumnMaxCount : (nCfgCount/nColumnMaxCount + 1));\n\tint nBtnWidth = 150;\t// 100 * 1.5 \n\tint nBtnHeight = 20;\t// 10 * 1.5\n\tint nInterval = 6;\n\t\n\t{\t\t\n\t\tCRect rcBtn;\n\t\tGetDlgItem(IDOK)->GetClientRect(&rcBtn);\n\t\t\n\t\tint nWndWidth = nBtnWidth * nColumnMaxCount + nInterval * (nColumnMaxCount + 1);\n\t\tint nWndHeight = nBtnHeight * nRowMaxCount + nInterval * (nRowMaxCount + 1)\n\t\t\t+ (rcBtn.Height()*2 + nInterval * 4);\n\t\tMoveWindow(0, 0, nWndWidth, nWndHeight);\n\t\t\n\t\tGetDlgItem(IDOK)->MoveWindow(nWndWidth / 2 - rcBtn.Width() - nInterval, nWndHeight - rcBtn.Height()*2 - nInterval * 2, \n\t\t\trcBtn.Width(), rcBtn.Height());\n\t\tGetDlgItem(IDCANCEL)->MoveWindow(nWndWidth / 2 + nInterval, nWndHeight - rcBtn.Height()*2 - nInterval * 2,\n\t\t\trcBtn.Width(), rcBtn.Height());\n\t\t\n\t\tCenterWindow();\n\t}\n\t\n\tm_pbtnCheck = new CButton[nCfgCount];\n\tassert(m_pbtnCheck);\n\t\n\tfor (int i = 0; i < nCfgCount; i++)\n\t{\n\t\tm_pbtnCheck[i].Create(\"\", WS_CHILD | WS_VISIBLE | /*BS_CHECKBOX |*/ BS_AUTOCHECKBOX, \n\t\t\tCRect(0, 0, 0, 0), this, emBtnID_base + i);\n\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%d\", i + 1);\n\t\tm_pbtnCheck[i].SetWindowText(csInfo);\n\n\t\tif (IsSet(i))\n\t\t{\n\t\t\tm_pbtnCheck[i].SetCheck(BST_CHECKED);\n\t\t}\n\t\t\n\t\tint nSpaceX = i - i/nColumnMaxCount * nColumnMaxCount;\n\t\tint nSpaceY = (i - i%nColumnMaxCount) / nColumnMaxCount;//i - i/nRowMaxCount * nRowMaxCount;\n\t\t\n\t\tm_pbtnCheck[i].MoveWindow(nInterval * (1 + nSpaceX) + nBtnWidth * nSpaceX, \n\t\t\tnInterval * (1 + nSpaceY) + nBtnHeight * nSpaceY, \n\t\t\tnBtnWidth, nBtnHeight, TRUE);\n\t}\n}\n\nvoid CSubDlgSensorInfoDescription::SetID(const std::vector<int>& vecID)\n{\t\n\tm_vecChannel = vecID;\n}\n\nconst std::vector<int>& CSubDlgSensorInfoDescription::GetID()\n{\n\treturn m_vecChannel;\n}\n\nBOOL CSubDlgSensorInfoDescription::IsSet(int nChannel)\n{\n\tstd::vector<int>::iterator it = std::find(m_vecChannel.begin(), m_vecChannel.end(), nChannel);\n\tif (it != m_vecChannel.end())\n\t{\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CSubDlgSensorInfoDescription message handlers\n\nBOOL CSubDlgSensorInfoDescription::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CSubDlgSensorInfoDescription::OnOK() \n{\n\t// TODO: Add extra validation here\n\tm_vecChannel.clear();\n\tfor (int i = 0; i < m_nMaxSensor; i++)\n\t{\n\t\tif (m_pbtnCheck[i].GetCheck())\n\t\t{\n\t\t\tm_vecChannel.push_back(i);\n\t\t}\n\t}\n\tCDialog::OnOK();\n}\n\nvoid CSubDlgSensorInfoDescription::OnDestroy() \n{\n\tCDialog::OnDestroy();\n\t\n\t// TODO: Add your message handler code here\n\tif (m_pbtnCheck)\n\t{\n\t\tfor (int i = 0; i < m_nMaxSensor; i++)\n\t\t{\n\t\t\tif (m_pbtnCheck[i].GetSafeHwnd())\n\t\t\t{\n\t\t\t\tm_pbtnCheck[i].DestroyWindow();\n\t\t\t}\n\t\t}\n\t\tdelete []m_pbtnCheck;\n\t\tm_pbtnCheck = NULL;\n\t}\n}\n","size_bytes":4379},"bin/Demo/MfcDemo/03.Alarm/AlarmDlg.cpp":{"content":"// AlarmDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"Alarm.h\"\n#include \"AlarmDlg.h\"\n#include \"resource.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n#define WM_DEVICE_ALARM\t\t\t(WM_USER + 1)\t\t\t\t// Self-define message: Device alarm\n#define WM_DEVICE_DISCONNECT\t(WM_USER + 100)\n#define WM_DEVICE_RECONNECT\t\t(WM_USER + 101)\n\nstruct DEVICE_ALARM_INFO \n{\n    int             nAlarmType;\n    char*           pBuf;\n    unsigned int    nBufSize;\n};\n\n/////////////////////////////////////////////////////////////////////////////\n// CAboutDlg dialog used for App About\n\nclass CAboutDlg : public CDialog\n{\npublic:\n\tCAboutDlg();\n\n// Dialog Data\n\t//{{AFX_DATA(CAboutDlg)\n\tenum { IDD = IDD_ABOUTBOX };\n\t//}}AFX_DATA\n\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CAboutDlg)\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n\t//}}AFX_VIRTUAL\n\n// Implementation\nprotected:\n\t//{{AFX_MSG(CAboutDlg)\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\n};\n\nCAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)\n{\n\t//{{AFX_DATA_INIT(CAboutDlg)\n\t//}}AFX_DATA_INIT\n}\n\nvoid CAboutDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CAboutDlg)\n\t//}}AFX_DATA_MAP\n}\n\nBEGIN_MESSAGE_MAP(CAboutDlg, CDialog)\n\t//{{AFX_MSG_MAP(CAboutDlg)\n\t\t// No message handlers\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CAlarmDlg dialog\n\nCAlarmDlg::CAlarmDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CAlarmDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CAlarmDlg)\n\tm_dvrPort = 37777;\n\tm_strDvrUserName = _T(\"admin\");\n\tm_strDvrPwd = _T(\"admin\");\n\t//}}AFX_DATA_INIT\n\t// Note that LoadIcon does not require a subsequent DestroyIcon in Win32\n\tm_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);\n\tm_bIsListen = FALSE;\n\n\tmemset(&stuTime,0,sizeof(SYSTEMTIME));\n\tmemset(&stuTimeLater,0,sizeof(SYSTEMTIME));\n\n\tm_LoginID = 0;\n\tm_pTabDevAlarmDlg = NULL;\n\tm_pTabQueryAlarm = NULL;\n}\n\nvoid CAlarmDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CAlarmDlg)\n\tDDX_Control(pDX, IDC_IPADDRESS_DVRIP, m_dvrIP);\n\tDDX_Control(pDX, IDC_TAB1, m_Tab);\n\tDDX_Text(pDX, IDC_EDIT_PORT, m_dvrPort);\n//\tDDV_MinMaxInt(pDX, m_dvrPort, 0, 100000);\n\tDDX_Text(pDX, IDC_EDIT_USERNAME, m_strDvrUserName);\n\tDDX_Text(pDX, IDC_EDIT_DVRPWD, m_strDvrPwd);\n\t//}}AFX_DATA_MAP\n}\n\nBEGIN_MESSAGE_MAP(CAlarmDlg, CDialog)\n\t//{{AFX_MSG_MAP(CAlarmDlg)\n\tON_WM_SYSCOMMAND()\n\tON_WM_PAINT()\n\tON_WM_QUERYDRAGICON()\n\tON_NOTIFY(TCN_SELCHANGE, IDC_TAB1, OnSelchangeTab1)\n\tON_WM_DESTROY()\n\tON_BN_CLICKED(IDC_BTN_LOGIN, OnBtnLogin)\n\tON_BN_CLICKED(IDC_BTN_LOGOUT, OnBtnLogout)\n    ON_MESSAGE(WM_DEVICE_ALARM, OnDevAlarm)\t\n\tON_MESSAGE(WM_DEVICE_DISCONNECT, OnDisConnect)\n\tON_MESSAGE(WM_DEVICE_RECONNECT, OnReConnect)\n\tON_WM_TIMER()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CAlarmDlg message handlers\n\nBOOL CAlarmDlg::OnInitDialog()\n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\t// Add \"About...\" menu item to system menu.\n\n\t// IDM_ABOUTBOX must be in the system command range.\n\tASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);\n\tASSERT(IDM_ABOUTBOX < 0xF000);\n\n\tCMenu* pSysMenu = GetSystemMenu(FALSE);\n\tif (pSysMenu != NULL)\n\t{\n\t\tCString strAboutMenu;\n\t\tstrAboutMenu.LoadString(IDS_ABOUTBOX);\n\t\tif (!strAboutMenu.IsEmpty())\n\t\t{\n\t\t\tpSysMenu->AppendMenu(MF_SEPARATOR);\n\t\t\tpSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);\n\t\t}\n\t}\n\n\t// Set the icon for this dialog.  The framework does this automatically\n\t//  when the application's main window is not a dialog\n\tSetIcon(m_hIcon, TRUE);\t\t\t// Set big icon\n\tSetIcon(m_hIcon, FALSE);\t\t// Set small icon\n\t\n\t// TODO: Add extra initialization here\n\t//Initialize TabControl\n\tInitTabControl();\n\t//Device default IP\n\tm_dvrIP.SetAddress(172,23,1,112);\n\n\t//Initialize net SDK\n\tInitNetSDK();\n\treturn TRUE;  // return TRUE  unless you set the focus to a control\n}\n\nvoid CAlarmDlg::OnSysCommand(UINT nID, LPARAM lParam)\n{\n\tif ((nID & 0xFFF0) == IDM_ABOUTBOX)\n\t{\n\t\tCAboutDlg dlgAbout;\n\t\tdlgAbout.DoModal();\n\t}\n\telse\n\t{\n\t\tCDialog::OnSysCommand(nID, lParam);\n\t}\n}\n\n// If you add a minimize button to your dialog, you will need the code below\n//  to draw the icon.  For MFC applications using the document/view model,\n//  this is automatically done for you by the framework.\n\nvoid CAlarmDlg::OnPaint() \n{\n\tif (IsIconic())\n\t{\n\t\tCPaintDC dc(this); // device context for painting\n\n\t\tSendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);\n\n\t\t// Center icon in client rectangle\n\t\tint cxIcon = GetSystemMetrics(SM_CXICON);\n\t\tint cyIcon = GetSystemMetrics(SM_CYICON);\n\t\tCRect rect;\n\t\tGetClientRect(&rect);\n\t\tint x = (rect.Width() - cxIcon + 1) / 2;\n\t\tint y = (rect.Height() - cyIcon + 1) / 2;\n\n\t\t// Draw the icon\n\t\tdc.DrawIcon(x, y, m_hIcon);\n\t}\n\telse\n\t{\n\t\tCDialog::OnPaint();\n\t}\n}\n\n// The system calls this to obtain the cursor to display while the user drags\n//  the minimized window.\nHCURSOR CAlarmDlg::OnQueryDragIcon()\n{\n\treturn (HCURSOR) m_hIcon;\n}\n\nvoid CAlarmDlg::SetDlgState(CWnd *pWnd, BOOL bShow)\n{\n\tif(bShow)\n\t{\n\t\tpWnd->ShowWindow(SW_SHOW);\n\t\t//Display in the middle \n\t\tpWnd->CenterWindow();\n\t}\n\telse\n\t{\n\t\tpWnd->ShowWindow(SW_HIDE);\n\t}\n}\n\nvoid CAlarmDlg::DoTab(int nTab)\n{\n\t//Confirm nTab is within the threshold\n\tif(nTab > 1)\n\t{\n\t\tnTab = 1;\n\t}\n\tif(nTab < 0)\n\t{\n\t\tnTab = 0;\n\t}\n\t\n\tBOOL bTab[2];\n\tbTab[0]=bTab[1]=FALSE;\n\tbTab[nTab]=TRUE;\n \n    SetDlgState(m_pTabDevAlarmDlg, bTab[0]);\n\tSetDlgState(m_pTabQueryAlarm, bTab[1]);\n}\n\nvoid CAlarmDlg::OnSelchangeTab1(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\t// TODO: Add your control notification handler code here\n\tint nSelect = m_Tab.GetCurSel();\n\tif(nSelect>=0)\n\t{\n\t\tDoTab(nSelect);\n\t}\n\t*pResult = 0;\n}\n\n//Initialize TabControl\nvoid CAlarmDlg::InitTabControl()\n{\t\n\tm_pTabDevAlarmDlg = new CDevAlarmDlg;\n\tm_pTabQueryAlarm =new CQueryAlarmState();\n\t//Create no-mode dialog box, specify tag control is the father-window of the no-mode dialog box.\t\n    m_pTabDevAlarmDlg->Create(IDD_DIALOG_ALARM, &m_Tab);\n\tm_pTabQueryAlarm->Create(IDD_DIALOG_QUERYALARMSTATE,&m_Tab);\n\n\tm_Tab.InsertItem(0, ConvertString(\"Device Alarm\"));\n\tm_Tab.InsertItem(1, ConvertString(\"Alarm Query\"));\n\t\n\tm_Tab.SetMinTabWidth(80);\n\tm_Tab.SetPadding(CSize(15,3));\n\tm_Tab.SetCurSel(0);\n\tDoTab(0);\n}\n\nvoid CAlarmDlg::OnDestroy() \n{\n\tCDialog::OnDestroy();\n\t\n\t// TODO: Add your message handler code here\n\tif(m_pTabDevAlarmDlg) delete m_pTabDevAlarmDlg;\n\tif(m_pTabQueryAlarm) delete m_pTabQueryAlarm;\n\n\t//Stop listening device message \n\tif(m_bIsListen)\n\t{\n\t\tm_bIsListen = FALSE;\n\t\tCLIENT_StopListen(m_LoginID);\n\t}\n\t\n\t//Log off \n\tif(0 != m_LoginID)\n\t{\n\t\tCLIENT_Logout(m_LoginID);\n\t}\n\t//Clear SDK and then release occupied resources \n\tCLIENT_Cleanup();\n}\n\nBOOL CAlarmDlg::PreTranslateMessage(MSG* pMsg) \n{\n\t// TODO: Add your specialized code here and/or call the base class\n\tif(pMsg->message == WM_KEYDOWN)\n\t{\n\t\t//Enter\n\t\tif(pMsg->wParam == VK_RETURN) return TRUE;\n\t\t//ESC\n\t\tif(pMsg->wParam == VK_ESCAPE) return TRUE;\n\t}\n\n\treturn CDialog::PreTranslateMessage(pMsg);\n}\n\n//Initialize net SDK\nvoid CAlarmDlg::InitNetSDK()\n{\n\tBOOL ret = CLIENT_Init(DisConnectFunc, (LDWORD)this);\n\tif (ret)\n\t{\n\t\t//Set message callback function. It is to receive all device messages by default.\n\t\tCLIENT_SetDVRMessCallBack(MessCallBack, (LDWORD)this);\n\t\tCLIENT_SetAutoReconnect(ReConnectFunc, (LDWORD)this);\n\t}\n\telse\n\t{\n\t\tMessageBox(ConvertString(\"Initialize SDK failed!\"), ConvertString(\"Prompt\"));\n\t}\n}\n\n//Callback function when device disconnected \nvoid CALLBACK DisConnectFunc(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser)\n{\n\tif(dwUser == 0)\n\t{\n\t\treturn;\n\t}\n\n\tCAlarmDlg *pThis = (CAlarmDlg *)dwUser;\n\tHWND hWnd = pThis->GetSafeHwnd();\n\tif (NULL == hWnd)\n\t{\n\t\treturn;\n\t}\n\tPostMessage(hWnd, WM_DEVICE_DISCONNECT, NULL, NULL);\t\t\n}\n\n//Callback function when device reconnect \nvoid CALLBACK ReConnectFunc(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser)\n{\n\tif(dwUser == 0)\n\t{\n\t\treturn;\n\t}\n\n\tCAlarmDlg *pThis = (CAlarmDlg *)dwUser;\n\tHWND hWnd = pThis->GetSafeHwnd();\n\tif (NULL == hWnd)\n\t{\n\t\treturn;\n\t}\n\tPostMessage(hWnd, WM_DEVICE_RECONNECT, NULL, NULL);\t\t\n}\n\n//Message callback process function. It is a callback of the whole SDK.\nBOOL CALLBACK MessCallBack(LONG lCommand, LLONG lLoginID, char *pBuf, DWORD dwBufLen, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser)\n{\n    DEVICE_ALARM_INFO* pAlarmInfo = new DEVICE_ALARM_INFO;\n    pAlarmInfo->nAlarmType = lCommand;\n    pAlarmInfo->nBufSize = dwBufLen;\n    pAlarmInfo->pBuf = new char[dwBufLen];\n    \n    memcpy(pAlarmInfo->pBuf, pBuf, dwBufLen);\n\n    ((CAlarmDlg*)dwUser)->PostMessage(WM_DEVICE_ALARM, (WPARAM)pAlarmInfo, NULL);\n\n    return TRUE;\t\n}\n\n//Process when device disconnected \nLRESULT CAlarmDlg::OnDisConnect(WPARAM wParam, LPARAM lParam)\n{\n\t//Add process code when device disconnected\n\tSetWindowText(ConvertString(\"Network disconnected\"));\n\treturn 0;\n}\n\n//Process when device reconnect \nLRESULT CAlarmDlg::OnReConnect(WPARAM wParam, LPARAM lParam)\n{\n\t//Add process code when device reconnect\n\tSetWindowText(ConvertString(\"Alarm\"));\n\treturn 0;\n}\n\n//Register user to Device \nvoid CAlarmDlg::OnBtnLogin() \n{\n\tSetWindowText(ConvertString(\"Alarm\"));\n\t// TODO: Add your control notification handler code here\n\tBOOL bValid = UpdateData(TRUE);\n\tif(bValid)\n\t{\n\t\tint err=0;\t//Storage the possible returned error\n\t\tchar *pchDVRIP;\n\t\tCString strDvrIP = GetDvrIP();\n\t\tpchDVRIP = (LPSTR)(LPCSTR)strDvrIP;\n\t\tWORD wDVRPort=(WORD)m_dvrPort;\n\t\tchar *pchUserName=(LPSTR)(LPCSTR)m_strDvrUserName;\n\t\tchar *pchPassword=(LPSTR)(LPCSTR)m_strDvrPwd;\n\n\t\t//Device information\n\t\tNET_DEVICEINFO_Ex deviceInfo;\n\t\t//Call log in interface \n\n        m_LoginID = CLIENT_LoginEx2(pchDVRIP, wDVRPort, pchUserName, pchPassword, \n                        EM_LOGIN_SPEC_CAP_TCP, NULL, &deviceInfo, &err);\n\n\t\tif(0 == m_LoginID)\n\t\t{\n\t\t\t//Display log in failure reason \n\t\t\tShowLoginErrorReason(err);\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tGetDlgItem(IDC_BTN_LOGIN)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_BTN_LOGOUT)->EnableWindow(TRUE);\n\t\t\t\n\t\t\tint nSelect = m_Tab.GetCurSel();\n\t\t\tif(nSelect>=0)\n\t\t\t{\n\t\t\t\tDoTab(nSelect);\n\t\t\t}\n\t\t\tif(CLIENT_StartListenEx(m_LoginID))\n\t\t\t{\n\t\t\t\tm_bIsListen = TRUE;\n\t\t\t}\n\t\t}\n\t}\n}\n//Log off device user \nvoid CAlarmDlg::OnBtnLogout() \n{\n\t// TODO: Add your control notification handler code here\n\t//Stop listening device message \n\tif(m_bIsListen)\n\t{\n\t\tm_bIsListen = FALSE;\n\t\tCLIENT_StopListen(m_LoginID);\n\t}\n\t\n\tBOOL bRet = CLIENT_Logout(m_LoginID);\n\t//Clear log in handle after logged off \n\tif(bRet)\n\t{\n\t\tm_LoginID=0;\n\t\tGetDlgItem(IDC_BTN_LOGIN)->EnableWindow(TRUE);\n\t\tGetDlgItem(IDC_BTN_LOGOUT)->EnableWindow(FALSE);\t\t\n\t\tif ( m_pTabDevAlarmDlg!=NULL)\n\t\t{\n\t\t\tm_pTabDevAlarmDlg->ClearAlarmInfo();\n\t\t}\n\t\tif ( m_pTabQueryAlarm!=NULL)\n\t\t{\n\t\t\tm_pTabQueryAlarm->CleanAllInfo();\n\t\t}\t\n\t}\n\telse\n\t{\n\t\tMessageBox(ConvertString(\"Logout failed!\"), ConvertString(\"Prompt\"));\n\t}\n\tSetWindowText(ConvertString(\"Alarm\"));\n\n\tClearAlarmInfoList();\n}\n\n//Get DVR IP address\nCString CAlarmDlg::GetDvrIP()\n{\n\tCString strRet=\"\";\n\tBYTE nField0,nField1,nField2,nField3;\n\tm_dvrIP.GetAddress(nField0,nField1,nField2,nField3);\n\tstrRet.Format(\"%d.%d.%d.%d\",nField0,nField1,nField2,nField3);\n\treturn strRet;\n}\n\n//Display failure reason \nvoid CAlarmDlg::ShowLoginErrorReason(int nError)\n{\n\tif(1 == nError)\t\tMessageBox(ConvertString(\"Invalid password!\"), ConvertString(\"Prompt\"));\n\telse if(2 == nError)\tMessageBox(ConvertString(\"Invalid account!\"), ConvertString(\"Prompt\"));\n\telse if(3 == nError)\tMessageBox(ConvertString(\"Timeout!\"), ConvertString(\"Prompt\"));\n\telse if(4 == nError)\tMessageBox(ConvertString(\"The user has logged in!\"), ConvertString(\"Prompt\"));\n\telse if(5 == nError)\tMessageBox(ConvertString(\"The user has been locked!\"), ConvertString(\"Prompt\"));\n\telse if(6 == nError)\tMessageBox(ConvertString(\"The user has listed into illegal!\"), ConvertString(\"Prompt\"));\n\telse if(7 == nError)\tMessageBox(ConvertString(\"The system is busy!\"), ConvertString(\"Prompt\"));\n\telse if(9 == nError)\tMessageBox(ConvertString(\"You Can't find the network server!\"), ConvertString(\"Prompt\"));\n\telse\tMessageBox(ConvertString(\"Login failed!\"), ConvertString(\"Prompt\"));\n}\n\nbool CAlarmDlg::FindInCList(int nAlarmType, int nChannel, POSITION& pos)\n{\n\tint nCount = m_listAlarmInfo.GetCount();\t\n\tpos = m_listAlarmInfo.GetHeadPosition();\n\tfor (int i = 0; i < nCount; i++)\n\t{\n\t\tCAlarmInfoEx alarmInfo = m_listAlarmInfo.GetAt(pos);\t\n\t\tif (alarmInfo.m_nAlarmType == nAlarmType && alarmInfo.m_nChannel == nChannel)\n\t\t{\n\t\t\treturn true;\t\t\t\n\t\t}\n\t\tm_listAlarmInfo.GetNext(pos);\n\t}\n\treturn false;\n}\n\nLRESULT\tCAlarmDlg::OnDevAlarm(WPARAM wParam, LPARAM lParam)\n{\n    DEVICE_ALARM_INFO* pAlarmInfo = (DEVICE_ALARM_INFO*) wParam;\n\tif(NULL == pAlarmInfo || NULL == pAlarmInfo->pBuf)\n\t{\n\t\treturn -1;\n\t}\n\n\tchar* pBuf = pAlarmInfo->pBuf;\n\tunsigned int nBufLen = pAlarmInfo->nBufSize;\n\n\tCAlarmInfoEx alarmInfo;\n\tswitch(pAlarmInfo->nAlarmType)\n\t{\n\tcase DH_ALARM_ALARM_EX:\t\t\t// 0x2101\t// External alarm \t\t\n\tcase DH_MOTION_ALARM_EX:\t\t// 0x2102\t// Motion detection alarm \t\t\n\tcase DH_VIDEOLOST_ALARM_EX:\t\t// 0x2103\t// Video loss alarm \t\t\n\tcase DH_SHELTER_ALARM_EX:\t\t// 0x2104\t// Camera masking alarm \t\t\n\tcase DH_DISKFULL_ALARM_EX:\t\t// 0x2106\t// HDD full alarm \t\t\n\tcase DH_DISKERROR_ALARM_EX:\t\t// 0x2107\t// HDD malfunction alarm \n\t\t{\t\t\t\n\t\t\talarmInfo.m_nAlarmType = pAlarmInfo->nAlarmType;\t\t\t\t\t\n\t\t\tfor (int i = 0; i < nBufLen; i ++)\n\t\t\t{\n\t\t\t\tif (1 == pBuf[i]) // alarm start\n\t\t\t\t{\n\t\t\t\t\tPOSITION pos;\n\t\t\t\t\tbool bFind = FindInCList(pAlarmInfo->nAlarmType, i, pos);\n\t\t\t\t\tif (!bFind) // not find\n\t\t\t\t\t{\n\t\t\t\t\t\talarmInfo.m_emAlarmStatus = ALARM_START;\n\t\t\t\t\t\talarmInfo.m_nChannel = i;\n\t\t\t\t\t\tCTime tm = CTime::GetCurrentTime();\n\t\t\t\t\t\talarmInfo.m_strTime = tm.Format(\"%Y-%m-%d %H:%M:%S\");\n\t\t\t\t\t\tm_listAlarmInfo.AddHead(alarmInfo);\n\t\t\t\t\t\tUpdateAlarmListCtrl(alarmInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse  // alarm stop\n\t\t\t\t{\n\t\t\t\t\tPOSITION pos;\n\t\t\t\t\tbool bFind = FindInCList(pAlarmInfo->nAlarmType, i, pos);\n\t\t\t\t\tif (bFind) // find, status changed\n\t\t\t\t\t{\t\t\t\t\t\t\n\t\t\t\t\t\tm_listAlarmInfo.RemoveAt(pos);\n\t\t\t\t\t\talarmInfo.m_emAlarmStatus = ALARM_STOP;\n\t\t\t\t\t\talarmInfo.m_nChannel = i;\n\t\t\t\t\t\tCTime tm = CTime::GetCurrentTime();\n\t\t\t\t\t\talarmInfo.m_strTime = tm.Format(\"%Y-%m-%d %H:%M:%S\");\n\t\t\t\t\t\tUpdateAlarmListCtrl(alarmInfo);\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\t\t\n\t\tbreak;\t\t\t\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdelete[] pBuf;\n\tpBuf = NULL;\n\tdelete pAlarmInfo;\n\tpAlarmInfo = NULL;\n    return 0;\n}\n\nvoid CAlarmDlg::UpdateAlarmListCtrl(const CAlarmInfoEx& alarmInfo)\n{\t\n\tm_pTabDevAlarmDlg->UpdateAlarmListCtrl(alarmInfo);\t\n}\n\nvoid CAlarmDlg::ClearAlarmInfoList()\n{\n\tm_listAlarmInfo.RemoveAll();\n}","size_bytes":14673},"bin/Demo/MfcDemo/06.EncodeConfig/ShowDemo.cpp":{"content":"// ShowDemo.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"ShowDemo.h\"\n#include \"ShowDemoDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CShowDemoApp\n\nBEGIN_MESSAGE_MAP(CShowDemoApp, CWinApp)\n\t//{{AFX_MSG_MAP(CShowDemoApp)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t\t//    DO NOT EDIT what you see in these blocks of generated code!\n\t//}}AFX_MSG\n\tON_COMMAND(ID_HELP, CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CShowDemoApp construction\n\nCShowDemoApp::CShowDemoApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The one and only CShowDemoApp object\n\nCShowDemoApp theApp;\n\n/////////////////////////////////////////////////////////////////////////////\n// CShowDemoApp initialization\n\nBOOL CShowDemoApp::InitInstance()\n{\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t//  of your final executable, you should remove from the following\n\t//  the specific initialization routines you do not need.\n\n#ifdef _AFXDLL\n\tEnable3dControls();\t\t\t// Call this when using MFC in a shared DLL\n#else\n\tEnable3dControlsStatic();\t// Call this when linking to MFC statically\n#endif\n\n\tCShowDemoDlg dlg;\n\tm_pMainWnd = &dlg;\n\tINT_PTR nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n","size_bytes":1990},"bin/DemoSrc/DecCB_demo/DecCB_demo.cpp":{"content":"// DecCB_demo.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"DecCB_demo.h\"\n#include \"DecCB_demoDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDecCB_demoApp\n\nBEGIN_MESSAGE_MAP(CDecCB_demoApp, CWinApp)\n\t//{{AFX_MSG_MAP(CDecCB_demoApp)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t\t//    DO NOT EDIT what you see in these blocks of generated code!\n\t//}}AFX_MSG\n\tON_COMMAND(ID_HELP, CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDecCB_demoApp construction\n\nCDecCB_demoApp::CDecCB_demoApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The one and only CDecCB_demoApp object\n\nCDecCB_demoApp theApp;\n\n/////////////////////////////////////////////////////////////////////////////\n// CDecCB_demoApp initialization\n\nBOOL CDecCB_demoApp::InitInstance()\n{\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t//  of your final executable, you should remove from the following\n\t//  the specific initialization routines you do not need.\n\n#ifdef _AFXDLL\n\tEnable3dControls();\t\t\t// Call this when using MFC in a shared DLL\n#else\n\tEnable3dControlsStatic();\t// Call this when linking to MFC statically\n#endif\n\n\tCDecCB_demoDlg dlg;\n\tm_pMainWnd = &dlg;\n\tint nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n","size_bytes":2045},"bin/Demo/MfcDemo/14.GateDemo/Tools.cpp":{"content":"#include \"stdafx.h\"\n#include \"Tools.h\"\n\n\nvoid SetDate( HWND hwnd,NET_TIME &stNetTime, int nID)\n{\n\tCDateTimeCtrl *pInfo = (CDateTimeCtrl*)GetDlgItem(hwnd, nID);\n\tSYSTEMTIME stuTime = {0};\n\tpInfo->GetTime(&stuTime);\n\tstNetTime.dwYear = stuTime.wYear;\n\tstNetTime.dwMonth = stuTime.wMonth;\n\tstNetTime.dwDay = stuTime.wDay;\n}\n\nvoid SetTime(HWND hwnd, NET_TIME &stNetTime, int nID)\n{\n\tCDateTimeCtrl *pInfo = (CDateTimeCtrl*)GetDlgItem(hwnd, nID);\n\tSYSTEMTIME stuTime = {0};\n\tpInfo->GetTime(&stuTime);\n\tstNetTime.dwHour = stuTime.wHour;\n\tstNetTime.dwMinute = stuTime.wMinute;\n\tstNetTime.dwSecond = stuTime.wSecond;\n}\n","size_bytes":610},"bin/Demo/MfcDemo/10.AlarmDevice/DlgCfgAlarmOut.cpp":{"content":"// DlgCfgAlarmOut.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgCfgAlarmOut.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// DlgCfgAlarmOut dialog\n\n\nDlgCfgAlarmOut::DlgCfgAlarmOut(CWnd* pParent /* = NULL */, LLONG hLoginId /* = NULL */, UINT32 uiAlarmOut /* = 0 */)\n\t: CDialog(DlgCfgAlarmOut::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(DlgCfgAlarmOut)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\tm_hLoginId = hLoginId;\n\tm_uiAlarmOut = uiAlarmOut;\n\t//}}AFX_DATA_INIT\n\tmemset(&m_stuInfo, 0, sizeof(m_stuInfo));\n}\n\n\nvoid DlgCfgAlarmOut::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(DlgCfgAlarmOut)\n\tDDX_Control(pDX, IDC_ALARMOUT_CMB_OUTMODE, m_cbOutMode);\n\tDDX_Control(pDX, IDC_ALARMOUT_CMB_CHN, m_cbChannel);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(DlgCfgAlarmOut, CDialog)\n\t//{{AFX_MSG_MAP(DlgCfgAlarmOut)\n\tON_BN_CLICKED(IDC_ALARMOUT_GET, OnAlarmoutGet)\n\tON_BN_CLICKED(IDC_ALARMOUT_SET, OnAlarmoutSet)\n\tON_CBN_SELCHANGE(IDC_ALARMOUT_CMB_CHN, OnSelchangeAlarmoutCmbChn)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// DlgCfgAlarmOut private method\n\nvoid DlgCfgAlarmOut::InitDlg()\n{\n\tint i = 0;\n\t\n\t// channel\n\tint nChannelNum = m_uiAlarmOut == 0 ? 16 : m_uiAlarmOut;\n\tfor (i = 0; i < nChannelNum; i++)\n\t{\n\t\tCString csTemp;\n\t\tcsTemp.Format(\"%s %02d\", ConvertString(\"Channel\", DLG_CFG_ALARMOUT), i + 1);\n\t\tm_cbChannel.InsertString(-1, csTemp);\n\t}\n\tm_cbChannel.SetCurSel(-1);\n\n\t// name\n\tSetDlgItemText(IDC_ALARMOUT_EDT_NAME, \"\");\n\n\t// output type\n\tSetDlgItemText(IDC_ALARMOUT_EDT_OUTTYPE, \"\");\n\n\t// output mode\n\tfor (i = 0; i < sizeof(DemoOutputMode) / sizeof(DemoOutputMode[0]); i++)\n\t{\n\t\tm_cbOutMode.InsertString(-1, ConvertString(DemoOutputMode[i].pszName, DLG_CFG_ALARMOUT));\n\t}\n\tm_cbOutMode.SetCurSel(-1);\n}\n\nvoid DlgCfgAlarmOut::StuToDlg()\n{\n\tint nSel = m_cbChannel.GetCurSel();\n\tif (-1 == nSel)\n\t{\n\t\tnSel = 0;\n\t}\n\n\tm_cbChannel.SetCurSel(nSel);\n\tSetDlgItemText(IDC_ALARMOUT_EDT_NAME, m_stuInfo.szChnName);\n\tSetDlgItemText(IDC_ALARMOUT_EDT_OUTTYPE, m_stuInfo.szOutputType);\n\tm_cbOutMode.SetCurSel(m_stuInfo.nOutputMode);\n    SetDlgItemInt(IDC_ALARMOUT_EDT_PULSEDELAY, m_stuInfo.nPulseDelay);\n}\n\nvoid DlgCfgAlarmOut::DlgToStu()\n{\n\tGetDlgItemText(IDC_ALARMOUT_EDT_NAME, m_stuInfo.szChnName, sizeof(m_stuInfo.szChnName));\n\tGetDlgItemText(IDC_ALARMOUT_EDT_OUTTYPE, m_stuInfo.szOutputType, sizeof(m_stuInfo.szOutputType));\n\tm_stuInfo.nOutputMode = m_cbOutMode.GetCurSel();\n    m_stuInfo.nPulseDelay = GetDlgItemInt(IDC_ALARMOUT_EDT_PULSEDELAY);\n}\n\nBOOL DlgCfgAlarmOut::GetAlarmOutConfig()\n{\n// \tint nSelChn = m_cbChannel.GetCurSel();\n// \tif (-1 == nSelChn)\n// \t{\n// \t\treturn FALSE;\n// \t}\n\n\n\tint nerror = 0;\n\tBOOL bSuccess = FALSE;\n\tBOOL bRet = FALSE;\n\tint nBufLen = 1024;\n\tchar *szOutBuffer = new char[nBufLen];\n\tif (szOutBuffer == NULL)\n\t{\n\t\treturn FALSE;\t\n\t}\n\tmemset(szOutBuffer, 0, sizeof(char) * nBufLen);\n\t\n\tint nSelChn = m_cbChannel.GetCurSel() == -1 ? 0 : m_cbChannel.GetCurSel();\n\tbSuccess = CLIENT_GetNewDevConfig((LLONG)m_hLoginId, CFG_CMD_ALARMOUT, nSelChn, szOutBuffer, 1024, &nerror, SDK_API_WAIT);\n\tif (bSuccess)\n\t{\n\t\tCFG_ALARMOUT_INFO stuInfo = {0};\n\t\tDWORD dwRet = 0;\n\t\tbRet = CLIENT_ParseData(CFG_CMD_ALARMOUT, szOutBuffer, &stuInfo, sizeof(stuInfo), &dwRet);\n\t\tif (bRet && sizeof(CFG_ALARMOUT_INFO) == dwRet)\n\t\t{\n\t\t\tmemcpy(&m_stuInfo, &stuInfo, sizeof(CFG_ALARMOUT_INFO));\n\t\t\t//MessageBox(\"Get config of AlarmOut ok!\", ConvertString(\"Prompt\"));\n\t\t} \n\t\telse\n\t\t{\n\t\t\tMessageBox(ConvertString(\"Parse AlarmOut error!\",DLG_CFG_ALARMOUT), ConvertString(\"Prompt\"));\n\t\t\t//return FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tCString csErr;\n\t\tcsErr.Format(\"%s %08x\", ConvertString(\"Query config of AlarmOut error:\", DLG_CFG_ALARMOUT),CLIENT_GetLastError());\n\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\t//return FALSE;\n\t}\n\n\tif (szOutBuffer)\n\t{\n\t\tdelete []szOutBuffer;\n\t\tszOutBuffer = NULL;\n\t}\n\n\treturn bRet;\n}\n\nBOOL DlgCfgAlarmOut::SetAlarmOutConfig()\n{\n\tint nSelChn = m_cbChannel.GetCurSel();\n\tint nSelMode = m_cbOutMode.GetCurSel();\n\tif (-1 == nSelChn || -1 == nSelMode)\n\t{\n\t\treturn FALSE;\n\t}\n\t\t\n\tchar szJson[1024] = {0};\n\tBOOL bRet = CLIENT_PacketData(CFG_CMD_ALARMOUT, &m_stuInfo, sizeof(m_stuInfo), szJson, sizeof(szJson));\n\tif (bRet)\n\t{\n\t\tint nerror = 0;\n\t\tint nrestart = 0;\n\t\tbRet  = CLIENT_SetNewDevConfig((LLONG)m_hLoginId, CFG_CMD_ALARMOUT, nSelChn, szJson, 1024, &nerror, &nrestart, SDK_API_WAIT);\t\n\t\tif (bRet)\n\t\t{\n\t\t\tif ( 1 == nrestart)\n\t\t\t{\n\t\t\t\tMessageBox(ConvertString(\"Set config of AlarmOut successfully! device need restart!\", DLG_CFG_ALARMOUT), ConvertString(\"Prompt\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tMessageBox(ConvertString(\"Set config of AlarmOut successfully!\", DLG_CFG_ALARMOUT), ConvertString(\"Prompt\"));\n\t\t\t}\n\t\t} \n\t\telse\n\t\t{\n\t\t\tCString csErr;\n\t\t\tcsErr.Format(\"%s %08x\", ConvertString(\"Set config of AlarmOut error:\", DLG_CFG_ALARMOUT), CLIENT_GetLastError());\n\t\t\tMessageBox(csErr, ConvertString(\"Prompt\"));\n\t\t\treturn FALSE;\n\t\t}\n\t} \n\telse\n\t{\n\t\tMessageBox(ConvertString(\"Packet AlarmOut error!\", DLG_CFG_ALARMOUT), ConvertString(\"Prompt\"));\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// DlgCfgAlarmOut message handlers\n\nBOOL DlgCfgAlarmOut::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this, DLG_CFG_ALARMOUT);\n\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\tif (m_hLoginId)\n\t{\n\t\tm_cbChannel.SetCurSel(0);\n\t\tif (GetAlarmOutConfig())\n\t\t{\n\t\t\tStuToDlg();\n\t\t}\n\t}\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid DlgCfgAlarmOut::OnAlarmoutGet() \n{\n\t// TODO: Add your control notification handler code here\n\tif (GetAlarmOutConfig())\n\t{\n\t\tStuToDlg();\n\t}\n}\n\nvoid DlgCfgAlarmOut::OnAlarmoutSet() \n{\n\t// TODO: Add your control notification handler code here\n\tDlgToStu();\n\tSetAlarmOutConfig();\n}\n\nvoid DlgCfgAlarmOut::OnSelchangeAlarmoutCmbChn() \n{\n\t// TODO: Add your control notification handler code here\t\n\tint nSelChn = m_cbChannel.GetCurSel();\n\tif (-1 == nSelChn)\n\t{\n\t\treturn;\n\t}\n\n\tif (GetAlarmOutConfig())\n\t{\n\t\tStuToDlg();\n\t}\n}\n","size_bytes":6310},"bin/Demo/MfcDemo/10.AlarmDevice/LoginDlg.cpp":{"content":"// LoginDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"LoginDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CLoginDlg dialog\n\n\nCLoginDlg::CLoginDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CLoginDlg::IDD, pParent)\n\t, m_lLoginID(0)\n{\n\t//{{AFX_DATA_INIT(CLoginDlg)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tmemset(&m_stuDevInfo, 0, sizeof(m_stuDevInfo));\n}\n\n\nvoid CLoginDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CLoginDlg)\n\tDDX_Control(pDX, IDC_COMBO_ADDRESS, m_cbAddr);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CLoginDlg, CDialog)\n\t//{{AFX_MSG_MAP(CLoginDlg)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CLoginDlg message handlers\n\nBOOL CLoginDlg::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\n\tg_SetWndStaticText(this, DLG_ADD_DEVICE);\n\t\n\tSetDlgItemText(IDC_COMBO_ADDRESS, \"172.5.2.103\");\n\tSetDlgItemInt(IDC_EDIT_PORT, 37777);\n\tSetDlgItemText(IDC_EDIT_USER, \"admin\");\n\tSetDlgItemText(IDC_EDIT_PWD, \"admin\");\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CLoginDlg::OnOK() \n{\n\tCString strAddr, strUser, strPwd;\n\tUINT nPort = GetDlgItemInt(IDC_EDIT_PORT);\n\tm_cbAddr.GetWindowText(strAddr);\n\tGetDlgItemText(IDC_EDIT_USER, strUser);\n\tGetDlgItemText(IDC_EDIT_PWD, strPwd);\n\t\n\tif (strAddr.IsEmpty())\n\t{\n\t\tMessageBox(ConvertString(\"Invalid Address.\", DLG_ADD_DEVICE), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\tif (nPort <= 0)\n\t{\n\t\tMessageBox(ConvertString(\"Invalid Port.\", DLG_ADD_DEVICE), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\tif (strAddr.IsEmpty())\n\t{\n\t\tMessageBox(ConvertString(\"Invalid User Name.\", DLG_ADD_DEVICE), ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\t\n\tint nError = 0;\n\tNET_DEVICEINFO_Ex stNetDevInfo;\n\tCString strTemp;\n\t\n\tLLONG lRet = CLIENT_LoginEx2((LPTSTR)(LPCTSTR)strAddr, nPort, (LPTSTR)(LPCTSTR)strUser, (LPTSTR)(LPCTSTR)strPwd, EM_LOGIN_SPEC_CAP_TCP, NULL, &stNetDevInfo, &nError);\n\t\n\tif (lRet == 0)\n\t{\n\t\tCString str;\n\t\tstr.Format(\"%s %d.\", ConvertString(\"Login error. Code:\", DLG_ADD_DEVICE), nError);\n\t\tMessageBox(str, ConvertString(\"Prompt\"));\n\t\treturn;\n\t}\n\t\n\tm_lLoginID = lRet;\n\tm_strAddr = strAddr;\n\tm_stuDevInfo = stNetDevInfo;\n\tCDialog::OnOK();\n}\n","size_bytes":2499},"bin/Demo/MfcDemo/01.RealPlayAndPTZControl/PtzScreen.cpp":{"content":"// PtzScreen.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"RealPlayAndPTZControl.h\"\n#include \"PtzScreen.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CPtzScreen\n\nCPtzScreen::CPtzScreen()\n{\n\tm_pMessageProc = NULL;\n\tm_dwMessageUser = 0;\n\tm_pGetParams = NULL;\n\tm_dwGetParams = 0;\n\tm_pSetParams = NULL;\n\tm_dwSetParams = 0;\n\tm_pRectEventFunc = NULL;\n\tm_dwRectEvent = 0;\n}\n\nCPtzScreen::~CPtzScreen()\n{\n\t\n}\nvoid  CPtzScreen::SetActiveWnd(int nIndex,BOOL bRepaint)\n{\n\tif(nIndex >= 0 && nIndex < PRIVATE_MAX_CHANNUM)\n\t{\n\t\tSetActivePage(&m_wndVideo[nIndex],bRepaint);\n\t}\n}\n\nCWnd* CPtzScreen::GetPage(int nIndex)\n{\n\tif (nIndex >= 0 && nIndex < PRIVATE_MAX_CHANNUM)\n\t{\n\t\treturn &m_wndVideo[nIndex];\n\t}\n\t\n\treturn NULL;\n}\nint CPtzScreen::SetShowPlayWin(int nMain, int nSub)\n{\n\tif (nSub < 0 || nSub > PRIVATE_MAX_CHANNUM)\n\t{\n\t\tnSub = 0;\n\t}\n\n\tint nNum = 16;\n\tint nBegin = 0;\n\tswitch(nMain) \n\t{\n\tcase SPLIT1:\n\t\tnNum = 1;\n\t\tnBegin = nSub;\n\t\tbreak;\n\tcase SPLIT4:\n\t\tnNum = 4;\n\t\tif (nSub >= 12)\n\t\t{\n\t\t\tnBegin = 12;\n\t\t}\n\t\telse if (nSub >= 8)\n\t\t{\n\t\t\tnBegin = 8;\n\t\t}\n\t\telse if (nSub >= 4)\n\t\t{\n\t\t\tnBegin = 4;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnBegin = 0;\n\t\t}\n\n\t\tbreak;\n\tcase SPLIT9:\n\t\tnNum = 9;\n\t\tif (nSub >= 10)\n\t\t{\n\t\t\tnBegin = 7;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnBegin = 0;\n\t\t}\n\t\tbreak;\n\tcase SPLIT16:\n\t\tnNum = 16;\n\t\tnBegin = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tm_bMultiScreen = TRUE;\n\tCList<CWnd*, CWnd*> templist;\n\n\tPOSITION pos = m_PageList.GetHeadPosition();\n\twhile(pos != NULL)\n\t{\n\t\tCWnd* pWnd = m_PageList.GetNext(pos);\n\t\tif (pWnd)\n\t\t{\n\t\t\ttemplist.AddTail(pWnd);\n\t\t}\n\t}\n\n\tm_PageList.RemoveAll();\n\n\t/*\n\twhile(m_PageList.GetCount())\n\t{\n\t\tDelPage(GetTailPage());\n\t}\n\t*/\n\t\n\tfor(int i=nBegin; i < (nBegin+nNum); i++)\n\t{\n\t\tAddPage(&m_wndVideo[i], TRUE);\n\t}\n\n\tSetActivePage(&m_wndVideo[nSub], TRUE);\n\n\tpos = templist.GetHeadPosition();\n\twhile(pos != NULL)\n\t{\n\t\tCWnd* pWnd = templist.GetNext(pos);\n\t\tif (pWnd)\n\t\t{\n\t\t\tpWnd->ShowWindow(SW_HIDE);\n\t\t}\n\t}\n\n\ttemplist.RemoveAll();\n\n\treturn m_PageList.GetCount();\n}\nvoid CPtzScreen::SetCallBack(OnMessageProcFunc cbMessageProc, LDWORD dwMessageUser,\n\t\t\t\t\t\t\t OnGetParamsFunc cbGetParams, LDWORD dwGetParams, \n\t\t\t\t\t\t\t OnSetParamsFunc cbSetParams, LDWORD dwSetParmas,\n\t\t\t\t\t\t\t OnRectEventFunc cbEventParams,LDWORD dwRectEventParams)\n{\n\tm_pMessageProc = cbMessageProc;\n\tm_dwMessageUser = dwMessageUser;\n\tm_pGetParams = cbGetParams;\n\tm_dwGetParams = dwGetParams;\n\tm_pSetParams = cbSetParams;\n\tm_dwSetParams = dwSetParmas;\n\tm_pRectEventFunc = cbEventParams;\n\tm_dwRectEvent = dwRectEventParams;\n}\nBEGIN_MESSAGE_MAP(CPtzScreen, CWnd)\n\t//{{AFX_MSG_MAP(CPtzScreen)\n\tON_WM_LBUTTONDOWN()\n\tON_WM_LBUTTONUP()\n\tON_WM_ACTIVATE()\n\tON_WM_CREATE()\n\tON_WM_DESTROY()\n\tON_WM_ACTIVATEAPP()\n\tON_WM_ICONERASEBKGND()\n\tON_WM_ASKCBFORMATNAME()\n\tON_WM_ERASEBKGND()\n\tON_WM_CANCELMODE()\n\tON_WM_PAINT()\n\tON_WM_CAPTURECHANGED()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n\n/////////////////////////////////////////////////////////////////////////////\n// CPtzScreen message handlers\n\nvoid CPtzScreen::OnLButtonDown(UINT nFlags, CPoint point) \n{\n\t// TODO: Add your message handler code here and/or call default\n\tCWnd::OnLButtonDown(nFlags, point);\n}\n\nvoid CPtzScreen::OnLButtonUp(UINT nFlags, CPoint point) \n{\n\t// TODO: Add your message handler code here and/or call default\n\t\n\tCWnd::OnLButtonUp(nFlags, point);\n}\n\nvoid CPtzScreen::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized) \n{\n\tCWnd::OnActivate(nState, pWndOther, bMinimized);\n\t\n\t// TODO: Add your message handler code here\n\t\n}\n\nint CPtzScreen::OnCreate(LPCREATESTRUCT lpCreateStruct) \n{\n\tif (CWnd::OnCreate(lpCreateStruct) == -1)\n\t\treturn -1;\n\t\n\t// TODO: Add your specialized creation code here\n\tfor(int i = 0; i < PRIVATE_MAX_CHANNUM; i++)\n\t{\n\t\tm_wndVideo[i].Create(\n\t\t\tNULL, \n\t\t\tNULL, \n\t\t\tWS_VISIBLE | WS_CHILD,\n\t\t\tCRect(0, 0, 0, 0),\n\t\t\tthis,\n\t\t\t1979,\n\t\t\tNULL);\n\t\t\n\t\tm_wndVideo[i].SetWinID(i);\n\t\t\n\t\tAddPage(&m_wndVideo[i]);\n\t}\n\t\n\tSetActivePage(&m_wndVideo[0], TRUE);\n\tSetDrawActivePage(TRUE, RGB(248,5,182), RGB(248,5,182));\n\t\n\treturn 0;\t\n\treturn 0;\n}\n\nvoid CPtzScreen::OnDestroy() \n{\n\tCWnd::OnDestroy();\n\t\n\t// TODO: Add your message handler code here\n\tfor(int i=0; i < PRIVATE_MAX_CHANNUM; i++)\n\t{\n\t\tm_wndVideo[0].DestroyWindow();\n\t}\n}\n#if _MSC_VER > 1300\nvoid CPtzScreen::OnActivateApp(BOOL bActive, DWORD hTask) \n#else\nvoid CPtzScreen::OnActivateApp(BOOL bActive, HTASK hTask)\n#endif\n{\n\tCWnd::OnActivateApp(bActive, hTask);\n\t\n\t// TODO: Add your message handler code here\n\t\n}\n\nvoid CPtzScreen::OnIconEraseBkgnd(CDC* pDC) \n{\n\t// TODO: Add your message handler code here and/or call default\n\t\n\tCWnd::OnIconEraseBkgnd(pDC);\n}\n\nvoid CPtzScreen::OnAskCbFormatName(UINT nMaxCount, LPTSTR lpszString) \n{\n\t// TODO: Add your message handler code here and/or call default\n\n\tCWnd::OnAskCbFormatName(nMaxCount, lpszString);\n}\n\nBOOL CPtzScreen::OnEraseBkgnd(CDC* pDC) \n{\n\t// TODO: Add your message handler code here and/or call default\n\tCRect rt;\n\tGetClientRect(&rt);\n\tCBrush br;\n\tbr.CreateSolidBrush(RGB(192,192,192));\n\tpDC->FillRect(&rt,&br);\n\t\n\treturn TRUE;\t\n}\n\nvoid CPtzScreen::OnCancelMode() \n{\n\tCWnd::OnCancelMode();\n\t\n\t// TODO: Add your message handler code here\n\t\n}\n\nvoid CPtzScreen::OnPaint() \n{\n\tCPaintDC dc(this); // device context for painting\n\t\n\t// TODO: Add your message handler code here\n\tUpdateWnd();\n\t// Do not call CWnd::OnPaint() for painting messages\n}\n\nvoid CPtzScreen::OnCaptureChanged(CWnd *pWnd) \n{\n\t// TODO: Add your message handler code here\n\t\n\tCWnd::OnCaptureChanged(pWnd);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","size_bytes":5895},"bin/Demo/MfcDemo/16.HumanTrait/PictureCtrl.cpp":{"content":"// PictureCtrl.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"PictureCtrl.h\"\n\n#define\tPICTURE_BACK_COLOR\tRGB(105,105,105)\nconst static COLORREF RESERVED_COLOR = RGB(255, 255, 255);\n\n// PictureCtrl\nIMPLEMENT_DYNAMIC(PictureCtrl, CStatic)\n\nPictureCtrl::PictureCtrl() : m_pPicture(NULL)\n{\n\n}\n\nPictureCtrl::~PictureCtrl()\n{\n\tif (m_pPicture != NULL)\n\t{\n\t\tm_pPicture->Release();\n\t\tm_pPicture = NULL;\n\t}\n}\n\nvoid PictureCtrl::SetImageDate(const BYTE* pBuf, int nBufSize)\n{\n\tUSES_CONVERSION;\n\n\tRECT rect;\n\tthis->GetWindowRect(&rect);\n\n\tCDC* pDC = NULL;\n\tpDC = this->GetWindowDC();\n\tif (NULL == pDC)\n\t{\n\t\treturn;\n\t}\n\n\tif (m_pPicture != NULL)\n\t{\n\t\tm_pPicture->Release();\n\t\tm_pPicture = NULL;\n\t}\n\n    HGLOBAL hMem  = GlobalAlloc(GMEM_MOVEABLE, nBufSize);\n    BYTE *pTmpBuf = (BYTE *)GlobalLock(hMem);\n    memcpy(pTmpBuf, pBuf, nBufSize);\n    GlobalUnlock(hMem);\n\n    if (m_pPicture != NULL)\n    {\n        m_pPicture->Release();\n        m_pPicture = NULL;\n    }\n\n    IStream* pStream = NULL;\n    CreateStreamOnHGlobal(hMem, false, &pStream);\n\n\t// Load Picture from stream\n\tHRESULT hr = S_FALSE;\n\thr = OleLoadPictureEx(pStream, nBufSize, TRUE, IID_IPicture, LP_DEFAULT, LP_DEFAULT, LP_DEFAULT,(LPVOID*)&m_pPicture);\n\tif (NULL == m_pPicture)\n\t{\n\t\tthis->ReleaseDC(pDC);\n\t\treturn;\n\t}\n\n\t// Show Picture\n\tOLE_XSIZE_HIMETRIC hmWidth; \n\tOLE_YSIZE_HIMETRIC hmHeight; \n\tm_pPicture->get_Width(&hmWidth); \n\tm_pPicture->get_Height(&hmHeight); \n\n\thr = m_pPicture->Render(*pDC, 0, 0, rect.right - rect.left, rect.bottom - rect.top, 0, hmHeight, hmWidth, -hmHeight, NULL);\n\tthis->ReleaseDC(pDC);\n\n    GlobalFree(hMem);\n    pStream->Release();\n}\n\n\nvoid PictureCtrl::SetImageFile(LPCSTR szImagePath)\n{\n    USES_CONVERSION;\n\n    RECT rect;\n    this->GetWindowRect(&rect);\n\n    CDC* pDC = NULL;\n    pDC = this->GetWindowDC();\n    if (NULL == pDC)\n    {\n        return;\n    }\n\n    if (m_pPicture != NULL)\n    {\n        m_pPicture->Release();\n        m_pPicture = NULL;\n    }\n\n    // Load Picture from path\n    HRESULT hr = S_FALSE;\n    hr = OleLoadPicturePath(T2OLE(szImagePath), NULL, 0, RESERVED_COLOR, IID_IPicture, (LPVOID*)&m_pPicture);\n    if (NULL == m_pPicture)\n    {\n        this->ReleaseDC(pDC);\n        return;\n    }\n\n    // Show Picture\n    OLE_XSIZE_HIMETRIC hmWidth; \n    OLE_YSIZE_HIMETRIC hmHeight; \n    m_pPicture->get_Width(&hmWidth); \n    m_pPicture->get_Height(&hmHeight); \n\n    hr = m_pPicture->Render(*pDC, 0, 0, rect.right - rect.left, rect.bottom - rect.top, 0, hmHeight, hmWidth, -hmHeight, NULL);\n    this->ReleaseDC(pDC);\n}\n\n\nBEGIN_MESSAGE_MAP(PictureCtrl, CStatic)\n\tON_WM_PAINT()\nEND_MESSAGE_MAP()\n\nvoid PictureCtrl::OnPaint()\n{\n\tif (NULL != m_pPicture)\n\t{\n\t\tCPaintDC dc(this);\n\n\t\tRECT rect;\n\t\tthis->GetWindowRect(&rect);\n\t\tOLE_XSIZE_HIMETRIC hmWidth; \n\t\tOLE_YSIZE_HIMETRIC hmHeight; \n\t\tm_pPicture->get_Width(&hmWidth); \n\t\tm_pPicture->get_Height(&hmHeight); \n\t\tm_pPicture->Render(dc.m_hDC, 0, 0, rect.right - rect.left, rect.bottom - rect.top, 0, hmHeight, hmWidth, -hmHeight, NULL);\t\n\t}\n\telse\n\t{\n\t\tCDC* cdc = this->GetDC();\n\t\tif (NULL == cdc)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tRECT rect;\n\t\tthis->GetClientRect(&rect);\n\t\tCBrush brush(PICTURE_BACK_COLOR);\n\t\tcdc->FillRect(&rect, &brush);\n\t\tthis->ReleaseDC(cdc);\n\t}\n\n\tCWnd::OnPaint();\n}\n\n","size_bytes":3231},"bin/Demo/MfcDemo/21.PassengerFlow/PassengerFlow.cpp":{"content":"// PassengerFlow.cpp : Defines the class behaviors for the application.\n//\n\n#include \"stdafx.h\"\n#include \"PassengerFlow.h\"\n#include \"PassengerFlowDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\n\n// CPassengerFlowApp\n\nBEGIN_MESSAGE_MAP(CPassengerFlowApp, CWinApp)\n\tON_COMMAND(ID_HELP, &CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n\n// CPassengerFlowApp construction\n\nCPassengerFlowApp::CPassengerFlowApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\n\n// The one and only CPassengerFlowApp object\n\nCPassengerFlowApp theApp;\n\n\n// CPassengerFlowApp initialization\n\nBOOL CPassengerFlowApp::InitInstance()\n{\n\t// InitCommonControlsEx() is required on Windows XP if an application\n\t// manifest specifies use of ComCtl32.dll version 6 or later to enable\n\t// visual styles.  Otherwise, any window creation will fail.\n\tINITCOMMONCONTROLSEX InitCtrls;\n\tInitCtrls.dwSize = sizeof(InitCtrls);\n\t// Set this to include all the common control classes you want to use\n\t// in your application.\n\tInitCtrls.dwICC = ICC_WIN95_CLASSES;\n\tInitCommonControlsEx(&InitCtrls);\n\n\tCWinApp::InitInstance();\n\n\tAfxEnableControlContainer();\n\n\t// Standard initialization\n\t// If you are not using these features and wish to reduce the size\n\t// of your final executable, you should remove from the following\n\t// the specific initialization routines you do not need\n\t// Change the registry key under which our settings are stored\n\t// TODO: You should modify this string to be something appropriate\n\t// such as the name of your company or organization\n\tSetRegistryKey(_T(\"Local AppWizard-Generated Applications\"));\n\n\tCPassengerFlowDlg dlg;\n\tm_pMainWnd = &dlg;\n\tINT_PTR nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with OK\n\t}\n\telse if (nResponse == IDCANCEL)\n\t{\n\t\t// TODO: Place code here to handle when the dialog is\n\t\t//  dismissed with Cancel\n\t}\n\n\t// Since the dialog has been closed, return FALSE so that we exit the\n\t//  application, rather than start the application's message pump.\n\treturn FALSE;\n}\n","size_bytes":2097},"bin/Demo/MfcDemo/10.AlarmDevice/AlarmDeviceDlg.cpp":{"content":"// AlarmDeviceDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"AlarmDeviceDlg.h\"\n#include \"DHPtzMenu.h\"\n#include \"MultiPlay.h\"\n#include \"MessageText.h\"\n\n#include \"DlgCapability.h\"\n#include \"AlarmSubscribe.h\"\n#include \"DlgAlarmBell.h\"\n#include \"DlgUpgrade.h\"\n#include \"DlgTalk.h\"\n\n#include \"DlgCfgAlarmCenter.h\"\n#include \"DlgCfgAlarmOut.h\"\n#include \"DlgCfgGuard.h\"\n#include \"DlgCfgAlarm.h\"\n#include \"DlgFileManager.h\"\n#include \"DlgOptPlaysound.h\"\n#include \"DlgStateBattery.h\"\n#include \"DlgCfgPSTNAlarmServer.h\"\n#include \"DlgAlarmState.h\"\n#include \"DlgCfgAlarmKeyboard.h\"\n#include \"DlgCfgAlarmPowerFault.h\"\n#include \"DlgCfgAlarmChassisIntrusion.h\"\n#include \"DlgCfgAlarmExAlarmBox.h\"\n#include \"DlgCfgExAlarmInput.h\"\n#include \"DlgCfgExAlarmOutput.h\"\n#include \"DlgExAlarmChannel.h\"\n#include \"DlgCfgWireless.h\"\n#include \"DlgCfgSerial.h\"\n#include \"DlgCfgNetwork.h\"\n#include \"DlgCfgLocales.h\"\n#include \"DlgCfgNTP.h\"\n#include \"DlgCfgMobile.h\"\n#include \"DlgCfgPhoneNotify.h\"\n#include \"DlgCfgAirCondition.h\"\n\n#include \"DlgAccess.h\"\n#include \"DlgFileList.h\"\n#include \"DlgOptAccess.h\"\n#include \"DlgUserManage.h\"\n#include \"DlgVersion.h\"\n#include \"DlgUserInfo.h\"\n#include \"DlgUpgrade.h\"\n#include \"DlgSetBypass.h\"\n#include \"DlgDeviceTime.h\"\n#include \"DlgActivatedDefenceArea.h\"\n#include \"DlgCfgAutoMaintain.h\"\n#include \"DlgSetNetWorkParam.h\"\n// #include \"DlgCfgChange.h\"\n#include \"DlgSetArmMode.h\"\n#include \"TabUserManageDlg.h\"\n#include \"DlgBypassCtl.h\"\n#include \"DlgCfgAlarmUrgency.h\"\n#include \"DlgQueryLog.h\"\n#include \"DlgCfgSTP.h\"\n#include \"DlgCfgSensorSampling.h\"\n#include \"DlgAnalogAlarmChannels.h\"\n#include \"DlgCfgAnalogAlarm.h\"\n#include \"DlgAnalogAlarmData.h\"\n#include \"DlgCfgSensorInfoOfVW.h\"\n#include \"DlgCfgBatteryLowPower.h\"\n#include \"DlgAlarmChannel.h\"\n#include \"DlgCfgAlarmSubSystem.h\"\n#include \"DlgAlarmSubSystem.h\"\n#include \"DlgLowRateWPAN.h\"\n#include \"DlgCfgSnapLinkage.h\"\n#include \"DlgAlarmOutSet.h\"\n#include \"AirConditionOperate.h\"\n#include \"DlgCfgNetAbort.h\"\n#include \"DlgCfgIPConflict.h\"\n#include \"DlgCfgMacConflict.h\"\n#include \"DlgRecoverConfig.h\"\n#include \"DlgCfgPSTNBreakLine.h\"\n#include \"DlgCfgNetCollection.h\"\n#include \"DlgCfgAlarmSlotBond.h\"\n#include \"DlgCfgRCEmergencyCall.h\"\n#include \"DlgCfgAlarmBell.h\"\n#include \"DlgCfgPSTNPersonServer.h\"\n#include \"DlgCfgArmLink.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n#define WM_DEVICE_DISCONNECT\t(WM_USER + 100)\n#define WM_DEVICE_RECONNECT\t\t(WM_USER + 101)\n\n//Forbid opening two programs at the same time \n#pragma data_seg(\"sharesec\")\n__declspec (allocate(\"sharesec\")) HWND g_share_hWnd = NULL;\n#pragma comment(linker,\"/SECTION:sharesec,RWS\")\n\n/////////////////////////////////////////////////////////////////////////////\n// CAboutDlg dialog used for App About\n\nclass CAboutDlg : public CDialog\n{\npublic:\n\tCAboutDlg();\n\n// Dialog Data\n\t//{{AFX_DATA(CAboutDlg)\n\tenum { IDD = IDD_ABOUTBOX };\n\t//}}AFX_DATA\n\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CAboutDlg)\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n\t//}}AFX_VIRTUAL\n\n// Implementation\nprotected:\n\t//{{AFX_MSG(CAboutDlg)\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\n};\n\nCAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)\n{\n\t//{{AFX_DATA_INIT(CAboutDlg)\n\t//}}AFX_DATA_INIT\n}\n\nvoid CAboutDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CAboutDlg)\n\t//}}AFX_DATA_MAP\n}\n\nBEGIN_MESSAGE_MAP(CAboutDlg, CDialog)\n\t//{{AFX_MSG_MAP(CAboutDlg)\n\t\t// No message handlers\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CClientDemoDlg dialog\n\nCAlarmDeviceDlg::CAlarmDeviceDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CAlarmDeviceDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CClientDemoDlg)\n\tm_DvrUserName = _T(\"admin\");\n\tm_DvrPassword = _T(\"admin123\");\n\tm_DvrPort = 37777;\n\tm_presetData = 1;\n\tm_crviseGroup = 1;\n\tm_moveNo = 1;\n\tm_posX = 0;\n\tm_posY = 0;\n\tm_posZoom = 0;\n\tm_uiAlarmIn = 0;\n\tm_uiAlarmOut = 0;\n\tm_uiAnalogAlarmIn = 0;\n\tm_emDeviceType = NET_PRODUCT_NONE;\n\t//}}AFX_DATA_INIT\n\t// Note that LoadIcon does not require a subsequent DestroyIcon in Win32\n\tm_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);\n\tm_nChannelCount = 0;\n\tm_LoginID = 0;\n\t//Clear the 9-window real-time monitor handle \n\tfor(int i=0;i<9;i++)\n\t{\n\t\tm_DispHanle[i]=0;\n\t\t//Write 9-window information into CVideoNodeInfo array.\n\t\tm_videoNodeInfo[i].SetVideoInfo(i+1,\"\",0,-1,\"\",\"\",DirectMode);\n\t}\n\tm_CurScreen =0;\n}\n\nvoid CAlarmDeviceDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CClientDemoDlg)\n\tDDX_Control(pDX, IDC_CMB_CONTROLQUERY, m_cmbControlQueryType);\n\tDDX_Control(pDX, IDC_CMB_CONFIG, m_cmbConfig);\n\tDDX_Control(pDX, IDC_COMBO_PLAYMODE, m_comboPlayMode);\n\tDDX_Control(pDX, IDC_COMBO_AUX_NO, m_auxNosel);\n\tDDX_Control(pDX, IDC_COMBO_PTZDATA, m_comboPTZData);\n\tDDX_Control(pDX, IDC_IRIS_OPEN, m_iris_open);\n\tDDX_Control(pDX, IDC_IRIS_CLOSE, m_iris_close);\n\tDDX_Control(pDX, IDC_FOCUS_FAR, m_focus_far);\n\tDDX_Control(pDX, IDC_FOCUS_NEAR, m_focus_near);\n\tDDX_Control(pDX, IDC_ZOOM_TELE, m_zoom_tele);\n\tDDX_Control(pDX, IDC_ZOOM_WIDE, m_zoom_wide);\n\tDDX_Control(pDX, IDC_PTZ_RIGHTDOWN, m_ptz_rightdown);\n\tDDX_Control(pDX, IDC_PTZ_RIGHTUP, m_ptz_rightup);\n\tDDX_Control(pDX, IDC_PTZ_LEFTDOWN, m_ptz_leftdown);\n\tDDX_Control(pDX, IDC_PTZ_LEFTUP, m_ptz_leftup);\n\tDDX_Control(pDX, IDC_PTZ_RIGHT, m_ptz_right);\n\tDDX_Control(pDX, IDC_PTZ_LEFT, m_ptz_left);\n\tDDX_Control(pDX, IDC_PTZ_DOWN, m_ptz_down);\n\tDDX_Control(pDX, IDC_PTZ_UP, m_ptz_up);\n\tDDX_Control(pDX, IDC_COMBO_Channel, m_comboChannel);\n\tDDX_Control(pDX, IDC_COMBO_DispNum, m_comboDispNum);\n\tDDX_Control(pDX, IDC_DvrIPAddress, m_DvrIPAddr);\n\tDDX_Text(pDX, IDC_EDIT_UserName, m_DvrUserName);\n\tDDX_Text(pDX, IDC_EDIT_Password, m_DvrPassword);\n\tDDX_Text(pDX, IDC_EDIT_PORT, m_DvrPort);\n\tDDX_Text(pDX, IDC_PRESET_DATA, m_presetData);\n//\tDDV_MinMaxInt(pDX, m_presetData, 0, 100);\n\tDDX_Text(pDX, IDC_CRUISE_GROUP, m_crviseGroup);\n\tDDX_Text(pDX, IDC_MODE_NO, m_moveNo);\n\tDDX_Text(pDX, IDC_POS_X, m_posX);\n\tDDX_Text(pDX, IDC_POS_Y, m_posY);\n\tDDX_Text(pDX, IDC_POS_ZOOM, m_posZoom);\n\t//}}AFX_DATA_MAP\n}\n\nBEGIN_MESSAGE_MAP(CAlarmDeviceDlg, CDialog)\n\t//{{AFX_MSG_MAP(CClientDemoDlg)\n\tON_WM_SYSCOMMAND()\n\tON_WM_PAINT()\n\tON_WM_QUERYDRAGICON()\n\tON_BN_CLICKED(IDC_BT_Login, OnBTLogin)\n\tON_BN_CLICKED(IDC_BUTTON_Play, OnBUTTONPlay)\n\tON_BN_CLICKED(IDC_BT_Leave, OnBTLeave)\n\tON_WM_DESTROY()\n\tON_BN_CLICKED(IDC_BUTTON_STOP, OnButtonStop)\n\tON_BN_CLICKED(IDC_BTN_PTZEXCTRL, OnBtnPtzexctrl)\n\tON_BN_CLICKED(IDC_PRESET_SET, OnPresetSet)\n\tON_BN_CLICKED(IDC_PRESET_ADD, OnPresetAdd)\n\tON_BN_CLICKED(IDC_PRESET_DELE, OnPresetDele)\n\tON_BN_CLICKED(IDC_START_CRUISE, OnStartCruise)\n\tON_BN_CLICKED(IDC_CRUISE_ADD_POINT, OnCruiseAddPoint)\n\tON_BN_CLICKED(IDC_CRUISE_DEL_POINT, OnCruiseDelPoint)\n\tON_BN_CLICKED(IDC_CRUISE_DEL_GROUP, OnCruiseDelGroup)\n\tON_BN_CLICKED(IDC_MODE_SET_BEGIN, OnModeSetBegin)\n\tON_BN_CLICKED(IDC_MODE_START, OnModeStart)\n\tON_BN_CLICKED(IDC_MODE_SET_DELETE, OnModeSetDelete)\n\tON_BN_CLICKED(IDC_LINE_SET_LEFT, OnLineSetLeft)\n\tON_BN_CLICKED(IDC_LINE_SET_RIGHT, OnLineSetRight)\n\tON_BN_CLICKED(IDC_LINE_START, OnLineStart)\n\tON_BN_CLICKED(IDC_FAST_GO, OnFastGo)\n\tON_BN_CLICKED(IDC_EXACT_GO, OnExactGo)\n\tON_BN_CLICKED(IDC_RESET, OnResetZero)\n\tON_BN_CLICKED(IDC_ROTATE_START, OnRotateStart)\n\tON_BN_CLICKED(IDC_ROTATE_STOP, OnRotateStop)\n\tON_BN_CLICKED(IDC_AUX_OPEN, OnAuxOpen)\n\tON_BN_CLICKED(IDC_AUX_CLOSE, OnAuxClose)\n\tON_BN_CLICKED(IDC_BTN_PTZMENU, OnBtnPtzmenu)\n\tON_CBN_SELCHANGE(IDC_COMBO_DispNum, OnSelchangeCOMBODispNum)\n\tON_CBN_CLOSEUP(IDC_COMBO_DispNum, OnCloseupCOMBODispNum)\n\tON_BN_CLICKED(IDC_BTN_CONFIG, OnBtnConfig)\n\tON_BN_CLICKED(IDC_BTN_CAP, OnBtnCap)\n\tON_BN_CLICKED(IDC_BTN_SUBSCRIBE, OnBtnSubscribe)\n\tON_BN_CLICKED(IDC_BTN_CONTROLQUERY, OnBtnControlQuery)\n\tON_BN_CLICKED(IDC_BTN_TALK, OnBtnTalk)\n\tON_MESSAGE(WM_DEVICE_DISCONNECT, OnDisConnect)\n\tON_MESSAGE(WM_DEVICE_RECONNECT, OnReConnect)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CClientDemoDlg message handlers\n\nBOOL CAlarmDeviceDlg::OnInitDialog()\n{\n\t//Forbid opening two programs at the same time \n\tthis->IsValid();\n\t\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\t// Add \"About...\" menu item to system menu.\n\n\t// IDM_ABOUTBOX must be in the system command range.\n\tASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);\n\tASSERT(IDM_ABOUTBOX < 0xF000);\n\n\tCMenu* pSysMenu = GetSystemMenu(FALSE);\n\tif (pSysMenu != NULL)\n\t{\n\t\tCString strAboutMenu;\n\t\tstrAboutMenu.LoadString(IDS_ABOUTBOX);\n\t\tif (!strAboutMenu.IsEmpty())\n\t\t{\n\t\t\tpSysMenu->AppendMenu(MF_SEPARATOR);\n\t\t\tpSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);\n\t\t}\n\t}\n\n\t// Set the icon for this dialog.  The framework does this automatically\n\t//  when the application's main window is not a dialog\n\tSetIcon(m_hIcon, TRUE);\t\t\t// Set big icon\n\tSetIcon(m_hIcon, FALSE);\t\t// Set small icon\n\t\n\t// TODO: Add extra initialization here\n\tm_ptzScreen.Create(NULL,NULL,WS_CHILD|WS_VISIBLE,CRect(0,0,0,0),this,1981);\n\tUpdataScreenPos();\n\tm_ptzScreen.ShowWindow(SW_SHOW);\n\tm_ptzScreen.SetCallBack(MessageProcFunc,(LDWORD)this,\n\t\t\t\t\t\t\tGetParamsFunc,(LDWORD)this,\n\t\t\t\t\t\t\tSetParamsFunc,(LDWORD)this,\n\t\t\t\t\t\t\tRectEventFunc,(LDWORD)this);\n\tm_ptzScreen.SetShowPlayWin(SPLIT9,0);\n\t//Set initial IP address \n\t{\n\t\tCString csIp = ConvertString(\"ip\", DEVICE_PARAM);\n\t\tif (csIp == CString(\"ip\"))\n\t\t{\n\t\t\tm_DvrIPAddr.SetWindowText(\"172.12.10.152\");\n\t\t} \n\t\telse\n\t\t{\n\t\t\tm_DvrIPAddr.SetWindowText(csIp);\n\t\t}\n\t\t\n\t\tCString csPort = ConvertString(\"port\", DEVICE_PARAM);\n\t\tif (csPort == CString(\"port\"))\n\t\t{\n\t\t\tSetDlgItemInt(IDC_EDIT_PORT, 37777);\n\t\t} \n\t\telse\n\t\t{\n\t\t\tGetDlgItem(IDC_EDIT_PORT)->SetWindowText(csPort);\n\t\t}\n\n\t\tCString csName = ConvertString(\"username\", DEVICE_PARAM);\n\t\tif (csName == CString(\"username\"))\n\t\t{\n\t\t\tGetDlgItem(IDC_EDIT_UserName)->SetWindowText(\"admin\");\n\t\t} \n\t\telse\n\t\t{\n\t\t\tGetDlgItem(IDC_EDIT_UserName)->SetWindowText(csName);\n\t\t}\n\t\t\n\t\tCString csPsw = ConvertString(\"password\", DEVICE_PARAM);\n\t\tif (csPsw == CString(\"password\"))\n\t\t{\n\t\t\tGetDlgItem(IDC_EDIT_Password)->SetWindowText(\"admin\");\n\t\t} \n\t\telse\n\t\t{\n\t\t\tGetDlgItem(IDC_EDIT_Password)->SetWindowText(csPsw);\n\t\t}\n\t}\n\t//m_DvrIPAddr.SetAddress(172,11,3,59);\n\t\n\t//Zoom dialogux box \n\tCRect rectSeparator;\n\tGetWindowRect(&m_rectLarge);\n\tGetDlgItem(IDC_SEPERATOR)->GetWindowRect(&rectSeparator);\n\tm_rectSmall.left=m_rectLarge.left;\n\tm_rectSmall.top=m_rectLarge.top;\n\tm_rectSmall.right=m_rectLarge.right;\n\tm_rectSmall.bottom=rectSeparator.bottom;\n\tSetWindowPos(NULL,0,0,m_rectSmall.Width(),m_rectSmall.Height(),SWP_NOMOVE | SWP_NOZORDER);\n\t\n\t//Command definition setup of PTZ control \n\tInitPTZControl();\n\t//Initialize channel and window dropdown menu \n\tInitComboBox();\n\t//Initialize net SDK\n\tInitNetSDK();\n\n\t\n\tm_cmbConfig.ResetContent();\n\tfor (int i = 0; i < sizeof(stuConfigType) / sizeof(stuConfigType[0]); i++)\n\t{\n\t\tm_cmbConfig.InsertString(-1, ConvertString(stuConfigType[i].szName, DLG_MAIN));\n\t}\n\tm_cmbConfig.SetCurSel(-1);\n\n\tm_cmbControlQueryType.ResetContent();\n\tfor (int j = 0; j < sizeof(stuControQueryType) / sizeof(stuControQueryType[0]); j++)\n\t{\n\t\tm_cmbControlQueryType.InsertString(-1, ConvertString(stuControQueryType[j].szName, DLG_MAIN));\n\t}\n\tm_cmbControlQueryType.SetCurSel(-1);\n\n\treturn TRUE;  // return TRUE  unless you set the focus to a control\n}\nvoid CAlarmDeviceDlg::UpdataScreenPos()\n{\n\tGetDlgItem(IDC_SCREEN_WINDOW)->GetClientRect(&m_clientRect);\n\t\n\tm_screenRect = m_clientRect;\n\tm_ptzScreen.MoveWindow(m_screenRect);\n}\n\nvoid CAlarmDeviceDlg::OnSysCommand(UINT nID, LPARAM lParam)\n{\n\tif ((nID & 0xFFF0) == IDM_ABOUTBOX)\n\t{\n\t\tCAboutDlg dlgAbout;\n\t\tdlgAbout.DoModal();\n\t}\n\telse\n\t{\n\t\tCDialog::OnSysCommand(nID, lParam);\n\t}\n}\n\n// If you add a minimize button to your dialog, you will need the code below\n//  to draw the icon.  For MFC applications using the document/view model,\n//  this is automatically done for you by the framework.\n\nvoid CAlarmDeviceDlg::OnPaint() \n{\n\tif (IsIconic())\n\t{\n\t\tCPaintDC dc(this); // device context for painting\n\n\t\tSendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);\n\n\t\t// Center icon in client rectangle\n\t\tint cxIcon = GetSystemMetrics(SM_CXICON);\n\t\tint cyIcon = GetSystemMetrics(SM_CYICON);\n\t\tCRect rect;\n\t\tGetClientRect(&rect);\n\t\tint x = (rect.Width() - cxIcon + 1) / 2;\n\t\tint y = (rect.Height() - cyIcon + 1) / 2;\n\n\t\t// Draw the icon\n\t\tdc.DrawIcon(x, y, m_hIcon);\n\t}\n\telse\n\t{\n\t\tCDialog::OnPaint();\n\t}\n}\n\n// The system calls this to obtain the cursor to display while the user drags\n//  the minimized window.\nHCURSOR CAlarmDeviceDlg::OnQueryDragIcon()\n{\n\treturn (HCURSOR) m_hIcon;\n}\n\nBOOL CAlarmDeviceDlg::PreTranslateMessage(MSG* pMsg) \n{\n    // TODO: Add your specialized code here and/or call the base class\n    if (pMsg->message == WM_KEYDOWN || pMsg->message == WM_KEYUP)\n    {\n        if (VK_ESCAPE == pMsg->wParam || VK_RETURN == pMsg->wParam)\n        {\n            return TRUE;\n        }\n    }\n    return CDialog::PreTranslateMessage(pMsg);\n}\n\n//Forbid opening two programs at the same time\nvoid CAlarmDeviceDlg::IsValid()\n{\n\tif(g_share_hWnd)\n\t{\n\t\tMessageBox(ConvertString(_T(\"Only one program will be allowed to open!\")), ConvertString(\"Prompt\"));\n\t\tCWnd* pWnd = CWnd::FromHandle(g_share_hWnd);\n\t\tif(pWnd)\n\t\t{\n\t\t\tif (pWnd->IsIconic())\n\t\t\t{\n\t\t\t\tpWnd->ShowWindow(SW_RESTORE);\n\t\t\t}\n\t\t\tpWnd->SetForegroundWindow(); \n\t\t}\n\t\texit(0);\n\t}\n\telse\n\t{\n\t\tg_share_hWnd = m_hWnd;\n\t}\n}\n\n//Callback function when device disconnected\nvoid CALLBACK DisConnectFunc(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser)\n{\n\tif(dwUser == 0)\n\t{\n\t\treturn;\n\t}\n\n\tCAlarmDeviceDlg *pThis = (CAlarmDeviceDlg *)dwUser;\n\tHWND hWnd = pThis->GetSafeHwnd();\n\tif (NULL == hWnd)\n\t{\n\t\treturn;\n\t}\n\tPostMessage(hWnd, WM_DEVICE_DISCONNECT, NULL, NULL);\n}\n\n//Callback function when device reconnect\nvoid CALLBACK ReConnectFunc(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser)\n{\n\tif(dwUser == 0)\n\t{\n\t\treturn;\n\t}\n\n\tCAlarmDeviceDlg *pThis = (CAlarmDeviceDlg *)dwUser;\n\tHWND hWnd = pThis->GetSafeHwnd();\n\tif (NULL == hWnd)\n\t{\n\t\treturn;\n\t}\n\tPostMessage(hWnd, WM_DEVICE_RECONNECT, NULL, NULL);\n}\n\n\n//Initialize net SDK\nvoid CAlarmDeviceDlg::InitNetSDK()\n{\n\t//Initialize net sdk, All callback begins here.\n\tBOOL bSuccess = CLIENT_Init(DisConnectFunc, (LDWORD)this);\n\tif (!bSuccess)\n\t{\n\t\t//Display function error occurrs reason.\n\t\tLastError();\n\t}\n\tCLIENT_SetAutoReconnect(ReConnectFunc, (LDWORD)this);\n\n\tNET_PARAM stuParam = {0};\n\n\tCString csConnectBufSize = ConvertString(\"ConnectBufSize\", SDK_PARAM);\n\tif (csConnectBufSize == CString(\"ConnectBufSize\"))\n\t{\n\t\tstuParam.nConnectBufSize = 250 * 1024;\n\t}\n\telse\n\t{\n\t\tstuParam.nConnectBufSize = atoi(csConnectBufSize.GetBuffer(0));\n\t}\n\t\n\tCString csConnectTime = ConvertString(\"ConnectTime\", SDK_PARAM);\n\tif (csConnectTime == CString(\"ConnectTime\"))\n\t{\n\t\tstuParam.nConnectTime = 1500;\n\t} \n\telse\n\t{\n\t\tstuParam.nConnectTime = atoi(csConnectTime.GetBuffer(0));\n\t}\n\t\n\tCString csConnectTryNum = ConvertString(\"ConnetTryNum\", SDK_PARAM);\n\tif (csConnectTryNum == CString(\"ConnetTryNum\"))\n\t{\n\t\tstuParam.nConnectTryNum = 1;\n\t} \n\telse\n\t{\n\t\tstuParam.nConnectTryNum = atoi(csConnectTryNum.GetBuffer(0));\n\t}\n\t\n\tCString csGetDevInfoTime = ConvertString(\"GetDevInfoTime\", SDK_PARAM);\n\tif (csGetDevInfoTime == CString(\"GetDevInfoTime\"))\n\t{\n\t\tstuParam.nGetDevInfoTime = 5000;\n\t} \n\telse\n\t{\n\t\tstuParam.nGetDevInfoTime = atoi(csGetDevInfoTime.GetBuffer(0));\n\t}\n\t\n\tCString csWaitTime = ConvertString(\"WaitTime\", SDK_PARAM);\n\tif (csWaitTime == CString(\"WaitTime\"))\n\t{\n\t\tstuParam.nWaittime = 5000;\n\t} \n\telse\n\t{\n\t\tstuParam.nWaittime = atoi(csWaitTime.GetBuffer(0));\n\t}\n\t\n\tCLIENT_SetNetworkParam(&stuParam);\n}\n\nvoid CAlarmDeviceDlg::OnBTLogin() \n{\n\t// TODO: Add your control notification handler code here\n\tBOOL bValid = UpdateData(TRUE);\t//Get interface input \n\tif(bValid)\n\t{\n\t\tint err = 0;\t//Storage the possible error return value.\n\t\tchar *pchDVRIP;\n\t\tCString strDvrIP = GetDvrIP();\n\t\tpchDVRIP = (LPSTR)(LPCSTR)strDvrIP;\n\t\tWORD wDVRPort=(WORD)m_DvrPort;\n\t\tchar *pchUserName=(LPSTR)(LPCSTR)m_DvrUserName;\n\t\tchar *pchPassword=(LPSTR)(LPCSTR)m_DvrPassword;\n\t\tNET_DEVICEINFO_Ex deviceInfo = {0};\n\t\t//Call log in interface \n\t\tLLONG lRet = CLIENT_LoginEx2(pchDVRIP, wDVRPort, pchUserName, pchPassword, EM_LOGIN_SPEC_CAP_TCP, \n                                     NULL, &deviceInfo, &err);\n\t\tif(0 != lRet)\n\t\t{\n\t\t\tm_LoginID = lRet;\n\t\t\tGetDlgItem(IDC_BT_Login)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_BT_Leave)->EnableWindow(TRUE);\n\t\t\tGetDlgItem(IDC_BUTTON_Play)->EnableWindow(TRUE);\n\t\t\t//Device channel and channel dropdown menu \n\t\t\tm_nChannelCount = (int)deviceInfo.nChanNum;\n\t\t\tm_uiAlarmIn = deviceInfo.nAlarmInPortNum;\n\t\t\tm_uiAlarmOut = deviceInfo.nAlarmOutPortNum;\n\t\t\tm_uiAnalogAlarmIn = GetAnalogAlarmIn();\n\t\t\tint nIndex = 0;\n\t\t\tm_comboChannel.ResetContent();\n\t\t\tfor(int i=0;i<m_nChannelCount;i++)\n\t\t\t{\n\t\t\t\tCString str;\n\t\t\t\tstr.Format(\"%d\",i+1);\n\t\t\t\tnIndex = m_comboChannel.AddString(str);\n\t\t\t\tm_comboChannel.SetItemData(nIndex,i);\n\t\t\t}\n\t\t\tif(0 < m_comboChannel.GetCount())\n\t\t\t{\n\t\t\t\tnIndex = m_comboChannel.AddString(ConvertString(\"Multi_Preview\"));\n\t\t\t\tm_comboChannel.SetItemData(nIndex,-1);\n\t\t\t\tm_comboChannel.SetCurSel(0);\n\t\t\t}\n\n\t\t\tm_emDeviceType = (NET_DEVICE_TYPE)deviceInfo.nDVRType;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//Display log in failure reason \n\t\t\tShowLoginErrorReason(err);\n\t\t}\n\t}\n\tSetWindowText(ConvertString(\"AlarmDevice\"));\n}\n\n//Play \nvoid CAlarmDeviceDlg::OnBUTTONPlay() \n{\n\t// TODO: Add your control notification handler code here\n\t//CLIENT_API LONG CLIENT_RealPlay(LONG lLoginID, int nChannelID, HWND hWnd);\n\tBOOL bValid = UpdateData(TRUE);\n\tif(bValid)\n\t{\n\t\tint nIndex = m_comboDispNum.GetCurSel();\n\t\tif(CB_ERR != nIndex)\n\t\t{\n\t\t\tint iDispNum =m_comboDispNum.GetItemData(nIndex);\n\t\t\t//Get video handle \n\t\t\tHWND hWnd=GetDispHandle(iDispNum);\n\t\t\tif(0 != hWnd)\n\t\t\t{\n\t\t\t\tnIndex = m_comboChannel.GetCurSel();\n\t\t\t\tif(CB_ERR != nIndex)\n\t\t\t\t{\n\t\t\t\t\t//Get channel number \n\t\t\t\t\tint iChannel = m_comboChannel.GetItemData(nIndex);\n\t\t\t\t\tnIndex = m_comboPlayMode.GetCurSel();\n\t\t\t\t\tif(CB_ERR != nIndex)\n\t\t\t\t\t{\n\t\t\t\t\t\t//Get play mode \n\t\t\t\t\t\tRealPlayMode ePlayMode = (RealPlayMode)m_comboPlayMode.GetItemData(nIndex);\n\t\t\t\t\t\tif(-1 == iChannel && ePlayMode == DirectMode)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//Play directly in multiple-window preview \n\t\t\t\t\t\t\tMultiPlayMode(iDispNum,hWnd);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(-1 == iChannel && ePlayMode == ServerMode)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//Data callback play mode in multiple-window preview mode. \n\t\t\t\t\t\t\tMultiPlayServerMode(iDispNum,hWnd);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(-1 != iChannel && ePlayMode == DirectMode)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//Play directly \n\t\t\t\t\t\t\tDirectPlayMode(iDispNum,iChannel,hWnd);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(-1 != iChannel && ePlayMode == ServerMode)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//Play in data callback mode \n\t\t\t\t\t\t\tServerPlayMode(iDispNum,iChannel,hWnd);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid CAlarmDeviceDlg::OnBTLeave() \n{\n\t// TODO: Add your control notification handler code here\n\t//CLIENT_API BOOL CLIENT_Logout(LONG lLoginID)\n\tSetWindowText(ConvertString(\"AlarmDevice\"));\n\tif(0 != m_LoginID)\n\t{\n\t\t//Clear 9-window real-time monitor handle \n\t\tfor(int i=0;i<9;i++)\n\t\t{\n\t\t\tCloseDispVideo(i + 1);\n\t\t\tm_DispHanle[i]=0;\n\t\t\t//Write 9-window message into CVideoNodeInfo array \n\t\t\tm_videoNodeInfo[i].SetVideoInfo(i+1,\"\",0, -1,\"\",\"\",DirectMode);\n\t\t}\n\n\t\tBOOL bSuccess = CLIENT_Logout(m_LoginID);\n\t\tif(bSuccess)\n\t\t{\n\t\t\tm_LoginID = 0;\n\t\t\tm_comboChannel.ResetContent();\n\t\t\tGetDlgItem(IDC_BT_Login)->EnableWindow(TRUE);\n\t\t\tGetDlgItem(IDC_BT_Leave)->EnableWindow(FALSE);\n\t\t\tGetDlgItem(IDC_BUTTON_Play)->EnableWindow(FALSE);\n\t\t\tInvalidate();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMessageBox(ConvertString(\"Fail to Logout!\"), ConvertString(\"Prompt\"));\n\t\t}\n\t}\n}\n\n//Get input IP\nCString CAlarmDeviceDlg::GetDvrIP()\n{\n\tCString strRet=\"\";\n\tBYTE nField0,nField1,nField2,nField3;\n\tm_DvrIPAddr.GetAddress(nField0,nField1,nField2,nField3);\n\tstrRet.Format(\"%d.%d.%d.%d\",nField0,nField1,nField2,nField3);\n\treturn strRet;\n}\n\nvoid CAlarmDeviceDlg::OnDestroy() \n{\n\tCDialog::OnDestroy();\n\t\n\tfor(int i=0;i<9;i++)\n\t{\n\t\tCloseDispVideo(i + 1);\n\t\tm_DispHanle[i]=0;\n\t}\n\n\t// TODO: Add your message handler code here\n\tif(0 != m_LoginID)\n\t{\n\t\tCLIENT_Logout(m_LoginID);\n\t}\n\t//Clear SDK and then release occupied resources.\n\tCLIENT_Cleanup();\n}\n\n//Get video handle \nHWND CAlarmDeviceDlg::GetDispHandle(int nNum)\n{\n\tHWND hWnd=0;\n\thWnd = ((CWnd *)(m_ptzScreen.GetPage(m_CurScreen)))->m_hWnd;\n\treturn hWnd;\t\n}\n\nvoid CAlarmDeviceDlg::InitComboBox()\n{\n\t//Video dropdown menu initialization \n\tint nIndex;\n\tint i = 0;\n\tCString strDispNum[9]={\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"};\n\tm_comboDispNum.ResetContent();\n\tfor(i=0;i<9;i++)\n\t{\n\t\tnIndex = m_comboDispNum.AddString(strDispNum[i]);\n\t\tm_comboDispNum.SetItemData(nIndex,i+1);\n\t}\n\tm_comboDispNum.SetCurSel(0);\n\t//Channel dropdown menu initialization \n\tm_comboChannel.ResetContent();\n\tfor(i=0;i<m_nChannelCount;i++)\n\t{\n\t\tCString str;\n\t\tstr.Format(\"%d\",i+1);\n\t\tnIndex = m_comboChannel.AddString(str);\n\t\tm_comboChannel.SetItemData(nIndex,i);\n\t}\n\tif(0 < m_comboChannel.GetCount())\n\t{\n\t\tnIndex = m_comboChannel.AddString(ConvertString(\"Multi_Preview\"));\n\t\tm_comboChannel.SetItemData(nIndex,-1);\n\t\tm_comboChannel.SetCurSel(0);\n\t}\n\t//Control parameter dropdown menu initialization \n\tCString strPTZData[8]={\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\"};\n\tm_comboPTZData.ResetContent();\n\tfor(i=0;i<8;i++)\n\t{\n\t\tnIndex = m_comboPTZData.AddString(strPTZData[i]);\n\t\tm_comboPTZData.SetItemData(nIndex,i+1);\n\t}\n\tm_comboPTZData.SetCurSel(3);\n\t//Auxiliary dropdown menu initialization\n\tCString strAuxNo[5]={\"23\",\"24\",\"27\",\"41\",\"43\"};\n\tm_auxNosel.ResetContent();\n\tfor(i=0;i<5;i++)\n\t{\n\t\tm_auxNosel.AddString(strAuxNo[i]);\n\t}\n\tm_auxNosel.SetCurSel(0);\n\t//Play mode dropdown menu initialization \n\tCString strPlayMode[3]={ConvertString(\"Direct-play\"), ConvertString(\"Data-callback\")};\n\tm_comboPlayMode.ResetContent();\n\n\tnIndex = m_comboPlayMode.AddString(strPlayMode[0]);\n\tm_comboPlayMode.SetItemData(nIndex,DirectMode);\n\n\tnIndex = m_comboPlayMode.AddString(strPlayMode[1]);\n\tm_comboPlayMode.SetItemData(nIndex,ServerMode);\n\tm_comboPlayMode.SetCurSel(0);\n}\n\n//Stop play\nvoid CAlarmDeviceDlg::OnButtonStop() \n{\n\t// TODO: Add your control notification handler code here\n\t//Get video number \n\tint nIndex = m_comboDispNum.GetCurSel();\n\tif(CB_ERR != nIndex)\n\t{\n\t\tint iDispNum = m_comboDispNum.GetItemData(nIndex);\n\t\t//Close current video \n\t\tCloseDispVideo(iDispNum);\n\t\t//Refresh page \n\t\tInvalidate();\n\t\tm_DispHanle[iDispNum-1] = 0;\n\t}\n}\n\n//Save video information \nvoid CAlarmDeviceDlg::SetPlayVideoInfo(int iDispNum,int iChannel,enum RealPlayMode ePlayMode)\n{\n\tBOOL bValid = UpdateData(TRUE);\n\tif(bValid)\n\t{\n\t\tCString strDvrIP = GetDvrIP();\n\t\tWORD wDVRPort=(WORD)m_DvrPort;\n\t\tm_videoNodeInfo[iDispNum-1].SetVideoInfo(iDispNum,strDvrIP,wDVRPort,iChannel,m_DvrUserName,m_DvrPassword,ePlayMode);\n\t}\n}\n\n//PTZ control \nvoid CAlarmDeviceDlg::PtzControl(int type, BOOL stop)\n{\n\tSetDlgItemText(IDC_PTZSTATUS,\"\");\n\tif(0 != m_LoginID)\n\t{\n\t\t//Get channel number \n\t\tUpdateData(TRUE);\n\t\tCString strDispNum;\n\t\tm_comboDispNum.GetWindowText(strDispNum);\n\t\tint iDispNum = atoi(strDispNum);\n\t\tint iChannel=m_videoNodeInfo[iDispNum-1].GetDvrChannel();\n\t\tif(-1 == iChannel)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBYTE param1=0,param2=0;\n\t\tBYTE bPTZData=(unsigned char)GetDlgItemInt(IDC_COMBO_PTZDATA);\n\t\tswitch(type) {\n\t\tcase DH_PTZ_UP_CONTROL:\n\t\t\t//Up\n\t\t\tparam1=0;\n\t\t\tparam2=bPTZData;\n\t\t\tbreak;\n\t\tcase DH_PTZ_DOWN_CONTROL:\n\t\t\t//Down\n\t\t\tparam1=0;\n\t\t\tparam2=bPTZData;\n\t\t\tbreak;\n\t\tcase DH_PTZ_LEFT_CONTROL:\n\t\t\t//Left \n\t\t\tparam1=0;\n\t\t\tparam2=bPTZData;\n\t\t\tbreak;\n\t\tcase DH_PTZ_RIGHT_CONTROL:\n\t\t\t//Right \n\t\t\tparam1=0;\n\t\t\tparam2=bPTZData;\n\t\t\tbreak;\n\t\tcase DH_EXTPTZ_LEFTTOP:\n\t\t\t//Up left\n\t\t\tparam1=bPTZData;\n\t\t\tparam2=bPTZData;\n\t\t\tbreak;\n\t\tcase DH_EXTPTZ_LEFTDOWN:\n\t\t\t//Up down \n\t\t\tparam1=bPTZData;\n\t\t\tparam2=bPTZData;\n\t\t\tbreak;\n\t\tcase DH_EXTPTZ_RIGHTTOP:\n\t\t\t//Up right \n\t\t\tparam1=bPTZData;\n\t\t\tparam2=bPTZData;\n\t\t\tbreak;\n\t\tcase DH_EXTPTZ_RIGHTDOWN:\n\t\t\t//Up down \n\t\t\tparam1=bPTZData;\n\t\t\tparam2=bPTZData;\n\t\t\tbreak;\n\t\tcase DH_PTZ_ZOOM_DEC_CONTROL:\n\t\t\t//Zoom out \n\t\t\tparam1=0;\n\t\t\tparam2=bPTZData;\n\t\t\tbreak;\n\t\tcase DH_PTZ_ZOOM_ADD_CONTROL:\n\t\t\t//Zoom in \n\t\t\tparam1=0;\n\t\t\tparam2=bPTZData;\n\t\t\tbreak;\n\t\tcase DH_PTZ_FOCUS_DEC_CONTROL:\n\t\t\t//Focus zoom in \n\t\t\tparam1=0;\n\t\t\tparam2=bPTZData;\n\t\t\tbreak;\n\t\tcase DH_PTZ_FOCUS_ADD_CONTROL:\n\t\t\t//Focus zoom out \n\t\t\tparam1=0;\n\t\t\tparam2=bPTZData;\n\t\t\tbreak;\n\t\tcase DH_PTZ_APERTURE_DEC_CONTROL:\n\t\t\t//Aperture zoom out \n\t\t\tparam1=0;\n\t\t\tparam2=bPTZData;\n\t\t\tbreak;\n\t\tcase DH_PTZ_APERTURE_ADD_CONTROL:\n\t\t\t//Aperture zoom in \n\t\t\tparam1=0;\n\t\t\tparam2=bPTZData;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tBOOL bRet=CLIENT_DHPTZControl(m_LoginID,iChannel,type,param1,param2,0,stop);\n\t\tif(bRet)\n\t\t{\n\t\t\tSetDlgItemText(IDC_PTZSTATUS, ConvertString(\"Succeed\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSetDlgItemText(IDC_PTZSTATUS, ConvertString(\"Fail\"));\n\t\t}\n\t}\n}\n\n//Dialogue box zoom \nvoid CAlarmDeviceDlg::OnBtnPtzexctrl() \n{\n\t// TODO: Add your control notification handler code here\n\tCString str;\n\tif(GetDlgItemText(IDC_BTN_PTZEXCTRL,str),(str==\"Advance>>\" || str == ConvertString(\"Advance>>\")))\n\t{\n\t\tSetDlgItemText(IDC_BTN_PTZEXCTRL, ConvertString(\"Close Advance<<\"));\n\t\tSetWindowPos(NULL,0,0,m_rectLarge.Width(),m_rectLarge.Height(),SWP_NOMOVE | SWP_NOZORDER);\n\t\tGetDlgItem(IDC_SEPERATOR)->ShowWindow(SW_SHOW);\n\t}\n\telse\n\t{\n\t\tSetDlgItemText(IDC_BTN_PTZEXCTRL, ConvertString(\"Advance>>\"));\n\t\tSetWindowPos(NULL,0,0,m_rectSmall.Width(),m_rectSmall.Height(),SWP_NOMOVE | SWP_NOZORDER);\n\t\tGetDlgItem(IDC_SEPERATOR)->ShowWindow(SW_HIDE);\n\t}\n}\n\n//PTZ control command definition setup \nvoid CAlarmDeviceDlg::InitPTZControl()\n{\n\tm_ptz_up.SetButtonCommand(DH_PTZ_UP_CONTROL);\n\tm_ptz_down.SetButtonCommand(DH_PTZ_DOWN_CONTROL);\n\tm_ptz_left.SetButtonCommand(DH_PTZ_LEFT_CONTROL);\n\tm_ptz_right.SetButtonCommand(DH_PTZ_RIGHT_CONTROL);\n\tm_zoom_wide.SetButtonCommand(DH_PTZ_ZOOM_DEC_CONTROL);\n\tm_zoom_tele.SetButtonCommand(DH_PTZ_ZOOM_ADD_CONTROL);\n\tm_focus_near.SetButtonCommand(DH_PTZ_FOCUS_DEC_CONTROL);\n\tm_focus_far.SetButtonCommand(DH_PTZ_FOCUS_ADD_CONTROL);\n\tm_iris_open.SetButtonCommand(DH_PTZ_APERTURE_ADD_CONTROL);\n\tm_iris_close.SetButtonCommand(DH_PTZ_APERTURE_DEC_CONTROL);\n\t\n\tm_ptz_rightup.SetButtonCommand(DH_EXTPTZ_RIGHTTOP);\n\tm_ptz_rightdown.SetButtonCommand(DH_EXTPTZ_RIGHTDOWN);\n\tm_ptz_leftup.SetButtonCommand(DH_EXTPTZ_LEFTTOP);\n\tm_ptz_leftdown.SetButtonCommand(DH_EXTPTZ_LEFTDOWN);\n}\n\n//PTZ control extensive function \nvoid CAlarmDeviceDlg::PtzExtControl(DWORD dwCommand, DWORD dwParam)\n{\n\tif(0 != m_LoginID)\n\t{\n\t\t//Get channel number \n\t\tCString strDispNum;\n\t\tCString strAuxNo;\n\t\tm_comboDispNum.GetWindowText(strDispNum);\n\t\tint iDispNum = atoi(strDispNum);\n\t\tint iChannel=m_videoNodeInfo[iDispNum-1].GetDvrChannel();\n\t\tif(-1 == iChannel)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tlong param1=0,param2=0,param3=0;\n\t\tswitch(dwCommand) {\n\t\tcase DH_PTZ_POINT_MOVE_CONTROL:\n\t\t\t//Go to preset \n\t\t\tparam1=0;\n\t\t\tparam2=(long)m_presetData;\n\t\t\tparam3=0;\n\t\t\tbreak;\n\t\tcase DH_PTZ_POINT_SET_CONTROL:\n\t\t\t//Add preset \n\t\t\tparam1=0;\n\t\t\tparam2=(long)m_presetData;\n\t\t\tparam3=0;\n\t\t\tbreak;\n\t\tcase DH_PTZ_POINT_DEL_CONTROL:\n\t\t\t//Delete preset \n\t\t\tparam1=0;\n\t\t\tparam2=(long)m_presetData;\n\t\t\tparam3=0;\n\t\t\tbreak;\n\t\tcase DH_PTZ_POINT_LOOP_CONTROL:\n\t\t\t//Begin tour/stop tour \n\t\t\tif (0 == dwParam) \n\t\t\t{\n\t\t\t\tparam1=(long)m_crviseGroup;\n\t\t\t\tparam2=0;\n\t\t\t\tparam3=76;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tparam1=(long)m_crviseGroup;\n\t\t\t\tparam2=0;\n\t\t\t\tparam3=96;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DH_EXTPTZ_ADDTOLOOP:\n\t\t\t//Add tour \n\t\t\tparam1=(long)m_crviseGroup;\n\t\t\tparam2=(long)m_presetData;\n\t\t\tparam3=0;\n\t\t\tbreak;\n\t\tcase DH_EXTPTZ_DELFROMLOOP:\n\t\t\t//Delete tour \n\t\t\tparam1=(long)m_crviseGroup;\n\t\t\tparam2=(long)m_presetData;\n\t\t\tparam3=0;\n\t\t\tbreak;\n\t\tcase DH_EXTPTZ_CLOSELOOP:\n\t\t\t//Delete tour group \n\t\t\tparam1=(long)m_crviseGroup;\n\t\t\tparam2=0;//(long)m_presetData;\n\t\t\tparam3=0;\n\t\t\tbreak;\n\t\tcase DH_EXTPTZ_SETMODESTART:\n\t\t\t//begin record \n\t\t\tparam1=(long)m_moveNo;\n\t\t\tparam2=0;\n\t\t\tparam3=0;\n\t\t\tbreak;\n\t\tcase DH_EXTPTZ_SETMODESTOP:\n\t\t\t//Stop record \n\t\t\tparam1=(long)m_moveNo;\n\t\t\tparam2=0;\n\t\t\tparam3=0;\n\t\t\tbreak;\n\t\tcase DH_EXTPTZ_RUNMODE:\n\t\t\t//begin pattern \n\t\t\tparam1=(long)m_moveNo;\n\t\t\tparam2=0;\n\t\t\tparam3=0;\n\t\t\tbreak;\n\t\tcase DH_EXTPTZ_STOPMODE:\n\t\t\t//Stop pattern \n\t\t\tparam1=(long)m_moveNo;\n\t\t\tparam2=0;\n\t\t\tparam3=0;\n\t\t\tbreak;\n\t\tcase DH_EXTPTZ_DELETEMODE:\n\t\t\t//Delete pattern \n\t\t\tparam1=(long)m_moveNo;\n\t\t\tparam2=0;\n\t\t\tparam3=0;\n\t\t\tbreak;\n\t\tcase DH_EXTPTZ_SETLEFTBORDER:\n\t\t\t//set left limit\n\t\t\tparam1=0;\n\t\t\tparam2=0;\n\t\t\tparam3=0;\n\t\t\tbreak;\n\t\tcase DH_EXTPTZ_SETRIGHTBORDER:\n\t\t\t//set right limit\n\t\t\tparam1=0;\n\t\t\tparam2=0;\n\t\t\tparam3=0;\n\t\t\tbreak;\n\t\tcase DH_EXTPTZ_STARTLINESCAN:\n\t\t\t//begin scan \n\t\t\tparam1=0;\n\t\t\tparam2=0;\n\t\t\tparam3=0;\n\t\t\tbreak;\n\t\tcase DH_EXTPTZ_CLOSELINESCAN:\n\t\t\t//Stop scan \n\t\t\tparam1=0;\n\t\t\tparam2=0;\n\t\t\tparam3=0;\n\t\t\tbreak;\n\t\tcase DH_EXTPTZ_FASTGOTO:\n\t\tcase DH_EXTPTZ_EXACTGOTO:\n\t\t\t//3D intelligent position \n\t\t\tparam1=m_posX;\n\t\t\tparam2=m_posY;\n\t\t\tparam3=m_posZoom;\n\t\t\tbreak;\n\t\tcase DH_EXTPTZ_RESETZERO:\n\t\t\tparam1=0;\n\t\t\tparam2=0;\n\t\t\tparam3=0;\n\t\t\tbreak;\n\t\tcase DH_EXTPTZ_STARTPANCRUISE:\n\t\t\t//Begin rotation\n\t\t\tparam1=0;\n\t\t\tparam2=0;\n\t\t\tparam3=0;\n\t\t\tbreak;\n\t\tcase DH_EXTPTZ_STOPPANCRUISE:\n\t\t\t//Stop rotation \n\t\t\tparam1=0;\n\t\t\tparam2=0;\n\t\t\tparam3=0;\n\t\t\tbreak;\n\t\tcase DH_EXTPTZ_AUXIOPEN:\n\t\t\t//Enable auxilian function \n\t\t\tm_auxNosel.GetWindowText(strAuxNo);\n\t\t\tparam1=atoi(strAuxNo);\n\t\t\tparam2=0;\n\t\t\tparam3=0;\n\t\t\tbreak;\n\t\tcase DH_EXTPTZ_AUXICLOSE:\n\t\t\t//Stop auxilian function\n\t\t\tm_auxNosel.GetWindowText(strAuxNo);\n\t\t\tparam1=atoi(strAuxNo);\n\t\t\tparam2=0;\n\t\t\tparam3=0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tBOOL bRet=CLIENT_DHPTZControlEx(m_LoginID,iChannel,dwCommand,param1,param2,param3,FALSE);\n\t\tif(bRet)\n\t\t{\n\t\t\tSetDlgItemText(IDC_PTZSTATUS, ConvertString(\"Succeed\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSetDlgItemText(IDC_PTZSTATUS, ConvertString(\"Fail\"));\n\t\t}\n\t}\n}\n\n//Go to preset \nvoid CAlarmDeviceDlg::OnPresetSet() \n{\n\t// TODO: Add your control notification handler code here\n\tBOOL bValid = UpdateData(TRUE);\n\tif(bValid)\n\t{\n\t\tPtzExtControl(DH_PTZ_POINT_MOVE_CONTROL);\n\t}\n}\n\n//Add preset \nvoid CAlarmDeviceDlg::OnPresetAdd() \n{\n\t// TODO: Add your control notification handler code here\n\tBOOL bValid = UpdateData(TRUE);\n\tif(bValid)\n\t{\n\t\tPtzExtControl(DH_PTZ_POINT_SET_CONTROL);\n\t}\n}\n\n//Delete preset \nvoid CAlarmDeviceDlg::OnPresetDele() \n{\n\t// TODO: Add your control notification handler code here\n\tBOOL bValid = UpdateData(TRUE);\n\tif(bValid)\n\t{\n\t\tPtzExtControl(DH_PTZ_POINT_DEL_CONTROL);\n\t}\n}\n\n//Begin tour \nvoid CAlarmDeviceDlg::OnStartCruise() \n{\n\t// TODO: Add your control notification handler code here\n\tBOOL bValid = UpdateData(TRUE);\n\tif(bValid)\n\t{\n\t\tCString str;\n\t\tif(GetDlgItemText(IDC_START_CRUISE,str),(str == \"Start Tour\" || str == ConvertString(\"Start Tour\")))\n\t\t{\n\t\t\tSetDlgItemText(IDC_START_CRUISE, ConvertString(\"Stop Tour\"));\n\t\t\tPtzExtControl(DH_PTZ_POINT_LOOP_CONTROL, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSetDlgItemText(IDC_START_CRUISE, ConvertString(\"Start Tour\"));\n\t\t\tPtzExtControl(DH_PTZ_POINT_LOOP_CONTROL, 1);\n\t\t}\n\t}\n}\n\n//Add tour \nvoid CAlarmDeviceDlg::OnCruiseAddPoint() \n{\n\t// TODO: Add your control notification handler code here\n\tBOOL bValid = UpdateData(TRUE);\n\tif(bValid)\n\t{\n\t\tPtzExtControl(DH_EXTPTZ_ADDTOLOOP);\n\t}\n}\n\n//Delete tour point\nvoid CAlarmDeviceDlg::OnCruiseDelPoint() \n{\n\t// TODO: Add your control notification handler code here\n\tBOOL bValid = UpdateData(TRUE);\n\tif(bValid)\n\t{\n\t\tPtzExtControl(DH_EXTPTZ_DELFROMLOOP);\n\t}\n}\n\n//Delete tour group \nvoid CAlarmDeviceDlg::OnCruiseDelGroup() \n{\n\t// TODO: Add your control notification handler code here\n\tBOOL bValid = UpdateData(TRUE);\n\tif(bValid)\n\t{\n\t\tPtzExtControl(DH_EXTPTZ_CLOSELOOP);\n\t}\n}\n\n//Begin record \nvoid CAlarmDeviceDlg::OnModeSetBegin() \n{\n\t// TODO: Add your control notification handler code here\n\tBOOL bValid = UpdateData(TRUE);\n\tif(bValid)\n\t{\n\t\tCString str;\n\t\tif(GetDlgItemText(IDC_MODE_SET_BEGIN,str),(str == \"Program Start\" || str == ConvertString(\"Program Start\")))\n\t\t{\n\t\t\tSetDlgItemText(IDC_MODE_SET_BEGIN, ConvertString(\"Program Stop\"));\n\t\t\tPtzExtControl(DH_EXTPTZ_SETMODESTART);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSetDlgItemText(IDC_MODE_SET_BEGIN, ConvertString(\"Program Start\"));\n\t\t\tPtzExtControl(DH_EXTPTZ_SETMODESTOP);\n\t\t}\n\t}\n}\n\n//Begin pattern \nvoid CAlarmDeviceDlg::OnModeStart() \n{\n\t// TODO: Add your control notification handler code here\n\tBOOL bValid = UpdateData(TRUE);\n\tif(bValid)\n\t{\n\t\tCString str;\n\t\tif(GetDlgItemText(IDC_MODE_START,str), (str ==\"Start Pattern\" || str == ConvertString(\"Start Pattern\")))\n\t\t{\n\t\t\tSetDlgItemText(IDC_MODE_START, ConvertString(\"Stop Pattern\"));\n\t\t\tPtzExtControl(DH_EXTPTZ_RUNMODE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSetDlgItemText(IDC_MODE_START, ConvertString(\"Start Pattern\"));\n\t\t\tPtzExtControl(DH_EXTPTZ_STOPMODE);\n\t\t}\n\t}\n}\n\n//Delete pattern \nvoid CAlarmDeviceDlg::OnModeSetDelete() \n{\n\t// TODO: Add your control notification handler code here\n\tBOOL bValid = UpdateData(TRUE);\n\tif(bValid)\n\t{\n\t\tPtzExtControl(DH_EXTPTZ_DELETEMODE);\n\t}\n}\n\n//Set left limit\nvoid CAlarmDeviceDlg::OnLineSetLeft() \n{\n\t// TODO: Add your control notification handler code here\n\tPtzExtControl(DH_EXTPTZ_SETLEFTBORDER);\n}\n\n//Set right limit \nvoid CAlarmDeviceDlg::OnLineSetRight() \n{\n\t// TODO: Add your control notification handler code here\n\tPtzExtControl(DH_EXTPTZ_SETRIGHTBORDER);\n}\n\n//Begin scan \nvoid CAlarmDeviceDlg::OnLineStart() \n{\n\t// TODO: Add your control notification handler code here\n\tCString str;\n\tif(GetDlgItemText(IDC_LINE_START,str),(str == \"Start\" || str == ConvertString(\"Start\")))\n\t{\n\t\tSetDlgItemText(IDC_LINE_START, ConvertString(\"Stop\"));\n\t\tPtzExtControl(DH_EXTPTZ_STARTLINESCAN);\t\n\t}\n\telse\n\t{\n\t\tSetDlgItemText(IDC_LINE_START, ConvertString(\"Start\"));\n\t\tPtzExtControl(DH_EXTPTZ_CLOSELINESCAN);\n\t}\n}\n\n//3D intelligent position \nvoid CAlarmDeviceDlg::OnFastGo() \n{\n\t// TODO: Add your control notification handler code here\n\tBOOL bValid = UpdateData(TRUE);\n\tif(bValid)\n\t{\n\t\tPtzExtControl(DH_EXTPTZ_FASTGOTO);\n\t}\n}\n\nvoid CAlarmDeviceDlg::OnExactGo() \n{\n\t// TODO: Add your control notification handler code here\n\tBOOL bValid = UpdateData(TRUE);\n\tif(bValid)\n\t{\n\t\tPtzExtControl(DH_EXTPTZ_EXACTGOTO);\n\t}\n}\n\n\nvoid CAlarmDeviceDlg::OnResetZero() \n{\n\t// TODO: Add your control notification handler code here\n\tBOOL bValid = UpdateData(TRUE);\n\tif(bValid)\n\t{\n\t\tPtzExtControl(DH_EXTPTZ_RESETZERO);\n\t}\n}\n\n\n//Begin rotation \nvoid CAlarmDeviceDlg::OnRotateStart() \n{\n\t// TODO: Add your control notification handler code here\n\tPtzExtControl(DH_EXTPTZ_STARTPANCRUISE);\n}\n\n//Stop rotation \nvoid CAlarmDeviceDlg::OnRotateStop() \n{\n\t// TODO: Add your control notification handler code here\n\tPtzExtControl(DH_EXTPTZ_STOPPANCRUISE);\n}\n\n//Enable auxilian function \nvoid CAlarmDeviceDlg::OnAuxOpen() \n{\n\t// TODO: Add your control notification handler code here\n\tPtzExtControl(DH_EXTPTZ_AUXIOPEN);\n}\n\n//Close auxilian function\nvoid CAlarmDeviceDlg::OnAuxClose() \n{\n\t// TODO: Add your control notification handler code here\n\tPtzExtControl(DH_EXTPTZ_AUXICLOSE);\n}\n\nvoid CAlarmDeviceDlg::OnBtnPtzmenu() \n{\n\t// TODO: Add your control notification handler code here\n\tif(0 == m_LoginID)\n\t{\n\t\tMessageBox(ConvertString(\"Please login first !\"), ConvertString(\"Prompt\"));\n\t}\n\telse\n\t{\n\t\tCDHPtzMenu dlg;\n\t\tCString strChannel;\n\t\tm_comboChannel.GetWindowText(strChannel);\n\t\tint iChannel=atoi(strChannel);\n\t\tif (iChannel > 0)\n\t\t{\n\t\t\tiChannel -= 1;\n\t\t}\n\t\tdlg.SetPtzParam(m_LoginID, iChannel);\n\t\tdlg.DoModal();\n\t}\n}\n\n//Play video directly \nvoid CAlarmDeviceDlg::DirectPlayMode(int iDispNum,int iChannel,HWND hWnd)\n{\n\t//Close current video \n\tCloseDispVideo(iDispNum);\n\t\n\tLLONG lRet = CLIENT_RealPlayEx(m_LoginID,iChannel,hWnd);\n\tif(0 != lRet)\n\t{\n\t\tm_DispHanle[iDispNum-1]=lRet;\n\t\tSetPlayVideoInfo(iDispNum,iChannel,DirectMode);\n        CPlayWnd* pWnd = (CPlayWnd*)FromHandle(hWnd);\n        pWnd->SetWndPlay(true);\n\t}\n\telse\n\t{\n\t\tMessageBox(ConvertString(\"Fail to play!\"), ConvertString(\"Prompt\"));\n\t}\n}\n\nvoid CALLBACK RealDataCallBackEx(LLONG lRealHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize, LLONG lParam, LDWORD dwUser)\n{\n\tif(dwUser == 0)\n\t{\n\t\treturn;\n\t}\n\n\tCAlarmDeviceDlg *dlg = (CAlarmDeviceDlg *)dwUser;\n\tdlg->ReceiveRealData(lRealHandle,dwDataType, pBuffer, dwBufSize, lParam);\n}\n\n//Play video in data callback mode \nvoid CAlarmDeviceDlg::ServerPlayMode(int iDispNum, int iChannel, HWND hWnd)\n{\n\t//Close current video \n\tCloseDispVideo(iDispNum);\n\t\n\t//Enable stream\n\tBOOL bOpenRet = s_PlayAPI.PLAY_OpenStream(iDispNum,0,0,1024*900);\n\tif(bOpenRet)\n\t{\n\t\t//Begin play \n\t\tBOOL bPlayRet = s_PlayAPI.PLAY_Play(iDispNum,hWnd);\n\t\tif(bPlayRet)\n\t\t{\n\t\t\t//Real-time play \n\t\t\tLLONG lRet = CLIENT_RealPlayEx(m_LoginID,iChannel,0);\n\t\t\tif(0 != lRet)\n\t\t\t{\n\t\t\t\tm_DispHanle[iDispNum-1]=lRet;\n\t\t\t\tSetPlayVideoInfo(iDispNum,iChannel,ServerMode);\n\t\t\t\t//Callback monitor data and then save \n\t\t\t\tCLIENT_SetRealDataCallBackEx2(lRet, RealDataCallBackEx, (LDWORD)this, 0x0f);\n                CPlayWnd* pWnd = (CPlayWnd*)FromHandle(hWnd);\n                pWnd->SetWndPlay(true);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tMessageBox(ConvertString(\"Fail to play!\"), ConvertString(\"Prompt\"));\n\t\t\t\ts_PlayAPI.PLAY_Stop(iDispNum);\n\t\t\t\ts_PlayAPI.PLAY_CloseStream(iDispNum);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts_PlayAPI.PLAY_CloseStream(iDispNum);\n\t\t}\n\t}\n\telse\n\t{\n\t\t//TRACE(\"PLAY_OpenStream failed, error: %d\\n\", s_PlayAPI.PLAY_GetLastError(iDispNum));\n\t}\n}\n\n//Process after receiving real-time data \nvoid CAlarmDeviceDlg::ReceiveRealData(LLONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, LDWORD dwBufSize, LLONG lParam)\n{\n\t//Stream port number according to the real-time handle.\n\tlong lRealPort=GetStreamPort(lRealHandle);\n\t//Input the stream data getting from the card\n\tBOOL bInput=FALSE;\n\tif(0 != lRealPort)\n\t{\n\t\tswitch(dwDataType) {\n\t\tcase 0:\n\t\t\t//Original data \n\t\t\tbInput = s_PlayAPI.PLAY_InputData(lRealPort,pBuffer,dwBufSize);\n\t\t\tif (!bInput)\n\t\t\t{\n\t\t\t\t//TRACE(\"input data error: %d\\n\", PLAY_GetLastError(lRealPort));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t//Standard video data \n\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t//yuv data \n\t\t\t\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t//pcm audio data \n\t\t\t\n\t\t\tbreak;\t\t\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\t\n\t}\n}\n\nlong CAlarmDeviceDlg::GetStreamPort(LLONG lRealHandle)\n{\n\tlong lPort=0;\n\tfor(int i=0;i<9;i++)\n\t{\n\t\tif(lRealHandle == m_DispHanle[i])\n\t\t{\n\t\t\tlPort=i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn lPort;\n}\n\n//Close video directly \nvoid CAlarmDeviceDlg::StopPlayForDirectMode(int iDispNum)\n{\n\tif(0 != m_DispHanle[iDispNum-1])\n\t{\n\t\tBOOL bRet = CLIENT_StopRealPlay(m_DispHanle[iDispNum-1]);\n        HWND hWnd=GetDispHandle(iDispNum);\n        CPlayWnd* pWnd = (CPlayWnd*)FromHandle(hWnd);\n        pWnd->SetWndPlay(false);\n\t}\n}\n\n//Close video by data callback way \nvoid CAlarmDeviceDlg::StopPlayForServerMode(int iDispNum)\n{\n\t//First close CLIENT_RealPlay\n\tif(0 != m_DispHanle[iDispNum-1])\n\t{\n\t\tBOOL bRealPlay = CLIENT_StopRealPlay(m_DispHanle[iDispNum-1]);\n\t\tif(bRealPlay)\n\t\t{\n            HWND hWnd=GetDispHandle(iDispNum);\n            CPlayWnd* pWnd = (CPlayWnd*)FromHandle(hWnd);\n            pWnd->SetWndPlay(false);\n\t\t\t//And then close PLAY_Play\n\t\t\tBOOL bPlay = s_PlayAPI.PLAY_Stop(iDispNum);\n\t\t\tif(bPlay)\n\t\t\t{\n\t\t\t\t//At last close PLAY_OpenStream\n\t\t\t\tBOOL bStream = s_PlayAPI.PLAY_CloseStream(iDispNum);\n\t\t\t}\n\t\t}\n\t}\n}\n\n//Multiple-window preview \nvoid CAlarmDeviceDlg::MultiPlayMode(int iDispNum, HWND hWnd)\n{\n\t//Close current video \n\tCloseDispVideo(iDispNum);\n\t\n\tCMultiPlay dlg;\n\tdlg.SetMultiPlayDlgInfo(m_nChannelCount);\n\tINT_PTR nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\tint nChannel = dlg.m_nChannel;\n\t\tint nMultiPlay = dlg.m_nMultiPlay;\n\t\tif(0 < nMultiPlay)\n\t\t{\n\t\t\tif(0 != m_LoginID)\n\t\t\t{\n\t\t\t\tLLONG lRet = 0;\n\t\t\t\tswitch(nMultiPlay) {\n\t\t\t\tcase 1:\n\t\t\t\t\tlRet = CLIENT_RealPlayEx(m_LoginID,nChannel,hWnd,DH_RType_Multiplay_1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tlRet = CLIENT_RealPlayEx(m_LoginID,nChannel,hWnd,DH_RType_Multiplay_4);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tlRet = CLIENT_RealPlayEx(m_LoginID,nChannel,hWnd,DH_RType_Multiplay_8);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 9:\n\t\t\t\t\tlRet = CLIENT_RealPlayEx(m_LoginID,nChannel,hWnd,DH_RType_Multiplay_9);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 16:\n\t\t\t\t\tlRet = CLIENT_RealPlayEx(m_LoginID,nChannel,hWnd,DH_RType_Multiplay_16);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(0 != lRet)\n\t\t\t\t{\n\t\t\t\t\tm_DispHanle[iDispNum-1]=lRet;\n\t\t\t\t\tSetPlayVideoInfo(iDispNum,nChannel,MultiMode);\n                    CPlayWnd* pWnd = (CPlayWnd*)FromHandle(hWnd);\n                    pWnd->SetWndPlay(true);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tMessageBox(ConvertString(\"Fail to play!\"), ConvertString(\"Prompt\"));\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t}\n}\n\n//Close video by multiple-window preview \nvoid CAlarmDeviceDlg::StopPlayForMultiMode(int iDispNum)\n{\n\tif(0 != m_DispHanle[iDispNum-1])\n\t{\n\t\tBOOL bRet = CLIENT_StopRealPlayEx(m_DispHanle[iDispNum-1]);\n        HWND hWnd=GetDispHandle(iDispNum);\n        CPlayWnd* pWnd = (CPlayWnd*)FromHandle(hWnd);\n        pWnd->SetWndPlay(false);\n\t}\n}\n\n//Display log in failure reason \nvoid CAlarmDeviceDlg::ShowLoginErrorReason(int nError)\n{\n\tif(1 == nError)\t\tMessageBox(ConvertString(\"Invalid password!\"), ConvertString(\"Prompt\"));\n\telse if(2 == nError)\tMessageBox(ConvertString(\"Invalid account!\"), ConvertString(\"Prompt\"));\n\telse if(3 == nError)\tMessageBox(ConvertString(\"Timeout!\"), ConvertString(\"Prompt\"));\n\telse if(4 == nError)\tMessageBox(ConvertString(\"The user has logged in!\"), ConvertString(\"Prompt\"));\n\telse if(5 == nError)\tMessageBox(ConvertString(\"The user has been locked!\"), ConvertString(\"Prompt\"));\n\telse if(6 == nError)\tMessageBox(ConvertString(\"The user has listed into illegal!\"), ConvertString(\"Prompt\"));\n\telse if(7 == nError)\tMessageBox(ConvertString(\"The system is busy!\"), ConvertString(\"Prompt\"));\n\telse if(9 == nError)\tMessageBox(ConvertString(\"You Can't find the network server!\"), ConvertString(\"Prompt\"));\n\telse\tMessageBox(ConvertString(\"Login failed!\"), ConvertString(\"Prompt\"));\n}\n\n//Display function execution error reason \nvoid CAlarmDeviceDlg::LastError()\n{\n\tDWORD dwError = CLIENT_GetLastError();\n\tswitch(dwError)\n\t{\n\tcase NET_NOERROR:\t\t\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_NOERROR));\n\t\tbreak;\n\tcase NET_ERROR:\t\t\t\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_ERROR));\n\t\tbreak;\n\tcase NET_SYSTEM_ERROR:\t\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_SYSTEM_ERROR));\n\t\tbreak;\n\tcase NET_NETWORK_ERROR:\t\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_NETWORK_ERROR));\n\t\tbreak;\n\tcase NET_DEV_VER_NOMATCH:\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_DEV_VER_NOMATCH));\n\t\tbreak;\n\tcase NET_INVALID_HANDLE:\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_INVALID_HANDLE));\n\t\tbreak;\n\tcase NET_OPEN_CHANNEL_ERROR:\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_OPEN_CHANNEL_ERROR));\n\t\tbreak;\n\tcase NET_CLOSE_CHANNEL_ERROR:\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_CLOSE_CHANNEL_ERROR));\n\t\tbreak;\n\tcase NET_ILLEGAL_PARAM:\t\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_ILLEGAL_PARAM));\n\t\tbreak;\n\tcase NET_SDK_INIT_ERROR:\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_SDK_INIT_ERROR));\n\t\tbreak;\n\tcase NET_SDK_UNINIT_ERROR:\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_SDK_UNINIT_ERROR));\n\t\tbreak;\n\tcase NET_RENDER_OPEN_ERROR:\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_RENDER_OPEN_ERROR));\n\t\tbreak;\n\tcase NET_DEC_OPEN_ERROR:\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_DEC_OPEN_ERROR));\n\t\tbreak;\n\tcase NET_DEC_CLOSE_ERROR:\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_DEC_CLOSE_ERROR));\n\t\tbreak;\n\tcase NET_MULTIPLAY_NOCHANNEL:\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_MULTIPLAY_NOCHANNEL));\n\t\tbreak;\n\tcase NET_TALK_INIT_ERROR:\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_TALK_INIT_ERROR));\n\t\tbreak;\n\tcase NET_TALK_NOT_INIT:\t\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_TALK_NOT_INIT));\n\t\tbreak;\t\n\tcase NET_TALK_SENDDATA_ERROR:\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_TALK_SENDDATA_ERROR));\n\t\tbreak;\n\tcase NET_NO_TALK_CHANNEL:\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_NO_TALK_CHANNEL));\n\t\tbreak;\n\tcase NET_NO_AUDIO:\t\t\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_NO_AUDIO));\n\t\tbreak;\t\t\t\t\t\t\t\t\n\tcase NET_REAL_ALREADY_SAVING:\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_REAL_ALREADY_SAVING));\n\t\tbreak;\n\tcase NET_NOT_SAVING:\t\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_NOT_SAVING));\n\t\tbreak;\n\tcase NET_OPEN_FILE_ERROR:\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_OPEN_FILE_ERROR));\n\t\tbreak;\n\tcase NET_PTZ_SET_TIMER_ERROR:\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_PTZ_SET_TIMER_ERROR));\n\t\tbreak;\n\tcase NET_RETURN_DATA_ERROR:\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_RETURN_DATA_ERROR));\n\t\tbreak;\n\tcase NET_INSUFFICIENT_BUFFER:\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_INSUFFICIENT_BUFFER));\n\t\tbreak;\n\tcase NET_NOT_SUPPORTED:\t\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_NOT_SUPPORTED));\n\t\tbreak;\n\tcase NET_NO_RECORD_FOUND:\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_NO_RECORD_FOUND));\n\t\tbreak;\t\n\tcase NET_LOGIN_ERROR_PASSWORD:\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_LOGIN_ERROR_PASSWORD));\n\t\tbreak;\n\tcase NET_LOGIN_ERROR_USER:\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_LOGIN_ERROR_USER));\n\t\tbreak;\n\tcase NET_LOGIN_ERROR_TIMEOUT:\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_LOGIN_ERROR_TIMEOUT));\n\t\tbreak;\n\tcase NET_LOGIN_ERROR_RELOGGIN:\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_LOGIN_ERROR_RELOGGIN));\n\t\tbreak;\n\tcase NET_LOGIN_ERROR_LOCKED:\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_LOGIN_ERROR_LOCKED));\n\t\tbreak;\n\tcase NET_LOGIN_ERROR_BLACKLIST:\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_LOGIN_ERROR_BLACKLIST));\n\t\tbreak;\n\tcase NET_LOGIN_ERROR_BUSY:\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_LOGIN_ERROR_BUSY));\n\t\tbreak;\n\tcase NET_LOGIN_ERROR_CONNECT:\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_LOGIN_ERROR_CONNECT));\n\t\tbreak;\n\tcase NET_LOGIN_ERROR_NETWORK:\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_LOGIN_ERROR_NETWORK));\n\t\tbreak;\t\t\t\t\t\t\t\t\n\tcase NET_RENDER_SOUND_ON_ERROR:\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_RENDER_SOUND_ON_ERROR));\n\t\tbreak;\n\tcase NET_RENDER_SOUND_OFF_ERROR:\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_RENDER_SOUND_OFF_ERROR));\n\t\tbreak;\n\tcase NET_RENDER_SET_VOLUME_ERROR:\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_RENDER_SET_VOLUME_ERROR));\n\t\tbreak;\n\tcase NET_RENDER_ADJUST_ERROR:\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_RENDER_ADJUST_ERROR));\n\t\tbreak;\n\tcase NET_RENDER_PAUSE_ERROR:\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_RENDER_PAUSE_ERROR));\n\t\tbreak;\n\tcase NET_RENDER_SNAP_ERROR:\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_RENDER_SNAP_ERROR));\n\t\tbreak;\n\tcase NET_RENDER_STEP_ERROR:\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_RENDER_STEP_ERROR));\n\t\tbreak;\n\tcase NET_RENDER_FRAMERATE_ERROR:\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_RENDER_FRAMERATE_ERROR));\n\t\tbreak;\n\tcase NET_CONFIG_DEVBUSY:\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_CONFIG_DEVBUSY));\n\t\tbreak;\n\tcase NET_CONFIG_DATAILLEGAL:\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_CONFIG_DATAILLEGAL));\n\t\tbreak;\t\t\t\t\t\t\t\n\tcase NET_NO_INIT:\t\t\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_NO_INIT));\n\t\tbreak;\n\tcase NET_DOWNLOAD_END:\t\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_DOWNLOAD_END));\n\t\tbreak;\n\tdefault:\t\t\t\t\t\t\tGetDlgItem(IDC_LAST_ERROR)->SetWindowText(ConvertString(ERROR_NET_ERROR));\t\t\t\t\t\t\n\t}\n}\n\n//Data callback mode in multiple-window preview \nvoid CAlarmDeviceDlg::MultiPlayServerMode(int iDispNum, HWND hWnd)\n{\n\t//Close current video \n\tCloseDispVideo(iDispNum);\n\t\n\tCMultiPlay dlg;\n\tdlg.SetMultiPlayDlgInfo(m_nChannelCount);\n\tINT_PTR nResponse = dlg.DoModal();\n\tif (nResponse == IDOK)\n\t{\n\t\tint nChannel = dlg.m_nChannel;\n\t\tint nMultiPlay = dlg.m_nMultiPlay;\n\t\tif(0 < nMultiPlay)\n\t\t{\n\t\t\tif(0 != m_LoginID)\n\t\t\t{\n\t\t\t\t//Enable stream\n\t\t\t\tBOOL bOpenRet = s_PlayAPI.PLAY_OpenStream(iDispNum,0,0,1024*900);\n\t\t\t\tif(bOpenRet)\n\t\t\t\t{\n\t\t\t\t\t//Begin play \n\t\t\t\t\tBOOL bPlayRet = s_PlayAPI.PLAY_Play(iDispNum,hWnd);\n\t\t\t\t\tif(bPlayRet)\n\t\t\t\t\t{\n\t\t\t\t\t\t//Real-time play \n\t\t\t\t\t\tLLONG lRet = 0;\n\t\t\t\t\t\tswitch(nMultiPlay)\n                        {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tlRet = CLIENT_RealPlayEx(m_LoginID,nChannel,0,DH_RType_Multiplay_1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tlRet = CLIENT_RealPlayEx(m_LoginID,nChannel,0,DH_RType_Multiplay_4);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\tlRet = CLIENT_RealPlayEx(m_LoginID,nChannel,0,DH_RType_Multiplay_8);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 9:\n\t\t\t\t\t\t\tlRet = CLIENT_RealPlayEx(m_LoginID,nChannel,0,DH_RType_Multiplay_9);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 16:\n\t\t\t\t\t\t\tlRet = CLIENT_RealPlayEx(m_LoginID,nChannel,0,DH_RType_Multiplay_16);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(0 != lRet)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tm_DispHanle[iDispNum-1]=lRet;\n\t\t\t\t\t\t\tSetPlayVideoInfo(iDispNum,nChannel,MultiServerMode);\n\t\t\t\t\t\t\t//Save monitor data callback\n\t\t\t\t\t\t\tCLIENT_SetRealDataCallBackEx2(lRet, RealDataCallBackEx, (LDWORD)this, 0x0f);\n                            CPlayWnd* pWnd = (CPlayWnd*)FromHandle(hWnd);\n                            pWnd->SetWndPlay(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ts_PlayAPI.PLAY_Stop(iDispNum);\n\n\t\t\t\t\t\t\ts_PlayAPI.PLAY_CloseStream(iDispNum);\n\t\t\t\t\t\t\tMessageBox(ConvertString(\"Fail to play!\"), ConvertString(\"Prompt\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n//Close video by data callback mode in multiple-window preview\nvoid CAlarmDeviceDlg::StopPlayForMultiServer(int iDispNum)\n{\n\t//First close CLIENT_RealPlay\n\tif(0 != m_DispHanle[iDispNum-1])\n\t{\n\t\tBOOL bRealPlay = CLIENT_StopRealPlay(m_DispHanle[iDispNum-1]);\n\t\tif(bRealPlay)\n\t\t{\n            HWND hWnd=GetDispHandle(iDispNum);\n            CPlayWnd* pWnd = (CPlayWnd*)FromHandle(hWnd);\n            pWnd->SetWndPlay(false);\n\t\t\t//Then close PLAY_Play\n\t\t\tBOOL bPlay = s_PlayAPI.PLAY_Stop(iDispNum);\n\t\t\tif(bPlay)\n\t\t\t{\n\t\t\t\t//At last close PLAY_OpenStream\n\t\t\t\tBOOL bStream = s_PlayAPI.PLAY_CloseStream(iDispNum);\n\t\t\t}\n\t\t}\n\t}\n}\n\n//Close video \nvoid CAlarmDeviceDlg::CloseDispVideo(int iDispNum)\n{\n\t//Close current video \n\tenum RealPlayMode ePlayMode = m_videoNodeInfo[iDispNum-1].GetPlayMode();\n\tif(ePlayMode == DirectMode)\n\t{\n\t\tStopPlayForDirectMode(iDispNum);\n\t}\n\telse if(ePlayMode == ServerMode)\n\t{\n\t\tStopPlayForServerMode(iDispNum);\n\t}\n\telse if(ePlayMode == MultiMode)\n\t{\n\t\tStopPlayForMultiMode(iDispNum);\n\t}\n\telse if(ePlayMode == MultiServerMode)\n\t{\n\t\tStopPlayForMultiServer(iDispNum);\n\t}\n}\n\n/************************************************************************/\n/* Callback function                                                      */\n/************************************************************************/\nvoid CALLBACK RectEventFunc(RECT WinRect,CPoint &pointStart,CPoint &pointEnd,LDWORD dwUser)\n{\n\tCAlarmDeviceDlg *dlg =(CAlarmDeviceDlg *)dwUser;\n\tCPoint Origin;\n\tCPoint SendPoint;\n\t\n\tOrigin.x = ( WinRect.left + WinRect.right ) / 2;\n\tOrigin.y = ( WinRect.top + WinRect.bottom ) / 2;\n\t\n\tint dx = (pointStart.x + pointEnd.x)/2;\n\tint dy = (pointStart.y + pointEnd.y)/2;\n\t\n\tint width  = WinRect.right - WinRect.left;\n\tint height = WinRect.bottom - WinRect.top; \n\t\n\tSendPoint.x = ( dx - Origin.x) * 8192 * 2 / width;\n\tSendPoint.y = ( dy - Origin.y) * 8192 * 2  / height ;\n\t\n\tint width2 = pointEnd.x - pointStart.x;\n\tint height2 = pointEnd.y - pointStart.y;\n\tint multiple = 0;\n\n\tif ( height2 !=0 && width2!=0)\n\t{\n\t\tmultiple = (width * height) / (width2 * height2);\n\t}\n\t\n\tdlg->m_posX = SendPoint.x;\n\tdlg->m_posY = SendPoint.y;\n\tdlg->m_posZoom = multiple;\n\tdlg->UpdateData(FALSE);\n\tdlg->PtzExtControl(DH_EXTPTZ_FASTGOTO);\n}\nvoid CALLBACK  MessageProcFunc(int nWndID, UINT message, LDWORD dwUser)\n{\n\tif(dwUser == 0)\n\t{\n\t\treturn;\n\t}\n\t\n\tCAlarmDeviceDlg *dlg = (CAlarmDeviceDlg *)dwUser;\n\tdlg->MessageProc(nWndID, message);\n\n}\nBOOL CALLBACK  GetParamsFunc(int nWndID, int type, LDWORD dwUser)\n{\n\tif(dwUser == 0)\n\t{\n\t\treturn FALSE;\n\t}\n\tCAlarmDeviceDlg *dlg = (CAlarmDeviceDlg *)dwUser;\n\treturn dlg->GetParams(nWndID, type);\n}\n\nBOOL CAlarmDeviceDlg::GetParams(int nWndID, int type)\n{\n\tBOOL bRet = FALSE;\n\t\n\tif (type == 0)\n\t{\n\t\tbRet = GetExitDecode(nWndID);\n\t}\n\telse if (type == 1)\n\t{\n\t\tbRet = GetExitCycle(nWndID);\n\t}\n\t\n\treturn bRet;\n}\n\nvoid CALLBACK SetParamsFunc(int nWndID, int type, LDWORD dwUser)\n{\n\tif(dwUser == 0)\n\t{\n\t\treturn;\n\t}\n\t\n\tCAlarmDeviceDlg *dlg = (CAlarmDeviceDlg *)dwUser;\n\tdlg->SetParams(nWndID, type);\n}\n\nvoid CAlarmDeviceDlg::SetParams(int nWndID, int type)\n{\n\tif (type == 0)\n\t{\n\t\tSetExitDecode(nWndID);\n\t}\n\telse if (type == 1)\n\t{\n\t\tSetExitCycle(nWndID);\n\t}\n\n}\nvoid CAlarmDeviceDlg::MessageProc(int nWndID, UINT message)\n{\n\tswitch(message)\n\t{\n\tcase WM_LBUTTONDOWN:\n\tcase WM_RBUTTONDOWN:\n\t\t{\n\t\t\tm_CurScreen =nWndID;\n\t\t\tm_comboDispNum.SetCurSel(m_CurScreen);\n\t\t\t//SetCurWindId(nWndID);\n\t\t\t//UpdateCurScreenInfo();\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t\n}\nBOOL CAlarmDeviceDlg::GetExitDecode(int nCurWndID)\n{\n\tBOOL bRet = FALSE;\n\tif (nCurWndID<0 || nCurWndID>=16)\n\t{\n\t\treturn bRet;\n\t}\n\t\n\tBOOL bIsTimeOut = m_cs.Lock();\n\tif(bIsTimeOut)\n\t{\n\t\tbRet = m_bWndExitDecode[nCurWndID];\n\t\tm_cs.Unlock();\n\t}\n\t\n\treturn bRet;\n}\n\nBOOL CAlarmDeviceDlg::GetExitCycle(int nCurWndID)\n{\n\tBOOL bRet = FALSE;\n\tif (nCurWndID<0 || nCurWndID>=16)\n\t{\n\t\treturn bRet;\n\t}\n\t\n\tbRet = m_bWndExitCycle[nCurWndID];\n\t\n\treturn bRet;\n}\n\nvoid CAlarmDeviceDlg::SetExitDecode(int nCurWndID)\n{\n\tif (nCurWndID<0 || nCurWndID>=16)\n\t{\n\t\treturn;\n\t}\n\t\n\tBOOL bIsTimeOut = m_cs.Lock();\n\tif(bIsTimeOut)\n\t{\n\t\tm_bWndExitDecode[nCurWndID] = !m_bWndExitDecode[nCurWndID];\n\t\tm_cs.Unlock();\n\t}\n}\n\nvoid CAlarmDeviceDlg::SetExitCycle(int nCurWndID)\n{\n\tif (nCurWndID<0 || nCurWndID>=16)\n\t{\n\t\treturn;\n\t}\n\t\n\tm_bWndExitCycle[nCurWndID] = !m_bWndExitCycle[nCurWndID];\n}\n\nvoid CAlarmDeviceDlg::OnSelchangeCOMBODispNum() \n{\n\t// TODO: Add your control notification handler code here\n\tm_CurScreen = m_comboDispNum.GetCurSel();\n\tm_ptzScreen.SetActiveWnd(m_CurScreen,TRUE);;\n}\n\nvoid CAlarmDeviceDlg::OnCloseupCOMBODispNum() \n{\n\t// TODO: Add your control notification handler code here\n\t\n}\n\nUINT32 CAlarmDeviceDlg::GetAnalogAlarmIn()\n{\n\tchar szBuf[1024 * 10] = {0};\n\tint nErr = 0;\n\tBOOL bRet = CLIENT_QueryNewSystemInfo(m_LoginID, CFG_CAP_CMD_ANALOGALARM, -1, szBuf, sizeof(szBuf), &nErr, SDK_API_WAIT);\n\tif (bRet)\n\t{\n\t\tCFG_CAP_ANALOGALARM stuInfo = {0};\n\t\tint nRet = 0;\n\t\tbRet = CLIENT_ParseData(CFG_CAP_CMD_ANALOGALARM, szBuf, &stuInfo, sizeof(stuInfo), &nRet);\n\t\tif (bRet && nRet == sizeof(CFG_CAP_ANALOGALARM))\n\t\t{\n\t\t\treturn stuInfo.dwLocalNum;\n\t\t}\n\t}\n\treturn 0;\n}\n//////////////////////////////////////////////////////////////////////////\n\nvoid CAlarmDeviceDlg::AlarmCenterCfg()\n{\n\tCDlgCfgAlarmCenter dlg(this, m_LoginID);\n \tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::AlarmOutCfg()\n{\n\tDlgCfgAlarmOut dlg(this, m_LoginID, m_uiAlarmOut);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::CommGlobalCfg()\n{\n \tCDlgCfgGuard dlg(this, m_LoginID);\n \tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::AlarmCfg()\n{\n\tCDlgCfgAlarm dlg(this, m_LoginID, m_uiAlarmIn);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::PSTN_Alarm_Server()\n{\t\n\tCDlgCfgPSTNAlarmServer dlg(this, (LLONG)m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::AlarmPowerFault()\n{\n\tCDlgCfgAlarmPowerFault dlg(this, (LLONG)m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::BatteryLowPower()\n{\n\tCDlgCfgBatteryLowPower dlg(this, (LLONG)m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::AlarmChassisIntrusion()\n{\n\tCDlgCfgAlarmChassisIntrusion dlg(this, (LLONG)m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::AlarmExAlarmBox()\n{\n\tCDlgCfgAlarmExAlarmBox dlg(this, (LLONG)m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::AlarmExAlarmInput()\n{\n\tCDlgCfgExAlarmInput dlg(this, (LLONG)m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::AlarmExAlarmOutput()\n{\n\tCDlgCfgExAlarmOutput dlg(this, (LLONG)m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::AlarmExAlarmChannel()\n{\n\tCDlgExAlarmChannel dlg(this, (LLONG)m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::OnBtnConfig() \n{\n\t// TODO: Add your control notification handler code here\n\t\n\ttagEMConfigType emType = (tagEMConfigType)m_cmbConfig.GetCurSel();\n\tswitch(emType)\n\t{\n\tcase emConfigType_Alarm:\n\t\tAlarmCfg();\n\t\tbreak;\n\tcase emConfigType_AlarmCenter:\n\t\tAlarmCenterCfg();\n\t\tbreak;\n\tcase emConfigType_AlarmChassisIntrusion:\n\t\tAlarmChassisIntrusion();\n\t\tbreak;\n\tcase emConfigType_AlarmExAlarmBox:\n\t\tAlarmExAlarmBox();\n\t\tbreak;\n\tcase emConfigType_AlarmExAlarmInput:\n\t\tAlarmExAlarmInput();\n\t\tbreak;\n\tcase emConfigType_AlarmExAlarmOutput:\n\t\tAlarmExAlarmOutput();\n\t\tbreak;\n\tcase emConfigType_AlarmKeyboard:\n\t\tAlarmKeyboard();\n\t\tbreak;\n\tcase emConfigType_AlarmSubSystem:\n\t\tAlarmSubSystemCfg();\n\t\tbreak;\n\tcase emConfigType_AlarmOut:\n\t\tAlarmOutCfg();\n\t\tbreak;\n\tcase emConfigType_AlarmPowerFault:\n\t\tAlarmPowerFault();\n\t\tbreak;\n\tcase emConfigType_AnalogAlarm:\n\t\tAnalogAlarmCfg();\n\t\tbreak;\n\tcase emConfigType_BatteryLowPower:\n\t\tBatteryLowPower();\n\t\tbreak;\n\tcase emConfigType_CommGlobal:\n\t\tCommGlobalCfg();\n\t\tbreak;\n\tcase emConfigType_Locales:\n\t\tLocales();\n\t\tbreak;\n\tcase emConfigType_Mobile:\n\t\tMobile();\n\t\tbreak;\n\tcase emConfigType_Network:\n\t\tNetworkCfg();\n\t\tbreak;\n\tcase emConfigType_NTP:\n\t\tNTP();\n\t\tbreak;\n\tcase emConfigType_PhoneEventNotify:\n\t\tPhoneEventNotify();\n\t\tbreak;\n\tcase emConfigType_PSTN_Alarm_Server:\n\t\tPSTN_Alarm_Server();\n\t\tbreak;\n\tcase emConfigType_SensorSampling:\n\t\tSensorSamplingCfg();\n\t\tbreak;\n\tcase emConfigType_Serial:\n\t\tSerialCfg();\n\t\tbreak;\n\tcase emConfigType_WireLess:\n\t\tWirelessCfg();\n\t\tbreak;\n\tcase emConfigType_AutoMainTain:\n\t\tAutoMainTain();\n\t\tbreak;\n\tcase emConfigType_SetNetworkParam:\n\t\tSetNetworkParam();\n\t\tbreak;\n    case emConfigType_SnapLinkage:\n        SnapLinkage();\n        break;\n\tcase emConfigType_STP:\n\t\tSTPCfg();\n\t\tbreak;\n\tcase emConfigType_Urgency:\n\t\tUrgency();\n\t\tbreak;\n\tcase emConfigType_VW_SensorInfo:\n\t\tVW_SensorInfo();\n\t\tbreak;\n    case emConfigType_AirCondition:\n\t\tAirConditionCfg();\n        break;\n    case emConfigType_NetAbort:\n        NetAbortCfg();\n        break;\n    case emConfigType_IPConflict:\n        IPConflictCfg();\n        break;\n    case emConfigType_MacConflict:\n        MacConflictCfg();\n        break;\n    case emConfigType_PSTNBreakLine:\n        PSTNBreakLineCfg();\n        break;\n\tcase emConfigType_NetCollection:\n\t\tNetCollectionCfg();\n\t\tbreak;\n\tcase emConfigType_AlarmSlotBond:\n\t\tAlarmSlotBondCfg();\n\t\tbreak;\n    case emConfigType_RCEmergencyCall:\n        RCEmergencyCallCfg();\n        break;\n    case emConfigType_AlarmBell:\n        AlarmBellCfg();\n        break;\n    case emConfigType_PSTNPersonServer:\n        PSTNPersonServerCfg();\n        break;\n    case emConfigType_ArmLink:\n        ArmLinkCfg();\n        break;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid CAlarmDeviceDlg::OnBtnCap() \n{\n\t// TODO: Add your control notification handler code here\n\tCDlgCapability dlg(this, m_LoginID, m_uiAlarmIn, m_uiAlarmOut);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::OnBtnSubscribe() \n{\n\t// TODO: Add your control notification handler code here\n\tAlarmSubscribe dlg(this, m_LoginID, m_uiAlarmIn);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::Locales()\n{\n\tCDlgCfgLocales dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::NTP()\n{\n\tCDlgCfgNTP dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::Mobile()\n{\n\tCDlgCfgMobile dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::PhoneEventNotify()\n{\n\tCDlgCfgPhoneNotify dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::NetworkCfg()\n{\n\tCDlgCfgNetwork dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::SerialCfg()\n{\n\tCDlgCfgSerial dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::WirelessCfg()\n{\n\tCDlgCfgWireless dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::AutoMainTain()\n{\n\tCDlgCfgAutoMaintain dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::Urgency()\n{\n\tCDlgCfgAlarmUrgency dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::VW_SensorInfo()\n{\n\tCDlgCfgSensorInfoOfVW dlg(this, m_LoginID, m_nChannelCount);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::AirConditionCfg()\n{\n    CDlgCfgAirCondition dlg(this, m_LoginID);\n    dlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::NetAbortCfg()\n{\n    CDlgCfgNetAbort dlg(this, m_LoginID);\n    dlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::IPConflictCfg()\n{\n    CDlgCfgIPConflict dlg(this, m_LoginID);\n    dlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::MacConflictCfg()\n{\n    CDlgCfgMacConflict dlg(this, m_LoginID);\n    dlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::PSTNBreakLineCfg()\n{\n    CDlgCfgPSTNBreakLine dlg(this, m_LoginID);\n    dlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::PSTNPersonServerCfg()\n{\n    CDlgCfgPSTNPersonServer dlg(this, m_LoginID);\n    dlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::ArmLinkCfg()\n{\n    DlgCfgArmLink dlg(this, m_LoginID);\n    dlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::OnBtnControlQuery() \n{\n\t// TODO: Add your control notification handler code here\n\tswitch ((emControlQueryType)m_cmbControlQueryType.GetCurSel())\n\t{\n\tcase emControlType_AccessManager:\n\t\tAccessManager();\n\t\tbreak;\n\tcase emControlType_AlarmBell:\n\t\tAlarmBell();\n\t\tbreak;\n\tcase emControlType_AlarmChannels:\n\t\tAlarmChannels();\n\t\tbreak;\n\tcase emControlType_AlarmChannelState:\n\t\tAlarmChannelState();\n\t\tbreak;\n    case emControlType_AlarmOutSet:\n        AlarmOutSet();\n        break;\n// \tcase emControlType_AlarmKeyboard:\n// \t\tAlarmKeyboard();\n// \t\tbreak;\n\tcase emControlType_AnalogAlarmChannels:\n\t\tGetAnalogAlarmChannels();\n\t\tbreak;\n\tcase emControlType_AnalogAlarmData:\n\t\tAnalogAlarmData();\n\t\tbreak;\n\tcase emControlType_AudioPlay:\n\t\tPlaySound();\n\t\tbreak;\n\tcase emControlType_FileManager:\n\t\tFileManagerCfg();\n\t\tbreak;\n\tcase emControlType_FileName:\n\t\tFileName();\n\t\tbreak;\n\tcase emControlType_Log:\n\t\tLog();\n\t\tbreak;\n\tcase emControlType_ModifyPasswd:\n\t\tModifyPsw();\n\t\tbreak;\n\tcase emControlType_OpenAccess:\n\t\tOpenAccess();\n\t\tbreak;\n\tcase emControlType_PowerState:\n\t\tPowerState();\n\t\tbreak;\n    case emControlType_RecoverConfig:\n        RestoreCfg();\n        break;\n\tcase emControlType_Version:\n\t\tVersion();\n\t\tbreak;\n\tcase emControlType_UserList:\n\t\tUserList();\n\t\tbreak;\n\tcase emControlType_Upgrade:\n\t\tUpgrade();\n\t\tbreak;\n\tcase emControlType_SetBypass:\n\t\tSetBypassMode();\n\t\tbreak;\n\tcase emControlType_DeviceTime:\n\t\tDeviceTime();\n\t\tbreak;\n\tcase emControlType_AlarmExAlarmChannel:\n\t\tAlarmExAlarmChannel();\n\t\tbreak;\n\tcase emControlType_ActivatedDefenceArea:\n\t\tActivatedDefenceArea();\n\t\tbreak;\n// \tcase emControlType_AttachCfgChange:\n// \t\tAttachCfgChange();\n// \t\tbreak;\n\tcase emControlType_SetArmMode:\n\t\tSetArmMode();\n\t\tbreak;\n// \tcase emControlType_QueryLog:\n// \t\tQueryLog();\n// \t\tbreak;\n\tcase emControlType_UserManager:\n\t\tUserManager();\n\t\tbreak;\n\tcase emControlType_AlarmSubSystem:\n\t\tAlarmSubSystem();\n\t\tbreak;\n    case emControlType_AirConditonOperate:\n        AirConditionOperate();\n        break;\n\tcase emControlType_LowRateWPAN:\n\t\tGetLowRateWPAN();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid CAlarmDeviceDlg::AccessManager()\n{\n\tCDlgAccess dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::AlarmBell()\n{\n\tCDlgAlarmBell dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::AlarmChannelState()\n{\n\tCDlgAlarmState dlg(this, (LLONG)m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::AlarmKeyboard()\n{\n\tCDlgCfgAlarmKeyboard dlg(this, (LLONG)m_LoginID, 256);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::AlarmSubSystemCfg()\n{\n\tCDlgCfgAlarmSubSystem dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::PlaySound()\n{\n\tCDlgOptPlaysound dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::FileManagerCfg()\n{\n\tCDlgFileManager dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::FileName()\n{\n\tCDlgFileList dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::Log()\n{\n\tCDlgQueryLog dlg(this, m_LoginID, m_emDeviceType);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::ModifyPsw()\n{\n\tCDlgUserManage dlg(this, m_LoginID, m_emDeviceType);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::OpenAccess()\n{\n\tCDlgOptAccess dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::PowerState()\n{\n\tCDlgStateBattery dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::RestoreCfg()\n{\n    CDlgRecoverConfig dlg(this, m_LoginID);\n    dlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::Version()\n{\n\tCDlgVersion dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::UserList()\n{\n\tCDlgUserInfo dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::Upgrade()\n{\n\tCDlgUpgrade dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::SetBypassMode()\n{\n\tCDlgBypassCtl dlg(this, m_LoginID, m_uiAlarmIn);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::DeviceTime()\n{\n\tCDlgDeviceTime dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::ActivatedDefenceArea()\n{\n\tCDlgActivatedDefenceArea dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::OnBtnTalk() \n{\n\t// TODO: Add your control notification handler code here\n\tCDlgTalk dlg(this, m_LoginID, m_emDeviceType);\n\tdlg.DoModal();\t\n}\n\nvoid CAlarmDeviceDlg::SetNetworkParam()\n{\n\tCDlgSetNetWorkParam dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\n// void CClientDemoDlg::AttachCfgChange()\n// {\n// \tCDlgCfgChange dlg(this, m_LoginID);\n// \tdlg.DoModal();\n// }\n\nvoid CAlarmDeviceDlg::SetArmMode()\n{\n\tCDlgSetArmMode dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::UserManager()\n{\n\tCTabUserManageDlg dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::SensorSamplingCfg()\n{\n\tCDlgCfgSensorSampling dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::SnapLinkage()\n{\n    CDlgCfgSnapLinkage dlg(this, m_LoginID, m_nChannelCount);\n    dlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::STPCfg()\n{\n\tCDlgCfgSTP dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::GetAnalogAlarmChannels()\n{\n\tCDlgAnalogAlarmChannels dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::AnalogAlarmCfg()\n{\n\tCDlgCfgAnalogAlarm dlg(this, m_LoginID, m_uiAnalogAlarmIn);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::AnalogAlarmData()\n{\n\tCDlgAnalogAlarmData dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::AlarmChannels()\n{\n\tCDlgAlarmChannel dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::AlarmSubSystem()\n{\n\tCDlgAlarmSubSystem dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::AlarmOutSet()\n{\n    CDlgAlarmOutSet dlg(this, m_LoginID, m_uiAlarmOut);\n    dlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::AirConditionOperate()\n{\n    CAirConditionOperate dlg(this, m_LoginID);\n    dlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::NetCollectionCfg()\n{\n\tCDlgCfgNetCollection dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::AlarmSlotBondCfg()\n{\n\tCDlgCfgAlarmSlotBond dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::RCEmergencyCallCfg()\n{\n    CDlgCfgRCEmergencyCall dlg(this, m_LoginID);\n    dlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::AlarmBellCfg()\n{\n    CDlgCfgAlarmBell dlg(this, m_LoginID);\n    dlg.DoModal();\n}\n\nvoid CAlarmDeviceDlg::GetLowRateWPAN()\n{\n\tCDlgLowRateWPAN dlg(this, m_LoginID);\n\tdlg.DoModal();\n}\n\n\n//Process when device disconnected \nLRESULT CAlarmDeviceDlg::OnDisConnect(WPARAM wParam, LPARAM lParam)\n{\n\t//Add process code when device disconnected\n\tSetWindowText(ConvertString(\"Network disconnected\"));\n\treturn 0;\n}\n\n//Process when device reconnect \nLRESULT CAlarmDeviceDlg::OnReConnect(WPARAM wParam, LPARAM lParam)\n{\n\t//Add process code when device reconnect\n\tSetWindowText(ConvertString(\"AlarmDevice\"));\n\treturn 0;\n}","size_bytes":67773},"bin/Demo/MfcDemo/00.DevInit/LibQREncode/rscode.c":{"content":"/*\n * qrencode - QR Code encoder\n *\n * Reed solomon encoder. This code is taken from Phil Karn's libfec then\n * editted and packed into a pair of .c and .h files.\n *\n * Copyright (C) 2002, 2003, 2004, 2006 Phil Karn, KA9Q\n * (libfec is released under the GNU Lesser General Public License.)\n *\n * Copyright (C) 2006-2011 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#if HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include <stdlib.h>\n#include <string.h>\n#ifdef HAVE_LIBPTHREAD\n#  include <pthread.h>\n#endif\n\n#include \"rscode.h\"\n\n/* Stuff specific to the 8-bit symbol version of the general purpose RS codecs\n *\n */\ntypedef unsigned char data_t;\n\n\n/**\n * Reed-Solomon codec control block\n */\nstruct _RS {\n\tint mm;              /* Bits per symbol */\n\tint nn;              /* Symbols per block (= (1<<mm)-1) */\n\tdata_t *alpha_to;     /* log lookup table */\n\tdata_t *index_of;     /* Antilog lookup table */\n\tdata_t *genpoly;      /* Generator polynomial */\n\tint nroots;     /* Number of generator roots = number of parity symbols */\n\tint fcr;        /* First consecutive root, index form */\n\tint prim;       /* Primitive element, index form */\n\tint iprim;      /* prim-th root of 1, index form */\n\tint pad;        /* Padding bytes in shortened block */\n\tint gfpoly;\n\tstruct _RS *next;\n};\n\nstatic RS *rslist = NULL;\n#ifdef HAVE_LIBPTHREAD\nstatic pthread_mutex_t rslist_mutex = PTHREAD_MUTEX_INITIALIZER;\n#endif\n\nint modnn(RS *rs, int x){\n\twhile (x >= rs->nn) {\n\t\tx -= rs->nn;\n\t\tx = (x >> rs->mm) + (x & rs->nn);\n\t}\n\treturn x;\n}\n\n\n#define MODNN(x) modnn(rs,x)\n\n#define MM (rs->mm)\n#define NN (rs->nn)\n#define ALPHA_TO (rs->alpha_to) \n#define INDEX_OF (rs->index_of)\n#define GENPOLY (rs->genpoly)\n#define NROOTS (rs->nroots)\n#define FCR (rs->fcr)\n#define PRIM (rs->prim)\n#define IPRIM (rs->iprim)\n#define PAD (rs->pad)\n#define A0 (NN)\n\n\n/* Initialize a Reed-Solomon codec\n * symsize = symbol size, bits\n * gfpoly = Field generator polynomial coefficients\n * fcr = first root of RS code generator polynomial, index form\n * prim = primitive element to generate polynomial roots\n * nroots = RS code generator polynomial degree (number of roots)\n * pad = padding bytes at front of shortened block\n */\nstatic RS *init_rs_char(int symsize, int gfpoly, int fcr, int prim, int nroots, int pad)\n{\n  RS *rs;\n\n\n/* Common code for intializing a Reed-Solomon control block (char or int symbols)\n * Copyright 2004 Phil Karn, KA9Q\n * May be used under the terms of the GNU Lesser General Public License (LGPL)\n */\n//#undef NULL\n//#define NULL ((void *)0)\n\n  int i, j, sr,root,iprim;\n\n  rs = NULL;\n  /* Check parameter ranges */\n  if(symsize < 0 || symsize > (int)(8*sizeof(data_t))){\n    goto done;\n  }\n\n  if(fcr < 0 || fcr >= (1<<symsize))\n    goto done;\n  if(prim <= 0 || prim >= (1<<symsize))\n    goto done;\n  if(nroots < 0 || nroots >= (1<<symsize))\n    goto done; /* Can't have more roots than symbol values! */\n  if(pad < 0 || pad >= ((1<<symsize) -1 - nroots))\n    goto done; /* Too much padding */\n\n  rs = (RS *)calloc(1,sizeof(RS));\n  if(rs == NULL)\n    goto done;\n\n  rs->mm = symsize;\n  rs->nn = (1<<symsize)-1;\n  rs->pad = pad;\n\n  rs->alpha_to = (data_t *)malloc(sizeof(data_t)*(rs->nn+1));\n  if(rs->alpha_to == NULL){\n    free(rs);\n    rs = NULL;\n    goto done;\n  }\n  rs->index_of = (data_t *)malloc(sizeof(data_t)*(rs->nn+1));\n  if(rs->index_of == NULL){\n    free(rs->alpha_to);\n    free(rs);\n    rs = NULL;\n    goto done;\n  }\n\n  /* Generate Galois field lookup tables */\n  rs->index_of[0] = A0; /* log(zero) = -inf */\n  rs->alpha_to[A0] = 0; /* alpha**-inf = 0 */\n  sr = 1;\n  for(i=0;i<rs->nn;i++){\n    rs->index_of[sr] = i;\n    rs->alpha_to[i] = sr;\n    sr <<= 1;\n    if(sr & (1<<symsize))\n      sr ^= gfpoly;\n    sr &= rs->nn;\n  }\n  if(sr != 1){\n    /* field generator polynomial is not primitive! */\n    free(rs->alpha_to);\n    free(rs->index_of);\n    free(rs);\n    rs = NULL;\n    goto done;\n  }\n\n  /* Form RS code generator polynomial from its roots */\n  rs->genpoly = (data_t *)malloc(sizeof(data_t)*(nroots+1));\n  if(rs->genpoly == NULL){\n    free(rs->alpha_to);\n    free(rs->index_of);\n    free(rs);\n    rs = NULL;\n    goto done;\n  }\n  rs->fcr = fcr;\n  rs->prim = prim;\n  rs->nroots = nroots;\n  rs->gfpoly = gfpoly;\n\n  /* Find prim-th root of 1, used in decoding */\n  for(iprim=1;(iprim % prim) != 0;iprim += rs->nn)\n    ;\n  rs->iprim = iprim / prim;\n\n  rs->genpoly[0] = 1;\n  for (i = 0,root=fcr*prim; i < nroots; i++,root += prim) {\n    rs->genpoly[i+1] = 1;\n\n    /* Multiply rs->genpoly[] by  @**(root + x) */\n    for (j = i; j > 0; j--){\n      if (rs->genpoly[j] != 0)\n\trs->genpoly[j] = rs->genpoly[j-1] ^ rs->alpha_to[modnn(rs,rs->index_of[rs->genpoly[j]] + root)];\n      else\n\trs->genpoly[j] = rs->genpoly[j-1];\n    }\n    /* rs->genpoly[0] can never be zero */\n    rs->genpoly[0] = rs->alpha_to[modnn(rs,rs->index_of[rs->genpoly[0]] + root)];\n  }\n  /* convert rs->genpoly[] to index form for quicker encoding */\n  for (i = 0; i <= nroots; i++)\n    rs->genpoly[i] = rs->index_of[rs->genpoly[i]];\n done:;\n\n  return rs;\n}\n\nRS *init_rs(int symsize, int gfpoly, int fcr, int prim, int nroots, int pad)\n{\n\tRS *rs;\n\n#ifdef HAVE_LIBPTHREAD\n\tpthread_mutex_lock(&rslist_mutex);\n#endif\n\tfor(rs = rslist; rs != NULL; rs = rs->next) {\n\t\tif(rs->pad != pad) continue;\n\t\tif(rs->nroots != nroots) continue;\n\t\tif(rs->mm != symsize) continue;\n\t\tif(rs->gfpoly != gfpoly) continue;\n\t\tif(rs->fcr != fcr) continue;\n\t\tif(rs->prim != prim) continue;\n\n\t\tgoto DONE;\n\t}\n\n\trs = init_rs_char(symsize, gfpoly, fcr, prim, nroots, pad);\n\tif(rs == NULL) goto DONE;\n\trs->next = rslist;\n\trslist = rs;\n\nDONE:\n#ifdef HAVE_LIBPTHREAD\n\tpthread_mutex_unlock(&rslist_mutex);\n#endif\n\treturn rs;\n}\n\n\nvoid free_rs_char(RS *rs)\n{\n\tfree(rs->alpha_to);\n\tfree(rs->index_of);\n\tfree(rs->genpoly);\n\tfree(rs);\n}\n\nvoid free_rs_cache(void)\n{\n\tRS *rs, *next;\n\n#ifdef HAVE_LIBPTHREAD\n\tpthread_mutex_lock(&rslist_mutex);\n#endif\n\trs = rslist;\n\twhile(rs != NULL) {\n\t\tnext = rs->next;\n\t\tfree_rs_char(rs);\n\t\trs = next;\n\t}\n\trslist = NULL;\n#ifdef HAVE_LIBPTHREAD\n\tpthread_mutex_unlock(&rslist_mutex);\n#endif\n}\n\n/* The guts of the Reed-Solomon encoder, meant to be #included\n * into a function body with the following typedefs, macros and variables supplied\n * according to the code parameters:\n\n * data_t - a typedef for the data symbol\n * data_t data[] - array of NN-NROOTS-PAD and type data_t to be encoded\n * data_t parity[] - an array of NROOTS and type data_t to be written with parity symbols\n * NROOTS - the number of roots in the RS code generator polynomial,\n *          which is the same as the number of parity symbols in a block.\n            Integer variable or literal.\n\t    * \n * NN - the total number of symbols in a RS block. Integer variable or literal.\n * PAD - the number of pad symbols in a block. Integer variable or literal.\n * ALPHA_TO - The address of an array of NN elements to convert Galois field\n *            elements in index (log) form to polynomial form. Read only.\n * INDEX_OF - The address of an array of NN elements to convert Galois field\n *            elements in polynomial form to index (log) form. Read only.\n * MODNN - a function to reduce its argument modulo NN. May be inline or a macro.\n * GENPOLY - an array of NROOTS+1 elements containing the generator polynomial in index form\n\n * The memset() and memmove() functions are used. The appropriate header\n * file declaring these functions (usually <string.h>) must be included by the calling\n * program.\n\n * Copyright 2004, Phil Karn, KA9Q\n * May be used under the terms of the GNU Lesser General Public License (LGPL)\n */\n\n#undef A0\n#define A0 (NN) /* Special reserved value encoding zero in index form */\n\nvoid encode_rs_char(RS *rs, const data_t *data, data_t *parity)\n{\n  int i, j;\n  data_t feedback;\n\n  memset(parity,0,NROOTS*sizeof(data_t));\n\n  for(i=0;i<NN-NROOTS-PAD;i++){\n    feedback = INDEX_OF[data[i] ^ parity[0]];\n    if(feedback != A0){      /* feedback term is non-zero */\n#ifdef UNNORMALIZED\n      /* This line is unnecessary when GENPOLY[NROOTS] is unity, as it must\n       * always be for the polynomials constructed by init_rs()\n       */\n      feedback = MODNN(NN - GENPOLY[NROOTS] + feedback);\n#endif\n      for(j=1;j<NROOTS;j++)\n\tparity[j] ^= ALPHA_TO[MODNN(feedback + GENPOLY[NROOTS-j])];\n    }\n    /* Shift */\n    memmove(&parity[0],&parity[1],sizeof(data_t)*(NROOTS-1));\n    if(feedback != A0)\n      parity[NROOTS-1] = ALPHA_TO[MODNN(feedback + GENPOLY[0])];\n    else\n      parity[NROOTS-1] = 0;\n  }\n}\n","size_bytes":9176},"bin/Demo/MfcDemo/10.AlarmDevice/DlgRecoverConfig.cpp":{"content":"// DlgRecoverConfig.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"DlgRecoverConfig.h\"\n#include \"DlgRestoreCfgNew.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgRecoverConfig dialog\n\n\nCDlgRecoverConfig::CDlgRecoverConfig(CWnd* pParent /* = NULL */, LLONG lLoginId /* = 0 */, NET_DEVICE_TYPE emType /* = NET_PRODUCT_NONE */)\n\t: CDialog(CDlgRecoverConfig::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDlgRecoverConfig)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_lLoginId = lLoginId;\n\tm_emType = emType;\n}\n\n\nvoid CDlgRecoverConfig::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDlgRecoverConfig)\n\tDDX_Control(pDX, IDC_RECOVERCONFIG_CMB_REVERTTYPE, m_ctlReverType);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDlgRecoverConfig, CDialog)\n\t//{{AFX_MSG_MAP(CDlgRecoverConfig)\n\tON_BN_CLICKED(IDC_RECOVERCONFIG_BTN_RESET, OnRecoverConfigBtnReset)\n\tON_BN_CLICKED(IDC_RECOVERCONFIG_BTN_RESETEX, OnRecoverConfigBtnResetEx)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDlgRecoverConfig message handlers\n\nvoid CDlgRecoverConfig::OnRecoverConfigBtnReset() \n{\n\t// TODO: Add your control notification handler code here\n    int nIndex = m_ctlReverType.GetCurSel();\n    DWORD dwFlag = m_ctlReverType.GetItemData(nIndex);\n    BOOL bRet = CLIENT_ControlDevice(m_lLoginId, DH_CTRL_RESTOREDEFAULT, &dwFlag, SDK_API_WAIT);\n    if (bRet)\n    {\n        MessageBox(ConvertString(\"Set restore ok!\", DLG_RECOVERCONFIG), ConvertString(\"Prompt\"));\n    }\n    else\n    {\n        CString csInfo;\n        csInfo.Format(\"%s:0x%08x\", ConvertString(\"Set restore failed\", DLG_RECOVERCONFIG), CLIENT_GetLastError());\n        MessageBox(csInfo, ConvertString(\"Prompt\"));\n    }\n}\n\nBOOL CDlgRecoverConfig::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\t// TODO: Add extra initialization here\n\tg_SetWndStaticText(this, DLG_RECOVERCONFIG);\n\t\n\tm_ctlReverType.ResetContent();\n\t{\n\t\tm_ctlReverType.ResetContent();\n\t\tint nIndex = m_ctlReverType.AddString(ConvertString(\"COM Setting\", DLG_RECOVERCONFIG));\n\t\tm_ctlReverType.SetItemData(nIndex,DH_RESTORE_COMM);\n\t\tnIndex = m_ctlReverType.AddString(ConvertString(\"Network Setting\", DLG_RECOVERCONFIG));\n\t\tm_ctlReverType.SetItemData(nIndex,DH_RESTORE_NETWORK);\n\t\tnIndex = m_ctlReverType.AddString(ConvertString(\"Alarm Setting\", DLG_RECOVERCONFIG));\n\t\tm_ctlReverType.SetItemData(nIndex,DH_RESTORE_ALARM);\n\t\tnIndex = m_ctlReverType.AddString(ConvertString(\"PTZ Control\", DLG_RECOVERCONFIG));\n\t\tm_ctlReverType.SetItemData(nIndex,DH_RESTORE_PTZ);\n\t\tnIndex = m_ctlReverType.AddString(ConvertString(\"Ouput Mode\", DLG_RECOVERCONFIG));\n\t\tm_ctlReverType.SetItemData(nIndex,DH_RESTORE_OUTPUTMODE);\n\t\tnIndex = m_ctlReverType.AddString(ConvertString(\"Restore all config\", DLG_RECOVERCONFIG));\n\t\tm_ctlReverType.SetItemData(nIndex,DH_RESTORE_ALL);\n\t\tnIndex = m_ctlReverType.AddString(ConvertString(\"COM Setting|Alarm Setting\", DLG_RECOVERCONFIG));\n\t\tm_ctlReverType.SetItemData(nIndex,DH_RESTORE_COMM | DH_RESTORE_ALARM);\n\t\tnIndex = m_ctlReverType.AddString(ConvertString(\"PTZ Control|Channel Name\", DLG_RECOVERCONFIG));\n\t}\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CDlgRecoverConfig::OnRecoverConfigBtnResetEx() \n{\n\t// TODO: Add your control notification handler code here\n\tCDlgRestoreCfgNew dlg(this, m_lLoginId);\n    dlg.DoModal();\n}\n","size_bytes":3641},"bin/Demo/MfcDemo/10.AlarmDevice/SubDlgSensorInfoDescription.cpp":{"content":"// SubDlgSensorInfoDescription.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"AlarmDevice.h\"\n#include \"SubDlgSensorInfoDescription.h\"\n#include <algorithm>\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CSubDlgSensorInfoDescription dialog\n\n\nCSubDlgSensorInfoDescription::CSubDlgSensorInfoDescription(CWnd* pParent /* = NULL */, int nMaxSensor /* = 72 */, int nColumn /* = 8 */)\n\t: CDialog(CSubDlgSensorInfoDescription::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CSubDlgSensorInfoDescription)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tnMaxSensor <= 0 ? (m_nMaxSensor = 72) : (m_nMaxSensor = nMaxSensor);\n    nColumn <= 0 ? (m_nColumn = 8) : (m_nColumn = nColumn);\n\tm_pbtnCheck = NULL;\n}\n\n\nvoid CSubDlgSensorInfoDescription::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CSubDlgSensorInfoDescription)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CSubDlgSensorInfoDescription, CDialog)\n\t//{{AFX_MSG_MAP(CSubDlgSensorInfoDescription)\n\tON_WM_DESTROY()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CSubDlgSensorInfoDescription private method\n\nvoid CSubDlgSensorInfoDescription::InitDlg()\n{\n\tint nCfgCount = m_nMaxSensor;\n\tint nColumnMaxCount = m_nColumn;\n\tint nRowMaxCount = (nCfgCount%nColumnMaxCount == 0 ? nCfgCount/nColumnMaxCount : (nCfgCount/nColumnMaxCount + 1));\n\tint nBtnWidth = 150;\t// 100 * 1.5 \n\tint nBtnHeight = 20;\t// 10 * 1.5\n\tint nInterval = 6;\n\t\n\t{\t\t\n\t\tCRect rcBtn;\n\t\tGetDlgItem(IDOK)->GetClientRect(&rcBtn);\n\t\t\n\t\tint nWndWidth = nBtnWidth * nColumnMaxCount + nInterval * (nColumnMaxCount + 1);\n\t\tint nWndHeight = nBtnHeight * nRowMaxCount + nInterval * (nRowMaxCount + 1)\n\t\t\t+ (rcBtn.Height()*2 + nInterval * 4);\n\t\tMoveWindow(0, 0, nWndWidth, nWndHeight);\n\t\t\n\t\tGetDlgItem(IDOK)->MoveWindow(nWndWidth / 2 - rcBtn.Width() - nInterval, nWndHeight - rcBtn.Height()*2 - nInterval * 2, \n\t\t\trcBtn.Width(), rcBtn.Height());\n\t\tGetDlgItem(IDCANCEL)->MoveWindow(nWndWidth / 2 + nInterval, nWndHeight - rcBtn.Height()*2 - nInterval * 2,\n\t\t\trcBtn.Width(), rcBtn.Height());\n\t\t\n\t\tCenterWindow();\n\t}\n\t\n\tm_pbtnCheck = new CButton[nCfgCount];\n\tassert(m_pbtnCheck);\n\t\n\tfor (int i = 0; i < nCfgCount; i++)\n\t{\n\t\tm_pbtnCheck[i].Create(\"\", WS_CHILD | WS_VISIBLE | /*BS_CHECKBOX |*/ BS_AUTOCHECKBOX, \n\t\t\tCRect(0, 0, 0, 0), this, emBtnID_base + i);\n\n\t\tCString csInfo;\n\t\tcsInfo.Format(\"%s%d\", ConvertString(\"Channel\"), i + 1);\n\t\tm_pbtnCheck[i].SetWindowText(csInfo);\n\n\t\tif (IsSet(i))\n\t\t{\n\t\t\tm_pbtnCheck[i].SetCheck(BST_CHECKED);\n\t\t}\n\t\t\n\t\tint nSpaceX = i - i/nColumnMaxCount * nColumnMaxCount;\n\t\tint nSpaceY = (i - i%nColumnMaxCount) / nColumnMaxCount;//i - i/nRowMaxCount * nRowMaxCount;\n\t\t\n\t\tm_pbtnCheck[i].MoveWindow(nInterval * (1 + nSpaceX) + nBtnWidth * nSpaceX, \n\t\t\tnInterval * (1 + nSpaceY) + nBtnHeight * nSpaceY, \n\t\t\tnBtnWidth, nBtnHeight, TRUE);\n\t}\n}\n\nvoid CSubDlgSensorInfoDescription::SetID(const std::vector<int>& vecID)\n{\t\n\tm_vecChannel = vecID;\n}\n\nconst std::vector<int>& CSubDlgSensorInfoDescription::GetID()\n{\n\treturn m_vecChannel;\n}\n\nBOOL CSubDlgSensorInfoDescription::IsSet(int nChannel)\n{\n\tstd::vector<int>::iterator it = std::find(m_vecChannel.begin(), m_vecChannel.end(), nChannel);\n\tif (it != m_vecChannel.end())\n\t{\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CSubDlgSensorInfoDescription message handlers\n\nBOOL CSubDlgSensorInfoDescription::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\tg_SetWndStaticText(this);\n\t// TODO: Add extra initialization here\n\tInitDlg();\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CSubDlgSensorInfoDescription::OnOK() \n{\n\t// TODO: Add extra validation here\n\tm_vecChannel.clear();\n\tfor (int i = 0; i < m_nMaxSensor; i++)\n\t{\n\t\tif (m_pbtnCheck[i].GetCheck())\n\t\t{\n\t\t\tm_vecChannel.push_back(i);\n\t\t}\n\t}\n\tCDialog::OnOK();\n}\n\nvoid CSubDlgSensorInfoDescription::OnDestroy() \n{\n\tCDialog::OnDestroy();\n\t\n\t// TODO: Add your message handler code here\n\tif (m_pbtnCheck)\n\t{\n\t\tfor (int i = 0; i < m_nMaxSensor; i++)\n\t\t{\n\t\t\tif (m_pbtnCheck[i].GetSafeHwnd())\n\t\t\t{\n\t\t\t\tm_pbtnCheck[i].DestroyWindow();\n\t\t\t}\n\t\t}\n\t\tdelete []m_pbtnCheck;\n\t\tm_pbtnCheck = NULL;\n\t}\n}\n","size_bytes":4496},"bin/Demo/MfcDemo/13.FaceRecognition/DispatchDlg.cpp":{"content":"// DispatchDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"FaceRecognition.h\"\n#include \"DispatchDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDispatchDlg dialog\n\n\nCDispatchDlg::CDispatchDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CDispatchDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CDispatchDlg)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CDispatchDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CDispatchDlg)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CDispatchDlg, CDialog)\n\t//{{AFX_MSG_MAP(CDispatchDlg)\n\t\t// NOTE: the ClassWizard will add message map macros here\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CDispatchDlg message handlers\n","size_bytes":1011}},"version":2}